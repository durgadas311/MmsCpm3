 2031 =         vers equ '1 ' ; Sep 28, 2017  17:06   drm "RTC72421.ASM"
                ;****************************************************************
                ; RTC (Time) BIOS module for CP/M 3 (CP/M plus),		*
                ; Copyright (c) 2017 Douglas Miller <durgadas311@gmail.com>	*
                ;****************************************************************
                	maclib Z80
                
 FFFF =         true	equ -1
 0000 =         false	equ not true
                
 000D =         cr	equ 13
 000A =         lf	equ 10
 0007 =         bell	equ 7
                
 1F63 =         epoch2k	equ	8035	; CP/M date for Jan 1 2000.
 00A0 =         rtc	equ	0a0h	; standard port address
                
                	extrn @cbnk
                	extrn ?bnksl
                	extrn @sec,@min,@hour,@date
                
                	public ?time,?itime
                
                	cseg	; common memory, available no matter which bank
                
                ; C=0 GET TIME (BDOS is about to read SCB), else SET TIME (BDOS just updated SCB)
                ; Typically, only C1=0 (SET) is used, to update the RTC chip.
                ; Cold Boot will call ?itime to force read of RTC chip.
                ; Must preserve HL, DE. Must be called with intrs enabled.
                ; Cannot depend on Bank 0 on entry...
                ?time:
 0000 79        	mov	a,c
 0001 B7        	ora	a
 0002 C8        	rz	; we keep time ourselves, not in RTC
 0003 3A0000    	lda	@cbnk
 0006 322F00    	sta	savbnk
 0009 F3        	di
 000A AF        	xra	a
 000B CD0000    	call	?bnksl
                	sspd	savsp
 000E+ED73      	DB	0EDH,73H
 0010+2D00      	DW	SAVSP
 0012 312D00    	lxi	sp,stack
 0015 FB        	ei	; TODO: bother with this?
 0016 CD3000    	call	settm
 0019 F3        	di
 001A 3A2F00    	lda	savbnk
 001D CD0000    	call	?bnksl
                	lspd	savsp
 0020+ED7B      	DB	0EDH,07BH
 0022+2D00      	DW	SAVSP
 0024 FB        	ei
 0025 C9        	ret	; No RTC device in this implementation
                
                	dseg	; this part can be banked
                
 0000 0000000000regs:	db	0,0,0,0,0,0,0,0,0,0,0,0,0
                
 000D           	ds	32
 002D           stack:	ds	0
 002D 0000      savsp:	dw	0
 002F 00        savbnk:	db	0
                
                ; This also must initialize the entire chip
 0030 E5        settm:	push	h
 0031 D5        	push	d
 0032 C5        	push	b
 0033 210000    	lxi	h,regs
 0036 3A0000    	lda	@sec
 0039 CD3601    	call	stbcd
 003C 3A0000    	lda	@min
 003F CD3601    	call	stbcd
 0042 3A0000    	lda	@hour
 0045 CD3601    	call	stbcd
 0048 E5        	push	h
                	lded	@date
 0049+ED5B      	DB	0EDH,5BH
 004B+0000      	DW	@DATE
 004D CD6C01    	call	dt2mdy
                	; A=dom, E=month, D=year(BCD)
 0050 E1        	pop	h
 0051 CD2101    	call	stbin
 0054 7B        	mov	a,e
 0055 CD2101    	call	stbin
 0058 7A        	mov	a,d
 0059 CD3601    	call	stbcd
 005C E5        	push	h
 005D 2A0000    	lhld	@date
 0060 CD4501    	call	weekdy
 0063 E1        	pop	h
 0064 77        	mov	m,a
 0065 AF        	xra	a
 0066 D3AD      	out	rtc+13
 0068 D3AE      	out	rtc+14
 006A 3E04      	mvi	a,0100b	; 24-hour format
 006C D3AF      	out	rtc+15
 006E CDF400    	call	hold
 0071 210000    	lxi	h,regs
 0074 0E9F      	mvi	c,rtc-1
 0076 060D      	mvi	b,13
 0078 0C        settm0:	inr	c
                	outi
 0079+EDA3      	DB	0EDH,0A3H
                	jrnz	settm0
 007B+20FB      	DB	20H,SETTM0-$-1
 007D CD0501    	call	unhold
 0080 C1        	pop	b
 0081 D1        	pop	d
 0082 E1        	pop	h
 0083 C9        	ret
                
                ?itime:	; initialize RTC and get time
 0084 E5        	push	h
 0085 D5        	push	d
 0086 C5        	push	b
 0087 DBAF      	in	rtc+15
 0089 F604      	ori	00000100b ; 24-hour format
 008B D3AF      	out	rtc+15
                	; more to init?
 008D CDF400    	call	hold
 0090 210000    	lxi	h,regs
 0093 0E9F      	mvi	c,rtc-1
 0095 060C      	mvi	b,12
 0097 0C        gettm0:	inr	c
                	ini
 0098+EDA2      	DB	0EDH,0A2H
                	jrnz	gettm0
 009A+20FB      	DB	20H,GETTM0-$-1
 009C CD0501    	call	unhold
 009F 210000    	lxi	h,regs
 00A2 CD1701    	call	gtbcd
 00A5 320000    	sta	@sec
 00A8 CD1701    	call	gtbcd
 00AB 320000    	sta	@min
 00AE CD1701    	call	gtbcd
 00B1 320000    	sta	@hour
 00B4 CD0C01    	call	gtbin	; day of month
 00B7 5F        	mov	e,a
 00B8 CD0C01    	call	gtbin	; month (1-12)
 00BB 3D        	dcr	a	; 0-11
 00BC 87        	add	a	; * 2 for table lookup
 00BD 57        	mov	d,a
                	; assume RTC is never set for 20th cetnury...
                	; i.e. year is always 20xx.
 00BE CD0C01    	call	gtbin	; year (century)
 00C1 47        	mov	b,a
 00C2 4F        	mov	c,a
 00C3 0D        	dcr	c	; could be -1
                	srar	c	;
 00C4+CB29      	DB	0CBH, 28H+C
                	srar	c	;
 00C6+CB29      	DB	0CBH, 28H+C
 00C8 0C        	inr	c	; C=number of leap years before
 00C9 E603      	ani	00000011b	; check leap year
 00CB 21BA01    	lxi	h,month0
                	jrnz	gettm2
 00CE+2003      	DB	20H,GETTM2-$-1
 00D0 21D201    	lxi	h,month1
                gettm2:	
 00D3 D5        	push	d	; save day of month
 00D4 5A        	mov	e,d
 00D5 1600      	mvi	d,0
 00D7 19        	dad	d
 00D8 7E        	mov	a,m
 00D9 23        	inx	h
 00DA 66        	mov	h,m
 00DB 6F        	mov	l,a	; number of days before this month
 00DC E5        	push	h	; save current month offset
 00DD 21631F    	lxi	h,epoch2k
 00E0 116D01    	lxi	d,365
 00E3 19        gettm1:	dad	d
                	djnz	gettm1
 00E4+10FD      	DB	10H,GETTM1-$-1
 00E6 09        	dad	b	; add leap years (B=0 now)
 00E7 C1        	pop	b	; current month offset
 00E8 09        	dad	b
 00E9 C1        	pop	b	; day of month
 00EA 0600      	mvi	b,0	;
 00EC 09        	dad	b
 00ED 220000    	shld	@date
 00F0 C1        	pop	b
 00F1 D1        	pop	d
 00F2 E1        	pop	h
 00F3 C9        	ret
                
 00F4 DBAD      hold:	in	rtc+13
 00F6 F601      	ori	0001b	; HOLD
 00F8 D3AD      	out	rtc+13
 00FA DBAD      	in	rtc+13
 00FC E602      	ani	0010b	; BUSY
 00FE C8        	rz
 00FF E60E      	ani	00001110b
 0101 D3AD      	out	rtc+13
                	; TODO: pause?
                	jr	hold
 0103+18EF      	DB	18H,HOLD-$-1
                
 0105 DBAD      unhold:	in	rtc+13
 0107 E6FE      	ani	11111110b
 0109 D3AD      	out	rtc+13
 010B C9        	ret
                
                ; Get (BCD digit) value from regs[] in binary
 010C 46        gtbin:	mov	b,m	; assume no masking required
 010D 23        	inx	h
 010E 7E        	mov	a,m	; MSD
 010F 23        	inx	h
 0110 87        	add	a	; X * 2
 0111 4F        	mov	c,a
 0112 87        	add	a
 0113 87        	add	a	; X * 8
 0114 81        	add	c	; (X * 8 + X * 2) = X * 10
 0115 80        	add	b	; + LSD
 0116 C9        	ret
                
                ; Get (BCD digit) value from regs[] in BCD
 0117 46        gtbcd:	mov	b,m	; assume no masking required
 0118 23        	inx	h
 0119 7E        	mov	a,m
 011A 23        	inx	h
 011B 87        	add	a
 011C 87        	add	a
 011D 87        	add	a
 011E 87        	add	a
 011F 80        	add	b
 0120 C9        	ret
                
                ; store binary value into (BCD) digit registers
 0121 D664      stbin:	sui	100
                	jrnc	stbin
 0123+30FC      	DB	30H,STBIN-$-1
 0125 C664      	adi	100
 0127 0E00      	mvi	c,0
 0129 D60A      stbin0:	sui	10
 012B 0C        	inr	c
                	jrnc	stbin0
 012C+30FB      	DB	30H,STBIN0-$-1
 012E C60A      	adi	10
 0130 0D        	dcr	c
 0131 77        	mov	m,a
 0132 23        	inx	h
 0133 71        	mov	m,c
 0134 23        	inx	h
 0135 C9        	ret
                
                ; store BCD value into (BCD) digit registers
 0136 47        stbcd:	mov	b,a
 0137 E60F      	ani	0fh
 0139 77        	mov	m,a
 013A 23        	inx	h
 013B 78        	mov	a,b
 013C 0F        	rrc
 013D 0F        	rrc
 013E 0F        	rrc
 013F 0F        	rrc
 0140 E60F      	ani	0fh
 0142 77        	mov	m,a
 0143 23        	inx	h
 0144 C9        	ret
                
                ; HL=CP/M date value (days since epoch)
                ; From DATE.PLM: week$day = (word$value + base$day - 1) mod 7;
                ;                base$day  lit '0',
 0145 2B        weekdy:	dcx	h	; 1/1/78 is "0" (Sun), -1 for offset
 0146 11581B    	lxi	d,7000
 0149 B7        	ora	a
                wd0:	dsbc	d
 014A+ED52      	DB	0EDH,D*8+42H
                	jrnc	wd0
 014C+30FC      	DB	30H,WD0-$-1
 014E 19        	dad	d
 014F 11BC02    	lxi	d,700
 0152 B7        	ora	a
                wd1:	dsbc	d
 0153+ED52      	DB	0EDH,D*8+42H
                	jrnc	wd1
 0155+30FC      	DB	30H,WD1-$-1
 0157 19        	dad	d
 0158 114600    	lxi	d,70
 015B B7        	ora	a
                wd2:	dsbc	d
 015C+ED52      	DB	0EDH,D*8+42H
                	jrnc	wd2
 015E+30FC      	DB	30H,WD2-$-1
 0160 19        	dad	d
 0161 110700    	lxi	d,7
 0164 B7        	ora	a
                wd3:	dsbc	d
 0165+ED52      	DB	0EDH,D*8+42H
                	jrnc	wd3
 0167+30FC      	DB	30H,WD3-$-1
 0169 19        	dad	d
 016A 7D        	mov	a,l
 016B C9        	ret
                
                ; DE=CP/M date value (days since epoch)
 016C 0E4E      dt2mdy:	mvi	c,78	; Epoch year, binary
 016E 0678      	mvi	b,078h	; Epoch year, BCD
 0170 7B        	mov	a,e
 0171 B2        	ora	d
                	jrnz	d2mdy0
 0172+2001      	DB	20H,D2MDY0-$-1
 0174 13        	inx	d
 0175 216D01    d2mdy0:	lxi	h,365
 0178 79        	mov	a,c
 0179 E603      	ani	03h	; Not strictly true, but works until year 2100...
                	jrnz	d2mdy1
 017B+2001      	DB	20H,D2MDY1-$-1
 017D 23        	inx	h
 017E E5        d2mdy1:	push	h
 017F B7        	ora	a
                	dsbc	d
 0180+ED52      	DB	0EDH,D*8+42H
 0182 E1        	pop	h
                	jrnc	d2mdy2	; done computing year...
 0183+300D      	DB	30H,D2MDY2-$-1
 0185 EB        	xchg
 0186 B7        	ora	a
                	dsbc	d
 0187+ED52      	DB	0EDH,D*8+42H
 0189 EB        	xchg
 018A 0C        	inr	c	; does not wrap at 100
 018B 78        	mov	a,b
 018C C601      	adi	1
 018E 27        	daa
 018F 47        	mov	b,a
                	jr	d2mdy0
 0190+18E3      	DB	18H,D2MDY0-$-1
 0192 C5        d2mdy2:	push	b	; DE = days within year 'C'
 0193 21D201    	lxi	h,month0+24
 0196 79        	mov	a,c
 0197 E603      	ani	03h
                	jrnz	d2mdy3
 0199+2003      	DB	20H,D2MDY3-$-1
 019B 21EA01    	lxi	h,month1+24
 019E 060C      d2mdy3:	mvi	b,12
 01A0 2B        d2mdy4:	dcx	h
 01A1 2B        	dcx	h
 01A2 05        	dcr	b
 01A3 FAB401    	jm	d2mdy5
 01A6 E5        	push	h
 01A7 D5        	push	d
 01A8 7E        	mov	a,m
 01A9 23        	inx	h
 01AA 66        	mov	h,m
 01AB 6F        	mov	l,a
                	; DE = days in year, HL = ytd[month]
 01AC B7        	ora	a
                	dsbc	d
 01AD+ED52      	DB	0EDH,D*8+42H
 01AF 7D        	mov	a,l	; potential remainder (neg)
 01B0 D1        	pop	d
 01B1 E1        	pop	h
                	jrnc	d2mdy4
 01B2+30EC      	DB	30H,D2MDY4-$-1
                d2mdy5:	neg	; B = month, 0-11; A = -dom
 01B4+ED44      	DB	0EDH,44H
 01B6 D1        	pop	d	; D=year (BCD)
 01B7 04        	inr	b	; month (1-12)
 01B8 58        	mov	e,b	; E=month
 01B9 C9        	ret		; A=dom
                
                ;               J   F   M   A   M   J   J   A   S   O   N   D
 01BA 00001F003Bmonth0: dw       0, 31, 59, 90,120,151,181,212,243,273,304,334
 01D2 00001F003Cmonth1: dw       0, 31, 60, 91,121,152,182,213,244,274,305,335
                
 01EA           	end
