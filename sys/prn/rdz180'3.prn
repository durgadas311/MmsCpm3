 2031 =         VERS EQU '1 ' ; Feb 15, 2020  16:39  drm  "RDZ180'3.ASM"
                ;*********************************************************
                ;	Disk I/O module for MMS CP/M 3.1
                ;	for RAM disk on the Z180 MMU 1M RAM
                ;	Copyright (c) 2020 Douglas Miller
                ;*********************************************************
 0000 =         false	equ	0
 FFFF =         true	equ	not false
                
                	maclib z180
                
                	extrn	@trk,@sect,@dma,@dbnk,@cbnk
                	extrn	@compg
                	extrn	@dircb,@dtacb
                	extrn	@tz180,@dz180
                	extrn	?bnksl
                
                ;---------------------------------------------------------
                ;
                ;	Physical drives are assigned as follows:
                ;
                ;	40 - 1st drive
                ;
                ;---------------------------------------------------------
                ;	Ports and Constants
                ;---------------------------------------------------------
                ;  PORT ASSIGNMENTS
                
 0038 =         mmu$cbr	equ	38h
 0039 =         mmu$bbr	equ	39h
 003A =         mmu$cbar equ	3ah
 0020 =         sar0l	equ	20h
 0021 =         sar0h	equ	21h
 0022 =         sar0b	equ	22h
 0023 =         dar0l	equ	23h
 0024 =         dar0h	equ	24h
 0025 =         dar0b	equ	25h
 0026 =         bcr0l	equ	26h
 0027 =         bcr0h	equ	27h
 0030 =         dstat	equ	30h
 0031 =         dmode	equ	31h
 0032 =         dcntl	equ	32h
                
                ; CP/M 3 uses 00000-39FFF, unused RAM is 3A000-7FFFF
 003A =         base$pg	equ	3ah	; 286720 bytes, 280K, 2240 sectors (128B)
 0046 =         num$pgs	equ	70	; in case anyone asks.
                
 0028 =         driv0	equ	40		; first drive in system
 0001 =         ndriv	equ	1		; # of drives is system
                
 008B =         dsm	equ	140-1	; 286720 bytes for ramdisk
 0004 =         bsh	equ	4
 000F =         blm	equ	15	; 2K block size
 0000 =         exm	equ	0
 003F =         drm	equ	64-1	; still requires manual ALV0 setup
 0080 =         alv0	equ	10000000b
                ; for 1M, 3A000-F8000, that's 190 pages (need 4K blocks)
 00BD =         dsm1	equ	190-1	; 760K for ramdisk
 0005 =         bsh1	equ	5
 001F =         blm1	equ	31	; 4K block size
 0000 =         exm1	equ	0
 007F =         drm1	equ	128-1	; still requires manual ALV0 setup
                ; same alv0, 1 block
                ;-------------------------------------------------------
                ;	Start of relocatable disk I/O module.
                ;-------------------------------------------------------
                	cseg
                
 0000 E000      	dw	thread
 0002 2801      	db	driv0,ndriv
 0004 C35000    	jmp	init$rd
 0007 C3AD00    	jmp	login$rd
 000A C31101    	jmp	read$rd
 000D C32C01    	jmp	write$rd
 0010 1600      	dw	string
 0012 06003500  	dw	dphtbl,modtbl
                
 0016 52445A3138string: DB	'RDZ180 ',0
 001E 3238304B20	DB	'280K RAM Disk ',0,'v3.10'
 0032 3120      	DW	VERS
 0034 24        	DB	'$'
                
 0035 80000000  modtbl: db	10000000b,00000000b,00000000b,00000000b ; drive 40, like HDD
 0039 FFFFFFFF  	  db	11111111b,11111111b,11111111b,11111111b
                
 003D 8000      rddpb:	dw	128	; SPT - arbitrary
 003F 040F00    	db	bsh,blm,exm
 0042 8B003F00  	dw	dsm,drm
 0046 8000      	db	alv0,0
 0048 00800000  	dw	08000h,0
 004C 0000      	db	0,0	; PSH,PSM = 128byte sectors
                
                ; 128 bytes to/from 'pbuf', HL=src, DE=dst
                xfer$dma:
 004E F3        	di
 004F 3A0000    	lda	@dbnk
 0052 CD0000    	call	?bnksl
 0055 018000    	lxi	b,128
                	ldir
 0058+EDB0      	DB	0EDH,0B0H
 005A AF        	xra	a
 005B CD0000    	call	?bnksl
 005E FB        	ei
 005F C9        	ret
                
 0060           pbuf:	ds	128
                
 00E0 =         thread	equ	$
                
                	dseg
 0000 =         dseg0	equ	$
                
 0000 000000    usr$addr: db	0,0,0
 0003 000000    dsk$addr: db	0,0,0
                
                ; No bank switching required, most of the time.
                ; No data buffers, no HASH
 0006 0000000000dphtbl: dw	0,0,0,0,0,0,rddpb,0,alv40,@dircb,0ffffh,0ffffh
 001E 00        	db 0
                
                alv40:	; ds	(dsm+1)/4 	;
 004F =         alv40e	equ	alv40+(dsm1+1+3)/4	; must reserve max amount
                
                ; This can be overlapped with alv40: never used after init$rd.
 001F 2052414D44label:	db	020h,'RAMDISK3LBL'
 000C =         lblen	equ	$-label
 002B 01000000  	db	00000001b,0,0,0	; no modes (yet)
 002F 0000000000	db	0,0,0,0,0,0,0,0	; password
 0037 00000000  	db	0,0,0,0		; ctime
 003B 00000000  	db	0,0,0,0		; utime
                
 003F 8000      dpb1m:	dw	128
 0041 051F00    	db	bsh1,blm1,exm1
 0044 BD007F00  	dw	dsm1,drm1
 0048 8000      	db	alv0,0
 004A 00800000  	dw	08000h,0
 004E 0000      	db	0,0	; PSH,PSM = 128byte sectors
                
                if alv40e-dseg0 > $-dseg0
                	ds	alv40e-$
                endif
                
                init$rd:	; interrupts are disabled - leave them that way
                	; Check if a valid directory already exists...
                	; carefully change mapping to make this easier...
                	; note: we must be (are) in bank 0...
 0050 3E80      	mvi	a,1000$0000b	; common at 8000, 32K for ramdisk view
                	out0	a,mmu$cbar
 0052+ED393A    	DB	0EDH, A*8+01H, MMU$CBAR
 0055 3E80      	mvi	a,80h	; see if 80000h RAM exists (1M)
                	out0	a,mmu$bbr
 0057+ED3939    	DB	0EDH, A*8+01H, MMU$BBR
 005A 210000    	lxi	h,0
 005D 7E        	mov	a,m
 005E 34        	inr	m
 005F BE        	cmp	m
                	jrz	ird4
 0060+2811      	DB	28H,IRD4-$-1
                	; fix DPB for RAM from base$pg..0f8h
 0062 213F00    	lxi	h,dpb1m
 0065 113D00    	lxi	d,rddpb
 0068 011100    	lxi	b,17	; not all changes, though
                	ldir
 006B+EDB0      	DB	0EDH,0B0H
 006D 213736    	lxi	h,'76'	; "760K"...
 0070 221E00    	shld	string+8
                ird4:
 0073 3E3A      	mvi	a,base$pg
                	out0	a,mmu$bbr	; map in first part of ramdisk
 0075+ED3939    	DB	0EDH, A*8+01H, MMU$BBR
 0078 210000    	lxi	h,0	; first sector... first dirent (label)
 007B 111F00    	lxi	d,label
 007E 060C      	mvi	b,lblen
 0080 1A        ird2:	ldax	d
 0081 BE        	cmp	m
                	jrnz	ird1
 0082+2006      	DB	20H,IRD1-$-1
 0084 13        	inx	d
 0085 23        	inx	h
                	djnz	ird2
 0086+10F8      	DB	10H,IRD2-$-1
                	jr	ird3
 0088+1819      	DB	18H,IRD3-$-1
                ird1:	; must re-initialize directory (to empty)
 008A 110000    	lxi	d,0
 008D 211F00    	lxi	h,label
 0090 012000    	lxi	b,32
                	ldir
 0093+EDB0      	DB	0EDH,0B0H
 0095 EB        	xchg	; make rest empty
 0096 112000    	lxi	d,32	; bytes/dirent
 0099 3A4400    	lda	rddpb+7	; assume 1-byte DRM
 009C 47        	mov	b,a	; DRM (one already done, so -1 OK)
 009D 3EE5      	mvi	a,0e5h	; empty entry
 009F 77        ird0:	mov	m,a
 00A0 19        	dad	d
                	djnz	ird0
 00A1+10FC      	DB	10H,IRD0-$-1
                ird3:
                	; restore mapping
 00A3 AF        	xra	a
                	out0	a,mmu$bbr	; map in first part of ramdisk
 00A4+ED3939    	DB	0EDH, A*8+01H, MMU$BBR
 00A7 3EE0      	mvi	a,1110$0000b	; standard mapping (TODO: get from memz180)
                	out0	a,mmu$cbar
 00A9+ED393A    	DB	0EDH, A*8+01H, MMU$CBAR
 00AC C9        	ret
                
                login$rd:
 00AD AF        	xra	a
 00AE C9        	ret
                
 00AF 00        punt:	db	0
                
                ; transfer crosses common boundary,
                ; this really can only happen when @dbnk == 1.
                ; setup temp buf in known region.
                punt$rw:
 00B0 AF        	xra	a
 00B1 320200    	sta	usr$addr+2
 00B4 216000    	lxi	h,pbuf
 00B7 220000    	shld	usr$addr
 00BA 3C        	inr	a
 00BB 32AF00    	sta	punt
                	jr	join$rw
 00BE+182A      	DB	18H,JOIN$RW-$-1
                
                ; TODO: handle buffer that crosses common boundary...
                setup$rw:
 00C0 AF        	xra	a
 00C1 32AF00    	sta	punt
                	; convert bank,vaddr to paddr
 00C4 2A0000    	lhld	@dma
 00C7 EB        	xchg
 00C8 210000    	lxi	h,@dz180
 00CB 3A0000    	lda	@compg	; check for common memory buffer...
 00CE 3D        	dcr	a
 00CF BA        	cmp	d
                	jrc	comm$rw	; use bank 0 for common
 00D0+380A      	DB	38H,COMM$RW-$-1
                	jrz	punt$rw
 00D2+28DC      	DB	28H,PUNT$RW-$-1
 00D4 3A0000    	lda	@dbnk
 00D7 87        	add	a
 00D8 4F        	mov	c,a
 00D9 0600      	mvi	b,0
 00DB 09        	dad	b
                comm$rw:
                	; add 0:D:E (user dma)
                	;   + H:L:0 (actually, (HL+1):(HL):0)
 00DC 7A        	mov	a,d
 00DD 86        	add	m
 00DE 57        	mov	d,a
 00DF 23        	inx	h
 00E0 3E00      	mvi	a,0
 00E2 8E        	adc	m
 00E3 320200    	sta	usr$addr+2
 00E6 EB        	xchg
 00E7 220000    	shld	usr$addr
                join$rw:
 00EA 3A0000    	lda	@sect	; 0-127
 00ED B7        	ora	a
 00EE 1F        	rar	; * 128
 00EF 57        	mov	d,a
 00F0 3E00      	mvi	a,0
 00F2 1F        	rar
 00F3 5F        	mov	e,a	; DE=sector*128
 00F4 3A0000    	lda	@trk	; 0-47 (16K each)
 00F7 4F        	mov	c,a
 00F8 AF        	xra	a
                	rarr	c	;
 00F9+CB19      	DB	0CBH, 18H + C
 00FB 1F        	rar		;
                	rarr	c	;
 00FC+CB19      	DB	0CBH, 18H + C
 00FE 1F        	rar		; C:A:0 = track * 128 * 128
                	; (0000xxxx:xx000000:00000000) track  C:A:0
                	; (00000000:00xxxxxx:x0000000) sector 0:D:E
                	; merge C:A:0 (track) and 0:D:E (sector) (no carry possible)
 00FF B2        	ora	d
 0100 57        	mov	d,a
                	; LBA is C:D:E
 0101 21A003    	lxi	h,base$pg SHL 4	; base addr of disk
                	; add C:D:E
                	;   + H:L:0
 0104 7A        	mov	a,d
 0105 85        	add	l
 0106 57        	mov	d,a
 0107 79        	mov	a,c
 0108 8C        	adc	h
 0109 320500    	sta	dsk$addr+2
 010C EB        	xchg
 010D 220300    	shld	dsk$addr
 0110 C9        	ret
                
                read$rd:
 0111 CDC000    	call	setup$rw
 0114 210300    	lxi	h,dsk$addr	; source
 0117 110000    	lxi	d,usr$addr	; dest
 011A CD4901    	call	rw$common
 011D 3AAF00    	lda	punt
 0120 B7        	ora	a
 0121 C8        	rz	; never an error?
 0122 2A0000    	lhld	@dma
 0125 EB        	xchg
 0126 216000    	lxi	h,pbuf
 0129 C34E00    	jmp	xfer$dma
                
                write$rd:
 012C CDC000    	call	setup$rw
 012F 3AAF00    	lda	punt
 0132 B7        	ora	a
                	jrz	wr0
 0133+2809      	DB	28H,WR0-$-1
 0135 2A0000    	lhld	@dma
 0138 116000    	lxi	d,pbuf
 013B CD4E00    	call	xfer$dma
 013E 210000    wr0:	lxi	h,usr$addr	; source
 0141 110300    	lxi	d,dsk$addr	; dest
 0144 CD4901    	call	rw$common
 0147 AF        	xra	a	; never an error?
 0148 C9        	ret
                
                rw$common:
 0149 F3        	di	; needed?
 014A 7E        	mov	a,m
                	out0	a,sar0l
 014B+ED3920    	DB	0EDH, A*8+01H, SAR0L
 014E 23        	inx	h
 014F 7E        	mov	a,m
                	out0	a,sar0h
 0150+ED3921    	DB	0EDH, A*8+01H, SAR0H
 0153 23        	inx	h
 0154 7E        	mov	a,m
                	out0	a,sar0b
 0155+ED3922    	DB	0EDH, A*8+01H, SAR0B
 0158 1A        	ldax	d
                	out0	a,dar0l
 0159+ED3923    	DB	0EDH, A*8+01H, DAR0L
 015C 13        	inx	d
 015D 1A        	ldax	d
                	out0	a,dar0h
 015E+ED3924    	DB	0EDH, A*8+01H, DAR0H
 0161 13        	inx	d
 0162 1A        	ldax	d
                	out0	a,dar0b
 0163+ED3925    	DB	0EDH, A*8+01H, DAR0B
 0166 3E80      	mvi	a,128
                	out0	a,bcr0l
 0168+ED3926    	DB	0EDH, A*8+01H, BCR0L
 016B AF        	xra	a
                	out0	a,bcr0h
 016C+ED3927    	DB	0EDH, A*8+01H, BCR0H
 016F 3E02      	mvi	a,00000010b	; mem2mem, burst mode
                	out0	a,dmode
 0171+ED3931    	DB	0EDH, A*8+01H, DMODE
 0174 3E60      	mvi	a,01100000b	; DE0,/DWE0(not /DWE1) - start ch 0
 0176 013000    	lxi	b,dstat		; B must be 0, 64-bit I/O internally
                	outp	a		; DMA starts now...
 0179+ED79      	DB	0EDH,A*8+41H
                rwc0:	tstio	01000000b	; wait for DMAC to idle
 017B+ED7440    	DB	0EDH, 74H, 01000000B
                	jrnz	rwc0
 017E+20FB      	DB	20H,RWC0-$-1
 0180 FB        	ei
 0181 C9        	ret
                
 0182           	end
