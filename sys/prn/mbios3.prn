 2035 =         vers equ '5 ' ; Oct 29, 2018  18:11   drm "MBIOS3.ASM"
                ;****************************************************************
                ; Main BIOS module for CP/M 3 (CP/M plus),			*
                ;	 Banked memory and Time split-out.			*
                ; Copyright (c) 1983 Magnolia Microsystems			*
                ;****************************************************************
                	maclib Z80
                
 FFFF =         true	equ -1
 0000 =         false	equ not true
                
 000D =         cr	equ	13
 000A =         lf	equ	10
 0007 =         bell	equ	7
                
 0000 =         cpm	equ	0
 0005 =         bdos	equ	5
 0008 =         RST1	equ	8
 0100 =         ccp	equ	0100h	; Console Command Processor gets loaded into the TPA
                
 00F2 =         port	equ	0f2h	;interupt control port
                
                ;  SCB registers
                	extrn @covec,@civec,@aovec,@aivec,@lovec,@ermde
                	extrn @mxtpa,@bnkbf,@sec,@min,@hour,@date
                	extrn @lptbl,@nbnk,@compg,@mmerr,@memstr,@rtcstr
                
                ;  External routines
                	extrn ?getdp,?serdp
                	extrn ?bnksl,?bnkck,?xmove,?mvccp,?move
                	extrn ?time,?itime
                
                ;  Variables for use by other modules
                	public @adrv,@pdrv,@rdrv,@side,@trk,@sect,@login
                	public @dma,@dbnk,@cnt,@scrbf,@dtacb,@dircb
                	public @dstat,@intby,@cmode,@dph,@rcnfg,@tick0
                	public @ctbl,@cbnk,@heapt
                	public bnkdos,resdos,wbtrap
                
                ;  Routines for use by other modules
                	public ?timot
                	public ?dvtbl,?drtbl,?halloc
                	public ?stbnk
                
                ;-------- Start of Code-producing source -----------
                
                	cseg		; GENCPM puts CSEG stuff in common memory
 0000 =         BIOS$0	equ	$
 FC00 =         bnkdos	equ	bios$0+0fc00h	;dummy values, reloc "Fxxx", GENCPM will
 FD00 =         resdos	equ	bios$0+0fd00h	; substitiute real values.
 0000 C30800    	jmp boot	; initial entry on cold start
 0003 C3D700    	jmp wboot	; reentry on program exit, warm start
                 
 0006 C3E903    	jmp const	; return console input status
 0009 C31204    	jmp conin	; return console input character
 000C C39903    	jmp conout	; send console output character
 000F C3A303    	jmp list	; send list output character
 0012 C39E03    	jmp auxout	; send auxilliary output character
 0015 C31704    	jmp auxin	; return auxilliary input character
                
 0018 C32702    	jmp home	; set disks to logical home
 001B C30701    	jmp seldsk	; select disk drive, return disk parameter info
 001E C32A02    	jmp settrk	; set disk track
 0021 C32F02    	jmp setsec	; set disk sector
 0024 C33402    	jmp setdma	; set disk I/O memory address
 0027 C34B02    	jmp read	; read physical block(s)
 002A C35002    	jmp write	; write physical block(s)
                
 002D C3C903    	jmp listst	; return list device status
 0030 C33F02    	jmp sectrn	; translate logical to physical sector
                
 0033 C3BF03    	jmp conost	; return console output status
 0036 C3EE03    	jmp auxist	; return aux input status
 0039 C3C403    	jmp auxost	; return aux output status
 003C C3FC02    ?dvtbl: jmp devtbl	; return address of device def table
 003F C38C03    	jmp cinit	; change baud rate of device
                
 0042 C3CA00    ?drtbl: jmp getdrv	; return address of disk drive table
 0045 C3C702    	jmp multio	; set multiple record count for disk I/O
 0048 C3CB02    	jmp flush	; flush BIOS maintained disk caching
                
 004B C30000    	jmp ?move	; block move memory to memory
 004E C30000    	jmp ?time	; Signal Time and Date operation
 0051 C30000    	jmp ?bnksl	; select bank for code execution and default DMA
 0054 C33B02    ?stbnk: jmp setbnk	; select different bank for disk I/O DMA operations.
 0057 C30000    	jmp ?xmove	; set source and destination banks for one operation
                
 005A C3E402    	jmp search	; reserved for OEM: search for module.
 005D C30000    	jmp 0		; reserved for future expansion
 0060 C30000    	jmp 0		; reserved for future expansion
                
                ; The following are accessed externally, relative to wboot entry.
                ; (for both utilities as well as SETUP.COM)
 0063           @dstat: ds	1
 0064           @intby: ds	1
                
 0065 0000      	dw	@lptbl	;logical/physical drive table
 0067 7004      	dw	thread	;module thread
 0069 0000      	dw	?serdp	;test mode validity, HL=memory address of ?serdp
                
 006B           @adrv:	ds	1		; currently selected disk drive
 006C           @pdrv:	ds	1		; physical drive number (MMS)
 006D           @rdrv:	ds	1		; module relative disk drive number
 006E           curmdl: ds	2		; currently selected Disk I/O module address
 0070           @cmode: ds	2
 0072           @dph:	ds	2
                
 0074 0080      icovec: dw	1000000000000000b
 0076 0080      icivec: dw	1000000000000000b
 0078 0020      iaovec: dw	0010000000000000b
 007A 0020      iaivec: dw	0010000000000000b
 007C 0040      ilovec: dw	0100000000000000b
                
 007E 00FFFFFF  defsrc: db	0,0ffh,0ffh,0ffh
 0082 00        tmpdrv: db	0
 0083 00        srctyp: db	000$00$000b	;only bits 3,4 are used (others ignored)
                
 0084 0000      	dw	@memstr	; Memory driver module string
 0086 0000      	dw	@rtcstr	; RTC driver module string
                ; End of externally dependent locations.
                
 0088 2A0000    bdose:	lhld	@mxtpa
 008B E9        	pchl
                
 008C 0000      @dma:	dw	0
 008E 0000      wbtrap: dw	0
                
                ;  Note Page-0 handling in banked system: At cold start, all vectors are
                ;initialized in bank 0, then copied to banks 1,2...  Then at warm starts,
                ;the vectors are re-initialized from bank 0.
                ;
                boot$1:
                	; bank 0 selected at this point...
 0090 CD0000    	call	?itime	; Initial setting of time/date in SCB
 0093 116902    	lxi	d,signon
 0096 0E09      	mvi	c,9
 0098 CD8800    	call	bdose
                	; BDOS selects bank 1...
 009B 3A6F04    	lda	bnkflg
 009E B7        	ora	a	;is banked memory installed?
 009F CA9402    	jz	ramerr
 00A2 CDFF00    	call	set$jumps  ;setup system jumps and put in all banks
                	; interrupts now enabled
                	; bank 1 selected
                ; fetch CCP for first time, system will put it in bank 1.
 00A5 11AD02    	lxi	d,ccp$com
 00A8 0E0F      	mvi	c,15	;open file
 00AA CD8800    	call	bdose
 00AD 3C        	inr	a
 00AE CA9902    	jz	noccp
 00B1 AF        	xra	a
 00B2 32CD02    	sta	fcb$nr
 00B5 110001    	lxi	d,ccp
 00B8 0E1A      	mvi	c,26	;set DMA address
 00BA CD8800    	call	bdose
 00BD 1E80      	mvi	e,128	;read upto 128 records (16K)
 00BF 0E2C      	mvi	c,44	;set multi-sector count
 00C1 CD8800    	call	bdose
 00C4 11AD02    	lxi	d,ccp$com
 00C7 0E14      	mvi	c,20	;read record(s)
 00C9 CD8800    	call	bdose
 00CC 7C        	mov	a,h	;H=number of records actually read
 00CD 32E302    	sta	ccprecs
 00D0 0E01      	mvi	c,1	; save CCP in bank 0 for warm boots.
 00D2 0600      	mvi	b,0	;NOTE: this restricts banked OS size to 39K.
 00D4 C3E400    	jmp	goccp	; (allowing 16K for "CCP" and reserving page 0)
                
                ; Don't know which bank is selected...
 00D7 319201    wboot:	lxi	sp,stack
 00DA CDFF00    	call	reset$pg0	; initialize page zero
                				; leaves bank 1 selected...
 00DD 3AE302    	lda	ccprecs 	; reload CCP
 00E0 0E00      	mvi	c,0
 00E2 0601      	mvi	b,1
 00E4 210001    goccp:	lxi	h,ccp
 00E7 CD0000    	call	?mvccp
 00EA 3E00      	mvi	a,0	; allow I/O modules to partake in the warm$boot.
 00EC CD0000    	call	?bnksl	;
 00EF 2A8E00    	lhld	wbtrap	;
 00F2 7C        	mov	a,h	;
 00F3 B5        	ora	l	;
 00F4 C46D04    	cnz	icall	;
 00F7 3E01      	mvi	a,1	;
 00F9 CD0000    	call	?bnksl	;
 00FC C30001    	jmp	ccp 	; exit to ccp
                
                set$jumps:
                reset$pg0:
 00FF F3        	di
 0100 3A6400    	lda	@intby
 0103 F602      	ori	00000010b	; enable 2mS clock intr
 0105 326400    	sta	@intby
 0108 D3F2      	out	port ; a side-effect of bnksel used to be output @intby...
 010A AF        	xra	a	;
 010B CD0000    	call	?bnksl	;select bank 0
 010E 3EC3      	mvi a,(JMP)
 0110 3200003205	sta cpm ! sta bdos	; set up jumps in page zero
 0116 320800    	sta RST1
 0119 2103002201	lxi h,BIOS$0+3 ! shld cpm+1	; BIOS warm start entry
 011F 2A00002206	lhld @mxtpa ! shld bdos+1	; BDOS system call entry
 0125 21B4012209	lxi h,clock ! shld RST1+1	;bank 0 is all set...
 012B 210000    	lxi	h,0	;
                	lded	@bnkbf	;
 012E+ED5B      	DB	0EDH,5BH
 0130+0000      	DW	@BNKBF
 0132 014000    	lxi	b,64	;
                	ldir		;
 0135+EDB0      	DB	0EDH,0B0H
 0137 3A0000    	lda	@nbnk
 013A 3D        rpg1:	dcr	a
 013B CA5001    	jz	rpg0
 013E F5        	push	psw
 013F CD0000    	call	?bnksl
 0142 2A0000    	lhld	@bnkbf	;
 0145 110000    	lxi	d,0	;
 0148 014000    	lxi	b,64	;
                	ldir		;
 014B+EDB0      	DB	0EDH,0B0H
 014D F1        	pop	psw
                	jr	rpg1
 014E+18EA      	DB	18H,RPG1-$-1
 0150 FB        rpg0:	ei	; bank 1 is selected
 0151 C9        	ret
                
 0152           	ds 64
 0192 =         stack	equ $
 0192           	ds 32
 01B2 =         iostk	equ $
 01B2 0000      iostkp: dw	$-$
                
                clock:	sspd	istk
 01B4+ED73      	DB	0EDH,73H
 01B6+E102      	DW	ISTK
 01B8 31E102    	lxi	sp,intstk
 01BB F5        	push	psw
 01BC E5        	push	h
 01BD 3A6400    	lda	@intby
 01C0 D3F2      	out	port
 01C2 216702    	lxi	h,@tick0
 01C5 35        	dcr	m
                	jrnz	xit
 01C6+2068      	DB	20H,XIT-$-1
 01C8 360A      	mvi	m,t0cnt
 01CA 23        	inx	h
 01CB 35        	dcr	m
                	jrnz	xit		;ONE SECOND:
 01CC+2062      	DB	20H,XIT-$-1
 01CE 3632      	mvi	m,t1cnt
 01D0 C5        	push	b
 01D1 215F02    	lxi	h,tictbl	; see if anything needs to be timed out
 01D4 0602      	mvi	b,numtic
 01D6 7E        to4:	mov	a,m
 01D7 23        	inx	h
 01D8 FEFF      	cpi	true
 01DA CAF801    	jz	to3
 01DD 7E        	mov	a,m
 01DE B7        	ora	a
                	jrz	to5		; nothing is timing out
 01DF+2813      	DB	28H,TO5-$-1
 01E1 35        	dcr	m
                	jrnz	to3		; not timed out yet
 01E2+2014      	DB	20H,TO3-$-1
 01E4 C5        	push	b
 01E5 E5        	push	h
 01E6 23        	inx	h
 01E7 7E        	mov	a,m  
 01E8 23        	inx	h
 01E9 66        	mov	h,m
 01EA 6F        	mov	l,a
 01EB CD6D04    	call	icall		; call module time out routine
 01EE E1        	pop	h
 01EF C1        	pop	b
 01F0 7E        	mov	a,m
 01F1 B7        	ora	a
                	jrnz	to3
 01F2+2004      	DB	20H,TO3-$-1
 01F4 2B        to5:	dcx	h
 01F5 36FF      	mvi	m,true
 01F7 23        	inx	h
 01F8 23        to3:	inx	h
 01F9 23        	inx	h
 01FA 23        	inx	h
 01FB 05        	dcr	b
                	jrnz	to4
 01FC+20D8      	DB	20H,TO4-$-1
 01FE C1        	pop	b
 01FF 210000    	lxi	h,@sec
 0202 7E        	mov	a,m
 0203 C601      	adi	1
 0205 27        	daa
 0206 77        	mov	m,a
 0207 FE60      	cpi	60h
                	jrc	xit
 0209+3825      	DB	38H,XIT-$-1
 020B 3600      	mvi	m,00h
 020D 210000    	lxi	h,@min
 0210 7E        	mov	a,m
 0211 C601      	adi	1
 0213 27        	daa
 0214 77        	mov	m,a
 0215 FE60      	cpi	60h
                	jrc	xit
 0217+3817      	DB	38H,XIT-$-1
 0219 3600      	mvi	m,00h
 021B 210000    	lxi	h,@hour
 021E 7E        	mov	a,m
 021F C601      	adi	1
 0221 27        	daa
 0222 77        	mov	m,a
 0223 FE24      	cpi	24h
                	jrc	xit
 0225+3809      	DB	38H,XIT-$-1
 0227 3600      	mvi	m,00h
 0229 2A0000    	lhld	@date
 022C 23        	inx	h
 022D 220000    	shld	@date
 0230 E1        xit:	pop	h
 0231 F1        	pop	psw
                	lspd	istk
 0232+ED7B      	DB	0EDH,07BH
 0234+E102      	DW	ISTK
 0236 FB        	ei
 0237 C9        	ret
                
 0238 FB        ?timot: ei			; (B)=I.D. (C)=count, (DE)=routine address
 0239 D5        	push	d
 023A 1E02      to1:	mvi	e,numtic
 023C 215F02    	lxi	h,tictbl
 023F 7E        to0:	mov	a,m
 0240 FEFF      	cpi	true
                	jrz	to2
 0242+2810      	DB	28H,TO2-$-1
 0244 B8        	cmp	b
                	jrz	to2
 0245+280D      	DB	28H,TO2-$-1
 0247 23        	inx	h
 0248 23        	inx	h
 0249 23        	inx	h
 024A 23        	inx	h
 024B 1D        	dcr	e
                	jrnz	to0
 024C+20F1      	DB	20H,TO0-$-1
 024E 79        	mov	a,c	;don't wait if all it wants is to clear a possible
 024F B7        	ora	a	;existing entry, since none exists for that module.
                	jrnz	to1	;
 0250+20E8      	DB	20H,TO1-$-1
 0252 D1        	pop	d
 0253 C9        	ret
 0254 F3        to2:	di
 0255 D1        	pop	d
 0256 70        	mov	m,b
 0257 23        	inx	h
 0258 71        	mov	m,c
 0259 23        	inx	h
 025A 73        	mov	m,e
 025B 23        	inx	h
 025C 72        	mov	m,d
 025D FB        	ei
 025E C9        	ret
                
 025F FF00      tictbl: db	true,0
 0261 0000      	dw	$-$
 0263 FF00      	db	true,0
 0265 0000      	dw	$-$
 0002 =         numtic equ ($-tictbl)/4
                
 0267 0A32      @tick0: db	t0cnt,t1cnt	;
 000A =         t0cnt	equ	10	;counts 2 milliseconds into 20 milliseconds.
 0032 =         t1cnt	equ	50	;counts 20 milliseconds into 1 second.
                
 0269 0D0A074350signon: db	13,10,7,'CP/M 3.10'
 0275 3520      	dw	vers
 0277 2028632920	db	' (c) 1982,1983 DRI and MMS'
 0291 0D0A24    	db	13,10,'$'
                
 0294 110000    ramerr: lxi	d,@mmerr
                	jr	errx
 0297+1803      	DB	18H,ERRX-$-1
 0299 11A302    noccp:	lxi	d,ccp$msg
 029C 0E09      errx:	mvi	c,9
 029E CD8800    	call	bdose
 02A1 F376      	di ! hlt
                
 02A3 0D0A074E6Fccp$msg db	13,10,7,'No CCP$'
                
 02AD 0143435020ccp$com db	1,'CCP     COM',0,0,0,0
 02BD           	ds	16
 02CD 00000000  fcb$nr	db	0,0,0,0
                
 02D1           	ds	16	;8 levels of stack
 02E1           intstk: ds	0
 02E1 0000      istk:	dw	0
                
 02E3 00        ccprecs db	0
                
                ; SEARCH for a module by device #.
                ;   entry:	C = device # (0-249)
                ;   exit:	[CY] = not found
                ;	   else HL=module address ("init" entry)
                ;		A=device number (relative to module's #0)
                ;
                
 02E4 117004    search: lxi	d,thread	;C=device number
 02E7 EB        snext:	xchg
 02E8 5E        	mov	e,m
 02E9 23        	inx	h
 02EA 56        	mov	d,m
 02EB 23        	inx	h
 02EC 7A        	mov	a,d
 02ED B3        	ora	e
 02EE D601      	sui	1	;produce [CY] if DE=0000
 02F0 D8        	rc		;return if device not found, DE=0000
 02F1 79        	mov	a,c
 02F2 96        	sub	m
                	jrc	snext
 02F3+38F2      	DB	38H,SNEXT-$-1
 02F5 23        	inx	h
 02F6 BE        	cmp	m
                	jrnc	snext
 02F7+30EE      	DB	30H,SNEXT-$-1
 02F9 23        	inx	h	;point to "init" vector
 02FA B7        	ora	a	;set [NC] condition
 02FB C9        	ret
                
 02FC 210003    devtbl: lxi	h,@ctbl
 02FF C9        	ret
                
 0300 6E6F646576@ctbl:	db	'nodev ',0,0	;character table, filled at cold-start.
 0308 6E6F646576	db	'nodev ',0,0
 0310 6E6F646576	db	'nodev ',0,0
 0318 6E6F646576	db	'nodev ',0,0
 0320 6E6F646576	db	'nodev ',0,0
 0328 6E6F646576	db	'nodev ',0,0
 0330 6E6F646576	db	'nodev ',0,0
 0338 6E6F646576	db	'nodev ',0,0
 0340 6E6F646576	db	'nodev ',0,0
 0348 6E6F646576	db	'nodev ',0,0
 0350 6E6F646576	db	'nodev ',0,0
 0358 6E6F646576	db	'nodev ',0,0
 0360 00        	db	0	;table terminator
                
                cdtbl:	rept 12 	;character device table, filled at cold-start.
                	dw cnull
                	endm
 0361+7903      	DW CNULL
 0363+7903      	DW CNULL
 0365+7903      	DW CNULL
 0367+7903      	DW CNULL
 0369+7903      	DW CNULL
 036B+7903      	DW CNULL
 036D+7903      	DW CNULL
 036F+7903      	DW CNULL
 0371+7903      	DW CNULL
 0373+7903      	DW CNULL
 0375+7903      	DW CNULL
 0377+7903      	DW CNULL
                
 0379 C38B03    cnull:	jmp	null	;init
 037C C38803    	jmp	nulli	;input status
 037F C38803    	jmp	nulli	;input
 0382 C38803    	jmp	nulli	;output status
 0385 C38B03    	jmp	null	;output
                
                
 0388 3E1A      nulli:	mvi	a,1ah	;E.O.F. character, also [NZ] to be always ready.
 038A B7        	ora	a	;sets [NZ] condition.
 038B C9        null:	ret
                
                
 038C 0600      cinit:	mvi	b,0	;C=device number (0-11)
 038E 216103    	lxi	h,cdtbl
 0391 09        	dad	b   
 0392 09        	dad	b  
 0393 5E        	mov	e,m
 0394 23        	inx	h
 0395 56        	mov	d,m
 0396 41        	mov	b,c
 0397 EB        	xchg
 0398 E9        	pchl		;jump to modules "init" with B=device #
                
                conout: 
 0399 2A0000    	lhld	@covec	; fetch console output bit vector
                	jr	out$scan0
 039C+1808      	DB	18H,OUT$SCAN0-$-1
                
                auxout:
 039E 2A0000    	lhld	@aovec	; fetch aux output bit vector
                	jr	out$scan0
 03A1+1803      	DB	18H,OUT$SCAN0-$-1
                
                list:
 03A3 2A0000    	lhld	@lovec	; fetch list output bit vector
                out$scan0:
 03A6 CD2C04    	call	swtosys
                out$scan:
 03A9 116103    	lxi	d,cdtbl
 03AC 0600      	mvi	b,0
                co$next:
                	slar	h	; shift out next bit
 03AE+CB24      	DB	0CBH, 20H + H
 03B0 3E0C      	mvi	a,12
 03B2 DC5304    	cc	indjmp1
 03B5 13        	inx	d
 03B6 13        	inx	d
 03B7 04        	inr	b
 03B8 7CB7      	mov a,h ! ora a ; see if any devices left
                	jrnz	co$next ; and go find them...
 03BA+20F2      	DB	20H,CO$NEXT-$-1
 03BC C34404    	jmp	xitusr
                  
                conost:
 03BF 2A0000    	lhld	@covec	; get console output bit vector
                	jr	ost$scan0
 03C2+1808      	DB	18H,OST$SCAN0-$-1
                
                auxost:
 03C4 2A0000    	lhld	@aovec	; get aux output bit vector
                	jr	ost$scan0
 03C7+1803      	DB	18H,OST$SCAN0-$-1
                
                listst:
 03C9 2A0000    	lhld	@lovec	; get list output bit vector
                ost$scan0:
 03CC CD2C04    	call	swtosys
                ost$scan:
 03CF 116103    	lxi	d,cdtbl
 03D2 0600      	mvi	b,0	;B = device number
                cos$next:
                	slar	h	; check next bit
 03D4+CB24      	DB	0CBH, 20H + H
 03D6 3E09      	mvi a,9 	; [NZ] will assume device ready (in case no call made)
 03D8 DC5304    	cc	indjmp1 ; check status for this device
 03DB B7        	ora a		; see if device ready
                	jrz	xitusr	; if any not ready, return false
 03DC+2866      	DB	28H,XITUSR-$-1
 03DE 13        	inx	d
 03DF 13        	inx	d
 03E0 04        	inr	b
 03E1 7CB7      	mov a,h ! ora a ; see if any more selected devices
                	jrnz cos$next
 03E3+20EF      	DB	20H,COS$NEXT-$-1
 03E5 F6FF      	ori 0FFh	; if all selected were ready, return true
                	jr	xitusr
 03E7+185B      	DB	18H,XITUSR-$-1
                
                
                
                const:
 03E9 2A0000    	lhld	@civec	; get console input bit vector
                	jr	ist$scan0
 03EC+1803      	DB	18H,IST$SCAN0-$-1
                
                auxist:
 03EE 2A0000    	lhld @aivec	; get aux input bit vector
                ist$scan0:
 03F1 CD2C04    	call	swtosys
 03F4 114404    	lxi	d,xitusr
 03F7 D5        	push	d
                ist$scan:
 03F8 116103    	lxi	d,cdtbl
 03FB 0600      	mvi	b,0
                cis$next:
                	slar	h	; check next bit
 03FD+CB24      	DB	0CBH, 20H + H
 03FF D20904    	jnc is0
 0402 3E03      	mvi a,3 	; assume device not ready
 0404 CD5304    	call indjmp1	; check status for this device
 0407 B7C0      	ora a ! rnz	; if any ready, return true
 0409 13        is0:	inx	d
 040A 13        	inx	d
 040B 04        	inr	b
 040C 7CB7      	mov a,h ! ora a ; see if any more selected devices
                	jrnz cis$next
 040E+20ED      	DB	20H,CIS$NEXT-$-1
 0410 AF        	xra a		; all selected were not ready, return false
 0411 C9        	ret
                
                
                conin:
 0412 2A0000    	lhld	@civec
                	jr	in$scan0
 0415+1803      	DB	18H,IN$SCAN0-$-1
                
                auxin:
 0417 2A0000    	lhld	@aivec
                in$scan0:
 041A CD2C04    	call	swtosys
                in$scan:
 041D E5        	push	h
 041E CDF803    	call	ist$scan	;see if there is a character ready
 0421 E1        	pop	h
 0422 B7        	ora	a
                	jrz	in$scan ;wait untill one is ready.
 0423+28F8      	DB	28H,IN$SCAN-$-1
 0425 3E06      	mvi	a,6
 0427 CD5D04    	call	indjmp	;get character
                	jr	xitusr
 042A+1818      	DB	18H,XITUSR-$-1
                
                swtosys:
 042C D1        	pop	d	;routine return address
 042D 3A6E04    	lda	@cbnk
 0430 B7        	ora	a
                	jrz	sw0
 0431+280E      	DB	28H,SW0-$-1
                	sspd	iostkp
 0433+ED73      	DB	0EDH,73H
 0435+B201      	DW	IOSTKP
 0437 31B201    	lxi	sp,iostk
 043A F5        	push	psw
 043B 3E00      	mvi	a,0
 043D CD0000    	call	?bnksl
 0440 F1        	pop	psw
 0441 F5        sw0:	push	psw
 0442 D5        	push	d
 0443 C9        	ret 
                
 0444 47        xitusr: mov	b,a
 0445 F1        	pop	psw
 0446 B7        	ora	a
                	jrz	xu0
 0447+2807      	DB	28H,XU0-$-1
 0449 CD0000    	call	?bnksl	;preserves BC.
                	lspd	iostkp
 044C+ED7B      	DB	0EDH,07BH
 044E+B201      	DW	IOSTKP
 0450 78        xu0:	mov	a,b
 0451 B7        	ora	a
 0452 C9        	ret
                
                indjmp1:
 0453 E5        	push	h
 0454 D5        	push	d
 0455 C5        	push	b
 0456 CD5D04    	call	indjmp
 0459 C1        	pop	b
 045A D1        	pop	d
 045B E1        	pop	h
 045C C9        	ret
                
 045D EB        indjmp: xchg
 045E 86        	add	m	;a=0,3,6,9,12,...
 045F 5F        	mov	e,a
 0460 3E00      	mvi	a,0
 0462 23        	inx	h
 0463 8E        	adc	m
 0464 57        	mov	d,a
 0465 EB        	xchg
 0466 E9        	pchl		;indirect call
                
 0467 85        addjmp: add	l	;a=0,3,6,9,...
 0468 6F        	mov	l,a
 0469 3E00      	mvi	a,0
 046B 8C        	adc	h
 046C 67        	mov	h,a
 046D E9        icall:	pchl		;indirect call
                
 046E 00        @cbnk:	db	0		; bank for processor operations
 046F           bnkflg: ds	1	;flag for banked RAM installed.
                
                ;must be at end of all "cseg" code.
 0470 =         thread	equ	$
                
                	dseg	; this part can be banked
 0000           @login: ds	2	;position is assumed by special BNKBDOS3.SPR...
                			; must be first item in DSEG.
                
 0002 =         hbnk	equ	2	;bank to use for Hash tables.
 0100 =         hstart	equ	100h	;reserve page 0 for interupt vectors, etc.
 0002 0000      hleft	dw	0
 0004 0001      hlast	dw	hstart
                ; TODO: @heapt must be checked against CCP for collisions,
                ; but CCP is not loaded/known when buffers are allocated from here.
                ; So, check before saving CCP to bank 0 in cold boot.
 0006 00FC      @heapt:	dw	bnkdos	; top of bank 0 memory, below BNKBDOS
                			; Modules may update this downward.
                
 0008 319201    boot:	lxi	sp,stack
 000B 3A0D00    	lda	13
 000E E6FD      	ani	11111101b	;we must be in bank 0 now or all is lost...
 0010 326400    	sta	@intby
 0013 D3F2      	out	port
 0015 3A0000    	lda	@compg
 0018 3D        	dcr	a	; minus 0100h
 0019 67        	mov	h,a
 001A 2E00      	mvi	l,0
 001C 220200    	shld	hleft
                ; Verify that we have banked RAM...
 001F CD0000    	call	?bnkck
 0022 326F04    	sta	bnkflg	;assume X/2-H8 Bank Switch not installed (error)
                ; Initialize all modules and build tables.
 0025 217004    	lxi	h,thread	;thread our way through the modules,
 0028 5E        in0:	mov	e,m		;initializing as we go.
 0029 23        	inx	h
 002A 56        	mov	d,m	;next module, or "0000" if we're past the end.
 002B 23        	inx	h
 002C 7A        	mov	a,d
 002D B3        	ora	e
 002E CA8400    	jz	init$done
 0031 7E        	mov	a,m	;device base number
 0032 23        	inx	h
 0033 23        	inx	h	;thread+4 = init entry (JMP)
 0034 D6C8      	sui	200	;if Char I/O module, build entry(s) in tables.
 0036 DA7C00    	jc	notchr
 0039 D5        	push	d	;save NEXT module address
 003A 4F        	mov	c,a
 003B 0600      	mvi	b,0
 003D 2B        	dcx	h
 003E 7E        	mov	a,m	;number of devices
 003F 23        	inx	h
 0040 EB        	xchg		;DE=init entry point
 0041 216103    	lxi	h,cdtbl
 0044 09        	dad	b
 0045 09        	dad	b
 0046 47        	mov	b,a
 0047 79        	mov	a,c
 0048 FE0C      in1:	cpi	12
 004A D27500    	jnc	in4	;if device # overflows, adjust next step.
 004D 73        	mov	m,e		;
 004E 23        	inx	h		;
 004F 72        	mov	m,d		;
 0050 23        	inx	h		;
 0051 3C        	inr	a
                	djnz	in1
 0052+10F4      	DB	10H,IN1-$-1
 0054 1B        	dcx	d
 0055 1A        	ldax	d	;number of devices
 0056 47        in3:	mov	b,a
 0057 79        	mov	a,c	;DE=module address, C=device base
 0058 87        	add	a	; *2
 0059 87        	add	a	; *4
 005A 87        	add	a	; *8
 005B 4F        	mov	c,a
 005C 78        	mov	a,b	;number of devices
 005D 0600      	mvi	b,0
 005F 210003    	lxi	h,@ctbl
 0062 09        	dad	b
 0063 EB        	xchg		;DE=@ctbl indexed by device base
 0064 0E12      	mvi	c,17+1	;B=0 still, point to CHRTBL vector
 0066 09        	dad	b	;point to chrtbl location
 0067 4E        	mov	c,m
 0068 23        	inx	h
 0069 66        	mov	h,m
 006A 69        	mov	l,c	;HL=chrtbl
 006B 87        	add	a
 006C 87        	add	a
 006D 87        	add	a	;num.dev * 8 = number of bytes in module's table.
 006E 4F        	mov	c,a	;B=0 still
                	ldir		;copy modules chrtbl into system table.
 006F+EDB0      	DB	0EDH,0B0H
 0071 E1        in2:	pop	h
 0072 C32800    	jmp	in0
                
 0075 91        in4:	sub	c	;compute number of devices that will fit.
 0076 C25600    	jnz	in3	;continue with initialization of tables
 0079 C37100    	jmp	in2
                
                notchr: 		;HL point to init entry
 007C D5        	push	d
 007D CD6D04    	call	icall	;"call" (HL)
 0080 E1        	pop	h
 0081 C32800    	jmp	in0
                
                init$done:		;all Disk I/O modules are initialized.
 0084 0E0B      	mvi	c,11
 0086 C5        in5:	push	b
 0087 CD8C03    	call	cinit
 008A C1        	pop	b
 008B 0D        	dcr	c
 008C F28600    	jp	in5
                
 008F 2A7400    	lhld	icovec
 0092 220000    	shld	@covec	;set console I/O
 0095 2A7600    	lhld	icivec
 0098 220000    	shld	@civec	;
 009B 2A7C00    	lhld	ilovec
 009E 220000    	shld	@lovec	;set list output device
 00A1 2A7800    	lhld	iaovec
 00A4 220000    	shld	@aovec	;set auxiliary I/O device
 00A7 2A7A00    	lhld	iaivec
 00AA 220000    	shld	@aivec	;
 00AD 217E00    	lxi	h,defsrc
 00B0 110100    	lxi	d,@ermde+1	;location of default search chain in SCB
 00B3 010500    	lxi	b,5
                	ldir
 00B6+EDB0      	DB	0EDH,0B0H
 00B8 3A8300    	lda	srctyp
 00BB E618      	ani	000$11$000b
 00BD 4F        	mov	c,a
 00BE 3AF6FF    	lda	@civec-10	;location of search type flags in CCP section
 00C1 E6E7      	ani	111$00$111b
 00C3 B1        	ora	c
 00C4 32F6FF    	sta	@civec-10
 00C7 C39000    	jmp	boot$1
                
                getdrv:
 00CA 21CE00C9  	lxi h,@dtbl ! ret
                
 00CE EE00000000@dtbl:	dw	dnull,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                
 00EE 0000000000dnull:	dw 0,0,0,0,0,0,0,0,0,@dircb,@dtacb,0
 0106 00        	db 0
                
                seldsk:
 0107 79326B00  	mov a,c ! sta @adrv			; save drive select code
 010B 210000    	lxi	h,@lptbl
 010E 060009    	mvi b,0 ! dad b 	      ; create index from drive code
 0111 7E        	mov	a,m
 0112 FEFF      	cpi	255
                	jrz	selerr
 0114+286B      	DB	28H,SELERR-$-1
 0116 326C00    	sta	@pdrv
 0119 4F        	mov	c,a
 011A 43        	mov	b,e	;save login flag thru "search" routine
 011B CDE402    	call	search
                	jrc	selerr
 011E+3861      	DB	38H,SELERR-$-1
 0120 326D00    	sta	@rdrv
 0123 226E00    	shld	curmdl
 0126 C5        	push	b	;save login bit
 0127 110E00    	lxi	d,14
 012A 19        	dad	d	;point to dphtbl
 012B 5E        	mov	e,m	;DE=dphtbl
 012C 23        	inx	h
 012D 56        	mov	d,m
 012E 23        	inx	h
 012F 4E        	mov	c,m	;BC=modtbl
 0130 23        	inx	h
 0131 46        	mov	b,m
 0132 3A6D00    	lda	@rdrv
 0135 87        	add	a
 0136 87        	add	a
 0137 87        	add	a	;*8
 0138 6F        	mov	l,a
 0139 2600      	mvi	h,0
 013B 09        	dad	b	;select mode bytes
 013C 227000    	shld	@cmode	;set current mode pointer
 013F C1        	pop	b	;get login bit back.
                	bit	0,b	;test for initial select.
 0140+CB40      	DB	0CBH,0*8+B+40H
                	jrnz	notlgi
 0142+2041      	DB	20H,NOTLGI-$-1
 0144 EB        	xchg		;DE=modes
 0145 4F        	mov	c,a
 0146 0600      	mvi	b,0
 0148 09        	dad	b	;+*8
 0149 09        	dad	b	;+*16
 014A 09        	dad	b	;+*24
 014B 3A6D00    	lda	@rdrv
 014E 4F        	mov	c,a
 014F 09        	dad	b	;+*1 = +*25
 0150 227200    	shld	@dph
 0153 CDE001    	call	setup$dph
                	jrc	selerr
 0156+3829      	DB	38H,SELERR-$-1
 0158 AF        	xra	a
 0159 32D702    	sta	@rcnfg
 015C 3E03      	mvi	a,3
 015E CDC102    	call	calmod	;call module's "login" routine.
 0161 B7        	ora	a	;see if an error occured.
                	jrnz	selerr
 0162+201D      	DB	20H,SELERR-$-1
 0164 3AD702    	lda	@rcnfg
 0167 B7        	ora	a
 0168 C4E001    	cnz	setup$dph
                	jrc	selerr
 016B+3814      	DB	38H,SELERR-$-1
 016D 3A6B00    	lda	@adrv
 0170 87        	add	a
 0171 4F        	mov	c,a
 0172 0600      	mvi	b,0
 0174 21CE00    	lxi	h,@dtbl
 0177 09        	dad	b
                	lded	@dph
 0178+ED5B      	DB	0EDH,5BH
 017A+7200      	DW	@DPH
 017C 73        	mov	m,e	;set current DPH in @dtbl
 017D 23        	inx	h
 017E 72        	mov	m,d
                	jr	selcom	;DE=dph
 017F+1816      	DB	18H,SELCOM-$-1
                
 0181 210000    selerr: lxi	h,0
 0184 C9        	ret
                
 0185 3A6B00    notlgi: lda	@adrv
 0188 87        	add	a
 0189 4F        	mov	c,a
 018A 0600      	mvi	b,0
 018C 21CE00    	lxi	h,@dtbl
 018F 09        	dad	b
 0190 5E        	mov	e,m	;get current DPH from @dtbl
 0191 23        	inx	h
 0192 56        	mov	d,m	;DE=dph
                	sded	@dph
 0193+ED53      	DB	0EDH,53H
 0195+7200      	DW	@DPH
 0197 2A7000    selcom: lhld	@cmode
 019A 010000    	lxi	b,0	;
                	bit	7,m	;Tracks-per-side not valid for Hard disks.
 019D+CB7E      	DB	0CBH,7*8+M+40H
                	jrnz	selxit
 019F+201C      	DB	20H,SELXIT-$-1
 01A1 23        	inx	h
                	bit	1,m	;unless its Z17...
 01A2+CB4E      	DB	0CBH,1*8+M+40H
                	jrz	sc0
 01A4+2802      	DB	28H,SC0-$-1
 01A6 0604      	mvi	b,4	;then side 1 has 4 less tracks (8 on DT)
 01A8 3E28      sc0:	mvi	a,40	;assume 5" ST
 01AA 23        	inx	h
                	bit	7,m	;check 5" drive
 01AB+CB7E      	DB	0CBH,7*8+M+40H
                	jrz	sc1
 01AD+2802      	DB	28H,SC1-$-1
 01AF 3E4D      	mvi	a,77	;8" drives have 77 tracks
 01B1 4F        sc1:	mov	c,a	;set side 0 tracks
 01B2 90        	sub	b
 01B3 47        	mov	b,a
 01B4 23        	inx	h	;fix for HT bug
                	bit	5,m	;check for DT
 01B5+CB6E      	DB	0CBH,5*8+M+40H
                	jrz	selxit
 01B7+2804      	DB	28H,SELXIT-$-1
                	slar	b	;multiply # of tracks by 2 if DT
 01B9+CB20      	DB	0CBH, 20H + B
                	slar	c	;
 01BB+CB21      	DB	0CBH, 20H + C
                selxit: sbcd	@tps
 01BD+ED43      	DB	0EDH,43H
 01BF+D502      	DW	@TPS
                	lded	@dph
 01C1+ED5B      	DB	0EDH,5BH
 01C3+7200      	DW	@DPH
 01C5 210C00    	lxi	h,+12
 01C8 19        	dad	d	;point to DPB entry
 01C9 4E        	mov	c,m
 01CA 23        	inx	h
 01CB 46        	mov	b,m
 01CC 0A        	ldax	b	;logical sectors-per-track, byte value
 01CD 210F00    	lxi	h,+15
 01D0 09        	dad	b
 01D1 46        	mov	b,m	;psh
 01D2 04        	inr	b
 01D3 05        gh2:	dcr	b
 01D4 CADB01    	jz	gh3
                	srlr	a
 01D7+CB3F      	DB	0CBH, 38H + A
                	jr	gh2
 01D9+18F8      	DB	18H,GH2-$-1
 01DB 32D402    gh3:	sta	@pspt	;physical sectors per track
 01DE EB        	xchg	;put DPH in (HL) for BDOS
 01DF C9        	ret
                
                setup$dph:
 01E0 B7        	ora	a	;reset [CY]
 01E1 2A7000    	lhld	@cmode	;HL=modes
                	bit	7,m	;check for hard-disk drive (modes not standard)
 01E4+CB7E      	DB	0CBH,7*8+M+40H
 01E6 C0        	rnz
 01E7 CD0000    	call	?getdp
 01EA 37        	stc
 01EB C0        	rnz
 01EC 2A7200    	lhld	@dph	;restore dph
 01EF 71        	mov	m,c	;set XLAT table
 01F0 23        	inx	h
 01F1 70        	mov	m,b
 01F2 010B00    	lxi	b,12-1
 01F5 09        	dad	b	;point to dpb
 01F6 73        	mov	m,e	;set DPB
 01F7 23        	inx	h
 01F8 72        	mov	m,d	;(DE=dpb)
 01F9 B7        	ora	a	;reset [CY]
 01FA C9        	ret
                
                ; Allocate space from hash pool into DPH.HASH/HBNK.
                ; Does nothing if space exhausted (caller must init for "no hash")
                ; BC = size of hash, @dph setup
                ; Preserves BC (only)
                ?halloc:
 01FB 2A7200    	lhld	@dph	; check if already set
 01FE 111600    	lxi	d,22
 0201 19        	dad	d	; point to &DPH.HASH
 0202 7E        	mov	a,m
 0203 23        	inx	h
 0204 B6        	ora	m
 0205 C0        	rnz	; <> 00000h, leave as-is
 0206 35        	dcr	m	; 0ffh
 0207 2B        	dcx	h
 0208 35        	dcr	m	; 0ffh = no HASH
 0209 EB        	xchg
 020A 78        	mov	a,b
 020B B1        	ora	c
 020C C8        	rz
 020D 2A0200    	lhld	hleft
 0210 B7        	ora	a
                	dsbc	b
 0211+ED42      	DB	0EDH,B*8+42H
 0213 D8        	rc	; no space - TODO: try next bank
 0214 220200    	shld	hleft
 0217 2A0400    	lhld	hlast
 021A EB        	xchg
 021B 73        	mov	m,e
 021C 23        	inx	h
 021D 72        	mov	m,d
 021E 23        	inx	h
 021F 3602      	mvi	m,hbnk
 0221 EB        	xchg
 0222 09        	dad	b
 0223 220400    	shld	hlast
 0226 C9        	ret
                
 0227 010000    home:	lxi b,0 	; same as set track zero
                settrk: sbcd trk
 022A+ED43      	DB	0EDH,43H
 022C+D802      	DW	TRK
 022E C9        	ret
                
                setsec: sbcd sect
 022F+ED43      	DB	0EDH,43H
 0231+DA02      	DW	SECT
 0233 C9        	ret
                
                setdma: sbcd @dma
 0234+ED43      	DB	0EDH,43H
 0236+8C00      	DW	@DMA
 0238 3A6E04    	lda @cbnk	; default DMA bank is current bank
 023B 32D302    setbnk: sta @dbnk
 023E C9        	ret
                
 023F 6960      sectrn: mov l,c ! mov h,b
 0241 7AB3C8    	mov a,d ! ora e ! rz
 0244 EB096E2600	xchg ! dad b ! mov l,m ! mvi h,0
 0249 2B        	dcx	h	;sectors numbered 0 - (n-1)
 024A C9        	ret
                
 024B 1E06      read:	mvi	e,6	;read entry is +6
 024D C35202    	jmp rw$common			; use common code
                
 0250 1E09      write:	mvi	e,9	;write entry is +9
                
                rw$common:	;do any track/sector/side conversion...
 0252 AF        	xra	a
 0253 32CD02    	sta	@side
 0256 2AD802    	lhld	trk
 0259 22CE02    	shld	@trk
 025C 2ADA02    	lhld	sect
 025F 22D002    	shld	@sect
 0262 2A7000    	lhld	@cmode
                	bit	7,m	;floppy or hard-disk?
 0265+CB7E      	DB	0CBH,7*8+M+40H
                	jrnz	rw0
 0267+2057      	DB	20H,RW0-$-1
 0269 23        	inx	h
 026A 23        	inx	h
 026B 23        	inx	h
                	bit	6,m
 026C+CB76      	DB	0CBH,6*8+M+40H
                	jrz	rw0
 026E+2850      	DB	28H,RW0-$-1
 0270 7E        	mov	a,m
 0271 E603      	ani	0011b	;DSALG
                	jrz	wrap	;as done by MMS
 0273+2834      	DB	28H,WRAP-$-1
 0275 3D        	dcr	a
                	jrz	alt	;as done by Zenith
 0276+2822      	DB	28H,ALT-$-1
 0278 3D        	dcr	a
                	jrz	cont1	;as done by EXO and Televideo.
 0279+280E      	DB	28H,CONT1-$-1
                
 027B 3AD402    cont2:	lda	@pspt	;as done by Gnat
                	srlr	a	;SPT must be EVEN
 027E+CB3F      	DB	0CBH, 38H + A
 0280 4F        	mov	c,a
 0281 3AD002    	lda	@sect
 0284 B9        	cmp	c	;don't change the sector number on side 1
                	jrc	rw0
 0285+3839      	DB	38H,RW0-$-1
                	jr	side1
 0287+1832      	DB	18H,SIDE1-$-1
                
 0289 3AD402    cont1:	lda	@pspt
                	srlr	a	;SPT must be EVEN
 028C+CB3F      	DB	0CBH, 38H + A
 028E 4F        	mov	c,a
 028F 3AD002    	lda	@sect
 0292 91        	sub	c
                	jrc	rw0
 0293+382B      	DB	38H,RW0-$-1
 0295 32D002    	sta	@sect
                	jr	side1
 0298+1821      	DB	18H,SIDE1-$-1
                
 029A 3ACE02    alt:	lda	@trk
 029D 1F        	rar
 029E 32CE02    	sta	@trk
 02A1 3E00      	mvi	a,0
 02A3 17        	ral
 02A4 32CD02    	sta	@side
                	jr	rw0
 02A7+1817      	DB	18H,RW0-$-1
                
                wrap:	lbcd	@tps	;B=tracks on side 1, C=tracks on side 0
 02A9+ED4B      	DB	0EDH,4BH
 02AB+D502      	DW	@TPS
 02AD 3ACE02    	lda	@trk	;(for all except Z17, B=C)
 02B0 B9        	cmp	c
                	jrc	rw0
 02B1+380D      	DB	38H,RW0-$-1
                	neg
 02B3+ED44      	DB	0EDH,44H
 02B5 81        	add	c
 02B6 80        	add	b
 02B7 3D        	dcr	a
 02B8 32CE02    	sta	@trk
 02BB 3E01      side1:	mvi	a,1
 02BD 32CD02    	sta	@side
 02C0 7B        rw0:	mov	a,e
 02C1 2A6E00    calmod: lhld	curmdl
 02C4 C36704    	jmp	addjmp			; leap to driver
                
 02C7 32D202C9  multio: sta @cnt ! ret
                
 02CB AFC9      flush:	xra a ! ret		; return with no error
                
                
 02CD           @side:	ds	1		; current side of media (floppy only)
 02CE           @trk:	ds	2		; current track number
 02D0           @sect:	ds	2		; current sector number
 02D2 00        @cnt:	db	0		; record count for multisector transfer
 02D3 00        @dbnk:	db	0		; bank for disk DMA operations
 02D4           @pspt:	ds	1		; physical sectors per track
 02D5           @tps:	ds	2
 02D7           @rcnfg: ds	1
 02D8           trk:	ds	2		 
 02DA           sect:	ds	2
                
 02DC           @scrbf: ds	1024
                
                ; These MUST be set by memory module
 06DC 0000      @dtacb: dw	0
 06DE 0000      @dircb: dw	0
                
 06E0           	end
