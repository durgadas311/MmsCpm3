vers equ '1 ' ; July 13, 1983  10:48  mjm  "LDR316.ASM"
**********************************************************
;	Loader Disk I/O module for MMS CP/M 3.1
;	for the MMS DD controller 77316
;	Copyright (c) 1983 Magnolia Microsystems
;*********************************************************

	MACLIB Z80

	public btend		;end of system (boot stops loading there)
	extrn BDOS,CBOOT,DSKSTA,TIMEOT,MIXER,DIRBUF,DLOG
	extrn NEWDSK,NEWTRK,NEWSEC,DMAA

driv0	equ	29		; first drive in system

; Physical drives are assigned as follows:
;
;	29 - 1st 8" drive
;	30 - 2nd 8" drive
;	31 - 3rd 8" drive
;	32 - 4th 8" drive
;	33 - 1st 5" drive
;	34 - 2nd 5" drive
;	35 - 3rd 5" drive
;	36 - 4th 5" drive
;
;	Ports and Constants

CTRL	EQU	038H		; EXTERNAL DISK CONTROL
WD1797	EQU	03CH		; CONTROLLER CHIP ADDRESS
STAT	EQU	WD1797		; STATUS REGISTER
TRACK	EQU	WD1797+1	; TRACK REGISTER
SECTOR	EQU	WD1797+2	; SECTOR REGISTER
DATA	EQU	WD1797+3	; DATA REGISTER
PORT	EQU	0F2H		; Z89 INTERRUPT CONTROL

DPHL	EQU	16		; LENGTH OF DISK PARAMETER HEADER
DPBL	EQU	15		; LENGTH OF DISK PARAMETER BLOCK
DPHDPB	EQU	10		; LOCATION OF DPB ADDRESS WITHIN DPH
MOD48RO EQU	00000100B	; 48 TPI DISK IN 96 TPI DRIVE (R/O)
MODEDD	EQU	01000000B	; DOUBLE DENSITY
LABLEN	EQU	19H		; LENGTH OF Z37 DISK LABEL
LABEL	EQU	04H		; POSITION OF LABEL IN SECTOR 0
LABHTH	EQU	05H		; START OF "HEATH EXTENSION" IN SECTOR 0
MODE2S	EQU	00000001H	; DOUBLE SIDED
LABDPB	EQU	0DH		; START OF DPB IN SECTOR 0
LABVER	EQU	00		; LABEL VERSION NUMBER
DPEH37	EQU	60H		; I.D.

; Standard CP/M page-zero assignments
?INT$BYTE	equ	13
?RST6		equ	(6)*8	; Interrupt routine for DD board

; Start of relocatable disk I/O module.
	cseg			; START OF MODULE

	jmp	init
	JMP	SEL$COMBO
	JMP	READ$COMBO

	DB	'77316 ',0,'MMS Double Density Loader ',0,'3.10'
	dw	vers
	db	'$'

; NOTE: DPH's are selected for mode and not by drive.   ; btmode codes
DPH:	DW	0,0,0,0,DIRBUF,dpb8sdss,CSV,ALV 	; 0 = SD 8"    bit 7=0
	DW	0,0,0,0,DIRBUF,dpb8ddss,CSV,ALV 	; 1 = DD SS 8" bit 7=1
	DW	0,0,0,0,DIRBUF,dpb8ddds,CSV,ALV 	; 2 = DD DS 8" bit 7=1
	DW	0,0,0,0,DIRBUF,dpb5ssst,CSV,ALV 	; 3 = DD SS ST 5"
	DW	0,0,0,0,DIRBUF,dpb5dsst,CSV,ALV 	; 4 = DD DS ST 5"
	DW	0,0,0,0,DIRBUF,dpb5ssdt,CSV,ALV 	; 5 = DD SS DT 5"
	DW	0,0,0,0,DIRBUF,dpb5dsdt,CSV,ALV 	; 6 = DD DS DT 5"
defdph: dw	0,0,0,0,0,DEFDPB

dpb8ddds:	; MMS 8" DD DS
	DW	64		; SECTORS PER TRACK
	DB	4,15,0		; BSH,BSM,EXM
	DW	608-1,192-1	; DSM-1,DRM-1
	DB	11100000B,0	; AL0,AL1
	DW	48,2		; CKS,OFF
	DB	00100010B,01100110B,00000000B	; MODE BYTES

dpb8ddss:	; MMS 8" DD SS
	DW	64		; SECTORS PER TRACK
	DB	4,15,0		; BSH,BSM,EXM
	DW	300-1,192-1	; DSM-1,DRM-1
	DB	11100000B,0	; AL0,AL1
	DW	48,2		; CKS,OFF
	DB	00000010B,01100110B,00000000B	; MODE BYTES

dpb8sdss:	; 8" SD SS
	DW	26		; SECTORS PER TRACK
	DB	3,7,0		; BSH,BSM,EXM
	DW	243-1,64-1	; DSM-1,DRM-1
	DB	11000000B,0	; AL0,AL1
	DW	16,2		; CKS,OFF
	DB	00000000B,00000110B,00000001B	; MODE BYTES

dpb5ssst:	; MMS 5" SS ST (DD)
	DW	36		; SECTORS PER TRACK
	DB	4,15,1		; BSH,BSM,EXM
	DW	83-1,96-1	; DSM-1,DRM-1
	DB	11000000B,0	; AL0,AL1
	DW	24,3		; CKS,OFF
	DB	00000010B,01100011B,00000000B	; MODE BYTES

dpb5dsst:	; MMS 5" DS ST (DD)
	DW	36		; SECTORS PER TRACK
	DB	4,15,1		; BSH,BSM,EXM
	DW	173-1,96-1	; DSM-1,DRM-1
	DB	11000000B,0	; AL0,AL1
	DW	24,3		; CKS,OFF
	DB	00100010B,01100011B,00000000B	; MODE BYTES

dpb5ssdt:	; MMS 5" SS DT (DD)
	DW	36		; SECTORS PER TRACK
	DB	5,31,3		; BSH,BSM,EXM
	DW	86-1,128-1	; DSM-1,DRM-1
	DB	10000000B,0	; AL0,AL1
	DW	32,3		; CKS,OFF
	DB	00000010B,01101011B,00000000B	; MODE BYTES

dpb5dsdt:	; MMS 5" DS DT (DD)
	DW	36		; SECTORS PER TRACK
	DB	5,31,3		; BSH,BSM,EXM
	DW	176-1,128-1	; DSM-1,DRM-1
	DB	10000000B,0	; AL0,AL1
	DW	32,3		; CKS,OFF
	DB	00100010B,01101011B,00000000B	; MODE BYTES

DEFDPB: DW	26		; EXTRA DPB AND MODE BYTES TO BE USED ONLY
	DB	3,7,0		; BY DRIVER WHEN ACCESSING TRACK 0
	DW	243-1,64-1	; OF A ZENITH 8" DD DISK. TRACK 0 ON THESE
	DB	11000000B,0	; DISKS IS OF THE STANDARD SINGLE DENSITY
	DW	16,2		; FORMAT
	DB	00000000B,00000010B,00000000B

;	Sector translation tables for 8" 

SKEW1:	DB	1,7,13,19,25,5,11,17,23,3,9,15,21
	DB	2,8,14,20,26,6,12,18,24,4,10,16,22

 if 0	;not needed if booting only from MMS formats
SKEW2:	DB	1,2,19,20,37,38,3,4,21,22,39,40
	DB	5,6,23,24,41,42,7,8,25,26,43,44
	DB	9,10,27,28,45,46,11,12,29,30,47,48
	DB	13,14,31,32,49,50,15,16,33,34,51,52
	DB	17,18,35,36

SKEW3:	DB	1,2,3,4,5,6,7,8,33,34,35,36,37,38,39,40
	DB	9,10,11,12,13,14,15,16,41,42,43,44,45,46,47,48
	DB	17,18,19,20,21,22,23,24,49,50,51,52,53,54,55,56
	DB	25,26,27,28,29,30,31,32,57,58,59,60,61,62,63,64

SKEW4:	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 endif
 
INIT:
	LXI	H,INTRQ$ROUTINE ; load interrupt routine into page-zero
	LXI	D,?RST6 	; as Restart 6.
	LXI	B,LEN$IR
	LDIR			; block transfer
	IN	STAT		; CLEAR WD-1797 from power-on (or whatever)
	lda	2287H		; boot drive in boot module
	sta	mixer
	RET


SEL$COMBO:
	LDA	NEWDSK		; get drive select code in 'A'.
	SUI	DRIV0
	STA	RELDSK		; SAVE IT
	LXI	H,DPH		; POINT TO DPH TABLE
	lda	2288H		; select which mode we booted in from boot mod
	add	a
	add	a
	add	a
	add	a	;*16 for DPH select
	add	l
	mov	l,a
	mvi	a,0
	adc	h
	mov	h,a
SEL0:	PUSH	H		; SAVE DPH ADDRESS
	XRA	A
	STA	SELERR		; NO SELECT ERROR (YET)
	STA	FLAG$8DD	; CLEAR 8" DD FLAG
	LXI	D,DPHDPB
	DAD	D		; POINT TO ADDRESS OF DPB
	CALL	HLIHL		; POINT TO DPB
	SHLD	CURDPB
	LXI	D,DPBL
	DAD	D		; POINT TO MODE BYTES
	SHLD	MODE		; SAVE MODE BYTE POINTER
	PUSH	H
	CALL	LOGIN		; HAS DISK BEEN LOGGED IN ?
	JRC	LOGGED
	POP	H		; GET MODE BYTE 1
	PUSH	H
	BIT	4,M		; SHOULD WE READ TRACK 0 SECTOR 0 ?
	CNZ	PHYSEL
	POP	H		; GET MODE BYTE 1
	PUSH	H
	INX	H		; MODE BYTE 2
	BIT	2,M		; IS IT A 5.25" DISK ?
	CZ	PHYSEL3 	; THEN CHECK FOR HALF TRACK
LOGGED: POP	H		; GET MODE BYTE 1
	INX	H		; MODE BYTE 2
	MVI	A,40		; 40 TRACKS PER SIDE
	BIT	3,M		; CHECK TRACK DENSITY BIT
	JRZ	STRK
	ADD	A		; 80 TRACKS PER SIDE
STRK:	BIT	2,M		; CHECK FOR 8"
	JRZ	NOT8DD
	MVI	A,77		; 8" DISK HAVE 77 TRACKS PER SIDE
	BIT	6,M		; CHECK FOR DD
	JRZ	NOT8DD
	STA	FLAG$8DD	; FLAG AN 8" DD DISK
NOT8DD: STA	TPS		; SAVE TRACKS PER SIDE
	INX	H		; POINT TO MODE BYTE 3
	MOV	A,M
	ANI	00000111B	; ISOLATE SKEW TABLE BITS
	LXI	D,0
	JRZ	GOTSKW 
	LXI	D,SKEW1
	DCR	A
	JRZ	GOTSKW
 if 0	;not needed for MMS formats
	LXI	D,SKEW2
	DCR	A
	JRZ	GOTSKW
	LXI	D,SKEW3
	DCR	A
	JRZ	GOTSKW
	LXI	D,SKEW4
 endif
GOTSKW: POP	H		; GET DPH ADDRESS BACK
	push	h
	MOV	M,E
	INX	H
	MOV	M,D		; SKEW TABLE ADDRESS INSTALLED IN DPH
; CALCULATE DEBLOCKING PARAMETERS
	LHLD	CURDPB		; GET DPB ADDRESS
	INX	H
	INX	H
	INX	H
	MOV	A,M		; GET BLOCK MASK
	STA	BLKMSK		; SAVE IT
	LXI	D,10
	DAD	D
	MOV	A,M		; GET TRACK OFFSET
	STA	OFFSET		; SAVE IT
	LHLD	MODE
	MOV	A,M
	ANI	03H		; ISOLATE SECTOR SIZE BITS
	STA	BLCODE		; STARE AS DEBLOCK CODE
; RETURN TO BIOS
	LDA	RELDSK
	MOV	C,A		; RESTORE PHYSICAL DRIVE #
	pop	h		; SELDSK NEEDS DPH in HL
	RET

LOGIN:	lhld	dlog		; CHECK FOR DISK LOGGED IN
	mov	a,l
	rar
	RET

PHYSEL: LDA	NEWDSK
	STA	HSTDSK
	XRA	A
	STA	HSTTRK		; TRACK 0
	STA	HSTSEC		; SECTOR 0
	STA	SELOP		; FLAG A SELECT OPERATION
	STA	MODFLG		; RESET CHANGED MODE FLAG
	MVI	A,5		; 5 RETRYS FOR A SELECT OPERATION
	STA	RETRYS
	CALL	READ		; TRY READING LABEL AT DENSITY
				; CURRENTLY INDICATED IN TABLES
	JRZ	PHYSEL1 	; BR IF SUCCESSFUL
	MVI	A,5		; RESET RETRYS TO 5
	STA	RETRYS
	STA	MODFLG		; SET CHANGED MODE FLAG
	LHLD	MODE
	INX	H		; POINT TO MODE BYTE 2
	MOV	A,M		; TRY OTHER DENSITY
	XRI	MODEDD
	MOV	M,A
	CALL	READ		; TRY TO READ LABEL
	JRNZ	PHYSEL5 	; ERROR
PHYSEL1:XRA	A		; ZERO ACCUM.
	MVI	B,LABLEN	; GET LENGTH OF LABEL
	LXI	H,HSTBUF+LABEL
CHKLAB1:ADD	M
	INX	H
	DJNZ	CHKLAB1
	INR	A
	JRZ	PHYSEL2 	; BR IF CORRECT CHECKSUM
	LDA	MODFLG
	ORA	A		; MODE BEEN CHANGED ?
	JRNZ	PHYSEL6 	;  THEN ERROR
	JR	PHYSEL7 	; OTHERWISE DONE, KEEPING OLD MODE BYTES

;
;  EXTRACT MODE INFORMATION FROM LABEL
;
PHYSEL2:
	LHLD	MODE		; HL POINTS TO MODE BYTE
	LXI	D,HSTBUF+LABHTH ; DE POINTS TO HEATH EXTENSION IN LABEL
	LDAX	D		; GET FIRST BYTE OF HEATH EXTENSION
	MVI	B,00011000B	; Z37 DOUBLE DENSITY FORMAT
	MVI	C,00000001B	; 256 BYTES PER SECTOR
	BIT	2,A		; GET EXTENDED DOUBLE DENSITY BIT
	JRZ	GETSID
	MVI	B,00110000B	; Z37 EXTENDED DOUBLE DENSITY FORMAT
	MVI	C,00000011B	; 1024 BYTES PER SECTOR
GETSID: ANI	00000001B	; GET SIDED BIT
	RRC
	RRC
	RRC			; MOVE TO BIT POSITION 5
	ORA	C		; OR IN SECTOR SIZE BITS
	ORI	00010100B	; OR IN OTHER Z37 RELATED BITS
	MOV	M,A		; SAVE NEW MODE BYTE 1
	INX	H		; POINT TO MODE BYTE 2
	MVI	C,0		; BITS FOR SINGLE DENSITY
	LDAX	D
	BIT	1,A		; GET DOUBLE DENSITY BIT
	JRZ	SDEN
	MVI	C,01100000B	; DOUBLE DENSITY
SDEN:	ANI	00001000B	; GET TRACK DENSITY BIT
	ORA	C		; OR IN SECTOR SIZE BITS
	MOV	C,A
	MOV	A,M		; GET MODE BYTE 2
	ANI	00000011B	; KEEP STEP RATE BITS
	ORA	C		; OR IN NEW BITS
	MOV	M,A		; SAVE NEW MODE BYTE 2
	INX	H		; POINT TO MODE BYTE 3
	MOV	M,B		; SAVE NEW MODE BYTE 3
;
;		MOVE LABEL INFO TO DISK PARAMETER BLOCK.
;
	LDED	CURDPB		; GET DPB ADDRESS
	LXI	H,HSTBUF+LABDPB ; GET ADDRESS OF INFO IN LABEL
	LXI	B,DPBL		; COUNT TO MOVE
	LDIR			; MOVE INFO
	JR	PHYSEL7


PHYSEL5:MVI	A,0FFH
	STA	HSTDSK		; FLAG BUFFER AS UNKNOWN
PHYSEL6:MVI	A,1
	STA	SELERR		; FLAG A SELECT ERROR
PHYSEL7:MVI	A,0FFH
	STA	SELOP		; SELECT OPERATION IS OVER
	RET

PHYSEL3:CALL	SELECT
	CALL	CHKRDY
	JRC	PHYSEL6 	; ERROR IF NOT READY
	CALL	HOME		;RESTORE HEAD TO TRACK 0
	JRC	PHYSEL6
	MVI	B,01001000B	;STEP IN, NO UPDATE
	CALL	TYPE$I
	CALL	TYPE$I		;STEP IN TWICE
	MVI	A,11000000B	; READ ADDRESS
	CALL	PUT$I
	ANI	00011000B SHL 1
	JRNZ	PHYSEL6
	IN	SECTOR
	CPI	2
	JRZ	PHYSEL4
	CPI	1
	JRNZ	PHYSEL6
	LHLD	MODE
	INX	H		; MODE BYTE 2
	BIT	3,M		; IS MODE SET TO DOUBLE TRACK ?
	JRNZ	PHYSEL6 	; ERROR BECAUSE WRONG DPB IS INSTALLED
	SETB	4,M		; SET HALF TRACK BIT
PHYSEL4:			; RESTORE
	CALL	HOME  
	JRC	PHYSEL6
	JR	PHYSEL7

READ$COMBO:
	LDA	SELERR		; WAS THERE AN ERROR ON SELECT ?
	ORA	A
	RNZ
	MVI	A,21		; 21 RETRYS FOR A READ/WRITE OPERATION
	STA	RETRYS
	LDA	NEWTRK
	ORA	A		; ARE WE ON TRACK 0 ?
	JRNZ	NOTZ8DD
	LHLD	MODE
	INX	H		; MODE BYTE 2
	MOV	A,M
	ANI	01100000B	; ISOLATE THE TWO DENSITY BITS
	CPI	01000000B	; IS IT DD WITH TRACK 0 SD ?
	JRNZ	NOTZ8DD
	lxi	h,defdph	; THEN WE MUST RE-SELECT DISK AS 8" SD
	PUSH	D		; SAVE REG. D
	CALL	SEL0
	POP	D		; RESTORE REG. D
	LXI	H,RESEL 	; RESELECT DISK WHEN DONE WITH I/O OPERATION
	PUSH	H
NOTZ8DD:PUSH	D		; TEMPORARILY SAVE RECORD NUMBER
	LXI	B,3
	LXI	H,NEWDSK
	LXI	D,REQDSK
	LDIR
	POP	D		; RESTORE RECORD NUMBER
	XRA	A		; CLEAR CARRY
	MOV	C,A		; CALCULATE PHYSICAL SECTOR
	LDA	BLCODE
	MOV	B,A
	LDA	NEWSEC
DBLOK1: DCR	B
	JM	DBLOK2
	RAR
	RARR	C
	JR	DBLOK1
DBLOK2: STA	REQSEC		; SAVE IT
	LDA	BLCODE		; CALCULATE BLKSEC
DBLOK3: DCR	A
	JM	DBLOK4
	RLCR	C
	JR	DBLOK3
DBLOK4: MOV	A,C
	STA	BLKSEC		; STORE IT

	INR	A		; NON-ZERO VALUE TO ACC.
	STA	RD$FLAG 	; FLAG A PRE-READ
	XRA	A		; NO LONGER WRITING AN UNALLOCATED BLOCK
	STA	UNALLOC
	LXI	H,NEWTRK
	LDA	OFFSET
	CMP	M		; IS IT THE DIRECTORY TRACK ?
	JRNZ	CHKBUF
	INX	H
	MOV	A,M
	ORA	A		; FIRST SECTOR OF DIRECTORY ?
	JRZ	READIT 
CHKBUF: LXI	H,REQDSK
	LXI	D,HSTDSK
	MVI	B,3
CHKNXT: LDAX	D
	CMP	M
	JRNZ	READIT
	INX	H
	INX	D
	DJNZ	CHKNXT
	JR	NOREAD		; THEN NO NEED TO PRE-READ
READIT:
	LXI	D,HSTDSK	; SET UP NEW BUFFER PARAMETERS
	LXI	H,REQDSK
	LXI	B,3
	LDIR
	LDA	RD$FLAG 	; DO WE NEED TO PRE-READ ?
	ORA	A
	CNZ	RD$SEC		; READ THE SECTOR
NOREAD: LXI	H,HSTBUF	; POINT TO START OF SECTOR BUFFER
	LXI	B,128
	LDA	BLKSEC		; POINT TO LOCATION OF CORRECT LOGICAL SECTOR
MOVIT1: DCR	A
	JM	MOVIT2
	DAD	B
	JR	MOVIT1
MOVIT2: LDED	DMAA		; POINT TO DMA
	LDIR			; MOVE IT
	XRA	A		; FLAG NO ERROR
	RET			; RETURN TO BDOS (OR RESEL ROUTINE)

RD$SEC: CALL	READ		; READ A PHYSICAL SECTOR
	RZ			; RETURN IF SUCCESSFUL
	MVI	A,0FFH		; FLAG BUFFER AS UNKNOWN
	STA	HSTDSK
	POP	D		; THROW AWAY TOP OF STACK
	MVI	A,1		; SIGNAL ERROR TO BDOS
	RET			; RETURN TO BDOS (OR RESEL ROUTINE)

RESEL:	PUSH	PSW		; SAVE STATUS OF I/O OPERATION
	CALL	SEL$COMBO	; SET UP CORRECT DISK PARAMETERS AGAIN
	POP	PSW		; RECALL STATUS OF I/O OPERATION FOR BDOS
	RET			; RETURN TO BDOS

READ:	CALL	ACCESS$R	; START DRIVE AND STEP TO PROPER TRACK
	JRC	ERROR
	CALL	IO$COMBO	; Read in the sector to the proper buffer.
	JRZ	NOT8DDR
	LXI	D,RD$8DD
NOT8DDR:MVI	B,10001000B	; READ COMMAND W/O SIDE SELECT
	MVI	A,0A2H		; INI INSTRUCTION (2ND BYTE)
	JR	TYPE$II

ERROR:	XRA	A		; PSW/Z MUST BE RESET TO INDICATE ERROR
	INR	A
	RET

TYPE$II:
	STA	FIX1+1		;setup physical routines for read/write
RETRY:						     
	PUSH	B		; save registers
	PUSH	D
	LDA	?INT$BYTE	; get interrupt byte
	ANI	11111101B	; Turn 2 millisecond clock off
	OUT	PORT		; to prevent interupts from causing lost-data

	LDA	SIDE		; get the side select bits
	ORA	B		; merge COMMAND and SIDE SELECT bits
	CALL	TYPE$II$COM	; execute disk transfer routine set by 'DE'.
	STA	DSKSTA		; save status of transfer
	LDA	CTRL$IMAGE
	OUT	CTRL		; BURST MODE OFF.
	LDA	?INT$BYTE	; get interrupt byte
	OUT	PORT		; CLOCK ON AGAIN

	XRA	A		; CLEAR CARRY FOR DSBC
	LXI	D,HSTBUF
	DSBC	D		; HL NOW CONTAINS # OF BYTES TRANSFERRED
	LDA	DSKSTA		; check for successful transfer
	ANI	10111111B
	JRNZ	IOERR		; RETRY IF ERROR
	LDA	SELOP		; IS THIS A SELECT OPERATION ?
	ORA	A
	JRZ	POPRET		; THEN DON'T CHECK SECTOR SIZE
	LDA	BLCODE		; CHECK IF CORRECT NUMBER OF BYTES TRANSFERRED
	CPI	3
	JRNZ	NOTED		; BLCODE=3 => 1024 BYTE SECTOR EXPECTED
	INR	A		; INCREMENT BECAUSE (H) FOR 1024 IS 4
NOTED:	CMP	H		; COMPARE TO EXPECTED SIZE
POPRET: POP	D
	POP	B
	RZ			; RETURN IF CORRECT
	JR	TRYAGN		; RETRY IF INCORRECT
IOERR:	CM	CHKRDY		; IF DISK WAS NOT READY, WAIT FOR READY SIGNAL
	POP	D
	POP	B
	JC	ERROR		; ERROR IF NO READY SIGNAL
TRYAGN: LXI	H,RETRYS	; decrement retry count
	DCR	M
	JZ	ERROR		; NO MORE RETRIES
	MOV	A,M
	CPI	10
	JNC	RETRY		; LESS THAN TEN RETRYS LEFT => STEP HEAD
	LDA	SELOP
	ORA	A
	JZ	RETRY		; DO NOT STEP HEAD IF SELECT OPERATION
	PUSH	B		; SAVE REGISTERS
	PUSH	D
	CALL	STEPIN		; STEP IN COMMAND
	CALL	SEEK		; SEEK WILL REPOSITION HEAD
	POP	D		; RESTORE REGISTERS
	POP	B
	JMP	RETRY		; TRY AGAIN

IO$COMBO:
	LHLD	MODE
	MOV	A,M		; GET MODE BYTE 1
	ANI	00001100B	; ISOLATE TRACK NUMBERING BITS
	CPI	00001000B	; IS IT XOS/GNAT NUMBERING ?
	LDA	HSTSEC		; GET SECTOR NUMBER
	JRNZ	NOTRAN
	LHLD	CURDPB		;*** This is supposed to translate sector
	CMP	M		;*** for the GNAT or X-O but it won't
	JRC	NOTRAN		;*** work as coded here. The SIDE byte must be
	SUB	M		;*** updated and the sector must be compared to
				;*** SPT/2 not SPT as coded.
NOTRAN: INR	A		; MAKE IT 1,2,3,...,SPT
	OUT	SECTOR		; give to controller
	LXI	D,IO$1024	; I/O ROUTINE FOR ALL BUT 8" DD
	LDA	FLAG$8DD	; CHECK FOR 8" DD
	ORA	A		; ZERO FLAG SET IF NOT
	RET

IO$1024:
	OUT	STAT		; send command to controller
	EI			; turn on interrupts
RW1	HLT			; WAIT FOR DRQ
FIX1	INI			; transfer byte (INI becomes OUTI for writes)
	JR	RW1		; loop until transfer complete.


RD$8DD:
	PUSH	PSW		; SAVE COMMAND
	LDA	CTRL$IMAGE
	ANI	11011111B	; set BURST MODE for hi-speed transfer
	OUT	CTRL
	POP	PSW		; restore disk command
	OUT	STAT		; GIVE COMMAND TO CONTROLLER
	EI
	HLT
RD1	INI
	JNZ	RD1
RD2	INI
	JNZ	RD2
RD3	INI
	JNZ	RD3
RD4	INI
	JNZ	RD4
	JR	$-1

TYPE$II$COM:
	LXI	B,(0)*256+(DATA) ; SETUP FOR 256 BYTES
	LXI	H,HSTBUF	 ; DATA BUFFER ADDRESS
	PUSH	D		 ; put 'DE' on stack.
	RET			 ; return to that address.

SELECT:
	LHLD	MODE		; point to drive mode byte table
	LDA	RELDSK		; get the RELATIVE drive number
	MOV	C,A		; relative drive number in (C) (rel. to driv0)
	INX	H		; POINT TO MODE BYTE 2
	MOV	A,M
	ANI	01000000B	; ISOLATE DENSITY BIT
	XRI	01000000B	; REVERSE IT (CONTROLLER WANTS 1 FOR SDEN.)
	ORA	C		; OR IN DRIVE SELECT CODE
	ORI	00101000B	; BURST MODE OFF, interrupt line enabled
	STA	CTRL$IMAGE	; save image for subsequent outputs
	MOV	A,M
	ANI	00000011B	; setup steprate bits for seek-restore commands
	STA	STEPRA		; RATE FOR SUBSEQUENT SEEK/RESTORE
	LXI	H,LOGDSK	; save position (track) of current drive
	MOV	A,M
	SUB	C		; CURRENT DRIVE SAME AS REQUESTED DRIVE ?
	PUSH	PSW		; SAVE RESULT ON STACK
	MOV	E,M		; in 'trks' array addressed by contents of
	MOV	M,C		; location 'logdsk'.
	MVI	B,0
	MOV	D,B
	LXI	H,TRKS
	DAD	D
	IN	TRACK
	MOV	M,A		; SAVE CURRENT TRACK #
	LXI	H,TRKS		; identify position (track) of requested drive
	DAD	B		; from 'trks' array addressed by new 'logdsk'.
	POP	PSW
	MOV	C,A		; RETURN RESULT OF ABOVE SUB C TO REG. C
	MOV	A,M
	OUT	TRACK		; set track number
	OUT	DATA		; SEEK TO same TRACK CAUSES
	MVI	A,00011011B	; HEAD-LOAD ONLY
	DI	;MUST NOT BE DISTRACTED
	OUT	STAT		; ISSUE COMMAND, HEAD WILL LOAD IN 15uS
	DAD	D		; 5.371 uS
	LDA	CTRL$IMAGE	; +6.348 =11.719 uS
	OUT	CTRL		; +5.371 = 17.090 uS, HEAD IS LOADED BY NOW
	EI			; COMMAND WILL FINISH IN ABOUT 30 uS
	JR $-1			; "RET" DONE BY INTRQ ROUTINE

ACCESS$R:
	CALL	SELECT
	MOV	A,C		; ARE WE SELECTING A DIFFERENT
	ORA	A		; DRIVE FROM BEFORE ?
	JRZ	SEEK
	LXI	D,33000 	; MUST WAIT 400 MS
WAIT:	DCX	D
	MOV	A,D
	ORA	E
	JRNZ	WAIT
SEEK:
	LDA	HSTTRK		; GET REQUESTED TRACK
	MVI	B,0		; SET SIDE VALUE FOR SIDE 0
	LHLD	MODE
	BIT	2,M	;*** NOTE: this test doesnot take into account the
			;*** condition of "GNAT/XO" or UNDEFINED codes.
	JRNZ	CONZEN		; ALTERNATE CONVERT PROCEDURE FOR ZENITH DISKS
	LXI	H,TPS		; GET TRACKS PER SIDE
	MOV	C,M
	CMP	C		; compare requested track with tracks-per-side
	JRC	SIDE0		; no conversion if on first side.	 
	CMA			; negate logical track number	 
	INR	A	
	ADD	C		; add tot tracks on disk surfaces (2*NUM$TRKS)
	ADD	C	
	DCR	A		; sub 1 because tracks start at 0	 
	JR	SIDE1 
CONZEN: BIT	5,M		; CHECK SIDED BIT
	JRZ	SIDE0		; NO CONVERT IF SINGLE SIDED
	RAR			; DIVIDE BY 2 TO GET REAL TRACK NUMBER
	JRNC	SIDE0
SIDE1:	MVI	B,00000010B	; set side value for 2nd side	 

SIDE0:	MOV	C,A		; store track number
	MOV	A,B		
	STA	SIDE		; save side value for read/write command
	LXI	H,SEKERR	; initialize seek error counters
	MVI	M,4		; 4 ERRORS ON SEEK IS FATAL
	INX	H
	MVI	M,10		; RESTORE once, then 9 errors are fatal
RETRS:	CALL	CHKRDY		; MAKE SURE DRIVE IS READY
	RC			; quit if drive is not ready
	MOV	A,C		; get track number back
	ORA	A		; FORCES "RESTORE" IF "seek to track 0"
	JRZ	HOME		;RESTORE HEAD TO TRACK 0
	LHLD	MODE		;TRACK NUMBER IN (A) MUST BE PRESERVED
	INX	H		; MODE BYTE 2
	MOV	H,M		; BIT 4 IS THE HALF-TRACK OPTION
	IN	TRACK		;CURRENT HEAD POSITION,
	SUB	C		;SEE HOW FAR WE WANT TO GO.
	RZ			;IF ZERO TRACKS TO STEP, WERE FINISHED
	MVI	B,01111000B	;ASSUME STEP-OUT + UPDATE + HEADLOAD
	JRNC	STOUT	;ASSUMPTION WAS CORRECT...
	MVI	B,01011000B	;ELSE MUST BE STEP-IN
	NEG		;AND NUMBER OF TRACKS WOULD BE NEGATIVE
STOUT:	MOV	L,A		;COUNTER FOR STEPING
SEEK5:	BIT	4,H		; CHECK FOR 48 TPI DISK IN 96 TPI DRIVE
	JRZ	NOTHT
	RES	4,B	;SELECT NO-UPDATE
	CALL	TYPE$I	;STEP HEAD
	ANI	00000100B SHL 1 ;DID THIS STEP PUT US AT TRACK 0 ?
	JRNZ	TRK0ERR
NOTHT:	SETB	4,B	;SELECT UPDATE TO TRACK-REG
	CALL	TYPE$I	;STEP HEAD
	ANI	00000100B SHL 1 ;DID THIS STEP PUT US AT TRACK 0 ?
	JRNZ	TRK0ERR
	DCR	L
	JRNZ	SEEK5
	IN	SECTOR		;SAVE CURRENT SECTOR NUMBER
	MOV	L,A
	CALL	READ$ADDR	; GET ACTUAL TRACK UNDER HEAD (IN SECTOR REG)
	IN	SECTOR		;GET TRACK NUMBER FROM MEDIA
	MOV	H,A
	MOV	A,L
	OUT	SECTOR		;RESTORE SECTOR NUMBER
	LDA	DSKSTA		;GET TRUE ERROR STATUS OF READ-ADDRESS
	RLC
	RC			;DRIVE NOT READY
	ANI	00011000B SHL 1 ; CRC ERROR + REC-NOT-FOUND
	MOV	A,H		; ACTUAL TRACK FROM READ-ADDRESS
	LXI	H,SEKERR	;POINT TO ERROR COUNTERS
	JRNZ	RESTR0
	CMP	C		; (C) MUST STILL BE VALID DEST. TRACK
	RZ	;NO ERRORS
RTS00:	DCR	M		; SHOULD WE KEEP TRYING ?
	STC
	RZ			;NO, WE'VE TRYED TOO MUCH
	OUT	TRACK		; re-define head position accordingly
	JR	RETRS		; RETRY SEEK

TRK0ERR:
	XRA	A
	LXI	H,SEKERR
	JR	RTS00

RESTR0: INX	H		; RESTORE ERROR COUNT
	DCR	M
	STC
	RZ			; If count 0, return with Carry set.
	MOV	A,M
	CPI	9
	JRNC	RESTR1		; RESTORE ONLY FIRST TIME
	CALL	STEPIN		; OTHERWISE STEP HEAD IN 1 TRACK
	JR	RETRS
RESTR1: 			; RESTORE HEAD TO TRACK 0
	MVI	A,00000011B
	STA	STEPRA		; RETRY WITH MAXIMUM STEP RATE
	CALL	HOME
	JR	RETRS		; RETRY SEEK

STEPIN: LHLD	MODE
	INX	H		; MODE BYTE 2
	BIT	4,M		; CHECK HALF TRACK BIT
	MVI	B,01001000B	; STEP IN WITHOUT UPDATE
	CNZ	TYPE$I		; STEP A SECOND TIME (W/O UPDATE) FOR HALF-TRK
	MVI	B,01011000B	; STEP IN AND UPDATE TRACK REGISTER
	JR	TYPE$I

HOME:		;POSITION HEAD AT TRACK ZERO...
	IN	STAT
	ANI	00000100B	;TEST TRACK ZERO SENSOR,
	JRNZ	@TRK0		;SKIP ROUTINE IF WE'RE ALREADY AT TRACK 0.
	IN	TRACK		;DOES THE SYSTEM THINK WE'RE AT TRACK 0 ??
	ORA	A
	JRNZ	HOME1	;IF IT DOESN'T, ITS PROBEBLY ALRIGHT TO GIVE "RESTORE"
	MVI	L,6 ;(6 TRKS)	;ELSE WE COULD BE IN "NEGATIVE TRACKS" SO...
	MVI	B,01001000B	;WE MUST STEP-IN A FEW TRACKS, LOOKING FOR THE
HOME0:	CALL	TYPE$I		;TRACK ZERO SIGNAL.
	ANI	00000100B SHL 1 ;"SHL 1" BECAUSE CHKRDY DOES AN "RLC"
	JRNZ	@TRK0
	DCR	L
	JRNZ	HOME0
HOME1:	MVI	B,00001000B	;RESTORE COMMAND, WITH HEADLOAD
	CALL	TYPE$I
	XRI	00000100B SHL 1 ;TEST TRACK-0 SIGNAL
	RAR
	RAR
	RAR
	RAR	;[CY] = 1 IF NOT AT TRACK 0
@TRK0:	MVI	A,0
	OUT	TRACK		;MAKE SURE EVERYONE KNOWS WERE AT TRACK 0
	RET

READ$ADDR:
	LDA	SIDE
	ORI	11000100B	; READ-ADDRESS COMMAND WITH SETTLE DELAY
	JR	PUT$I		; IGNORE DATA (AND DATA-LOST ERROR)

TYPE$I:
	LDA	STEPRA		; STEP-RATE BITS
	ORA	B		; MERGE COMMAND
PUT$I	DI			; prevent interrupt routines
	OUT	STAT		; SEND command TO CONTROLLER
WB:	IN	STAT		; WAIT FOR BUSY SIGNAL
	RAR			; TO COME UP
	JRNC	WB
WNB:	IN	STAT		; poll controller for function-complete
	RAR			; Busy?
	JRC	WNB		; wait until not busy.
	RAL
	STA	DSKSTA		;SAVE TYPE$II (III) STATUS FOR ERROR DETECTION.
	MVI	A,11010000B	;TERMINATE COMMAND (RESET STATUS TO TYPE 1)
	OUT	STAT
	EI			; re-enable interrupts.
	IN	DATA		; FALL THROUGH TO CHKRDY
	
CHKRDY:
	LXI	D,56000 	; WAIT NO MORE THAN 1.6 SECOND FOR READY 
CHKR0:	
	IN	STAT		; read disk status
	RLC			; shift 'NOT READY' bit into Carry
	RNC			; stop if drive is ready 
	DCX	D		; count loops	 
	MOV	A,D	
	ORA	E		; Test for end of loops
	JRNZ	CHKR0		; loop again if not
	IN	STAT		; one last chance for drive to be ready  
	RLC			; Y if NOTRDY	
	RET			; End
	

HLIHL:	MOV	A,M		; LOAD HL INDIRECT THRU HL
	INX	H
	MOV	H,M
	MOV	L,A
	RET

INTRQ$ROUTINE:
	IN	STAT		; Clear interrupt request
	INX	SP		; TERMINATE SUB-ROUTINE by eliminating the
	INX	SP		; return address PUSHed by the interrupt.
	EI			; turn interrupts back on.
	RET			; end
LEN$IR	EQU	$-INTRQ$ROUTINE ; length of routine to transfer.

FLAG$8DD: DB	0
TPS:	DB	0		; TRACKS PER SIDE
STEPRA	DB	0		; STEP RATE CODE 
RETRYS	DB	0
SEKERR	DB	0,0		; SEEK,RESTORE ERROR COUNTS
MODE	DW	0		; POINTER TO MODE BYTE
RELDSK	DB	0		; DRIVE # RELATIVE TO 0
LOGDSK	DB	8		; CURRENT DRIVE SELECTED BY THIS MODULE
CTRL$IMAGE: DB	0		; IMAGE OF CONTROL PORT
SIDE	DB	0		; SIDE SELECT BIT FOR COMMANDS
RD$FLAG DB	0
UNALLOC DB	0
BLKMSK	DB	0
HSTDSK	DB	0FFH
HSTTRK	DB	0
HSTSEC	DB	0
REQDSK: DB	0,0
REQSEC: DB	0
BLKSEC	DB	0
BLCODE	DB	0
OFFSET: DB	0		; OFFSET TO DIRECTORY TRACK
SELERR: DB	0
SELOP:	DB	0FFH
CURDPB: DW	0
MODFLG: DB	0

; Current head positions for each drive
TRKS:	DB	255,255,255,255,255,255,255,255,0	

btend	equ	$

HSTBUF: DS	1024
CSV:	ds	0
ALV:	ds	0

	end

for each drive
TRKS:	DB	255,255,255,