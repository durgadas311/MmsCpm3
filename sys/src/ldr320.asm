VERS	EQU   '3 '  ; May 28, 2018 12:28 drm "ldr320.asm"
***************************************************
;	Loader disk I/O module for MMS CP/M 2.24
;	for the 77320 SASI bus interface 
;	Copyright (c) 1983 Magnolia Microsystems
***************************************************

	MACLIB	Z80
	$-MACRO

	public	btend		;end of system (boot stops loading there)
	extrn	BDOS,CBOOT,DSKSTA,TIMEOT,MIXER,DIRBUF,DLOG
	extrn	NEWDSK,NEWTRK,NEWSEC,DMAA

***************************************************
**  PORTS AND CONSTANTS
***************************************************
GPIO	EQU	0F2H		; SWITCH 501

ACK	EQU	00000001B
INT	EQU	00000010B
PER	EQU	00000100B
BUSY	EQU	00001000B
CMND	EQU	00010000B
MSG	EQU	00100000B
POUT	EQU	01000000B
REQ	EQU	10000000B

RUN	EQU	00000000B
SWRS	EQU	00010000B
INTE	EQU	00100000B
SEL	EQU	01000000B

RECAL	EQU	1	; COMMAND OP CODES
RDBL	EQU	8
WRBL	EQU	10
INIT	EQU	12

DPHDPB	EQU	10
DPHL	EQU	16
DPBL	EQU	21
DDEFL	EQU	4
CSTRNG	EQU	13
NPART	EQU	19
CBYTE	EQU	4
DDATA	EQU	5
DCTYPE	EQU	3
SECTBL	EQU	20
DDPB	EQU	47

WRALL	EQU	0	; WRITE TO ALLOCATED
WRDIR	EQU	1	; WRITE TO DIRECTORY
WRUNA	EQU	2	; WRITE TO UNALLOCATED
READOP	EQU	3	; READ OPERATION

BTDRV	EQU	2034H	; BOOT DRIVE SAVE BY PROM
STRNG	EQU	25F0H	; ASCII PARTITION NUMBER SAVE BY BOOT LOADER
UNITNUM EQU	2131H	; LUN NUMBER SAVE BY EPROM

***************************************************
** START OF RELOCATABLE DISK I/O MODULE
*************************************************** 

	cseg   
 
	JMP	INIT$SASI
	JMP	SEL$COMBO
	JMP	READ$COMBO

	dw	0
	dw	0     

;	TEXT
	DB	'77320',0,'SASI system loader',0,'v3.00'
	DW	VERS,'$'


DPH0:	DW	0,0,0,0,DIRBUF,DPB0,CSV0,ALV0
DPH1:	DW	0,0,0,0,DIRBUF,DPB1,CSV0,ALV0
DPH2:	DW	0,0,0,0,DIRBUF,DPB2,CSV0,ALV0
DPH3:	DW	0,0,0,0,DIRBUF,DPB3,CSV0,ALV0
DPH4:	DW	0,0,0,0,DIRBUF,DPB4,CSV0,ALV0
DPH5:	DW	0,0,0,0,DIRBUF,DPB5,CSV0,ALV0
DPH6:	DW	0,0,0,0,DIRBUF,DPB6,CSV0,ALV0
DPH7:	DW	0,0,0,0,DIRBUF,DPB7,CSV0,ALV0
DPH8:	DW	0,0,0,0,DIRBUF,DPB8,CSV0,ALV0


;	SECTOR DEFINITION/TRANSLATION TABLE
;		--ADDRESS--,   FLAG BYTE
DDEFTBL:DB	0,   0,   0,   0
	DB	0,   0,   0,   0
	DB	0,   0,   0,   0
	DB	0,   0,   0,   0
	DB	0,   0,   0,   0
	DB	0,   0,   0,   0
	DB	0,   0,   0,   0
	DB	0,   0,   0,   0
	DB	0,   0,   0,   0

;
;
; DISK PARAMETER BLOCKS -- CONTAIN DUMMY DATA. REAL DATA IS OBTAINED FROM 
;			   MAGIC SECTOR ON INITIALIZATION OF PARTITION
;
DPB0:	DW	64		; SPT
	DB	5,31,1		; BSH,BLM,EXM
	DW	4-1,512-1	; DSM,DRM
	DB	0F0H,0		; AL0,AL1
	DW	0,2		; CKS,OFF
	DB	00000010B,10000000B,0  ; MODE BYTES
	DB	0FFH,0FFH,0FFH	; MODE MASKS

DPB1:	DW	64		; SPT
	DB	5,31,1		; BSH,BLM,EXM
	DW	4-1,512-1	; DSM,DRM
	DB	0F0H,0		; AL0,AL1
	DW	0,2		; CKS,OFF
	DB	00000010B,10000000B,0  ; MODE BYTES
	DB	0FFH,0FFH,0FFH	; MODE MASKS

DPB2:	DW	64		; SPT
	DB	5,31,1		; BSH,BLM,EXM
	DW	4-1,512-1	; DSM,DRM
	DB	0F0H,0		; AL0,AL1
	DW	0,2		; CKS,OFF
	DB	00000010B,10000000B,0  ; MODE BYTES
	DB	0FFH,0FFH,0FFH	; MODE MASKS

DPB3:	DW	64		; SPT
	DB	5,31,1		; BSH,BLM,EXM
	DW	4-1,512-1	; DSM,DRM
	DB	0F0H,0		; AL0,AL1
	DW	0,2		; CKS,OFF
	DB	00000010B,10000000B,0  ; MODE BYTES
	DB	0FFH,0FFH,0FFH	; MODE MASKS

DPB4:	DW	64		; SPT
	DB	5,31,1		; BSH,BLM,EXM
	DW	4-1,512-1	; DSM,DRM
	DB	0F0H,0		; AL0,AL1
	DW	0,2		; CKS,OFF
	DB	00000010B,10000000B,0  ; MODE BYTES
	DB	0FFH,0FFH,0FFH	; MODE MASKS

DPB5:	DW	64		; SPT
	DB	5,31,1		; BSH,BLM,EXM
	DW	4-1,512-1	; DSM,DRM
	DB	0F0H,0		; AL0,AL1
	DW	0,2		; CKS,OFF
	DB	00000010B,10000000B,0  ; MODE BYTES
	DB	0FFH,0FFH,0FFH	; MODE MASKS

DPB6:	DW	64		; SPT
	DB	5,31,1		; BSH,BLM,EXM
	DW	4-1,512-1	; DSM,DRM
	DB	0F0H,0		; AL0,AL1
	DW	0,2		; CKS,OFF
	DB	00000010B,10000000B,0  ; MODE BYTES
	DB	0FFH,0FFH,0FFH	; MODE MASKS

DPB7:	DW	64		; SPT
	DB	5,31,1		; BSH,BLM,EXM
	DW	4-1,512-1	; DSM,DRM
	DB	0F0H,0		; AL0,AL1
	DW	0,2		; CKS,OFF
	DB	00000010B,10000000B,0  ; MODE BYTES
	DB	0FFH,0FFH,0FFH	; MODE MASKS

DPB8:	DW	64		; SPT
	DB	5,31,1		; BSH,BLM,EXM
	DW	4-1,512-1	; DSM,DRM
	DB	0F0H,0		; AL0,AL1
	DW	0,2		; CKS,OFF
	DB	00000010B,10000000B,0  ; MODE BYTES
	DB	0FFH,0FFH,0FFH	; MODE MASKS
PAGE



;	SELECT DISK CODE
;
SEL$COMBO:
	XRA	A
	STA	SELERR		; NO SELECT ERRORS (YET)
	LDA	DRIV0		; CALCULATE DRIVE NUMBER RELATIVE TO 0
	MOV	D,A
	LDA	NEWDSK
	SUB	D     
	STA	RELDSK
	LXI	H,DDEFTBL
	MOV	E,A		; NOW POINT TO THE CORRECT
	MVI	D,0		; ENTRY IN THE SECTOR
	DAD	D		; OFFSET TABLE
	DAD	D
	DAD	D
	DAD	D
	SHLD	SECPTR
	MOV	A,M
	ANI	11100000B
	STA	LUN		; SAVE LOGICAL UNIT NUMBER BITS
	MOV	B,E
	INR	B
	LXI	H,DPH0-DPHL	; POINT TO DPH TABLE
	LXI	D,DPHL		; LENGTH OF DPH's
SEL1:	DAD	D
	DJNZ	SEL1		; CALCULATE POINTER TO REQUESTED DPH
	shld	curdph		
	LXI	D,DPHDPB
	DAD	D		; POINT TO ADDRESS OF DPB
	CALL	HLIHL		; DPB ADDRESS IN HL
	SHLD	CURDPB		; SAVE IT

	LXI	H,LUNDATA-16	; CALCULATE POINTER TO
	LXI	D,16		;  DATA FOR THIS LOGICAL UNIT
	LDA	LUN
	RLC
	RLC
	RLC
NXTLUN: DAD	D
	DCR	A
	JP	NXTLUN
	SHLD	DATAPTR

	CALL	CHK$INIT	; INITIALIZE DRIVE IF NECESSARY
	LHLD	CURDPB
	INX	H
	INX	H
	INX	H
	MOV	A,M		; GET BLOCK MASK
	STA	BLKMSK		; USED FOR UNALLOCATED RECORD COUNT
	LXI	D,10
	DAD	D
	MOV	A,M		; GET TRACK OFFSET
	STA	OFFSET
	INX	H
	INX	H		; POINT TO MODE BYTE 1
	MOV	A,M
	ANI	3		; ISOLATE SECTOR SIZE BITS
	STA	BLCODE		; SAVE AS DEBLOCKING CODE
RETSEL: LDA	RELDSK
	MOV	C,A
	lhld	curdph
	RET

ERREXT: MVI	A,1
	STA	SELERR
	JR	RETSEL


;
;	DRIVER INITIALIZATION CODE
;
INIT$SASI:
	LDA	UNITNUM 	;FROM BOOT PROM
	ANI	00000011B
	RRC
	RRC
	RRC
	LXI	H,DDEFTBL
	LXI	D,4
	MVI	B,9
SETLUN	MOV	M,A		;SET ALL LUN BITS IN TBL
	DAD	D
	DJNZ	SETLUN
	MVI	A,50
	STA	DRIV0
	ADI	9
	STA	DRIV$LAST
	LDA	STRNG		;FROM BOOT LOADER
	ORA	A
	JZ	DEFDRV
	SUI	'0'
DEFDRV	ADI	50
	STA	MIXER

	MVI	B,7CH 
	IN	GPIO		; READ SWITCH 501
	ANI	00000011B	; WHAT'S PORT 7C SET FOR ?
	CPI	00000010B	;  IF Z67, THEN THIS IS IT
	JRZ	GOTPRT
	MVI	B,78H
	IN	GPIO		; READ SWITCH 501
	ANI	00001100B	; WHAT'S PORT 78 SET FOR ?
	CPI	00001000B	;  IF Z67, THEN THIS IS IT
	RNZ
GOTPRT: MOV	A,B
	STA	BASE$PORT	; SAVE BASE PORT ADDRESS
	XRA	A
	RET

CHK$INIT:
	CALL	GETSTART
	LHLD	SECPTR
	INX	H
	INX	H
	INX	H		; POINT TO FLAG BYTE
	MOV	A,M
	STA	FLAGS		; SAVE FOR USE BY INIT$DRIVE
	BIT	7,M		; CHECK INITIALIZATION BIT
	JZ	INIT$HARD
	BIT	5,M		; IS IT REMOVABLE MEDIA ?
	JNZ	INIT$HARD	;  MUST INITIALIZE
	CALL	INIT$DRIVE	; SEND DATA TO CONTROLLER ON LOGIN OF A L.U.N.
	JNZ	INIT$ERR	
	RET

GETSTART:
	LXIX	DDEFTBL
	LDA	DRIV0		; GET PHYSICAL DRIVE NUMBER
	MOV	B,A
	LDA	DRIV$LAST	; GET TOTAL NUMBER OF PARTITIONS
	SUB	B
	MOV	H,A
	LDA	LUN		; PUT LUN IN L REG
	MOV	L,A
	LXI	D,4		; INCREMENT FOR DDEFTAB       
STLOOP	LDX	A,+0		; GET STARTING PHYSICAL DRIVE NUMBER
	ANI	11100000B	; OF CURRENT LUN.
	CMP	L
	JRZ	GOT$START
	DADX	D
	INR	B
	DCR	H
	JNZ	STLOOP
	POP	D
	JMP	INIT$ERR
GOT$START:
	MOV	A,B
	STA	STRLUN
	MVI	C,0		; GET NUMBER OF PARTITIONS IN LUN
ENDLOOP:			
	DADX	D
	INR	C
	LDX	A,+0
	ANI	11100000B
	CMP	L
	JRNZ	GOT$END 	; B = STARTING PHYSICAL DRIVE NUMBER OF LUN
	DCR	H
	JNZ	ENDLOOP 	; C = NUMBER OF PARTITION IN THE CURRENT LUN
GOT$END:
	MOV	A,C
	STA	PARTLUN 	; SAVE FOR INIT$HARD  AND LOGIN
	RET

INIT$HARD:
	MVI	A,0FFH		
	STA	HSTDSK		
	CALL	GETCON		; RESTORE THE HEADS
	LXI	H,RCMND
	XRA	A		; DEFAULT STEP RATE
	STA	RCMND+5
	CZ	OUTCM0
	CZ	CHK$STAT
	MVI	A,RDBL		; OP CODE TO READ A SECTOR
	STA	CMBFR
	XRA	A		; SECTOR 0
	STA	CMBFR+1
	STA	CMBFR+2
	STA	CMBFR+3
	INR	A
	STA	CMBFR+4 	; READ 1 SECTOR
	CALL	GETCON		; WAKE UP CONTROLLER
	CZ	OUTCOM		; OUTPUT READ COMMAND
	CZ	SASIRW		; READ IN SECTOR
	CZ	CHK$STAT	; CHECK STATUS OF READ
	JNZ	INIT$ERR

	LDA	HSTBUF+NPART	; COMPARE # OF PART. DRIVER & MAGIC SECTOR
	LXI	H,PARTLUN
	CMP	M
	JNC	KEEPPAR 	; USE THE SMALLEST ONE
	MOV	M,A
KEEPPAR:LDA	DRIV0
	MOV	D,A
	LDA	STRLUN
	SUB	D
	STA	STRLUN		; SAVE RELATIVE START OF LUN	  

	MOV	B,A		; SEE IF INITIALIZING A PART. THAT DOES EXIST
	LDA	RELDSK
	SUB	B
	CMP	M				      
	JNC	INIT$ERR		 

	INR	B
	LXI	H,DPB0-DPBL	; CALCULATE START OF DPB IN DRIVER
	LXI	D,DPBL
NXTDPB	DAD	D
	DJNZ	NXTDPB
	PUSH	H

	LDA	PARTLUN
	MOV	B,A
	LXI	H,0		; CALCULATE TOTAL LENGTH OF DPB'S TO BE MOVED 
	LXI	D,DPBL
NXTLEN	DAD	D
	DJNZ	NXTLEN
	MOV	B,H		; PUT LENGTH IN BC
	MOV	C,L
	POP	D		; PUT TO ADDRESS IN DE
	LXI	H,HSTBUF+DDPB	; PUT FROM ADDRESS IN HL
	LDIR
	
	LXI	H,DDEFTBL	; CALCULATE START IN DDEFTBL
	LDA	STRLUN
	SLAR	A		; MULT BY 2
	SLAR	A		; MULT BY 4
	MOV	E,A
	MVI	D,0
	DAD	D
	PUSH	H		; SAVE FOR SET INIT. BITS
	XCHG			; TO ADDRES IN DE
	LXI	H,HSTBUF+SECTBL ; FROM ADDRESS
	LDA	PARTLUN
	MOV	B,A		
NXTDEF	PUSH	B		; MOVE PARTITION ADDRESS TABLE INTO DRIVER
	LDAX	D		; DE = DDEFTBL
	ORA	M		; HL = HSTBUF+SECTBL (MAGIC SECTOR)
	MOV	M,A
	LXI	B,3
	LDIR
	INX	D		; DDEFTBL IS 4 BYTES WIDE
	POP	B
	DJNZ	NXTDEF

	LXI	H,HSTBUF+DCTYPE ; GET L.U.N. SPECIFIC DATA FROM
	LDED	DATAPTR 	;  'MAGIC SECTOR'
	LXI	B,16		;  PUT IT INTO SPACE RESERVED FOR THIS L.U.N.
	LDIR
	
	CALL	INIT$DRIVE
	JRNZ	INIT$ERR	; ERROR ON PHYSICAL INITIALIZATION

	POP	H		; SET INITIALIZATION BITS
	INX	H
	INX	H
	INX	H
	LXI	D,DDEFL  
	LDA	PARTLUN
	MOV	B,A
NXTFLG	SETB	7,M
	DAD	D
	DJNZ	NXTFLG
	RET

INIT$ERR:
	POP	D		; CLEAR STACK
	JMP	ERREXT

PAGE

READ$COMBO:
	MVI	A,READOP
	STA	WRTYPE
	LDA	SELERR
	ORA	A
	RNZ
	LDA	NEWDSK
	STA	REQDSK
	LHLD	NEWSEC+1	; (HRDTRK)
	SHLD	REQTRK
	MVI	C,0		; CALCULATE PHYSICAL SECTOR
	LDA	BLCODE		; PHYSICAL SECTOR SIZE CODE
	ORA	A		; TEST FOR ZERO
	MOV	B,A
	LDA	NEWSEC
	STA	REQSEC		; INITIAL GUESS IS 128 BYTE SECTORS
	JRZ	DBLOK3		; 128 BYTE SECTORS ?
DBLOK1: SRLR	A		; DIVIDE ACCUMULATOR BY 2
	RARR	C		; SAVE OVERFLOW BITS
	DJNZ	DBLOK1		; AND CONTINUE IF BLOCKING STILL <> 0
	STA	REQSEC		; SAVE IT
	LDA	BLCODE		; CALCULATE BLKSEC
	MOV	B,A		; FOR LOOPING
DBLOK2: RLCR	C		; NOE RESTORE THE OVERFLOW BY
	DJNZ	DBLOK2		; ROTATING IT RIGHT
DBLOK3: MOV	A,C
	STA	BLKSEC		; STORE IT
	MVI	A,0FFH
	STA	RD$FLAG 	; FLAG A PRE-READ
	LDA	WRTYPE
	RAR
	JRC	ALLOC		; NO NEED TO CHECK FOR UNALLOCATED RECORDS
	RAR			; CARRY IS SET ON WRUNA
	JRNC	CHKUNA
	SDED	URECORD 	; SET UNALLOCATED RECORD #
	DCR	A
	STA	UNALLOC 	; FLAG WRITING OF AN UNALLOCATED BLOCK
CHKUNA: LDA	UNALLOC 	; ARE WE WRITING AN UNALLOCATED BLOCK ?
	ORA	A
	JRZ	ALLOC
	LHLD	URECORD 	; IS REQUESTED RECORD SAME AS EXPECTED
	DSBC	D		;  SAME AS EXPECTED UNALLOCATED RECORD ?
	JRNZ	ALLOC		; IF NOT, THEN DONE WITH UNALLOCATED BLOCK
	XRA	A		; CLEAR PRE-READ FLAG
	STA	RD$FLAG
	INX	D		; INCREMENT TO NEXT EXPECTED UNALLOCATED RECORD
	SDED	URECORD
	LDA	BLKMSK
	ANA	E		; IS IT THE START OF A NEW BLOCK ?
	JRNZ	CHKSEC
ALLOC:	XRA	A		; NO LONGER WRITING AN UNALLOCATED BLOCK
	STA	UNALLOC

;*****************************************************************************
; CHKSEC: THIS SUBROUTINE COMPARES THE REQUESTED DISK TRACK AND SECTOR	     ;
;	  TO THE DISK,TRACK AND SECTOR CURRENTLY IN THE BUFFER. 	     ;
;	  OUTPUT: ZERO FLAG SET IF SAME, RESET IF DIFFERENT		     ;
;									     ;
CHKSEC: ANA	A		; CLEAR CARRY FOR DSBC			     ;
	LHLD	REQTRK							     ;
	LDED	OFFSET							     ;
	DSBC	D							     ;
	JRNZ	CHKBUF							     ;
	LDA	NEWSEC							     ;
	ORA	A		; FIRST SECTOR OF DIRECTORY ?		     ;
	JRZ	SET$PRE$RD						     ;
CHKBUF: LXI	H,REQDSK						     ;
	LXI	D,HSTDSK						     ;
	MVI	B,4							     ;
CHKBUF1:LDAX	D							     ;
	CMP	M							     ;
	JRNZ	READIT							     ;
	INX	H							     ;
	INX	D							     ;
	DJNZ	CHKBUF1 						     ;
	JR	NOREAD		;  THEN NO NEED TO PRE-READ		     ;
;*****************************************************************************

SET$PRE$RD:			; SET PRE READ FLAG FOR READING 
	MVI	A,0FFH		; DIRECTORY SO A PHY READ IS DONE
	STA	RD$FLAG

READIT: LXI	D,HSTDSK	; SET UP NEW BUFFER PARAMETERS
	LXI	H,REQDSK
	LXI	B,4
	LDIR
	LDA	RD$FLAG 	; DO WE NEED TO PRE-READ ?
	ORA	A
	CNZ	RD$SEC		; READ THE SECTOR
NOREAD: LXI	H,HSTBUF	; POINT TO START OF SECTOR BUFFER
	LXI	B,128
	LDA	BLKSEC		; POINT TO LOCATION OF CORRECT LOGICAL SECTOR
MOVIT1: DCR	A
	JM	MOVIT2
	DAD	B
	JR	MOVIT1
MOVIT2: LDED	DMAA		; POINT TO DMA
	LDIR			; MOVE IT
	XRA	A		; FLAG NO ERROR
	RET			; RETURN TO BDOS

RD$SEC: CALL	READ		; READ A PHYSICAL SECTOR
	RZ			; RETURN IF SUCCESSFUL
	MVI	A,0FFH		; FLAG BUFFER AS UNKNOWN
	STA	HSTDSK
RWERR:	POP	D		; THROW AWAY TOP OF STACK
	MVI	A,1		; SIGNAL ERROR TO BDOS
	ORA	A
	RET			; RETURN TO BDOS

;
;	READ A PHYSICAL SECTOR CODE
;
READ:
	MVI	A,RDBL		; READ COMMAND CODE
	STA	CMBFR		; COMMAND BUFFER OP CODE
	CALL	SET$SEC 	; CALCULATE AND INSTALL ACTUAL SECTOR
	CALL	WAKE$UP 	; SETUP CONTROLLER
	CZ	OUTCOM		; AND OUTPUT THE COMMAND
	CZ	SASIRW		; DO READ OR WRITE
	CZ	CHK$STAT	; CHECK THE BUS RESPONSE
	RET

INIT$DRIVE:
	LHLD	DATAPTR 	; SEE IF IT'S XEBEC
	MOV	A,M
	ANI	11100000B
	JRNZ	NOTXBC		; SKIP IF NOT
	CALL	GETCON		; GET CONTROLLER'S ATTENTION
	LXI	H,ICMND 	; INITIALIZATION COMMAND STRING
	CZ	OUTCM0		; OUTPUT COMMAND
	RNZ
	LHLD	DATAPTR 	; DRIVE CHARACTERISTIC DATA
	INX	H
	INX	H
	MVI	B,8		; 8 BYTES LONG
	MVI	E,(REQ OR POUT OR BUSY)
	CALL	OUTCM1		; OUTPUT THE DATA
	CZ	CHK$STAT	;  AND CHECK STATUS
	JMP	RESDR		; mjm LETS NOT SEND ZEROS IF XEBEC
NOTXBC: LHLD	DATAPTR
	LXI	D,10		; NOW DO "ASSIGN DRIVE TYPE" COMMAND
	DAD	D		;  ( FOR DATA PERIPHERALS DONTROLLERS )
	PUSH	H
	CALL	GETCON		; GET CONTROLLER'S ATTENTION
	POP	H
	CZ	OUTCM0		; SEND THE COMMAND
	CZ	CHK$STAT
RESDR	CALL	GETCON		; RESTORE THE HEADS
	LXI	H,RCMND
	LIXD	DATAPTR 	; PUT CONTROL BYTE IN BUFFER
	LDX	A,+1
	STA	RCMND+5
	CZ	OUTCM0
	CZ	CHK$STAT
	RET


;	CALCULATE THE REQUESTED SECTOR
;
SET$SEC:
	LHLD	HSTTRK		; GET REQUESTED TRACK
	DAD	H		; *2
	DAD	H		; *4
	DAD	H		; *8
	DAD	H		; *16
	DAD	H		; *32
	DAD	H		; *64 (64 SECTORS/TRACK)
	PUSH	H
	LHLD	SECPTR
	MOV	C,M
	INX	H
	MOV	D,M
	INX	H
	MOV	E,M
	POP	H
	DAD	D		; ADD IN PARTITION OFFSET
	JRNC	NOCAR0		; CARRY FROM DAD (IF ANY) GOES INTO
	INR	C		;  HIGH ORDER BYTE OF SECTOR NUMBER
NOCAR0: LDA	BLCODE
	MOV	B,A
	ORA	A
	MOV	A,C
	JRZ	NODIV
	ANI	00011111B	; ELIMINATE L.U.N. BITS FROM DIVISION
	MOV	C,A
NXDIV:	SRAR	C
	RARR	H
	RARR	L
	DJNZ	NXDIV
NODIV:	LDA	HSTSEC		; GET REQUESTED SECTOR
	MOV	E,A
	MVI	D,0
	DAD	D		; ADD IT IN
	JRNC	NOCAR1
	INR	C
NOCAR1: MOV	A,C
	STA	CMBFR+1 	; MOVE TO COMMAND BUFFER
	MOV	A,H
	STA	CMBFR+2 	; MOVE REST OF SECTOR NUMBER TO COMMAND BUFFER
	MOV	A,L
	STA	CMBFR+3
	MVI	A,1		; TRANSFER 1 SECTOR
	STA	CMBFR+4
	LHLD	DATAPTR 	; GET CONTROL BYTE
	INX	H
	MOV	A,M
	STA	CMBFR+5 	; PUT INTO COMMAND BUFFER
	RET

HLIHL:	MOV	A,M
	INX	H
	MOV	H,M
	MOV	L,A
	RET

WAKE$UP:CALL	GETCON
	RZ
	CALL	INIT$DRIVE
	RNZ
	CALL	GETCON
	RET


;
;	GET THE BUS' ATTENTION
;
GETCON:
	LDA	BASE$PORT
	MOV	C,A
	INR	C		; CONTROL PORT ADDRESS TO REG. C
	MVI	A,RUN
	OUTP	A		; CLEAR SEL BIT
	MVI	B,0		; TIMER COUNTER
GETCN1: DCR	C
	XRA	A
	OUTP	A		; CLEAR DATA REGISTER
	INR	C		; AND SEND IT TO THE CARD
	INP	A		; READ CONTROL PORT
	ANI	BUSY
	JRZ	GETCN2
	DJNZ	GETCN1
	DCR	B		; RESET PSW/Z TO INDICATE ERROR
	RET
GETCN2: 
	MVI	A,SEL
	OUTP	A		; WAKE UP CONTROLER
	MVI	B,0
GETCN3:
	INP	A
	ANI	BUSY
	JRNZ	GETCN4
	DJNZ	GETCN3
	DCR	B		; RESET PSW/Z TO INDICATE ERROR
	RET
GETCN4: 
	MVI	A,RUN
	OUTP	A
	XRA	A		; NO ERROR
	RET


;
; OUTCOM: OUTPUT A COMMAND TO THE DRIVE
;
OUTCOM: LXI	H,CMBFR
OUTCM0: INX	H
	MOV	A,M		; CLEAR LUN BITS IN COMMAND BUFFER
	ANI	00011111B
	MOV	M,A
	LDA	LUN		; OR L.U.N. BITS INTO COMMAND
	ORA	M
	MOV	M,A
	DCX	H
	MVI	B,6		; COMMAND IS 6 BYTES LONG
	LDA	BASE$PORT
	MOV	C,A		; DATA PORT TO REG. C
	INR	A
	MOV	D,A		; CONTROL PORT TO REG. D
	MVI	E,(REQ OR CMND OR POUT OR BUSY)
OUTCM1: PUSH	B
	MVI	B,0		; SET LOOP COUNTER
	MOV	C,D		; CONTROL PORT ADDRESS TO REG. C
OUTLOP: INP	A
	ANI	(REQ OR CMND OR POUT OR BUSY)
	CMP	E
	JRZ	OUTOK
	DJNZ	OUTLOP
	DCR	B		; SET ERROR (NZ)
	POP	B
	RET
OUTOK:	POP	B		; RETURNS DATA PORT ADDRESS TO REG. C
	OUTI			; OUTPUT COMMAND BYTE
	JNZ	OUTCM1
	XRA	A		; SET SUCCESS (Z)
	RET
;
;	ACTUAL READ-WRITE OF DATA
;
SASIRW: 			; THIS ROUTINE IS FOR READING AND WRITING
	LXI	H,HSTBUF	; AND WRITING DATA
	LDA	BASE$PORT
	MOV	C,A		; DATA PORT ADDRESS TO REG. C
NXTSEC: INR	C		; INCREMENT TO CONTROL PORT
SASICK: INP	A		; FIRST CHECK FOR DRIVE READY
	STA	DSKSTA	     ; STORE STATUS
	ANI	(CMND OR BUSY OR REQ OR POUT)
	CPI	(CMND OR BUSY OR REQ)  ; IF POUT DROPS,
	RZ			       ;  WE ARE INTO STATUS PHASE
	ANI	(CMND OR BUSY OR REQ)
	CPI	(BUSY OR REQ)	; WHEN CMND DROPS, SEEK IS COMPLETE, AND WE ARE
	JRNZ	SASICK		;  READY FOR DATA TRANSFER
	DCR	C		; DATA PORT ADDRESS TO REG. C
	MVI	B,128
	INIR			; CHANGED TO OUTIR FOR WRITE
	JR	NXTSEC

PAGE


;	CHECK STATUS OF READ OR WRITE
;
CHK$STAT:			; THIS ROUTINE CHECKS WHAT'S UP
	LXI	H,STAT		; STATUS BUFFER
	LDA	BASE$PORT
	MOV	D,A		; DATA PORT ADDRESS STORED IN REG. D
	INR	A
	MOV	E,A		; CONTROL PORT ADDRESS STORED IN REG. E
	JR	CHK01
CHKNXT: MOV	C,D		; INPUT FROM DATA PORT
	INP	A
	MOV	M,A		; SAVE IN MEMORY
CHK01:	MOV	C,E		; INPUT FROM CONTROL PORT
	INP	A
	ANI	(MSG OR REQ OR CMND OR POUT)
	CPI	(REQ OR CMND)
	JRZ	CHKNXT
	CPI	(MSG OR REQ OR CMND)
	JRNZ	CHK01
	MOV	C,D		; INPUT FROM DATA PORT
	INP	A		; GET FINAL BYTE
	MOV	A,M		; AND THROW IT AWAY, GET STATUS
	ANI	03		; EITHER BIT SET IS AN ERROR
	RET

****************************************************************

;
;	DATA BUFFERS AND STORAGE
;
LUNDATA:DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ; 16 BYTES OF DATA FOR EACH
	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ; LOGICAL UNIT -- PULLED FROM
	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ; MAGIC SECTOR ON
	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ; INITIALIZATION
				     ; BYTE 1 : DRIVE/CONTROLLER TYPE
				     ; BYTE 2 : CONTROL BYTE
				     ; BYTES 3 - 10 : DRIVE CHARACTERISTIC DATA
				     ; BYTES 11 - 16 : ASSIGN DRIVE TYPE
				     ;				     COMMAND
LUN:	DB	0		; LOGICAL UNIT NUMBER
CMBFR:	DB	0,0,0,0,0,0	; COMMAND BUFFER
ICMND:	DB	INIT,0,0,0,0,0	; INITIALIZE DRIVE CHARACTERISTICS COMMAND
				;					 STRING
RCMND:	DB	RECAL,0,0,0,0,0 ; RESTORE COMMAND
DATAPTR:DW	0		; POINTER TO LUNDATA FOR THIS L.U.N.
SECPTR	DW	0		; POINTER TO CURRENT SECTOR TABLE ENTRY
CURDPH	DW	0		; current disk parameter header
SELERR	DB	0		; SELECT ERROR FLAG
FLAGS:	DB	0		; BIT 7 = INITIALIZATION FLAG,
				; BIT 6 = FLOPPY DISK FLAG
				; BIT 5 = REMOVABLE MEDIA FLAG
				; BIT 4 (SPARE)
				; BITS 0-3 = PARTITION NUMBER,
BASE$PORT:
	DB	0		; BASE PORT ADDRESS
DRIV0	DB	0		; FIRST PHYSICAL DRIVE NUMBER
DRIV$LAST:			; LAST PHYSICAL DRIVE NUMBER
	DB	0
STRLUN	DB	0		; RELATIVE PARTITION NUMBER OF CURRENT LUN
PARTLUN DB	0		; NUMBER OF PARTITIONS IN CURRENT LUN
STAT:	DB	0
;
; DEBLOCKING VARIABLES
;
RD$FLAG:DB	0		; FLAG FOR PRE-READ
HSTDSK	DB	0FFH
HSTTRK	DW	0
HSTSEC	DB	0
REQDSK	DB	0
REQTRK	DW	0
REQSEC	DB	0
BLCODE: DB	0		; SECTOR SIZE CODE (0=128,1=256,2=512,3=1024)
BLKSEC: DB	0		; LOCATION OF LOGICAL SECTOR WITHIN PHYSICAL
WRTYPE	DB	0
UNALLOC DB	0
URECORD DW	0
RELDSK	DB	0		; DISK NUMBER RELATIVE TO 0
CURDPB	DW	0		; ADDRESS OF CURRENT DISK PARAMETER BLOCK
BLKMSK	DB	0		; BLOCK MASK
OFFSET	DB	0

btend	equ	$

********************************************************
** BUFFERS
********************************************************

HSTBUF: DS	512
CSV0:	DS	128
ALV0:	DS	256

	END
