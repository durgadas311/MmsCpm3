		; Boot Module for SDCard(s) on H8xSPI
			maclib	ram
**** ram.lib ****
**** bsdcard.asm ****
			maclib	core
**** core.lib ****
**** bsdcard.asm ****
			maclib	z80
**** z80.lib ****
**** bsdcard.asm ****
		
0050          	drv0	equ	80
0002          	ndrv	equ	2
		
0040          	spi	equ	40h	; same board as WizNet
		
0040          	spi?dat	equ	spi+0
0041          	spi?ctl	equ	spi+1
0041          	spi?sts	equ	spi+1
		
0004          	SD0SCS	equ	0100b	; SCS for SDCard 0
0008          	SD1SCS	equ	1000b	; SCS for SDCard 1
		
0040          	CMDST	equ	01000000b	; command start bits
		
1000          		org	1000h
1000  03      	first:	db	HIGH (last-first)	; +0: num pages
1001  10      		db	HIGH first		; +1: ORG page
1002  5002    		db	drv0,ndrv	; +2,+3: phy drv base, num
		
1004  C31710  		jmp	init	; +4: init entry
1007  C31910  		jmp	boot	; +7: boot entry
		
100A  53      		db	'S'	; +10: Boot command letter
100B  07      		db	7	; +11: front panel key
100C  42      		db	42h	; +12: port, 0 if variable
100D  A4C2CE  		db	10100100b,11000010b,11001110b	; +13: FP display ("Sdc")
1010  53444361		db	'SDCard',0	; +16: mnemonic string
      726400
		
		; should do card init sequence... but don't know LUN...
1017          	init:
1017  AF      		xra	a	; NC
1018  C9      		ret
		
1019          	boot:
			; Partition is passed to bootloader, but we need
			; segment offset before we can start.
			; stack: retL, retH, str0, str1, ...
1019  210200  		lxi	h,2
101C  39      		dad	sp	; HL=string (maybe)
101D  CD4F10  		call	cardsetup
1020  D8      		rc
1021  CD9610  		call	cardinit
1024  D8      		rc
			; init for reading...
1025  2A5621  		lhld	l2156h
1028  226F11  		shld	cmd17+1
102B  2A5821  		lhld	l2156h+2
102E  227111  		shld	cmd17+3
1031  218022  		lxi	h,bootbf
1034  224011  		shld	dma
1037  3E0A    		mvi	a,10	; 10 sectors to read
1039  324211  		sta	cnt
103C          	boot0:
103C  2A4011  		lhld	dma
103F  CD0311  		call	read
1042  D8      		rc
1043  CDED10  		call	incr
1046  214211  		lxi	h,cnt
1049  35      		dcr	m
104A  20F0    		jrnz	boot0
104C  C33B00  		jmp	hwboot
		
		; HL=string
104F          	cardsetup:
104F  EB      		xchg		; DE=string
1050  210000  		lxi	h,0	; def segment
1053  225821  		shld	l2156h+2
1056  225A21  		shld	l2156h+4
1059  3A3121  		lda	AIO$UNI	; 0000000d = 0/1
105C  3C      		inr	a	; 01b/10b
105D  07      		rlc
105E  07      		rlc		; = SD0SCS/SD1SCS
105F  323F11  		sta	scs
1062  3E50    		mvi	a,drv0
1064  323420  		sta	l2034h	; pre-loader expects 80-88 for partn
1067  1A      		ldax	d
1068  13      		inx	d
1069  FEC3    		cpi	0c3h	; JMP means no string present
106B  2824    		jrz	nostr
106D  B7      		ora	a	; check for "", too
106E  2821    		jrz	nostr
1070  CD2011  		call	trydig
1073  300F    		jrnc	gotdig
1075  CD2F11  		call	tryltr
1078  D8      		rc
1079  1A      		ldax	d
107A  13      		inx	d
107B  B7      		ora	a
107C  2813    		jrz	gotit
107E  CD2011  		call	trydig
1081  D8      		rc
1082  1809    		jr	chkend
1084  1A      	gotdig:	ldax	d
1085  13      		inx	d
1086  B7      		ora	a
1087  2808    		jrz	gotit
1089  CD2F11  		call	tryltr
108C  D8      		rc
108D  1A      	chkend:	ldax	d
108E  B7      		ora	a
108F  37      		stc
1090  C0      		rnz	; max two chars
1091          	gotit:
1091  225621  	nostr:	shld	l2156h	; l2156h[0]=31:24, l2156h[1]=23:16... (32-bit LBA)
1094  AF      		xra	a
1095  C9      		ret
		
		; perform SDCard power-on initialization
		; returns CY on error
1096          	cardinit:
			; waive 1mS delay... we are well past that...
1096  CD7511  		call	run74	; must cycle >= 74 clocks
			; CMD0 - enter SPI mode
1099  214311  		lxi	h,cmd0
109C  1601    		mvi	d,1
109E  1E01    		mvi	e,1	; turn off SCS
10A0  CD9811  		call	sdcmd
10A3  D8      		rc
10A4  3A4911  		lda	cmd0+6	; R1
10A7  FE01    		cpi	00000001b	; IDLE bit set?
10A9  37      		stc
10AA  C0      		rnz
10AB  214A11  		lxi	h,cmd8
10AE  1605    		mvi	d,5
10B0  1E01    		mvi	e,1	; turn off SCS
10B2  CD9811  		call	sdcmd
10B5  D8      		rc
10B6  3A5011  		lda	cmd8+6
10B9  FE01    		cpi	00000001b	; no error, IDLE bit still set
10BB  2809    		jrz	ok8
10BD  CB57    		bit	2,a	; Illegal Command
10BF  37      		stc
10C0  C8      		rz
			; CMD8 not recognized, SD1 card... (not supported?)
10C1  3E00    		mvi	a,0
10C3  325D11  		sta	acmd41+1
10C6          	ok8:
10C6  210500  		lxi	h,5	; small number of errors allowed
10C9          	cdi0:	; this could take a long time...  need timeout...
10C9  E5      		push	h
10CA  215C11  		lxi	h,acmd41
10CD  1601    		mvi	d,1
10CF  CD7E11  		call	doacmd
10D2  E1      		pop	h
10D3  D8      		rc
10D4  3A6211  		lda	acmd41+6
10D7  FE00    		cpi	00000000b	; READY?
10D9  280B    		jrz	cdi1
10DB  E67E    		ani	01111110b	; any errors?
10DD  28EA    		jrz	cdi0		; loop infinitely if just "BUSY"
10DF  2B      		dcx	h
10E0  7C      		mov	a,h
10E1  B5      		ora	l
10E2  20E5    		jrnz	cdi0
10E4  37      		stc	; timeout - error
10E5  C9      		ret
10E6          	cdi1:	; done with init
			; now try CMD58 if applicable
10E6  3A5D11  		lda	acmd41+1
10E9  B7      		ora	a
10EA  C8      		rz	; no more init for SDC1... return NC
			; SDC2... get CMD58
		; TODO: check card power-OK bit?
		;	lxi	h,cmd58
		;	mvi	d,5
		;	mvi	e,1	; turn off SCS
		;	call	sdcmd
		;	rc
		;	lda	cmd58+7 ; OCR 31:24
		;	bit	7,a	; power-up status
		;	stc
		;	rz
10EB  AF      		xra	a
10EC  C9      		ret
		
		; increment LBA in cmd17, and DMA
10ED          	incr:
10ED  2A4011  		lhld	dma
10F0  24      		inr	h	; +256
10F1  24      		inr	h	; +512
10F2  224011  		shld	dma
10F5  217211  		lxi	h,cmd17+4
10F8  34      		inr	m
10F9  C0      		rnz
10FA  2B      		dcx	h
10FB  34      		inr	m
10FC  C0      		rnz
10FD  2B      		dcx	h
10FE  34      		inr	m
10FF  C0      		rnz
1100  2B      		dcx	h
1101  34      		inr	m
1102  C9      		ret
		
		; read LBA stored in cmd17...
		; HL=buffer
		; returns CY on error
1103          	read:
1103  E5      		push	h
1104  216E11  		lxi	h,cmd17
1107  1601    		mvi	d,1
1109  1E00    		mvi	e,0	; leave SCS on
110B  CD9811  		call	sdcmd
110E  E1      		pop	h
110F  380A    		jrc	badblk	; turn off SCS
1111  3A7411  		lda	cmd17+6
1114  B7      		ora	a
1115  2004    		jrnz	badblk	; turn off SCS
1117  CDDA11  		call	sdblk	; turns off SCS
111A  C9      		ret	; CY=error
111B          	badblk:
111B  AF      		xra	a
111C  D341    		out	spi?ctl	; SCS off
111E  37      		stc
111F  C9      		ret
		
1120          	trydig:
1120  FE30    		cpi	'0'	; digit?
1122  D8      		rc	; error
1123  FE3A    		cpi	'9'+1	; max 9 partitions
1125  3F      		cmc
1126  D8      		rc	; error - or letter
1127  D630    		sui	'0'
1129  C650    		adi	drv0
112B  323420  		sta	l2034h	; pre-loader expects 70-78 for partn
112E  C9      		ret
		
112F          	tryltr:
112F  FE41    		cpi	'A'
1131  D8      		rc	; error - or digit
1132  E65F    		ani	5fh	; toupper
1134  D641    		sui	'A'	; 000sssss
1136  FE1A    		cpi	26
1138  3F      		cmc
1139  D8      		rc
113A  07      		rlc
113B  07      		rlc
113C  07      		rlc		; sssss000 = 256M/512B
113D  67      		mov	h,a	;
113E  C9      		ret
		
113F  04      	scs:	db	SD0SCS
1140  0000    	dma:	dw	0
1142  00      	cnt:	db	0
		
		; command is always 6 bytes.
		; CRC is ignored, but "end bit" must be "1".
		; This explains the problems seen with "Samsung 32Pro",
1143  40000000	cmd0:	db	CMDST+0,0,0,0,0,95h
      0095
1149  00      		db	0
114A  48000001	cmd8:	db	CMDST+8,0,0,01h,0aah,87h
      AA87
1150  00000000		db	0,0,0,0,0
      00
1155  77000000	cmd55:	db	CMDST+55,0,0,0,0,1
      0001
115B  00      		db	0
115C  69400000	acmd41:	db	CMDST+41,40h,0,0,0,1
      0001
1162  00      		db	0
1163  7A000000	cmd58:	db	CMDST+58,0,0,0,0,1
      0001
1169  00000000		db	0,0,0,0,0
      00
116E  51000000	cmd17:	db	CMDST+17,0,0,0,0,1
      0001
1174  00      		db	0
		
		; run-out at least 74 clock cycles... with SCS off...
1175  060A    	run74:	mvi	b,10	; 80 cycles
1177  0E40    		mvi	c,spi?dat
1179  ED78    	run740:	inp	a
117B  10FC    		djnz	run740
117D  C9      		ret
		
		; E=dump flag, always turns off SCS
117E          	doacmd:
117E  E5      		push	h
117F  D5      		push	d
1180  215511  		lxi	h,cmd55
1183  1601    		mvi	d,1
1185  1E00    		mvi	e,0	; do not turn off SCS
1187  CD9811  		call	sdcmd
			; ignore results? CMD55 never gives error?
118A  D1      		pop	d
118B  E1      		pop	h
118C  1E01    		mvi	e,1
118E  CD9811  		call	sdcmd
1191  F5      		push	psw
			; for some reason, this is required (at least for ACMD41)
			; when certain cards (Flexon) are in-socket during power up.
			; If the card is re-seated after power up, this is not needed.
			; Unclear if this is a MT011 anomaly or universal.
1192  DB40    		in	spi?dat
1194  DB40    		in	spi?dat
1196  F1      		pop	psw
1197  C9      		ret
		
		; send (6 byte) command to SDCard, get response.
		; HL=command+response buffer, D=response length
		; return A=response code (00=success), HL=idle length, DE=gap length
1198          	sdcmd:
1198  3A3F11  		lda	scs
119B  D341    		out	spi?ctl	; SCS on
119D  0E40    		mvi	c,spi?dat
			; wait for idle
			; TODO: timeout this loop
119F  E5      		push	h	; save command+response buffer
11A0  210001  		lxi	h,256	; idle timeout
11A3  ED78    	sdcmd0:	inp	a
11A5  FEFF    		cpi	0ffh
11A7  2808    		jrz	sdcmd1
11A9  2B      		dcx	h
11AA  7C      		mov	a,h
11AB  B5      		ora	l
11AC  20F5    		jrnz	sdcmd0
			; timeout - error
11AE  E1      		pop	h
11AF  37      		stc
11B0  C9      		ret
11B1  E1      	sdcmd1:	pop	h	; command buffer back
11B2  0606    		mvi	b,6
11B4  EDB3    		outir
11B6  ED78    		inp	a	; prime the pump
11B8  E5      		push	h	; points to response area...
11B9  210001  		lxi	h,256	; gap timeout
11BC  ED78    	sdcmd2:	inp	a
11BE  FEFF    		cpi	0ffh
11C0  2008    		jrnz	sdcmd3
11C2  2B      		dcx	h
11C3  7C      		mov	a,h
11C4  B5      		ora	l
11C5  20F5    		jrnz	sdcmd2
11C7  E1      		pop	h
11C8  37      		stc
11C9  C9      		ret
11CA  E1      	sdcmd3:	pop	h	; response buffer back
11CB  42      		mov	b,d
11CC  77      		mov	m,a
11CD  23      		inx	h
11CE  05      		dcr	b
11CF  2802    		jrz	sdcmd4
11D1  EDB2    		inir	; rest of response
11D3  7B      	sdcmd4:	mov	a,e	; SCS flag
11D4  B7      		ora	a
11D5  C8      		rz
11D6  AF      		xra	a
11D7  D341    		out	spi?ctl	; SCS off
11D9  C9      		ret	; NC
		
		; read a 512-byte data block, with packet header and CRC (ignored).
		; READ command was already sent and responded to.
		; HL=buffer
		; return CY on error (A=error), SCS always off
11DA          	sdblk:
11DA  3A3F11  		lda	scs
11DD  D341    		out	spi?ctl	; SCS on
11DF  0E40    		mvi	c,spi?dat
			; wait for packet header (or error)
			; TODO: timeout this loop
11E1  110001  		lxi	d,256	; gap timeout
11E4  ED78    	sdblk0:	inp	a
11E6  FEFF    		cpi	0ffh
11E8  2008    		jrnz	sdblk1
11EA  1B      		dcx	d
11EB  7A      		mov	a,d
11EC  B3      		ora	e
11ED  20F5    		jrnz	sdblk0
11EF  37      		stc
11F0  1810    		jr	sdblk2
11F2          	sdblk1:	
11F2  FEFE    		cpi	11111110b	; data start
11F4  37      		stc	; else must be error
11F5  200B    		jrnz	sdblk2
11F7  0600    		mvi	b,0	; 256 bytes at a time
11F9  EDB2    		inir
11FB  EDB2    		inir
11FD  ED78    		inp	a	; CRC 1
11FF  ED78    		inp	a	; CRC 2
1201  AF      		xra	a	; NC
1202  F5      	sdblk2:	push	psw
1203  AF      		xra	a
1204  D341    		out	spi?ctl	; SCS off
1206  F1      		pop	psw
1207  C9      		ret
		
1208  FFFFFFFF		rept	(($+0ffh) and 0ff00h)-$
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
      FFFFFFFF
0000          	if ($ > 1800h)
		endif
		
1300          	last:	end



Statistics:

     4	passes
     0	jr promotions
   130	symbols
   768	bytes

   329	macro calls
  3759	macro bytes
     0	invented symbols
