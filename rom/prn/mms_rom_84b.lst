		; Z89/Z90 Monitor EPROM 444-84B, by Magnolia Microsystems
		; Z89/Z90/H8-Z80 Monitor EPROM 444-84D, June 29, 2019, drm
0014          	VERN	equ	14h	; ROM version
		
0000          	false	equ	0
FFFF          	true	equ	not false
		
		; TODO: alter version based on config (or some string)
FFFF          	gide	equ	true
FFFF          	wiznet	equ	true
0000          	mms422	equ	false
0000          	remex	equ	false
0000          	corvus	equ	false
0000          	xcomp	equ	false
0000          	terminal equ	false
		
			maclib	z80
**** z80.lib ****
**** mms_rom_84b.asm ****
			$*macro
		
000D          	CR	equ	13
000A          	LF	equ	10
0007          	BEL	equ	7
001B          	ESC	equ	27
0000          	TRM	equ	0
007F          	DEL	equ	127
		
FFFF          	if gide
0060          	GIDE$DA	equ	060h	; GIDE data port
0061          	GIDE$ER	equ	061h	; GIDE error register
0062          	GIDE$SC	equ	062h	; GIDE sector count
0063          	GIDE$SE	equ	063h	; GIDE sector number
0064          	GIDE$CL	equ	064h	; GIDE cylinder low
0065          	GIDE$CH	equ	065h	; GIDE cylinder high
0066          	GIDE$DH	equ	066h	; GIDE drive/head
0067          	GIDE$CS	equ	067h	; GIDE command/status
		endif
		
FFFF          	if wiznet
		; WIZNET/NVRAM (SPI adapter) defines
0040          	spi	equ	40h	; base port
0040          	spi$dat	equ	spi+0
0041          	spi$ctl	equ	spi+1	; must be spi$dat+1
0041          	spi$sta	equ	spi+1
		
0001          	WZSCS	equ	01b	; /SCS for WIZNET
0002          	NVSCS	equ	10b	; /SCS for NVRAM
		
		; NVRAM constants
		; NVRAM/SEEPROM commands
0003          	NVRD	equ	00000011b
0002          	NVWR	equ	00000010b
0005          	RDSR	equ	00000101b
0006          	WREN	equ	00000110b
		; NVRAM/SEEPROM status bits
0001          	WIP	equ	00000001b
		
		; WIZNET constants
0008          	nsocks	equ	8
0008          	sock0	equ	000$01$000b	; base pattern for Sn_ regs
0014          	txbuf0	equ	000$10$100b	; base pattern for Tx buffer
0018          	rxbuf0	equ	000$11$000b	; base pattern for Rx buffer
		
		; common regs
0001          	gar	equ	1
0005          	subr	equ	5
0009          	shar	equ	9
000F          	sipr	equ	15
0015          	ir	equ	21
0017          	sir	equ	23
001D          	pmagic	equ	29
		
		; socket regs, relative
0000          	sn$mr	equ	0
0001          	sn$cr	equ	1
0002          	sn$ir	equ	2
0003          	sn$sr	equ	3
0004          	sn$prt	equ	4
000C          	sn$dipr	equ	12
0010          	sn$dprt	equ	16
001D          	sn$resv8 equ	29	; reserved
0024          	sn$txwr	equ	36
0026          	sn$rxrsr equ	38
0028          	sn$rxrd	equ	40
002F          	sn$kpalvtr equ	47
		
001D          	NvKPALVTR equ	sn$resv8 ; place to stash keep-alive in nvram
		
		; socket commands
0001          	OPEN	equ	01h
0004          	CONNECT	equ	04h
0008          	DISC	equ	08h
0020          	SEND	equ	20h
0040          	RECV	equ	40h
		
		; socket status
0013          	SOKINIT	equ	13h
0017          	ESTABLISHED equ	17h
		
2280          		org	2280h
2280          	server:	ds	1	; SID, dest of send
2281          	nodeid:	ds	1	; our node id
2282          	cursok:	ds	1	; current socket select patn
2283          	curptr:	ds	2	; into chip mem
2285          	msgptr:	ds	2
2287          	msglen:	ds	2
2289          	totlen:	ds	2
228B          	dma:	ds	2
		
2300          		org	2300h
		msgbuf:	ds	0
2300          	msg$fmt: ds	1
2301          	msg$did: ds	1
2302          	msg$sid: ds	1
2303          	msg$fnc: ds	1
2304          	msg$siz: ds	1
2305          	msg$dat: ds	128
		
2400          		org	2400h
2400          	nvbuf:	ds	512
		endif
		
		; Legacy devices and defines
		
1800          		org	01800h	; H17 Floppy ROM routines
1800          		ds	1014
1BF6          	R$ABORT: ds	35	;00011011.11110110	033.366	R.ABORT
1C19          	CLOCK:	ds	38	;00011100.00011001	034.031 CLOCK
1C3F          	R$READ:	ds	499	;00011100.00111111	034.077	R.READ
1E32          	R$SDP:	ds	107	;			034.062 R.SDP
1E9D          	R$WHD:	ds	28	;00011110.10011101	036.235	R.WHD
1EB9          	R$WNH:	ds	161	;00011110.10111001	036.271	R.WNH
1F5A          	R$CONST: ds	88	;00011111.01011010	037.132	R.CONST
1FB2          		ds	78
		
		; RAM variables, some defined by H17 Floppy ROM
2000          		org	02000h
2000          	ramstart:
2000          		ds	3
2003          	l2003h:	ds	1	; - 02003h
2004          	l2004h:	ds	1	; - 02004h
2005          		ds	3
2008          	l2008h:	ds	1	; - 02008h
2009          	ctl$F0:	ds	1	; - 02009h
200A          		ds	17
201B          	ticcnt:	ds	2	; - 0201bh
201D          	monstk:	ds	2	; - 0201dh
201F          	intvec:
201F          	vrst1:	ds	3	; rst1 jmp vector - 0201fh
2022          	vrst2:	ds	3	; rst2 jmp vector - 02022h
2025          	vrst3:	ds	3	; rst3 jmp vector - 02025h
2028          	vrst4:	ds	3	; rst4 jmp vector - 02028h
202B          	vrst5:	ds	3	; rst5 jmp vector - 0202bh
202E          	vrst6:	ds	3	; rst6 jmp vector - 0202eh
2031          	vrst7:	ds	3	; rst7 jmp vector - 02031h
2034          	l2034h:	ds	2	; - 02034h
2036          	ctl$F2:	ds	1	; - 02036h GPP template/image
2037          	l2037h:	ds	2	; - 02037h
2039          		ds	7
2040          	l2040h:	ds	8
2048          	D$CONST: ds	88+20	; - 02048h	disk constants
20B4          	DECNT:	ds	1	; - 020b4h
20B5          		ds	124
2131          	AIO$UNI: ds	1	; - 02131h
2132          	cmdbuf:	ds	6	; SASI command buffer
2138          	resbuf:	ds	2	; SASI result buffer
213A          		ds	22
2150          	cport:	ds	1	; - 02150h
2151          		ds	1
2152          	SEC$CNT:	ds	1	; - 02152h
2153          	l2153h:	ds	1
2154          		ds	2
2156          	l2156h:	ds	6	; cmdbuf for SASI, segoff for GIDE
215C          		ds	292
		bootbf:	ds	0	; - 02280h
		
3000          	memtest	equ	03000h
C000          	ramboot	equ	0c000h
		
		; Start of ROM code
0000          		org	00000h
		
0000          	rombeg:
0000  C34604  	rst0:	jmp	init
		
0003  6F6F7420	bootms:	db	'oot ',TRM
      00
		
0008  CDEC04  	rst1:	call	intsetup
000B  2A1B20  		lhld	ticcnt
000E  C3B900  		jmp	int1$cont
0000          	if ((high int1$cont) <> 0)
		endif
		
0010          	rst2	equ	$-1	; must be a nop...
0011  CDEC04  		call	intsetup
0014  1A      		ldax	d
0015  C38001  		jmp	int2$cont
		
0018  C32520  	rst3:	jmp	vrst3
		
001B  6F2000  	goms:	db	'o ',TRM
001E  0000    		db	0,0
		
0020  C32820  	rst4:	jmp	vrst4
		
FFFF          	if wiznet
0023  C31E0D  		jmp	sndrcv	; 'msgbuf' setup...
0026  0000    		db	0,0
		else
		endif
		
0028  C32B20  	rst5:	jmp	vrst5
002B          	delayx:
002B  C36002  		jmp	delay
		
002E  3F00    	qmsg:	db	'?',TRM
		
0030  C32E20  	rst6:	jmp	vrst6
		
FFFF          	if wiznet
0033  C3F20C  		jmp	wizopen	; 'server' set, D=socket BSB
0036  0000    		db	0,0
		else
		endif
		
0038  C33120  	rst7:	jmp	vrst7
		
003B  75627374	subms:	db	'ubstitute ',TRM
      69747574
      652000
0046  726F6772	pcms:	db	'rogram Counter ',TRM
      616D2043
      6F756E74
      65722000
0056  656D6F72	mtms:	db	'emory test',TRM
      79207465
      737400
		
			rept	0066h-$
0061  00      		db	0
0062  00      		db	0
0063  00      		db	0
0064  00      		db	0
0065  00      		db	0
0000          	if	($ <> 0066h)
		endif
		
0066          	nmi:
0066  E3      		xthl	; save HL and pop RETADR
0067  E5      		push	h	; put RETADR in new position
0068  F5      		push	psw
0069  2B      		dcx	h
006A  7E      		mov	a,m		; check cause of NMI
006B  FEF0    		cpi	0f0h	; H8 front-panel port
006D          		jrz	port$f0
006D  281B    		DB	28H,port$f0-$-1
006F  FEF1    		cpi	0f1h	; H8 port
0071          		jrz	port$ign
0071  2808    		DB	28H,port$ign-$-1
0073  FEFA    		cpi	0fah	; H8...
0075          		jrz	port$ign
0075  2804    		DB	28H,port$ign-$-1
0077  FEFB    		cpi	0fbh	; H8...
0079          		jrnz	nmi$xit2
0079  202D    		DB	20H,nmi$xit2-$-1
007B          	port$ign:	; ports 0F1H, 0FAH, 0FBH.
007B  2B      		dcx	h
007C  7E      		mov	a,m
007D  FED3    		cpi	0d3h	; OUT
007F          		jrz	nmi$xit2
007F  2827    		DB	28H,nmi$xit2-$-1
0081  FEDB    		cpi	0dbh	; IN
0083          		jrnz	nmi$xit2
0083  2023    		DB	20H,nmi$xit2-$-1
			; IN 0F1H, 0FAH or 0FBH...
0085  F1      		pop	psw
0086  3E00    		mvi	a,000h	; these ports "return" 000h
0088          		jr	nmi$xit	; exit NMI
0088  181F    		DB	18H,nmi$xit-$-1
		
008A          	port$f0:	; H8 front panel port...
008A  2B      		dcx	h
008B  7E      		mov	a,m
008C  FEDB    		cpi	0dbh	; IN
008E          		jrnz	not$in
008E  2005    		DB	20H,not$in-$-1
0090  F1      		pop	psw
0091  3EFF    		mvi	a,0ffh	; simulate input of 0ffh
0093          		jr	nmi$xit
0093  1814    		DB	18H,nmi$xit-$-1
0095          	not$in:
0095  FED3    		cpi	0d3h	; OUT
0097          		jrnz	nmi$xit2
0097  200F    		DB	20H,nmi$xit2-$-1
0099  F1      		pop	psw	; byte to output to 0F0H...
009A  F5      		push	psw	; _  7 6 5 4 3 2 1 0
009B  17      		ral		; 7  6 5 4 3 2 1 0 _
009C  17      		ral		; 6  5 4 3 2 1 0 _ 7
009D  2F      		cma		; 6  5'4'3'2'1'0'_ 7'
009E  17      		ral		; 5' 4'3'2'1'0'_ 7'6
009F  07      		rlc		; 4' 3'2'1'0'_ 7'6 5'
00A0  E603    		ani	003h	; _  _ _ _ _ _ _ 6 5'
00A2  213620  		lxi	h,ctl$F2
00A5  B6      		ora	m
00A6  D3F2    		out	0f2h ; simulate some H8 features
00A8          	nmi$xit2:
00A8  F1      		pop	psw
00A9          	nmi$xit:
00A9  E1      		pop	h
00AA  E3      		xthl
00AB          		retn
00AB  ED45    		DB	0EDH,45H
		
00AD          	int1$1:
00AD  0A      		ldax	b
00AE  0F      		rrc
00AF  DC1F20  		cc	vrst1
00B2          	intret:
00B2  F1      		pop	psw
00B3  F1      		pop	psw
00B4  C1      		pop	b
00B5  D1      		pop	d
00B6  E1      		pop	h
00B7          	nulint:
00B7  FB      		ei
00B8  C9      		ret
		
00B9          	int1$cont:
00B9  23      		inx	h
00BA  221B20  		shld	ticcnt
00BD  010920  		lxi	b,ctl$F0
00C0  0A      		ldax	b
00C1  D3F0    		out	0f0h
00C3  E620    		ani	020h
00C5          		jrnz	intret
00C5  20EB    		DB	20H,intret-$-1
00C7  0B      		dcx	b
00C8          	int1$0:
00C8  0A      		ldax	b
00C9  17      		ral
00CA          		jrc	int1$1
00CA  38E1    		DB	38H,int1$1-$-1
00CC  210A00  		lxi	h,10
00CF  39      		dad	sp
00D0  5E      		mov	e,m
00D1  23      		inx	h
00D2  56      		mov	d,m
00D3  1B      		dcx	d
00D4  1A      		ldax	d
00D5  FE76    		cpi	076h	; HLT
00D7          		jrnz	int1$1
00D7  20D4    		DB	20H,int1$1-$-1
00D9  CD9605  		call	belout
00DC  3E48    		mvi	a,'H'
00DE  CD9805  		call	conout
00E1          	re$entry:		; re-entry point for errors, etc.
00E1  210920  		lxi	h,ctl$F0
00E4  36F0    		mvi	m,0f0h	; !beep, 2mS, MON, !SI
00E6  2A1D20  		lhld	monstk
00E9  F9      		sphl
00EA  CD9605  		call	belout
			;jmp	start
00ED          	start:
00ED  FB      		ei
00EE  21ED00  		lxi	h,start
00F1  E5      		push	h
00F2  21DF07  		lxi	h,prompt
00F5  CD3406  		call	msgout
00F8          	prloop:
00F8  CD8205  		call	coninx
00FB  E65F    		ani	01011111b ; toupper
00FD  211B01  		lxi	h,cmdtab
0100  0605    		mvi	b,5
0102          	cmloop:
0102  BE      		cmp	m
0103  23      		inx	h
0104          		jrz	docmd
0104  280D    		DB	28H,docmd-$-1
0106  23      		inx	h
0107  23      		inx	h
0108          		djnz	cmloop
0108  10F8    		DB	10H,cmloop-$-1
010A  4F      		mov	c,a
010B  CDF407  		call	xcmds
010E  CD9605  		call	belout
0111          		jr	prloop
0111  18E5    		DB	18H,prloop-$-1
		
0113          	docmd:
0113  CD9805  		call	conout
0116  7E      		mov	a,m
0117  23      		inx	h
0118  66      		mov	h,m
0119  6F      		mov	l,a
011A  E9      		pchl
		
011B          	cmdtab:
011B  47      		db	'G'
011C  5A01    		dw	cmdgo
011E  53      		db	'S'
011F  2405    		dw	cmdsub
0121  50      		db	'P'
0122  3A01    		dw	cmdpc
0124  42      		db	'B'
0125  A902    		dw	cmdboot
0127  4D      		db	'M'
0128  5C06    		dw	cmdmt
012A  00      		db	0
		
			; patched-out code?
012B  00      		db	000h
012C  00      		db	000h
012D  00      		db	000h
012E  00      		db	000h
012F  00      		db	000h
0130  00      		db	000h
0131  00      		db	000h
0132  00      		db	000h
0133  00      		db	000h
0134  00      		db	000h
0135  00      		db	000h
0136  00      		db	000h
0137  C32204  		jmp	z47$dati
		
013A          	cmdpc:
013A  214600  		lxi	h,pcms
013D  CD3406  		call	msgout
0140  210C00  		lxi	h,12
0143  39      		dad	sp
0144  5E      		mov	e,m
0145  23      		inx	h
0146  56      		mov	d,m
0147  EB      		xchg
0148  CD6C05  		call	inhexcr
014B          		jrc	cmdpc0
014B  3807    		DB	38H,cmdpc0-$-1
014D  CDEB05  		call	adrnl
0150  CD6C05  		call	inhexcr
0153  D0      		rnc
0154          	cmdpc0:
0154  EB      		xchg
0155          	cmdpc1:
0155  160D    		mvi	d,CR
0157  C3A305  		jmp	adrin
		
015A          	cmdgo:
015A  211B00  		lxi	h,goms
015D  CD3406  		call	msgout
0160  210D00  		lxi	h,13
0163  39      		dad	sp
0164  CD6C05  		call	inhexcr
0167  DC5501  		cc	cmdpc1	; read HEX until CR
016A  CD2A06  		call	crlf
016D  3ED0    		mvi	a,0d0h	; no-beep, 2mS, !MON, !single-step
016F          		jr	cmdgo0
016F  1808    		DB	18H,cmdgo0-$-1
0171  F3      		di
0172  3A0920  		lda	ctl$F0
0175  EE10    		xri	010h	; toggle single-step
0177  D3F0    		out	0f0h
0179          	cmdgo0:
0179  320920  		sta	ctl$F0
017C  E1      		pop	h
017D  C3B200  		jmp	intret
		
0180          	int2$cont:
0180  F610    		ori	010h	; disable single-step
0182  D3F0    		out	0f0h
0184  12      		stax	d
0185  E620    		ani	020h	; MON active?
0187  C2ED00  		jnz	start	; break to monitor code
018A  C32220  		jmp	vrst2	; else chain to (possible) user code.
		
018D          	take$5:
018D  3E05    		mvi	a,5	; 5 seconds
018F          	take$A:
018F  219F01  		lxi	h,timeout
0192  222020  		shld	vrst1+1
0195  325221  		sta	SEC$CNT
0198  3E01    		mvi	a,1
019A  320820  		sta	l2008h
019D  FB      		ei
019E  C9      		ret
		
019F          	timeout:
019F  211B20  		lxi	h,ticcnt
01A2  AF      		xra	a
01A3  B6      		ora	m
01A4  C0      		rnz
01A5  23      		inx	h
01A6  7E      		mov	a,m
01A7  0F      		rrc
01A8  D8      		rc
			; every 512 ticks... 1024mS
01A9  215221  		lxi	h,SEC$CNT
01AC  35      		dcr	m
01AD  C0      		rnz
01AE          	error:
01AE  2A1D20  		lhld	monstk
01B1  F9      		sphl
01B2  212E00  		lxi	h,qmsg
01B5  CD3406  		call	msgout
01B8  21B700  		lxi	h,nulint
01BB  222020  		shld	vrst1+1
01BE  320820  		sta	l2008h
01C1  DBF2    		in	0f2h
01C3  E603    		ani	00000011b
01C5          		jrnz	error0
01C5  2002    		DB	20H,error0-$-1
01C7  D37F    		out	07fh
01C9          	error0:
01C9  C3E100  		jmp	re$entry
		
01CC          	chkauto:
01CC  215321  		lxi	h,l2153h	; auto-boot disable?
01CF  DBF2    		in	0f2h
01D1  57      		mov	d,a
01D2  EE80    		xri	080h	; toggle auto-boot
01D4  B6      		ora	m
01D5  F8      		rm		; auto-boot OFF
01D6  72      		mov	m,d	; ensure we only fail once... and only on power-up?
01D7  CD0C02  		call	gtdfbt
01DA  21E601  		lxi	h,autbms
01DD  CD3406  		call	msgout
01E0  318022  		lxi	sp,bootbf
01E3  C35603  		jmp	goboot0
		
01E6  4175746F	autbms:	db	'Auto Boot',TRM
      20426F6F
      7400
		
		; determine device for port 078H
		; return phy drv number in D.
01F0          	gtdev1:
01F0  1600    		mvi	d,0	; Z17
01F2  DBF2    		in	0f2h
01F4          	gtdev0:
01F4  E603    		ani	00000011b	; port 078H device
01F6  C8      		rz		; Z17 (or Z37)
01F7  FE01    		cpi	01b
01F9  1605    		mvi	d,5
01FB  C8      		rz		; Z47
01FC  FE02    		cpi	10b
01FE  1603    		mvi	d,3
0200  C8      		rz		; Z67/MMS77320
0000          	if mms422
		else
0201  C3AE01  		jmp	error	; fatal error... not defined
		endif
		
		; determine device for port 078H
		; return phy drv number in D.
0204          	gtdev2:
0204  162E    		mvi	d,46	; Z37
0206  DBF2    		in	0f2h
0208  0F      		rrc
0209  0F      		rrc
020A          		jr	gtdev0	; rest are same
020A  18E8    		DB	18H,gtdev0-$-1
		
		; determine default boot device.
020C          	gtdfbt:
020C  110000  		lxi	d,0
020F  DBF2    		in	0f2h
0211  E670    		ani	01110000b	; default boot selection
0213  FE20    		cpi	00100000b	; device at 07CH
0215          		jrz	gtdev1
0215  28D9    		DB	28H,gtdev1-$-1
0217  FE30    		cpi	00110000b	; device at 078H
0219          		jrz	gtdev2
0219  28E9    		DB	28H,gtdev2-$-1
021B  C31808  		jmp	gtdvtb		; get MMS device
		
		; Check SW501 for installed device.
		; C = desired port pattern, 00=Z17/Z37, 01=Z47, 10=Z67, 11=undefined
		; returns base I/O port adr in B.
021E          	getport:
021E  067C    		mvi	b,07ch
0220  DBF2    		in	0f2h
0222  E603    		ani	003h
0224  B9      		cmp	c
0225  C8      		rz
0226  0678    		mvi	b,078h
0228  DBF2    		in	0f2h
022A  0F      		rrc
022B  0F      		rrc
022C  E603    		ani	003h
022E  B9      		cmp	c
022F  C8      		rz
0230  E1      		pop	h	; discard return address
0231          	s501er:
0231  213702  		lxi	h,s501ms
0234  C33406  		jmp	msgout
		
0237  53573530	s501ms:	db	'SW501 wrong ',TRM
      31207772
      6F6E6720
      00
		
		; hack to support 3 drives on H17
0244          	m$sdp:
0244  3E0A    		mvi	a,10
0246  32B420  		sta	DECNT
0249  3A3121  		lda	AIO$UNI
024C  F5      		push	psw	; 0,1,2
024D  C6FE    		adi	-2	;
024F  CE03    		aci	3	; 1,2,4
0251  C33C1E  		jmp	R$SDP+10	; hacked R.SDP for 3-drives
		
0254          	inport0:
0254  B7      		ora	a	; NC
		; input from cport+CY
0255          	inportx:
0255  C5      		push	b
0256  3A5021  		lda	cport
0259  CE00    		aci	0
025B  4F      		mov	c,a
025C          		inp	a
025C  ED78    		DB	0EDH,a*8+40H
025E  C1      		pop	b
025F  C9      		ret
		
0260          	delay:
0260  E5      		push	h
0261  211B20  		lxi	h,ticcnt
0264  86      		add	m
0265          	delay0:
0265  BE      		cmp	m
0266          		jrnz	delay0
0266  20FD    		DB	20H,delay0-$-1
0268  E1      		pop	h
0269  C9      		ret
		
026A          	digerr:
026A  CD9605  		call	belout
026D          		jr	btdig0
026D  1806    		DB	18H,btdig0-$-1
		; Got a digit in boot command, parse it
026F          	btdig:	; boot by phys drive number, E=0
026F  CD9805  		call	conout	; echo digit
0272  E60F    		ani	00fh	; convert to binary
0274  57      		mov	d,a
0275          	btdig0:
0275  CD8705  		call	conin	; get another, until term char (C)
0278  B9      		cmp	c
0279          		jrz	gotnum
0279  281D    		DB	28H,gotnum-$-1
027B  FE30    		cpi	'0'
027D          		jrc	digerr
027D  38EB    		DB	38H,digerr-$-1
027F  FE3A    		cpi	'9'+1
0281          		jrnc	digerr
0281  30E7    		DB	30H,digerr-$-1
0283  CD9805  		call	conout
0286  E60F    		ani	00fh
0288  060A    		mvi	b,10	; add 10 times, i.e. D = (D * 10) + A
028A          	btdig1:
028A  82      		add	d
028B  DAAE01  		jc	error
028E          		djnz	btdig1
028E  10FA    		DB	10H,btdig1-$-1
0290  57      		mov	d,a
0291  FEC8    		cpi	200
0293  D2AE01  		jnc	error
0296          		jr	btdig0
0296  18DD    		DB	18H,btdig0-$-1
		
0298          	gotnum:	; Boot N... "N" in D
0298  7A      		mov	a,d
0299  FE05    		cpi	5
029B  DA5303  		jc	goboot
029E  FE09    		cpi	9
02A0  D25303  		jnc	goboot
02A3  C6C8    		adi	200	; modify 5..8 to not conflict
02A5  57      		mov	d,a
02A6  C35303  		jmp	goboot
		
02A9          	cmdboot:
02A9  210300  		lxi	h,bootms
02AC  CD3406  		call	msgout	; complete (B)oot
02AF  3EC3    		mvi	a,0c3h
02B1  328022  		sta	bootbf	; mark "no string"
02B4  318022  		lxi	sp,bootbf
02B7  CD0C02  		call	gtdfbt
02BA  0E0D    		mvi	c,CR	; end input on CR
02BC          		jr	boot0
02BC  1803    		DB	18H,boot0-$-1
02BE          	bterr:
02BE  CD9605  		call	belout
02C1          	boot0:
02C1  CD8705  		call	conin
02C4  B9      		cmp	c
02C5  CA5303  		jz	goboot
02C8  1E00    		mvi	e,0
02CA  FE30    		cpi	'0'
02CC          		jrc	nodig
02CC  3804    		DB	38H,nodig-$-1
02CE  FE3A    		cpi	'9'+1
02D0          		jrc	btdig
02D0  389D    		DB	38H,btdig-$-1
02D2          	nodig:	; boot by letter... Boot alpha-
02D2  E65F    		ani	05fh ; toupper
02D4  FE5B    		cpi	'Z'+1
02D6          		jrnc	bterr
02D6  30E6    		DB	30H,bterr-$-1
02D8  FE41    		cpi	'A'
02DA          		jrc	bterr
02DA  38E2    		DB	38H,bterr-$-1
02DC  CD9805  		call	conout
02DF  CD9805  		call	conout
02E2  FE42    		cpi	'B'
02E4          		jrc	gotit	; 'A' is synonym for default
02E4  3816    		DB	38H,gotit-$-1
02E6  211A06  		lxi	h,bootb1	; Heath/Zenith device letters
02E9  47      		mov	b,a
02EA          	luboot:
02EA  7E      		mov	a,m
02EB  23      		inx	h
02EC  56      		mov	d,m
02ED  23      		inx	h
02EE  B8      		cmp	b
02EF          		jrz	gotit
02EF  280B    		DB	28H,gotit-$-1
02F1  B7      		ora	a
02F2          		jrnz	luboot
02F2  20F6    		DB	20H,luboot-$-1
02F4  1600    		mvi	d,0
02F6  CD4908  		call	mmslookup
02F9  DAAE01  		jc	error
02FC          	gotit:
02FC  3E2D    		mvi	a,'-'	; next is optional unit number...
02FE  CD9805  		call	conout
0301          		jr	luboot0
0301  1803    		DB	18H,luboot0-$-1
		
0303          	lunerr:
0303  CD9605  		call	belout
0306          	luboot0:
0306  CD8705  		call	conin
0309  B9      		cmp	c
030A          		jrz	goboot
030A  2847    		DB	28H,goboot-$-1
030C  FE3A    		cpi	':'
030E          		jrz	colon
030E  2827    		DB	28H,colon-$-1
0310  FE20    		cpi	' '
0312          		jrz	space
0312  281E    		DB	28H,space-$-1
0314  FE30    		cpi	'0'
0316          		jrc	lunerr
0316  38EB    		DB	38H,lunerr-$-1
0318  FE3A    		cpi	'9'+1
031A          		jrnc	lunerr
031A  30E7    		DB	30H,lunerr-$-1
031C  CD9805  		call	conout
031F  D630    		sui	'0'
0321  5F      		mov	e,a	; single digit (0..9)
0322          	luboot1:
0322  CD8705  		call	conin
0325  B9      		cmp	c
0326          		jrz	goboot
0326  282B    		DB	28H,goboot-$-1
0328  FE3A    		cpi	':'	; Boot alpha-dig:str
032A          		jrz	colon
032A  280B    		DB	28H,colon-$-1
032C  FE20    		cpi	' '	; cosmetic spaces?
032E          		jrz	space
032E  2802    		DB	28H,space-$-1
0330  3E07    		mvi	a,BEL
0332          	space:
0332  CD9805  		call	conout
0335          		jr	luboot1
0335  18EB    		DB	18H,luboot1-$-1
		
0337          	colon:	; get arbitrary string as last boot param
0337  0600    		mvi	b,0
0339  218022  		lxi	h,bootbf
033C          	btstr0:
033C  CD9805  		call	conout
033F  CD8705  		call	conin
0342  04      		inr	b
0343  23      		inx	h
0344  77      		mov	m,a
0345  B9      		cmp	c
0346          		jrnz	btstr0
0346  20F4    		DB	20H,btstr0-$-1
0348  78      		mov	a,b
0349  328022  		sta	bootbf	; bootbf: <len> <string...> as in CP/M cmd buf
034C  AF      		xra	a	; TRM - string terminator
034D          	btstr1:	; use stack as char array...
034D  F5      		push	psw
034E  33      		inx	sp	; undo half of push
034F  2B      		dcx	h
0350  7E      		mov	a,m
0351          		djnz	btstr1
0351  10FA    		DB	10H,btstr1-$-1
		; D=Phys Drive base number, E=Unit number
		; (or, D=Phys Drive unit, E=0)
0353          	goboot:
0353  CD2A06  		call	crlf
0356          	goboot0:
0356  21AE01  		lxi	h,error
0359  E5      		push	h
035A  CDAF07  		call	h17init
035D  7B      		mov	a,e
035E  323121  		sta	AIO$UNI	; relative unit num
0361  82      		add	d
0362  323420  		sta	l2034h	; boot phys drv unit num
0365  7A      		mov	a,d
0366  FE03    		cpi	3	; 0,1,2
0368          		jrc	bz17	; Z17 boot
0368  3809    		DB	38H,bz17-$-1
			; 3,4 not used?
036A  D605    		sui	5
036C  FE04    		cpi	4	; 5,6,7,8
036E          		jrc	bz47	; Z47 boot
036E  3847    		DB	38H,bz47-$-1
0370  C30008  		jmp	exboot	;
		
0373          	bz17:
0373  83      		add	e
0374  FE03    		cpi	3
0376  D0      		rnc	; invalid Z17 drive
0377  323121  		sta	AIO$UNI
037A  DBF2    		in	0f2h
037C  E603    		ani	00000011b
037E  C23102  		jnz	s501er	; no Z17 installed
0381  3E7C    		mvi	a,07ch
0383  325021  		sta	cport
0386  214402  		lxi	h,m$sdp
0389  228620  		shld	D$CONST+62
038C  3E0A    		mvi	a,10
038E  47      		mov	b,a	; B = 10, one full revolution?
038F  CD8F01  		call	take$A	; error after 10 seconds...
0392  CD4402  		call	m$sdp	; hacked R.SDP - setup dev parms (select drive)
0395          	bz17$0:
0395  CD9D1E  		call	R$WHD	; WHD - wait hole detect
0398  CDB91E  		call	R$WNH	; WNH - wait no hole
039B          		djnz	bz17$0	; essentially hang until user inserts a disk...
039B  10F8    		DB	10H,bz17$0-$-1
039D  CDF61B  		call	R$ABORT	; R.ABORT - reset everything
03A0  118022  		lxi	d,bootbf	; DMA address
03A3  010009  		lxi	b,00900h	; B = 9 (num sectors), C = 0 (residual bytes to read)
03A6  210000  		lxi	h,0		; track/sector number to start
03A9  CD3F1C  		call	R$READ
03AC  D8      		rc
03AD  E1      		pop	h
03AE          	hxboot:
03AE  21191C  		lxi	h,CLOCK	; CLOCK - standard 2mS handler
03B1  222020  		shld	vrst1+1 ; normal TICK intr routine
03B4  C38022  		jmp	bootbf	; run boot code...
		
03B7          	bz47:
03B7  83      		add	e
03B8  FE04    		cpi	004h
03BA  D0      		rnc
03BB  0F      		rrc
03BC  0F      		rrc
03BD  0F      		rrc
03BE  3C      		inr	a
03BF  5F      		mov	e,a
03C0  0E01    		mvi	c,01b
03C2  CD1E02  		call	getport
03C5  78      		mov	a,b
03C6  325021  		sta	cport
03C9  CD8D01  		call	take$5	; error out after 5 seconds...
03CC  3E02    		mvi	a,2
03CE  CD1404  		call	outport0
03D1  3E02    		mvi	a,2
03D3  CD0704  		call	z47$cmdo
03D6  7B      		mov	a,e
03D7  CD0304  		call	z47$dato
03DA  CD2204  		call	z47$dati
03DD  E60C    		ani	00ch
03DF  0F      		rrc
03E0  0F      		rrc
03E1  3C      		inr	a
03E2  47      		mov	b,a
03E3  3E01    		mvi	a,1
03E5          	bz47$0:
03E5  87      		add	a
03E6          		djnz	bz47$0
03E6  10FD    		DB	10H,bz47$0-$-1
03E8  1F      		rar
03E9  47      		mov	b,a
03EA  218022  		lxi	h,bootbf
03ED  C5      		push	b
03EE  CD2B04  		call	z47$read
03F1  C1      		pop	b
03F2  1C      		inr	e
03F3  CD2B04  		call	z47$read
03F6  CD5402  		call	inport0
03F9  E601    		ani	001h
03FB  C0      		rnz
03FC          	hwboot:
03FC  AF      		xra	a
03FD  320820  		sta	l2008h
0400  C3AE03  		jmp	hxboot
		
0403          	z47$dato:
0403  1680    		mvi	d,080h	; TR - date transfer request
0405          		jr	z47$out0
0405  1802    		DB	18H,z47$out0-$-1
0407          	z47$cmdo:
0407  1620    		mvi	d,020h	; DONE
0409          	z47$out0:
0409  37      		stc
040A  F5      		push	psw
040B          	z47$wt0:
040B  CD5402  		call	inport0
040E  A2      		ana	d
040F          		jrz	z47$wt0
040F  28FA    		DB	28H,z47$wt0-$-1
0411  F1      		pop	psw
0412          		jr	z47$out1
0412  1801    		DB	18H,z47$out1-$-1
0414          	outport0:
0414  B7      		ora	a
0415          	z47$out1:
0415  C5      		push	b
0416  47      		mov	b,a
0417  3A5021  		lda	cport
041A  CE00    		aci	0
041C  4F      		mov	c,a
041D  78      		mov	a,b
041E          		outp	a
041E  ED79    		DB	0EDH,a*8+41H
0420  C1      		pop	b
0421  C9      		ret
		
0422          	z47$dati:
0422  CD5402  		call	inport0
0425  07      		rlc	; TR
0426          		jrnc	z47$dati
0426  30FA    		DB	30H,z47$dati-$-1
0428  C35502  		jmp	inportx	; CY=1, input cport+1
		
042B          	z47$read:
042B  3E07    		mvi	a,7	; read thru buffer command
042D  CD0704  		call	z47$cmdo
0430  AF      		xra	a
0431  CD0304  		call	z47$dato	; params
0434  7B      		mov	a,e
0435  CD0304  		call	z47$dato	; params
0438          	z47$rd0:
0438  0E80    		mvi	c,128
043A          	z47$rd1:
043A  CD2204  		call	z47$dati
043D  77      		mov	m,a
043E  23      		inx	h
043F  0D      		dcr	c
0440          		jrnz	z47$rd1
0440  20F8    		DB	20H,z47$rd1-$-1
0442  05      		dcr	b
0443          		jrnz	z47$rd0
0443  20F3    		DB	20H,z47$rd0-$-1
0445  C9      		ret
		
		; ROM start point - initialize everything
0446          	init:
			; find amount of RAM
0446  21001F  		lxi	h,ramstart-0100h
0449          	ramsiz:
0449  24      		inr	h
044A  7E      		mov	a,m
044B  34      		inr	m
044C  BE      		cmp	m
044D  77      		mov	m,a
044E          		jrnz	ramsiz
044E  20F9    		DB	20H,ramsiz-$-1
0450  2B      		dcx	h
0451  F9      		sphl		; set SP to top of RAM (-1)
0452  E5      		push	h	; save top on stack
0453  21E100  		lxi	h,re$entry
0456  E5      		push	h
			; determine H19 BAUD, by experimentation
0457  0E03    		mvi	c,003h	; br38400
0459          	baud0:
0459  3E83    		mvi	a,083h
045B  D3EB    		out	0ebh
045D  AF      		xra	a
045E  D3E9    		out	0e9h
0460  79      		mov	a,c
0461  D3E8    		out	0e8h
0463  07      		rlc
0464  4F      		mov	c,a
0465  3E03    		mvi	a,003h
0467  D3EB    		out	0ebh
0469  AF      		xra	a
046A  D3E9    		out	0e9h
046C  DBE8    		in	0e8h
046E  210705  		lxi	h,initms	; ask H19 for response...
0471  CD3406  		call	msgout
0474  0619    		mvi	b,25	; loop 6400 times... let Rx overrun...
0476          	baud1:
0476  3D      		dcr	a
0477          		jrnz	baud1	; 4096 cycles each
0477  20FD    		DB	20H,baud1-$-1
0479          		djnz	baud1	; +13 * 25... 102725 cycles, about 50mS
0479  10FB    		DB	10H,baud1-$-1
047B  DBED    		in	0edh
047D  1F      		rar
047E  DBE8    		in	0e8h
0480  17      		ral
0481  D697    		sui	097h
0483          		jrnz	baud0
0483  20D4    		DB	20H,baud0-$-1
0485  23      		inx	h
0486  CD3406  		call	msgout
0489  060F    		mvi	b,15	; 15*256 = 3840 loops
048B          	baud2:
048B  3D      		dcr	a
048C          		jrnz	baud2
048C  20FD    		DB	20H,baud2-$-1
048E          		djnz	baud2
048E  10FB    		DB	10H,baud2-$-1
0490  3E0F    		mvi	a,00001111b	; all outputs ON
0492  D3EC    		out	0ech		; OUT2=1 hides 16C2550 intr enable diff
			; compute checksum, compare
0494  010000  		lxi	b,rombeg
0497          		exx
0497  D9      		DB	0D9H
0498  11FC0F  		lxi	d,romend-rombeg
049B  210000  		lxi	h,0
049E  0600    		mvi	b,0
04A0          	cksum0:
04A0          		exx
04A0  D9      		DB	0D9H
04A1  0A      		ldax	b
04A2  03      		inx	b
04A3          		exx
04A3  D9      		DB	0D9H
04A4  4F      		mov	c,a
04A5  09      		dad	b
04A6  1B      		dcx	d
04A7  7A      		mov	a,d
04A8  B3      		ora	e
04A9  C2A004  		jnz	cksum0
04AC          		lded	chksum
04AC  ED5B    		DB	0EDH,5BH
04AE  FE0F    		DW	chksum
04B0          		dsbc	d
04B0  ED52    		DB	0EDH,d*8+42H
04B2  CABD04  		jz	rom$ok
04B5  21EC0F  		lxi	h,erprom
04B8          	msg$die:
04B8  CD3406  		call	msgout
04BB  F3      		di
04BC  76      		hlt
04BD          	rom$ok:
04BD  AF      		xra	a
04BE  325321  		sta	l2153h
04C1  323620  		sta	ctl$F2	; 2mS, Org0 OFF
04C4  3EC9    		mvi	a,0c9h	; RET
04C6  320420  		sta	l2004h
04C9  210050  		lxi	h,05000h	; 0, (beep, 2mS, !MON, !SI)
04CC  220820  		shld	l2008h
04CF  CF      		rst	1	; kick-start clock
04D0  211B20  		lxi	h,ticcnt
04D3  11C800  		lxi	d,0280h-440	; tuned to produce ~0x280 for 2.048MHz
04D6  7E      		mov	a,m
04D7          	tick0:	; wait for next tick of clock...
04D7  BE      		cmp	m
04D8          		jrz	tick0
04D8  28FD    		DB	28H,tick0-$-1
04DA  C605    		adi	5	; +10mS (actually, +8mS from new tick)
04DC          	tick1:
04DC  13      		inx	d	; count CPU cycles for 8mS...
04DD  BE      		cmp	m	; but note: 2mS interrupt overhead,
04DE  BE      		cmp	m	; so count will be low.
04DF          		jrnz	tick1	; each loop = 32 cycles
04DF  20FB    		DB	20H,tick1-$-1
04E1  7A      		mov	a,d
04E2  FE02    		cpi	2	; min 9984 cycles... 1.248MHz...
					; max 18144 cycles... 2.268MHz
04E4          		jrz	intsetup
04E4  2806    		DB	28H,intsetup-$-1
			; Unsupported CPU speed...
04E6  211305  		lxi	h,unsupm
04E9  CD3406  		call	msgout
		
04EC          	intsetup:
04EC  E3      		xthl
04ED  D5      		push	d
04EE  C5      		push	b
04EF  F5      		push	psw
04F0  EB      		xchg
04F1  210A00  		lxi	h,10
04F4  39      		dad	sp
04F5  E5      		push	h
04F6  D5      		push	d
04F7  110920  		lxi	d,ctl$F0
04FA  1A      		ldax	d
04FB  2F      		cma
04FC  E630    		ani	030h
04FE  C8      		rz
04FF  210200  		lxi	h,2
0502  39      		dad	sp
0503  221D20  		shld	monstk
0506  C9      		ret
		
0507  801B5B3F	initms:	db	080h,ESC,'[?2h',ESC,'Z',TRM
      32681B5A
      00
0510  1B7A00  		db	ESC,'z',TRM
		
0513  556E7375	unsupm:	db	'Unsupp CPU speed',TRM
      70702043
      50552073
      70656564
      00
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Substitute command
0524          	cmdsub:
0524  213B00  		lxi	h,subms
0527  CD3406  		call	msgout
052A  210320  		lxi	h,l2003h
052D  160D    		mvi	d,CR
052F  CDA305  		call	adrin
0532  EB      		xchg
0533          	cmdsub0:
0533  CDEB05  		call	adrnl
0536  7E      		mov	a,m
0537  CDFA05  		call	hexout
053A  CDF605  		call	spout
053D          	cmdsub1:
053D  CDD805  		call	hexin
0540          		jrnc	cmdsub4
0540  3019    		DB	30H,cmdsub4-$-1
0542  FE0D    		cpi	CR
0544          		jrz	cmdsub2
0544  280C    		DB	28H,cmdsub2-$-1
0546  FE2D    		cpi	'-'
0548          		jrz	cmdsub3
0548  280B    		DB	28H,cmdsub3-$-1
054A  FE2E    		cpi	'.'
054C  C8      		rz
054D  CD9605  		call	belout
0550          		jr	cmdsub1
0550  18EB    		DB	18H,cmdsub1-$-1
0552          	cmdsub2:
0552  23      		inx	h
0553          		jr	cmdsub0
0553  18DE    		DB	18H,cmdsub0-$-1
0555          	cmdsub3:
0555  CD9805  		call	conout
0558  2B      		dcx	h
0559          		jr	cmdsub0
0559  18D8    		DB	18H,cmdsub0-$-1
055B          	cmdsub4:
055B  3600    		mvi	m,000h
055D          	cmdsub5:
055D  CD9805  		call	conout
0560  CDCF05  		call	hexbin
0563          		rld
0563  ED6F    		DB	0EDH, 6FH
0565  CD6C05  		call	inhexcr
0568          		jrnc	cmdsub2
0568  30E8    		DB	30H,cmdsub2-$-1
056A          		jr	cmdsub5
056A  18F1    		DB	18H,cmdsub5-$-1
		
056C          	inhexcr:
056C  CD8705  		call	conin
056F  FE0D    		cpi	CR
0571  C8      		rz
0572  CDDB05  		call	hexchk
0575  3F      		cmc
0576  D8      		rc
0577  CD9605  		call	belout
057A          		jr	inhexcr
057A  18F0    		DB	18H,inhexcr-$-1
		
		; This loop checks for auto boot while waiting for command input.
		; Theoretically, one could flip the auto-boot dipsw at the MMS: prompt?
057C          	coninx0:
057C  CDCC01  		call	chkauto
057F  CDF307  		call	nulfn	; some patched-out code?
0582          	coninx:
0582  DBED    		in	0edh
0584  0F      		rrc
0585          		jrnc	coninx0
0585  30F5    		DB	30H,coninx0-$-1
0587          	conin:
0587  DBED    		in	0edh
0589  0F      		rrc
058A          		jrnc	conin
058A  30FB    		DB	30H,conin-$-1
058C  DBE8    		in	0e8h
058E  E67F    		ani	07fh
0590  FE7F    		cpi	DEL	; DEL key restarts from anywhere?
0592  CAE100  		jz	re$entry
0595  C9      		ret
		
0596          	belout:
0596  3E07    		mvi	a,BEL
0598          	conout:
0598  F5      		push	psw
0599          	conot1:
0599  DBED    		in	0edh
059B  E620    		ani	00100000b
059D          		jrz	conot1
059D  28FA    		DB	28H,conot1-$-1
059F  F1      		pop	psw
05A0  D3E8    		out	0e8h
05A2  C9      		ret
		
		; D=term char (e.g. '.' for Substitute)
		; HL=location to store address
05A3          	adrin:
05A3  E5      		push	h
05A4  210000  		lxi	h,0
05A7          	adrin0:
05A7  D48705  		cnc	conin
05AA  CDDB05  		call	hexchk
05AD          		jrc	adrin1
05AD  380E    		DB	38H,adrin1-$-1
05AF  CD9805  		call	conout
05B2  CDCF05  		call	hexbin
05B5  29      		dad	h
05B6  29      		dad	h
05B7  29      		dad	h
05B8  29      		dad	h
05B9  B5      		ora	l
05BA  6F      		mov	l,a
05BB          		jr	adrin0
05BB  18EA    		DB	18H,adrin0-$-1
05BD          	adrin1:
05BD  BA      		cmp	d
05BE          		jrz	adrin2
05BE  2806    		DB	28H,adrin2-$-1
05C0  CD9605  		call	belout
05C3  B7      		ora	a
05C4          		jr	adrin0
05C4  18E1    		DB	18H,adrin0-$-1
05C6          	adrin2:
05C6  CD9805  		call	conout
05C9  EB      		xchg
05CA  E1      		pop	h
05CB  72      		mov	m,d
05CC  2B      		dcx	h
05CD  73      		mov	m,e
05CE  C9      		ret
		
05CF          	hexbin:
05CF  D63A    		sui	'9'+1
05D1          		jrnc	hexbi0
05D1  3002    		DB	30H,hexbi0-$-1
05D3  C607    		adi	7
05D5          	hexbi0:
05D5  C603    		adi	3
05D7  C9      		ret
		
05D8          	hexin:
05D8  CD8705  		call	conin
05DB          	hexchk:
05DB  FE30    		cpi	'0'
05DD  D8      		rc	
05DE  FE3A    		cpi	'9'+1
05E0  3F      		cmc
05E1  D0      		rnc
05E2  E65F    		ani	05fh	; toupper
05E4  FE41    		cpi	'A'
05E6  D8      		rc	
05E7  FE47    		cpi	'F'+1
05E9  3F      		cmc
05EA  C9      		ret
		
05EB          	adrnl:
05EB  CD2A06  		call	crlf
05EE          	adrout:
05EE  7C      		mov	a,h
05EF  CDFA05  		call	hexout
05F2  7D      		mov	a,l
05F3  CDFA05  		call	hexout
05F6          	spout:
05F6  3E20    		mvi	a,' '
05F8          		jr	conout
05F8  189E    		DB	18H,conout-$-1
		
05FA          	hexout:
05FA  F5      		push	psw
05FB  07      		rlc
05FC  07      		rlc
05FD  07      		rlc
05FE  07      		rlc
05FF  CD0306  		call	hexdig
0602  F1      		pop	psw
0603          	hexdig:
0603  E60F    		ani	00fh
0605  C690    		adi	090h
0607  27      		daa
0608  CE40    		aci	040h
060A  27      		daa
060B          		jr	conout
060B  188B    		DB	18H,conout-$-1
		
		; Special entry points expected by HDOS, or maybe Heath CP/M boot.
			rept	0613h-$
060D  00      		db	0
060E  00      		db	0
060F  00      		db	0
0610  00      		db	0
0611  00      		db	0
0612  00      		db	0
0000          	if	($ <> 0613h)
		endif
0613  C30304  		jmp	z47$dato ; Must be at 0613
0616  00      		db	0
0617  C30704  		jmp	z47$cmdo ; Must be at 0617
		
		; Heath/Zenith device boot table
061A          	bootb1:
061A  4200    		db	'B',0	; Z17
061C  432E    		db	'C',46	; Z37
061E  4405    		db	'D',5	; Z47
0620  4503    		db	'E',3	; Z67
0622  00      		db	0
		
0623          	waitcr:
0623  CD8705  		call	conin
0626  FE0D    		cpi	CR
0628          		jrnz	waitcr
0628  20F9    		DB	20H,waitcr-$-1
062A          	crlf:
062A  3E0D    		mvi	a,CR
062C  CD9805  		call	conout
062F  3E0A    		mvi	a,LF
0631  C39805  		jmp	conout
		
0634          	msgout:
0634  7E      		mov	a,m
0635  B7      		ora	a
0636  C8      		rz
0637  CD9805  		call	conout
063A  23      		inx	h
063B          		jr	msgout
063B  18F7    		DB	18H,msgout-$-1
		
063D          	cserr:
063D  214206  		lxi	h,cserms
0640          		jr	msgout
0640  18F2    		DB	18H,msgout-$-1
		
0642  07436B73	cserms:	db	BEL,'Cksum error',TRM
      756D2065
      72726F72
      00
		
064F  546F7020	topms:	db	'Top of Mem: ',TRM
      6F66204D
      656D3A20
      00
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Memory Test command
065C          	cmdmt:
065C  215600  		lxi	h,mtms
065F  CD3406  		call	msgout
0662  CD2306  		call	waitcr
0665  214F06  		lxi	h,topms
0668  CD3406  		call	msgout
066B  210000  		lxi	h,0
066E  39      		dad	sp
066F  7C      		mov	a,h
0670  3C      		inr	a
0671          		jrz	cmdmt0
0671  2802    		DB	28H,cmdmt0-$-1
0673  D620    		sui	020h
0675          	cmdmt0:
0675  67      		mov	h,a
0676  2E00    		mvi	l,0
0678  2B      		dcx	h
0679  D630    		sui	'0'
067B  5F      		mov	e,a
067C  CDEE05  		call	adrout
067F  CD2A06  		call	crlf
0682  1600    		mvi	d,000h
0684  0E30    		mvi	c,030h
0686  0600    		mvi	b,000h
0688          		exx
0688  D9      		DB	0D9H
0689  21B406  		lxi	h,mtest0
068C  11F12F  		lxi	d,memtest - (mtest1-mtest0)
068F  01FB00  		lxi	b,mtestZ-mtest0
0692          		ldir
0692  EDB0    		DB	0EDH,0B0H
0694  110030  		lxi	d,memtest
0697  21C306  		lxi	h,mtest1
069A  0EEC    		mvi	c,mtestZ-mtest1
069C  AF      		xra	a
069D          		exaf
069D  08      		DB	08H
069E  AF      		xra	a
069F          	cmdmt1:
069F  86      		add	m
06A0          		exaf
06A0  08      		DB	08H
06A1  EB      		xchg
06A2  86      		add	m
06A3          		exaf
06A3  08      		DB	08H
06A4  EB      		xchg
06A5  23      		inx	h
06A6  13      		inx	d
06A7  0D      		dcr	c
06A8          		jrnz	cmdmt1
06A8  20F5    		DB	20H,cmdmt1-$-1
06AA  4F      		mov	c,a
06AB          		exaf
06AB  08      		DB	08H
06AC  B9      		cmp	c
06AD  C23D06  		jnz	cserr
06B0  F3      		di
06B1  C3F82F  		jmp	memtest - (mtest1-mtest)
		
		;------------------------------------------------
		; Start of relocated code...
		; Memory Test routine, position-endependent
		;
06B4  040C0408	mtest0:	db	04h,0ch,04h,08h,0ch,08h,20h
      0C0820
		
06BB          	mtest:
06BB  21F12F  		lxi	h,memtest - (mtest1-mtest0)
06BE  01F207  		lxi	b,0700h + 0f2h	; length of unlock sequence, GPIO port
06C1          		outir
06C1  EDB3    		DB	0EDH,0B3H
06C3          	mtest1:		; lands at 03000h - retained relocated code
06C3          		exx
06C3  D9      		DB	0D9H
06C4  62      		mov	h,d
06C5  2E00    		mvi	l,0
06C7  78      		mov	a,b
06C8          		exx
06C8  D9      		DB	0D9H
06C9  4F      		mov	c,a
06CA  0602    		mvi	b,2
06CC          	mtest2:
06CC  79      		mov	a,c
06CD  07      		rlc
06CE  07      		rlc
06CF  07      		rlc
06D0  07      		rlc
06D1  4F      		mov	c,a
06D2  E60F    		ani	00fh
06D4  C690    		adi	090h
06D6  27      		daa
06D7  CE40    		aci	040h
06D9  27      		daa
06DA  D3E8    		out	0e8h
06DC          	mtest3:
06DC  DBED    		in	0edh
06DE  E620    		ani	020h
06E0          		jrz	mtest3
06E0  28FA    		DB	28H,mtest3-$-1
06E2  05      		dcr	b
06E3          		jrnz	mtest2
06E3  20E7    		DB	20H,mtest2-$-1
06E5  3E0D    		mvi	a,CR
06E7  D3E8    		out	0e8h
06E9          		exx
06E9  D9      		DB	0D9H
06EA  78      		mov	a,b
06EB          	mtest4:
06EB  77      		mov	m,a
06EC  C601    		adi	1
06EE  27      		daa
06EF  2C      		inr	l
06F0          		jrnz	mtest4
06F0  20F9    		DB	20H,mtest4-$-1
06F2  24      		inr	h
06F3  0D      		dcr	c
06F4          		jrnz	mtest4
06F4  20F5    		DB	20H,mtest4-$-1
06F6  7C      		mov	a,h
06F7  92      		sub	d
06F8  4F      		mov	c,a
06F9  62      		mov	h,d
06FA  2E00    		mvi	l,0
06FC  78      		mov	a,b
06FD          	mtest5:
06FD  BE      		cmp	m
06FE          		jrnz	mtest9
06FE  2046    		DB	20H,mtest9-$-1
0700  C601    		adi	1
0702  27      		daa
0703  2C      		inr	l
0704          		jrnz	mtest5
0704  20F7    		DB	20H,mtest5-$-1
0706  24      		inr	h
0707  0D      		dcr	c
0708          		jrnz	mtest5
0708  20F3    		DB	20H,mtest5-$-1
070A          		exx
070A  D9      		DB	0D9H
070B  210030  		lxi	h,memtest
070E  110000  		lxi	d,0
0711  01EC00  		lxi	b,mtestZ-mtest1
0714          		exx
0714  D9      		DB	0D9H
0715  7A      		mov	a,d
0716  EE30    		xri	030h
0718  57      		mov	d,a
0719          		jrz	mtest6
0719  2803    		DB	28H,mtest6-$-1
071B  4B      		mov	c,e
071C          		jr	mtest7
071C  180A    		DB	18H,mtest7-$-1
071E          	mtest6:
071E  0E30    		mvi	c,030h
0720  3E01    		mvi	a,001h
0722  80      		add	b
0723  27      		daa
0724  47      		mov	b,a
0725          		exx
0725  D9      		DB	0D9H
0726  EB      		xchg
0727          		exx
0727  D9      		DB	0D9H
0728          	mtest7:
0728          		exx
0728  D9      		DB	0D9H
0729          		ldir
0729  EDB0    		DB	0EDH,0B0H
072B  7A      		mov	a,d
072C  E6F0    		ani	0f0h
072E  67      		mov	h,a
072F  2E00    		mvi	l,0
0731  0EEC    		mvi	c,mtestZ-mtest1
0733  AF      		xra	a
0734          	mtest8:
0734  86      		add	m
0735  23      		inx	h
0736  0D      		dcr	c
0737          		jrnz	mtest8
0737  20FB    		DB	20H,mtest8-$-1
0739  4F      		mov	c,a
073A          		exaf
073A  08      		DB	08H
073B  B9      		cmp	c
073C          		jrnz	mtestE
073C  2049    		DB	20H,mtestE-$-1
073E          		exaf
073E  08      		DB	08H
073F  7A      		mov	a,d
0740  E6F0    		ani	0f0h
0742  67      		mov	h,a
0743  2E00    		mvi	l,0
0745  E9      		pchl
0746          	mtest9:
0746  AE      		xra	m
0747  57      		mov	d,a
0748  3E0A    		mvi	a,LF
074A  D3E8    		out	0e8h
074C          	mtestA:
074C  DBED    		in	0edh
074E  E620    		ani	020h
0750          		jrz	mtestA
0750  28FA    		DB	28H,mtestA-$-1
0752  0E02    		mvi	c,2
0754  0604    		mvi	b,4
0756          	mtestB:
0756  7C      		mov	a,h
0757  07      		rlc
0758  07      		rlc
0759  07      		rlc
075A  07      		rlc
075B  E60F    		ani	00fh
075D  C690    		adi	090h
075F  27      		daa
0760  CE40    		aci	040h
0762  27      		daa
0763  D3E8    		out	0e8h
0765          	mtestC:
0765  DBED    		in	0edh
0767  E620    		ani	020h
0769          		jrz	mtestC
0769  28FA    		DB	28H,mtestC-$-1
076B  29      		dad	h
076C  29      		dad	h
076D  29      		dad	h
076E  29      		dad	h
076F          		djnz	mtestB
076F  10E5    		DB	10H,mtestB-$-1
0771  3E20    		mvi	a,' '
0773  D3E8    		out	0e8h
0775          	mtestD:
0775  DBED    		in	0edh
0777  E620    		ani	020h
0779          		jrz	mtestD
0779  28FA    		DB	28H,mtestD-$-1
077B  0D      		dcr	c
077C  EB      		xchg
077D  0602    		mvi	b,002h
077F          		jrnz	mtestB
077F  20D5    		DB	20H,mtestB-$-1
0781  3E2A    		mvi	a,'*'
0783  D3E8    		out	0e8h
0785          		jr	mtestG
0785  1814    		DB	18H,mtestG-$-1
0787          	mtestE:
0787  DBED    		in	0edh
0789  E620    		ani	020h
078B          		jrz	mtestE
078B  28FA    		DB	28H,mtestE-$-1
078D  3E0A    		mvi	a,LF
078F  D3E8    		out	0e8h
0791          	mtestF:
0791  DBED    		in	0edh
0793  E620    		ani	020h
0795          		jrz	mtestF
0795  28FA    		DB	28H,mtestF-$-1
0797  3E21    		mvi	a,'!'
0799  D3E8    		out	0e8h
079B          	mtestG:
079B  DBED    		in	0edh
079D  E620    		ani	020h
079F          		jrz	mtestG
079F  28FA    		DB	28H,mtestG-$-1
07A1  AF      		xra	a
07A2  06FA    		mvi	b,0fah
07A4          	mtestH:
07A4  3D      		dcr	a
07A5          		jrnz	mtestH
07A5  20FD    		DB	20H,mtestH-$-1
07A7          		djnz	mtestH
07A7  10FB    		DB	10H,mtestH-$-1
07A9  3E07    		mvi	a,BEL
07AB  D3E8    		out	0e8h
07AD          		jr	mtestG
07AD  18EC    		DB	18H,mtestG-$-1
		; End of relocated code
07AF          	mtestZ	equ	$
		;------------------------------------------------
		
		; returns with interrupts disabled
07AF          	h17init:
07AF  F3      		di
07B0  AF      		xra	a
07B1  D37F    		out	07fh
07B3  D5      		push	d
07B4  210920  		lxi	h,ctl$F0
07B7  36D0    		mvi	m,0d0h	; !beep, 2mS, !mon, !SI
07B9  215A1F  		lxi	h,R$CONST
07BC  114820  		lxi	d,D$CONST
07BF  015800  		lxi	b,88
07C2          		ldir
07C2  EDB0    		DB	0EDH,0B0H
07C4  6B      		mov	l,e
07C5  62      		mov	h,d
07C6  13      		inx	d
07C7  0E1E    		mvi	c,30
07C9  77      		mov	m,a
07CA          		ldir	; fill l20a0h...
07CA  EDB0    		DB	0EDH,0B0H
07CC  3C      		inr	a	; A=1
07CD  211F20  		lxi	h,intvec	; vector area
07D0          	h17ini0:
07D0  36C3    		mvi	m,0c3h
07D2  23      		inx	h
07D3  36B7    		mvi	m,LOW (nulint-rst0)
07D5  23      		inx	h
07D6  3600    		mvi	m,HIGH (nulint-rst0)
07D8  23      		inx	h
07D9  87      		add	a	; shift left, count 7
07DA  F2D007  		jp	h17ini0
07DD  D1      		pop	d
07DE  C9      		ret
		
07DF  0D0A4D4D	prompt:	db	CR,LF,'MMS: ',TRM
      533A2000
07E7  28632920		db	'(c) 1982 MMS'
      31393832
      204D4D53
		
07F3          	nulfn:
07F3  C9      		ret
		
07F4          	xcmds:
07F4  79      		mov	a,c
0000          	if terminal
		endif
07F5  FE52    		cpi	'R'	; set baud Rate
07F7  CAC80E  		jz	setbr
07FA  FE56    		cpi	'V'	; eprom Version
07FC  CAD40F  		jz	prtver
07FF  C9      		ret
		
		; D=Phys Drive base, E=Unit
		; (or D=Phys Drive unit, E=0)
0800          	exboot:
0000          	if remex
		endif
0800  215908  		lxi	h,devtbl
0803          	exboot1:
0803  7A      		mov	a,d
0804  96      		sub	m
0805  23      		inx	h
0806  BE      		cmp	m
0807          		jrc	exboot2
0807  3808    		DB	38H,exboot2-$-1
0809  7E      		mov	a,m
080A  23      		inx	h
080B  23      		inx	h
080C  23      		inx	h
080D  B7      		ora	a
080E          		jrnz	exboot1
080E  20F3    		DB	20H,exboot1-$-1
0810  C9      		ret
		
0811          	exboot2:	; found device, jump to handler
0811  23      		inx	h
0812  4E      		mov	c,m
0813  23      		inx	h
0814  66      		mov	h,m
0815  69      		mov	l,c
0816  83      		add	e
0817  E9      		pchl
		
		; Returns NZ if found, D=phy drv
0818          	gtdvtb:
0818  DBF2    		in	0f2h
081A  E670    		ani	01110000b	; default boot device
081C  07      		rlc
081D  07      		rlc
081E  07      		rlc
081F  07      		rlc
0820  219308  		lxi	h,defbt
0823          	gtdvtb0:
0823  85      		add	l
0824  6F      		mov	l,a
0825  3E00    		mvi	a,0
0827  8C      		adc	h
0828  67      		mov	h,a
0829  7E      		mov	a,m
082A  FEFF    		cpi	0ffh
082C  C8      		rz	; no device
082D  FEFE    		cpi	0feh
082F          		jrz	gtdvtb1	; extended dipsw
082F  2802    		DB	28H,gtdvtb1-$-1
0831  57      		mov	d,a
0832  C9      		ret	; NZ
		
0833          	gtdvtb1:
0833  DB5C    		in	05ch
0835  E6E0    		ani	11100000b	; device
0837  07      		rlc
0838  07      		rlc
0839  07      		rlc
083A  219B08  		lxi	h,auxbt
083D  CD2308  		call	gtdvtb0
0840  C8      		rz	; no device
0841  DB5C    		in	05ch
0843  E61C    		ani	00011100b	; LUN
0845  0F      		rrc
0846  0F      		rrc
0847  5F      		mov	e,a	; D=phy drv, E=LUN
0848  C9      		ret
		
		; lookup letter in MMS table
0849          	mmslookup:
0849  21A308  		lxi	h,bootb2
084C          	mmslk0:
084C  7E      		mov	a,m
084D  23      		inx	h
084E  56      		mov	d,m
084F  23      		inx	h
0850  B8      		cmp	b
0851  C8      		rz
0852  B7      		ora	a
0853          		jrnz	mmslk0
0853  20F7    		DB	20H,mmslk0-$-1
0855  1600    		mvi	d,0
0857  37      		stc
0858  C9      		ret
		
		; disk device/drive table by phy drv
0859          	devtbl:
0859  0302    		db	3,2
085B  310A    		dw	bz67
0000          	if remex
		endif
0000          	if corvus
		endif
085D  1D08    		db	29,8
085F  BE08    		dw	bm316
0000          	if xcomp
		endif
0861  2801    		db	40,1
0863  140B    		dw	bm318
0865  2E04    		db	46,4
0867  3A09    		dw	bz37
0000          	if mms422
		endif
FFFF          	if wiznet
0869  3C01    		db	60,1
086B  3C0C    		dw	bwiznet
		endif
FFFF          	if gide
086D  4609    		db	70,9
086F  C909    		dw	bgide
		endif
0871  A804    		db	168,4
0873  210A    		dw	bm320
0875  AC04    		db	172,4
0877  210A    		dw	bm320
0879  B004    		db	176,4
087B  210A    		dw	bm320
087D  B404    		db	180,4
087F  210A    		dw	bm320
0881  B804    		db	184,4
0883  210A    		dw	bm320
0885  BC04    		db	188,4
0887  210A    		dw	bm320
0889  C004    		db	192,4
088B  210A    		dw	bm320
088D  C404    		db	196,4
088F  210A    		dw	bm320
0891  0000    		dw	0
		
0893          	defbt:	; default boot table... port F2 bits 01110000b
0893  21      		db	33	; -000---- MMS 5" floppy 0
0894  1D      		db	29	; -001---- MMS 8" floppy 0
0895  FF      		db	0ffh	; -010---- n/a  (port 7CH)
0896  FF      		db	0ffh	; -011---- n/a  (port 78H)
0897  FF      		db	0ffh	; -100---- none
FFFF          	if gide
0898  46      		db	70	; -101---- GIDE disk part 0
		else
		endif
0899  3C      		db	60	; -110---- Network
089A  FE      		db	0feh	; -111---- redirect to I/O board dipsw
		
089B          	auxbt:	; default boot redirect (aux dipsw) bits 11100000b
0000          	if corvus
		else
089B  FF      		db	0ffh	; 000----- none (was MMS 77314 Corvus)
		endif
0000          	if remex
		else
089C  FF      		db	0ffh	; 001----- none (was MMS 77314 REMEX (Z47))
		endif
089D  FF      		db	0ffh	; 010----- none
0000          	if xcomp
		else
089E  FF      		db	0ffh	; 011----- none
		endif
089F  3C      		db	60	; 100----- Network
08A0  A8      		db	168	; 101----- MMS 77320 SASI
FFFF          	if gide
08A1  46      		db	70	; 110----- GIDE disk
		else
		endif
08A2  FF      		db	0ffh	; 111----- none
		
08A3          	bootb2:
0000          	if remex
		endif
0000          	if corvus
		endif
08A3  491D    		db	'I',29		; MMS 77316 8"
08A5  4A21    		db	'J',33		; MMS 77316 5"
0000          	if xcomp
		endif
08A7  4D28    		db	'M',40		; MMS 77318 RAM-disk
0000          	if mms422
		endif
08A9  4FA8    		db	'O',168		; SASI ctrl 0
08AB  50AC    		db	'P',172		; SASI ctrl 1
08AD  51B0    		db	'Q',176		; SASI ctrl 2
08AF  52B4    		db	'R',180		; SASI ctrl 3
08B1  53B8    		db	'S',184		; SASI ctrl 4
08B3  54BC    		db	'T',188		; SASI ctrl 5
08B5  55C0    		db	'U',192		; SASI ctrl 6
08B7  56C4    		db	'V',196		; SASI ctrl 7
FFFF          	if wiznet
08B9  573C    		db	'W',60		; WIZNET Network
		endif
FFFF          	if gide
08BB  5846    		db	'X',70		; GIDE ctrl/disk
		endif
08BD  00      		db	0
		
0000          	if corvus
		endif
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77316 Floppy boot
08BE          	bm316:
08BE  213509  		lxi	h,int316
08C1  222F20  		shld	vrst6+1
08C4  FE08    		cpi	008h
08C6  D0      		rnc
08C7  F628    		ori	028h
08C9  57      		mov	d,a
08CA  D338    		out	038h
08CC  AF      		xra	a
08CD  D3F2    		out	0f2h	; 2mS intr off
08CF  3E0B    		mvi	a,00bh	; home/restore to track 0
08D1  CD3009  		call	cmd316
08D4  0108CF  		lxi	b,53000
08D7          	bm316$0:
08D7  DB3C    		in	03ch
08D9  07      		rlc
08DA          		jrnc	bm316$1
08DA  3005    		DB	30H,bm316$1-$-1
08DC  0B      		dcx	b
08DD  78      		mov	a,b
08DE  B1      		ora	c
08DF          		jrnz	bm316$0
08DF  20F6    		DB	20H,bm316$0-$-1
08E1          	bm316$1:
08E1  DB3C    		in	03ch
08E3  E699    		ani	099h
08E5  C0      		rnz
08E6  1E19    		mvi	e,019h
08E8          	bm316$2:
08E8  218022  		lxi	h,bootbf
08EB  AF      		xra	a
08EC          	bm316$3:
08EC  3C      		inr	a
08ED  D33E    		out	03eh
08EF  013F00  		lxi	b,003fh
08F2  3E88    		mvi	a,088h
08F4  CD0E09  		call	rd316
08F7  E6BF    		ani	0bfh
08F9  7A      		mov	a,d
08FA  D338    		out	038h
08FC          		jrz	bm316$4
08FC  2807    		DB	28H,bm316$4-$-1
08FE  EE40    		xri	040h
0900  57      		mov	d,a
0901  1D      		dcr	e
0902          		jrnz	bm316$2
0902  20E4    		DB	20H,bm316$2-$-1
0904  C9      		ret
0905          	bm316$4:
0905  DB3E    		in	03eh
0907  FE02    		cpi	002h
0909          		jrc	bm316$3
0909  38E1    		DB	38H,bm316$3-$-1
090B  C3FC03  		jmp	hwboot
		
090E          	rd316:
090E  F5      		push	psw
090F  7A      		mov	a,d
0910  E644    		ani	044h
0912          		jrnz	rd316$5
0912  200F    		DB	20H,rd316$5-$-1
			; 8" DD read special case
0914  7A      		mov	a,d
0915  E6DF    		ani	0dfh
0917  D338    		out	038h
0919  F1      		pop	psw
091A  D33C    		out	03ch
091C  FB      		ei
091D  76      		hlt	; wait for first byte
091E          	rd316$8: ini
091E  EDA2    		DB	0EDH,0A2H
0920  C31E09  		jmp	rd316$8
		
0923          	rd316$5:
0923  7A      		mov	a,d
0924  D338    		out	038h
0926  F1      		pop	psw
0927  D33C    		out	03ch
0929  FB      	hlt$ini: ei
092A  76      	rd316$0: hlt
092B          		ini
092B  EDA2    		DB	0EDH,0A2H
092D  C32A09  		jmp	rd316$0
		
0930          	cmd316:
0930  D33C    		out	03ch
0932  FB      	ei$spin: ei
0933          		jr	$-1	; wait for intr to break us out
0933  18FE    		DB	18H,$-1-$-1
		
0935  F1      	int316:	pop	psw
0936  DB3C    		in	03ch
0938  FB      		ei
0939  C9      		ret
		
093A          	bz37:
093A  21C009  		lxi	h,intz37
093D  222920  		shld	vrst4+1
0940  2B      		dcx	h
0941  223720  		shld	l2037h
0944  FE04    		cpi	004h
0946  D0      		rnc
0947  3C      		inr	a
0948  2E08    		mvi	l,008h
094A          	bz37$0:
094A  29      		dad	h
094B  3D      		dcr	a
094C          		jrnz	bz37$0
094C  20FC    		DB	20H,bz37$0-$-1
094E  D379    		out	079h
0950  DBF2    		in	0f2h
0952  E60C    		ani	00ch
0954  C0      		rnz
0955  3E78    		mvi	a,078h
0957  325021  		sta	cport
095A  3ED0    		mvi	a,0d0h
095C  D37A    		out	07ah
095E  7D      		mov	a,l
095F  F608    		ori	008h
0961  57      		mov	d,a
0962  D378    		out	078h
0964  14      		inr	d
0965  1E19    		mvi	e,019h
0967  3E05    		mvi	a,5
0969  CD8F01  		call	take$A
096C  017B14  		lxi	b,0147bh	; mask, port
096F          	bz37$1:
096F  DB7A    		in	07ah
0971  A8      		xra	b
0972  E602    		ani	002h
0974          		jrz	bz37$1
0974  28F9    		DB	28H,bz37$1-$-1
0976          		djnz	bz37$1
0976  10F7    		DB	10H,bz37$1-$-1
0978          	bz37$2:
0978  218022  		lxi	h,bootbf
097B  3E01    		mvi	a,001h
097D  D379    		out	079h
097F  D37A    		out	07ah
0981  7A      		mov	a,d
0982  D378    		out	078h
0984  0604    		mvi	b,004h
0986          	bz37$3:
0986  AF      		xra	a
0987  D379    		out	079h
0989  3E40    		mvi	a,040h
098B  D37A    		out	07ah
098D  CD3209  		call	ei$spin
0990          		djnz	bz37$3
0990  10F4    		DB	10H,bz37$3-$-1
0992  AF      		xra	a
0993  D379    		out	079h
0995  3E0B    		mvi	a,00bh
0997  D37A    		out	07ah
0999  CD3209  		call	ei$spin
099C  7A      		mov	a,d
099D  EE04    		xri	004h
099F  57      		mov	d,a
09A0  F602    		ori	002h
09A2  D378    		out	078h
09A4  3E9C    		mvi	a,09ch
09A6  D37A    		out	07ah
09A8  CD2909  		call	hlt$ini
09AB  E6EF    		ani	0efh
09AD          		jrnz	bz37$4
09AD  200D    		DB	20H,bz37$4-$-1
09AF  7C      		mov	a,h
09B0  FE2C    		cpi	02ch
09B2          		jrc	bz37$4
09B2  3808    		DB	38H,bz37$4-$-1
09B4  3E08    		mvi	a,008h
09B6  D378    		out	078h
09B8  E1      		pop	h
09B9  C3FC03  		jmp	hwboot
09BC          	bz37$4:
09BC  1D      		dcr	e
09BD          		jrnz	bz37$2
09BD  20B9    		DB	20H,bz37$2-$-1
09BF  C9      		ret
		
09C0  DB7A    	intz37:	in	07ah
09C2  E3      		xthl
09C3  2A3720  		lhld	l2037h
09C6  E3      		xthl
09C7  FB      		ei
09C8  C9      		ret
		
0000          	if xcomp
		endif
		
FFFF          	if gide
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; GIDE HDD boot
09C9          	bgide:
09C9  FE09    		cpi	9 ; 9 partitons, max
09CB  D0      		rnc
			; Partition is passed to bootloader, but we need
			; segment offset before we can start.
09CC  D1      		pop	d	; error return address
09CD  C1      		pop	b	; possible string
09CE  C5      		push	b
09CF  D5      		push	d
			; parse a single letter
09D0  210000  		lxi	h,0	; def segment off
09D3  79      		mov	a,c
09D4  FEC3    		cpi	0c3h	; JMP means no string present
09D6          		jrz	nostr
09D6  280D    		DB	28H,nostr-$-1
09D8  78      		mov	a,b
09D9  B7      		ora	a	; limit to 1 char?
09DA  C0      		rnz
09DB  79      		mov	a,c
09DC  E65F    		ani	5fh
09DE  D641    		sui	'A'	; 000sssss = segment ID
09E0  D8      		rc
09E1  07      		rlc
09E2  07      		rlc
09E3  07      		rlc		; sssss000 = segoff: 0000 sssss000 00000000 00000000
09E4  67      		mov	h,a	; swap for little endian SHLD/LHLD
09E5  225621  	nostr:	shld	l2156h	; l2156h[0]=27:24, l2156h[1]=23:16
09E8  7D      		mov	a,l
09E9  F6E0    		ori	11100000b	; LBA mode + std "1" bits
09EB  D366    		out	GIDE$DH	; LBA 27:4, drive 0, LBA mode
09ED  7C      		mov	a,h
09EE  D365    		out	GIDE$CH	; LBA 23:16
09F0  AF      		xra	a
09F1  D364    		out	GIDE$CL	; LBA 15:8
09F3  D363    		out	GIDE$SE	; LBA 7:0
09F5  3E0A    		mvi	a,10
09F7  D362    		out	GIDE$SC	; 10 sectors (standard boot length)
09F9  3E20    		mvi	a,20h	; READ SECTORS
09FB  D367    		out	GIDE$CS
09FD  218022  		lxi	h,bootbf
0A00  0E60    		mvi	c,GIDE$DA
0A02  1E0A    		mvi	e,10
0A04  0600    		mvi	b,0	; should always be 0 after inir
0A06          	bgide0:
0A06  DB67    		in	GIDE$CS
0A08          		bit	7,a	; busy
0A08  CB7F    		DB	0CBH,7*8+a+40H
0A0A          		jrnz	bgide0
0A0A  20FA    		DB	20H,bgide0-$-1
0A0C          		bit	0,a	; error
0A0C  CB47    		DB	0CBH,0*8+a+40H
0A0E  C0      		rnz
0A0F          		bit	6,a	; ready
0A0F  CB77    		DB	0CBH,6*8+a+40H
0A11  C8      		rz
0A12          		bit	3,a	; DRQ
0A12  CB5F    		DB	0CBH,3*8+a+40H
0A14          		jrz	bgide0
0A14  28F0    		DB	28H,bgide0-$-1
0A16          		inir	; 256 bytes
0A16  EDB2    		DB	0EDH,0B2H
0A18          		inir	; 512 bytes
0A18  EDB2    		DB	0EDH,0B2H
0A1A  1D      		dcr	e
0A1B          		jrnz	bgide0
0A1B  20E9    		DB	20H,bgide0-$-1
			; final status check?
0A1D  E1      		pop	h	; adj stack for possible string
0A1E  C3FC03  		jmp	hwboot
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77320 SASI HDD boot
0A21          	bm320:
0A21  FE04    		cpi	4 ; 4 units per controller, max
0A23  D0      		rnc
0A24  5F      		mov	e,a	; relative drive num
0A25  7A      		mov	a,d ; phy drv
0A26  D6A8    		sui	168
0A28  E6FC    		ani	0fch	; Controller num
0A2A  0F      		rrc
0A2B  0F      		rrc
0A2C  53      		mov	d,e ; D = relative drive num
0A2D  5F      		mov	e,a ; E = controller num
0A2E  7A      		mov	a,d
0A2F          		jr	bsasi
0A2F  1805    		DB	18H,bsasi-$-1
		
0A31          	bz67:
0A31  FE02    		cpi	2
0A33  D0      		rnc	
0A34  1E00    		mvi	e,0	; Controller 0 only
0A36          	bsasi:
0A36  0F      		rrc
0A37  0F      		rrc
0A38  0F      		rrc
0A39  DD      		db 0ddh
0A3A  67      		mov h,a	; movxh	a	; 0xx00000 = relative drive num (LUN)
0A3B  0E02    		mvi	c,10b
0A3D  CD1E02  		call	getport
0A40  C0      		rnz
0A41  78      		mov	a,b
0A42  325021  		sta	cport
0A45  3C      		inr	a
0A46  4F      		mov	c,a
0A47  AF      		xra	a
0A48          		outp	a
0A48  ED79    		DB	0EDH,a*8+41H
0A4A  210000  		lxi	h,0		; zero-out command buffer
0A4D  223221  		shld	cmdbuf
0A50  223421  		shld	cmdbuf+2
0A53  223621  		shld	cmdbuf+4
0A56  225621  		shld	l2156h	; zero-out ...
0A59  225821  		shld	l2156h+2
0A5C  325A21  		sta	l2156h+4
0A5F  53      		mov	d,e
0A60  3E04    		mvi	a,4	; delay 8mS, also NZ
0A62  B7      		ora	a
0A63  FB      		ei
0A64          	bsasi0:
0A64  C8      		rz
0A65  CD2B00  		call	delayx
0A68  1E00    		mvi	e,0	; Test Drive Ready
0A6A  CD870A  		call	sasi$cmd
0A6D  3EFF    		mvi	a,255	; longer delay on retry...
0A6F          		jrc	bsasi0
0A6F  38F3    		DB	38H,bsasi0-$-1
0A71  1E01    		mvi	e,1	; Recalibrate (Home)
0A73  CD870A  		call	sasi$cmd
0A76  D8      		rc
0A77  210A80  		lxi	h,0800ah	; 10 sectors, retry
0A7A  223621  		shld	cmdbuf+4
0A7D  1E08    		mvi	e,8	; Read
0A7F  CD870A  		call	sasi$cmd
0A82  D8      		rc
0A83  E1      		pop	h
0A84  C3FC03  		jmp	hwboot
		
		; send SASI read command, get results
0A87          	sasi$cmd:
0A87  F3      		di
0A88  DD      		db 0ddh	; undocumented Z80 instruction
0A89  6B      		mov l,e	; movxl	e	; SASI command
0A8A          		sixd	cmdbuf
0A8A  DD22    		DB	0DDH,22H
0A8C  3221    		DW	cmdbuf
0A8E  0600    		mvi	b,0	; wait for "not BUSY" first
0A90  1E06    		mvi	e,6	;
0A92  210000  		lxi	h,0	; 0x060000 loop/timeout count
0A95          	sscmd0:
0A95          		inp	a
0A95  ED78    		DB	0EDH,a*8+40H
0A97  E608    		ani	00001000b
0A99  B8      		cmp	b
0A9A          		jrz	sscmd1
0A9A  280A    		DB	28H,sscmd1-$-1
0A9C  2B      		dcx	h
0A9D  7D      		mov	a,l
0A9E  B4      		ora	h
0A9F          		jrnz	sscmd0
0A9F  20F4    		DB	20H,sscmd0-$-1
0AA1  1D      		dcr	e
0AA2          		jrnz	sscmd0
0AA2  20F1    		DB	20H,sscmd0-$-1
0AA4  37      		stc
0AA5  C9      		ret
0AA6          	sscmd1:
0AA6  78      		mov	a,b
0AA7  EE08    		xri	00001000b	; wait for BUSY
0AA9          		jrz	sscmd2		; got BUSY...
0AA9  2810    		DB	28H,sscmd2-$-1
0AAB  47      		mov	b,a
0AAC  0D      		dcr	c
0AAD  AF      		xra	a
0AAE          		outp	a
0AAE  ED79    		DB	0EDH,a*8+41H
0AB0  0C      		inr	c
0AB1  0C      		inr	c
0AB2          		outp	d
0AB2  ED51    		DB	0EDH,d*8+41H
0AB4  0D      		dcr	c
0AB5  3E40    		mvi	a,040h	; SELECT
0AB7          		outp	a
0AB7  ED79    		DB	0EDH,a*8+41H
0AB9          		jr	sscmd0	; wait for BUSY now...
0AB9  18DA    		DB	18H,sscmd0-$-1
		
0ABB          	sscmd2:
0ABB  3E02    		mvi	a,002h	; enable INTR
0ABD          		outp	a
0ABD  ED79    		DB	0EDH,a*8+41H
0ABF  213221  		lxi	h,cmdbuf
0AC2          	sscmd3:
0AC2          		inp	a
0AC2  ED78    		DB	0EDH,a*8+40H
0AC4          		bit	7,a	; REQ
0AC4  CB7F    		DB	0CBH,7*8+a+40H
0AC6          		jrz	sscmd3
0AC6  28FA    		DB	28H,sscmd3-$-1
0AC8          		bit	4,a	; CMD
0AC8  CB67    		DB	0CBH,4*8+a+40H
0ACA          		jrz	sscmd4
0ACA  280A    		DB	28H,sscmd4-$-1
0ACC          		bit	6,a	; MSG
0ACC  CB77    		DB	0CBH,6*8+a+40H
0ACE          		jrz	sscmd6
0ACE  2819    		DB	28H,sscmd6-$-1
0AD0  0D      		dcr	c
0AD1          		outi		; output command byte
0AD1  EDA3    		DB	0EDH,0A3H
0AD3  0C      		inr	c
0AD4          		jr	sscmd3
0AD4  18EC    		DB	18H,sscmd3-$-1
		
0AD6          	sscmd4:
0AD6  218022  		lxi	h,bootbf
0AD9          	sscmd5:
0AD9          		inp	a
0AD9  ED78    		DB	0EDH,a*8+40H
0ADB          		bit	7,a	; REQ
0ADB  CB7F    		DB	0CBH,7*8+a+40H
0ADD          		jrz	sscmd5
0ADD  28FA    		DB	28H,sscmd5-$-1
0ADF          		bit	4,a	; CMD - indicates data done
0ADF  CB67    		DB	0CBH,4*8+a+40H
0AE1          		jrnz	sscmd6
0AE1  2006    		DB	20H,sscmd6-$-1
0AE3  0D      		dcr	c
0AE4          		ini		; input data byte
0AE4  EDA2    		DB	0EDH,0A2H
0AE6  0C      		inr	c
0AE7          		jr	sscmd5
0AE7  18F0    		DB	18H,sscmd5-$-1
0AE9          	sscmd6:
0AE9          		inp	a
0AE9  ED78    		DB	0EDH,a*8+40H
0AEB  E6D0    		ani	0d0h	; REQ, OUT, CMD
0AED  FE90    		cpi	090h	; must be REQ, CMD
0AEF          		jrnz	sscmd6	; wait for it...
0AEF  20F8    		DB	20H,sscmd6-$-1
0AF1  0D      		dcr	c
0AF2          		inp	l	; result 0
0AF2  ED68    		DB	0EDH,l*8+40H
0AF4  0C      		inr	c
0AF5          	sscmd7:
0AF5          		inp	h	; status
0AF5  ED60    		DB	0EDH,h*8+40H
0AF7  7C      		mov	a,h
0AF8  E6E0    		ani	0e0h	; REG, OUT, MSG
0AFA  FEA0    		cpi	0a0h	; must be REQ, MSG
0AFC          		jrnz	sscmd7
0AFC  20F7    		DB	20H,sscmd7-$-1
0AFE  223821  		shld	resbuf	; command results
0B01  0D      		dcr	c
0B02          		inp	a	; last data byte
0B02  ED78    		DB	0EDH,a*8+40H
0B04  0C      		inr	c
0B05  FB      		ei
0B06  B7      		ora	a
0B07  37      		stc
0B08  C0      		rnz		; error
0B09          		bit	0,l	; SASI error bit
0B09  CB45    		DB	0CBH,0*8+l+40H
0B0B  C0      		rnz
0B0C          		bit	1,l	; or other error?
0B0C  CB4D    		DB	0CBH,1*8+l+40H
0B0E  C0      		rnz
0B0F          		bit	1,h	; ACK
0B0F  CB4C    		DB	0CBH,1*8+h+40H
0B11  C0      		rnz
0B12  AF      		xra	a	; success
0B13  C9      		ret
		
0000          	if remex
		endif
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77318 (RAM-disk) boot
0B14          	bm318:
0B14  F3      		di
0B15  21230B  		lxi	h,l318rt
0B18  1100C0  		lxi	d,ramboot
0B1B  011E00  		lxi	b,l318sz
0B1E          		ldir
0B1E  EDB0    		DB	0EDH,0B0H
0B20  C300C0  		jmp	ramboot
		
		; MMS 77318 (RAM-disk) boot loader - relocated to ramboot
0B23          	l318rt:
0B23  2115C0  		lxi	h,ramboot+l318lo
0B26  0608    		mvi	b,l318lz
0B28  0EF2    		mvi	c,0f2h
0B2A          		outir	; unlock memory and select OS image bank
0B2A  EDB3    		DB	0EDH,0B3H
0B2C  3A0000  		lda	0
0B2F  FEC3    		cpi	0c3h	; JMP - does OS look good?
0B31  CA0000  		jz	0	; start OS
0B34          		outi	; re-select ROM bank
0B34  EDA3    		DB	0EDH,0A3H
0B36  FB      		ei
0B37  C9      		ret	; return to monitor (boot error)
		
		; 77318 Unlock and select bank "E" (16K common + "bank 1")
		; NOTE: "22h" should not be there, left-over cruft from CP/M unlock.
0015          	l318lo	equ	$-l318rt
0B38  040C0408	l318ul:	db	04h,0ch,04h,08h,0ch,08h,22h,10h
      0C082210
0008          	l318lz	equ	$-l318ul
0B40  00      		db	0	; fall-back to ROM on error...
001E          	l318sz	equ	$-l318rt
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		
0000          	if mms422
		endif
		
FFFF          	if wiznet
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; WIZNET WIZ850io (Network) boot loader
		
0B41          	getwiz1:
0B41  3E01    		mvi	a,WZSCS
0B43  D341    		out	spi$ctl
0B45  0E40    		mvi	c,spi$dat
0B47  AF      		xra	a
0B48          		outp	a	; hi adr always 0
0B48  ED79    		DB	0EDH,a*8+41H
0B4A          		outp	e
0B4A  ED59    		DB	0EDH,e*8+41H
0B4C          		res	2,d
0B4C  CB92    		DB	0CBH,2*8+d+80H
0B4E          		outp	d
0B4E  ED51    		DB	0EDH,d*8+41H
0B50          		inp	a	; prime MISO
0B50  ED78    		DB	0EDH,a*8+40H
0B52          		inp	a
0B52  ED78    		DB	0EDH,a*8+40H
0B54  F5      		push	psw
0B55  0C      		inr	c	; ctl port
0B56  AF      		xra	a
0B57          		outp	a	; clear SCS
0B57  ED79    		DB	0EDH,a*8+41H
0B59  F1      		pop	psw
0B5A  C9      		ret
		
0B5B          	putwiz1:
0B5B  F5      		push	psw
0B5C  3E01    		mvi	a,WZSCS
0B5E  D341    		out	spi$ctl
0B60  0E40    		mvi	c,spi$dat
0B62  AF      		xra	a
0B63          		outp	a	; hi adr always 0
0B63  ED79    		DB	0EDH,a*8+41H
0B65          		outp	e
0B65  ED59    		DB	0EDH,e*8+41H
0B67          		setb	2,d
0B67  CBD2    		DB	0CBH,2*8+d+0C0H
0B69          		outp	d
0B69  ED51    		DB	0EDH,d*8+41H
0B6B  F1      		pop	psw
0B6C          		outp	a	; data
0B6C  ED79    		DB	0EDH,a*8+41H
0B6E  0C      		inr	c	; ctl port
0B6F  AF      		xra	a
0B70          		outp	a	; clear SCS
0B70  ED79    		DB	0EDH,a*8+41H
0B72  C9      		ret
		
		; Get 16-bit value from chip
		; Prereq: IDM_AR0 already set, auto-incr on
		; Entry: A=value for IDM_AR1
		; Return: HL=register pair contents
0B73          	getwiz2:
0B73  3E01    		mvi	a,WZSCS
0B75  D341    		out	spi$ctl
0B77  0E40    		mvi	c,spi$dat
0B79  AF      		xra	a
0B7A          		outp	a	; hi adr always 0
0B7A  ED79    		DB	0EDH,a*8+41H
0B7C          		outp	e
0B7C  ED59    		DB	0EDH,e*8+41H
0B7E          		res	2,d
0B7E  CB92    		DB	0CBH,2*8+d+80H
0B80          		outp	d
0B80  ED51    		DB	0EDH,d*8+41H
0B82          		inp	a	; prime MISO
0B82  ED78    		DB	0EDH,a*8+40H
0B84          		inp	h	; data
0B84  ED60    		DB	0EDH,h*8+40H
0B86          		inp	l	; data
0B86  ED68    		DB	0EDH,l*8+40H
0B88  0C      		inr	c	; ctl port
0B89  AF      		xra	a
0B8A          		outp	a	; clear SCS
0B8A  ED79    		DB	0EDH,a*8+41H
0B8C  C9      		ret
		
		; HL = output data, E = off, D = BSB, B = len
0B8D          	wizset:
0B8D  3E01    		mvi	a,WZSCS
0B8F  D341    		out	spi$ctl
0B91  0E40    		mvi	c,spi$dat
0B93  AF      		xra	a
0B94          		outp	a	; hi adr always 0
0B94  ED79    		DB	0EDH,a*8+41H
0B96          		outp	e
0B96  ED59    		DB	0EDH,e*8+41H
0B98          		setb	2,d
0B98  CBD2    		DB	0CBH,2*8+d+0C0H
0B9A          		outp	d
0B9A  ED51    		DB	0EDH,d*8+41H
0B9C          		outir
0B9C  EDB3    		DB	0EDH,0B3H
0B9E  0C      		inr	c	; ctl port
0B9F  AF      		xra	a
0BA0          		outp	a	; clear SCS
0BA0  ED79    		DB	0EDH,a*8+41H
0BA2  C9      		ret
		
		; Put 16-bit value to chip
		; Prereq: IDM_AR0 already set, auto-incr on
		; Entry: A=value for IDM_AR1
		;        HL=register pair contents
0BA3          	putwiz2:
0BA3  3E01    		mvi	a,WZSCS
0BA5  D341    		out	spi$ctl
0BA7  0E40    		mvi	c,spi$dat
0BA9  AF      		xra	a
0BAA          		outp	a	; hi adr always 0
0BAA  ED79    		DB	0EDH,a*8+41H
0BAC          		outp	e
0BAC  ED59    		DB	0EDH,e*8+41H
0BAE          		setb	2,d
0BAE  CBD2    		DB	0CBH,2*8+d+0C0H
0BB0          		outp	d
0BB0  ED51    		DB	0EDH,d*8+41H
0BB2          		outp	h	; data to write
0BB2  ED61    		DB	0EDH,h*8+41H
0BB4          		outp	l
0BB4  ED69    		DB	0EDH,l*8+41H
0BB6  0C      		inr	c	; ctl port
0BB7  AF      		xra	a
0BB8          		outp	a	; clear SCS
0BB8  ED79    		DB	0EDH,a*8+41H
0BBA  C9      		ret
		
		; Issue command, wait for complete
		; D=Socket ctl byte
		; Returns: A=Sn_SR
0BBB  47      	wizcmd:	mov	b,a
0BBC  1E01    		mvi	e,sn$cr
0BBE          		setb	2,d
0BBE  CBD2    		DB	0CBH,2*8+d+0C0H
0BC0  3E01    		mvi	a,WZSCS
0BC2  D341    		out	spi$ctl
0BC4  0E40    		mvi	c,spi$dat
0BC6  AF      		xra	a
0BC7          		outp	a	; hi adr always 0
0BC7  ED79    		DB	0EDH,a*8+41H
0BC9          		outp	e
0BC9  ED59    		DB	0EDH,e*8+41H
0BCB          		outp	d
0BCB  ED51    		DB	0EDH,d*8+41H
0BCD          		outp	b	; command
0BCD  ED41    		DB	0EDH,b*8+41H
0BCF  0C      		inr	c	; ctl port
0BD0  AF      		xra	a
0BD1          		outp	a	; clear SCS
0BD1  ED79    		DB	0EDH,a*8+41H
0BD3  CD410B  	wc0:	call	getwiz1
0BD6  B7      		ora	a
0BD7          		jrnz	wc0
0BD7  20FA    		DB	20H,wc0-$-1
0BD9  1E03    		mvi	e,sn$sr
0BDB  CD410B  		call	getwiz1
0BDE  C9      		ret
		
		; HL=socket relative pointer (TX_WR)
		; DE=length (preserved, not used)
		; Returns: HL=msgptr, C=spi$dat
0BDF          	cpsetup:
0BDF  3E01    		mvi	a,WZSCS
0BE1  D341    		out	spi$ctl
0BE3  0E40    		mvi	c,spi$dat
0BE5          		outp	h
0BE5  ED61    		DB	0EDH,h*8+41H
0BE7          		outp	l
0BE7  ED69    		DB	0EDH,l*8+41H
0BE9  3A8222  		lda	cursok
0BEC  B0      		ora	b
0BED          		outp	a
0BED  ED79    		DB	0EDH,a*8+41H
0BEF  2A8522  		lhld	msgptr
0BF2  C9      		ret
		
		; length always <= 133 bytes, never overflows OUTIR/INIR
0BF3          	cpyout:
0BF3  0614    		mvi	b,txbuf0
0BF5  CDDF0B  		call	cpsetup
0BF8  43      		mov	b,e	; length
0BF9          		outir		; send data
0BF9  EDB3    		DB	0EDH,0B3H
0BFB  228522  		shld	msgptr
0BFE  0C      		inr	c	; ctl port
0BFF  AF      		xra	a
0C00          		outp	a	; clear SCS
0C00  ED79    		DB	0EDH,a*8+41H
0C02  C9      		ret
		
		; HL=socket relative pointer (RX_RD)
		; DE=length
		; Destroys IDM_AR0, IDM_AR1
		; length always <= 133 bytes, never overflows OUTIR/INIR
0C03          	cpyin:
0C03  0618    		mvi	b,rxbuf0
0C05  CDDF0B  		call	cpsetup	;
0C08          		inp	a	; prime MISO
0C08  ED78    		DB	0EDH,a*8+40H
0C0A  43      		mov	b,e	; fraction of page
0C0B          		inir		; recv data
0C0B  EDB2    		DB	0EDH,0B2H
0C0D  228522  		shld	msgptr
0C10  0C      		inr	c	; ctl port
0C11  AF      		xra	a
0C12          		outp	a	; clear SCS
0C12  ED79    		DB	0EDH,a*8+41H
0C14  C9      		ret
		
		; L=bits to reset
		; D=socket base
0C15          	wizsts:
0C15  1E02    		mvi	e,sn$ir
0C17  CD410B  		call	getwiz1	; destroys C
0C1A  F5      		push	psw
0C1B  A5      		ana	l
0C1C          		jrz	ws0	; don't reset if not set (could race)
0C1C  2804    		DB	28H,ws0-$-1
0C1E  7D      		mov	a,l
0C1F  CD5B0B  		call	putwiz1
0C22  F1      	ws0:	pop	psw
0C23  C9      		ret
		
		; D=socket BSB, C=bits to check
		; Return: A=status reg
0C24  21007D  	wizist:	lxi	h,32000
0C27  C5      	wst0:	push	b	; C has status bits to check
0C28  E5      		push	h
0C29  69      		mov	l,c
0C2A  CD150C  		call	wizsts
0C2D  E1      		pop	h
0C2E  C1      		pop	b
0C2F  47      		mov	b,a
0C30  A1      		ana	c
0C31          		jrnz	wst1
0C31  2007    		DB	20H,wst1-$-1
0C33  2B      		dcx	h
0C34  7C      		mov	a,h
0C35  B5      		ora	l
0C36          		jrnz	wst0
0C36  20EF    		DB	20H,wst0-$-1
0C38  37      		stc
0C39  C9      		ret
0C3A  78      	wst1:	mov	a,b
0C3B  C9      		ret
		
		;	WIZNET boot routine
		;
0C3C          	bwiznet:
0C3C  D5      		push	d
			; extract optional string. must do it now, before we
			; overwrite bootbf.
0C3D  110523  		lxi	d,msg$dat	; target for string
0C40  218022  		lxi	h,bootbf
0C43  AF      		xra	a
0C44  320423  		sta	msg$siz
0C47  7E      		mov	a,m
0C48  FEC3    		cpi	0c3h	; no string
0C4A          		jrz	nb5
0C4A  2808    		DB	28H,nb5-$-1
0C4C  4F      		mov	c,a
			; we send N+1 bytes, NUL term
0C4D  320423  		sta	msg$siz
0C50  0600    		mvi	b,0
0C52          		ldir
0C52  EDB0    		DB	0EDH,0B0H
0C54  AF      	nb5:	xra	a
0C55  12      		stax	d	; NUL term
0C56  D1      		pop	d
0C57  7B      		mov	a,e	; server id, 0..9
0C58  328022  		sta	server
			; look at WIZNET hard, init as needed
0C5B  111D00  		lxi	d,pmagic	; D = 0 (comm regs), E = PMAGIC offset
0C5E  CD410B  		call	getwiz1
0C61  B7      		ora	a
0C62  CCF50D  		cz	wizcfg	; configure chip from nvram
0C65  D8      		rc
0C66  328122  		sta	nodeid ; our slave (client) ID
			; locate server node id in chip's socket regs.
			;
0C69  0608    		mvi	b,nsocks
0C6B  110408  		lxi	d,(sock0 shl 8) + sn$prt
0C6E          	nb1:
0C6E  CD730B  		call	getwiz2	; destroys C,HL
0C71  7C      		mov	a,h
0C72  FE31    		cpi	31h
0C74          		jrnz	nb0
0C74  2006    		DB	20H,nb0-$-1
0C76  3A8022  		lda	server
0C79  BD      		cmp	l
0C7A          		jrz	nb2	; found server socket
0C7A  2807    		DB	28H,nb2-$-1
0C7C          	nb0:
0C7C  3E20    		mvi	a,001$00$000b
0C7E  82      		add	d	; next socket
0C7F  57      		mov	d,a
0C80          		djnz	nb1
0C80  10EC    		DB	10H,nb1-$-1
0C82  C9      		ret	; error: server not configured
0C83          	nb2:	; D = server socket BSB
0C83  7A      		mov	a,d
0C84  E6E0    		ani	11100000b
0C86  328222  		sta	cursok
0C89  CDF20C  		call	wizopen
0C8C  D8      		rc	; any error
0C8D  3E01    		mvi	a,1	; FNC for "boot me"
0C8F  320323  		sta	msg$fnc
			; string already setup
0C92          	loop:
0C92  3EB0    		mvi	a,0b0h	; FMT for client boot messages
0C94  320023  		sta	msg$fmt
0C97  CD1E0D  		call	sndrcv
0C9A  D8      		rc	; network failure
0C9B  3A0023  		lda	msg$fmt
0C9E  FEB1    		cpi	0b1h	; FMT for server boot responses
0CA0  C0      		rnz
			; TODO: verify SID?
0CA1  3A0323  		lda	msg$fnc
0CA4  B7      		ora	a
0CA5  C8      		rz	; NAK - error
0CA6  3D      		dcr	a
0CA7          		jrz	ldmsg
0CA7  2838    		DB	28H,ldmsg-$-1
0CA9  3D      		dcr	a
0CAA          		jrz	stdma
0CAA  282D    		DB	28H,stdma-$-1
0CAC  3D      		dcr	a
0CAD          		jrz	load
0CAD  2811    		DB	28H,load-$-1
0CAF  3D      		dcr	a
0CB0  C0      		rnz	; unsupported FNC
			; done: execute boot code
0CB1  3A8222  		lda	cursok
0CB4  F608    		ori	sock0
0CB6  57      		mov	d,a
0CB7  3E08    		mvi	a,DISC
0CB9  CDBB0B  		call	wizcmd
0CBC  2A0523  		lhld	msg$dat
0CBF  E9      		pchl
0CC0  2A8B22  	load:	lhld	dma
0CC3  EB      		xchg
0CC4  210523  		lxi	h,msg$dat
0CC7  018000  		lxi	b,128
0CCA          		ldir
0CCA  EDB0    		DB	0EDH,0B0H
0CCC  EB      		xchg
0CCD  228B22  		shld	dma
0CD0  AF      	ack:	xra	a	; FNC 0 = ACK
0CD1  320323  		sta	msg$fnc
0CD4  320423  		sta	msg$siz
0CD7          		jr	loop
0CD7  18B9    		DB	18H,loop-$-1
0CD9  2A0523  	stdma:	lhld	msg$dat
0CDC  228B22  		shld	dma
0CDF          		jr	ack
0CDF  18EF    		DB	18H,ack-$-1
0CE1  CD2A06  	ldmsg:	call	crlf
0CE4  210523  		lxi	h,msg$dat
0CE7  7E      	ldm0:	mov	a,m
0CE8  23      		inx	h
0CE9  FE24    		cpi	'$'
0CEB          		jrz	ack
0CEB  28E3    		DB	28H,ack-$-1
0CED  CD9805  		call	conout
0CF0          		jr	ldm0
0CF0  18F5    		DB	18H,ldm0-$-1
		
		; D = server socket BSB
0CF2          	wizopen:
0CF2  1E03    		mvi	e,sn$sr
0CF4  CD410B  		call	getwiz1
0CF7  FE17    		cpi	ESTABLISHED
0CF9  C8      		rz	; ready to rock-n-roll...
			; try to open...
0CFA  FE13    		cpi	SOKINIT
0CFC          		jrz	nb4
0CFC  2809    		DB	28H,nb4-$-1
0CFE  3E01    		mvi	a,OPEN
0D00  CDBB0B  		call	wizcmd
0D03  FE13    		cpi	SOKINIT
0D05  37      		stc
0D06  C0      		rnz	; failed to open (init)
0D07  1E02    	nb4:	mvi	e,sn$ir	; ensure no lingering bits...
0D09  3E1F    		mvi	a,00011111b
0D0B  CD5B0B  		call	putwiz1
0D0E  3E04    		mvi	a,CONNECT
0D10  CDBB0B  		call	wizcmd
0D13  0E0B    		mvi	c,00001011b	; CON, DISCON, or TIMEOUT
0D15  CD240C  		call	wizist	; returns when one is set, or CY
0D18  D8      		rc
0D19  E601    		ani	00000001b	; need CON
0D1B  D601    		sui	00000001b	; CY if bit is 0
0D1D  C9      		ret
		
		;	Send Message on Network, receive response
		;	msgbuf setup with FMT, FNC, LEN, data
		;	msg len always <= 128 (133 total) bytes.
0D1E          	sndrcv:			; BC = message addr
			; TODO: drain/flush receiver
		; begin send phase
0D1E  210023  		lxi	h,msgbuf
0D21  228522  		shld	msgptr
0D24  3A8222  		lda	cursok
0D27  F608    		ori	sock0
0D29  57      		mov	d,a
			; D=socket patn
0D2A  3A8022  		lda	server
0D2D  320123  		sta	msg$did	; Set Server ID (dest) in header
0D30  3A8122  		lda	nodeid
0D33  320223  		sta	msg$sid	; Set Slave ID (src) in header
0D36  3A0423  		lda	msg$siz	; msg siz (-1)
0D39  C606    		adi	5+1	; hdr, +1 for (-1)
0D3B  6F      		mov	l,a
0D3C  2600    		mvi	h,0
0D3E  228722  		shld	msglen
0D41  1E24    		mvi	e,sn$txwr
0D43  CD730B  		call	getwiz2
0D46  228322  		shld	curptr
0D49  2A8722  		lhld	msglen
0D4C          		lbcd	curptr
0D4C  ED4B    		DB	0EDH,4BH
0D4E  8322    		DW	curptr
0D50  09      		dad	b
0D51  1E24    		mvi	e,sn$txwr
0D53  CDA30B  		call	putwiz2
			; send data
0D56  2A8722  		lhld	msglen
0D59  EB      		xchg
0D5A  2A8322  		lhld	curptr
0D5D  CDF30B  		call	cpyout
0D60  3A8222  		lda	cursok
0D63  F608    		ori	sock0
0D65  57      		mov	d,a
0D66  3E20    		mvi	a,SEND
0D68  CDBB0B  		call	wizcmd
			; ignore Sn_SR?
0D6B  0E1A    		mvi	c,00011010b	; SEND_OK bit, TIMEOUT, DISConnect
0D6D  CD240C  		call	wizist
0D70  D8      		rc
0D71  E610    		ani	00010000b	; SEND_OK
0D73  37      		stc
0D74  C8      		rz
		; begin recv phase - loop
0D75  3A8222  		lda	cursok	; is D still socket BSB?
0D78  F608    		ori	sock0
0D7A  57      		mov	d,a
		;	Receive Message from Network
0D7B  210023  		lxi	h,msgbuf
0D7E  228522  		shld	msgptr
0D81  0E06    		mvi	c,00000110b	; RECV, DISC
0D83  CD240C  		call	wizist	; check for recv within timeout
0D86          		jrc	rerr
0D86  386A    		DB	38H,rerr-$-1
0D88  E604    		ani	00000100b	; RECV
0D8A          		jrz	rerr
0D8A  2866    		DB	28H,rerr-$-1
0D8C  210000  		lxi	h,0
0D8F  228922  		shld	totlen
0D92          	rm0:	; D must be socket base...
0D92  1E26    		mvi	e,sn$rxrsr	; length
0D94  CD730B  		call	getwiz2
0D97  7C      		mov	a,h
0D98  B5      		ora	l
0D99          		jrz	rm0
0D99  28F7    		DB	28H,rm0-$-1
0D9B  228722  		shld	msglen		; not CP/NET msg len
0D9E  1E28    		mvi	e,sn$rxrd	; pointer
0DA0  CD730B  		call	getwiz2
0DA3  228322  		shld	curptr
0DA6          		lbcd	msglen	; BC=Sn_RX_RSR
0DA6  ED4B    		DB	0EDH,4BH
0DA8  8722    		DW	msglen
0DAA  2A8922  		lhld	totlen
0DAD  B7      		ora	a
0DAE          		dsbc	b
0DAE  ED42    		DB	0EDH,b*8+42H
0DB0  228922  		shld	totlen	; might be negative...
0DB3          		lbcd	curptr
0DB3  ED4B    		DB	0EDH,4BH
0DB5  8322    		DW	curptr
0DB7  2A8722  		lhld	msglen	; BC=Sn_RX_RD, HL=Sn_RX_RSR
0DBA  09      		dad	b	; HL=nxt RD
0DBB  1E28    		mvi	e,sn$rxrd
0DBD  CDA30B  		call	putwiz2
			; DE destroyed...
0DC0          		lded	msglen
0DC0  ED5B    		DB	0EDH,5BH
0DC2  8722    		DW	msglen
0DC4  2A8322  		lhld	curptr
0DC7  CD030C  		call	cpyin
0DCA  3A8222  		lda	cursok
0DCD  F608    		ori	sock0
0DCF  57      		mov	d,a
0DD0  3E40    		mvi	a,RECV
0DD2  CDBB0B  		call	wizcmd
			; ignore Sn_SR?
0DD5  2A8922  		lhld	totlen	; might be neg (first pass)
0DD8  7C      		mov	a,h
0DD9  B7      		ora	a
0DDA  F2EE0D  		jp	rm1
			; can we guarantee at least msg hdr?
0DDD  3A0423  		lda	msg$siz	; msg siz (-1)
0DE0  C606    		adi	5+1	; header, +1 for (-1)
0DE2  5F      		mov	e,a
0DE3  3E00    		mvi	a,0
0DE5  8F      		adc	a
0DE6  57      		mov	d,a	; true msg len
0DE7  19      		dad	d	; subtract what we already have
0DE8          		jrnc	rerr	; something is wrong, if still neg
0DE8  3008    		DB	30H,rerr-$-1
0DEA  228922  		shld	totlen
0DED  7C      		mov	a,h
0DEE  B5      	rm1:	ora	l
0DEF          		jrnz	rm0
0DEF  20A1    		DB	20H,rm0-$-1
0DF1  C9      		ret	; success (A=0)
		
0DF2          	rerr:
0DF2  AF      	err:	xra	a
0DF3  3D      		dcr	a	; NZ
0DF4  C9      		ret
		
		; Try to read NVRAM config for WIZNET.
		; Returns: A = node id (PMAGIC) or CY if error (no config)
0DF5          	wizcfg:	; restore config from NVRAM
0DF5  210000  		lxi	h,0
0DF8  110002  		lxi	d,512
0DFB  CDA20E  		call	nvget
0DFE  CD7E0E  		call	vcksum
0E01  37      		stc
0E02  C0      		rnz	; checksum wrong - no config available
0E03  210124  		lxi	h,nvbuf+gar
0E06  1600    		mvi	d,0
0E08  1E01    		mvi	e,gar
0E0A  0612    		mvi	b,18	; GAR+SUBR+SHAR+SIPR
0E0C  CD8D0B  		call	wizset
0E0F  3A1D24  		lda	nvbuf+pmagic
0E12  1E1D    		mvi	e,pmagic
0E14  CD5B0B  		call	putwiz1
0E17          		lxix	nvbuf+32	; start of socket0 data
0E17  DD21    		DB	0DDH,21H
0E19  2024    		DW	nvbuf+32
0E1B  1608    		mvi	d,SOCK0
0E1D  0608    		mvi	b,8
0E1F          	rest0:
0E1F  C5      		push	b
0E20          		ldx	a,sn$prt
0E20  DD7E04  		DB	0DDH,a*8+46H,sn$prt
0E23  FE31    		cpi	31h
0E25          		jrnz	rest1	; skip unconfigured sockets
0E25  201E    		DB	20H,rest1-$-1
0E27  3E01    		mvi	a,1	; TCP mode
0E29  1E00    		mvi	e,sn$mr
0E2B  CD5B0B  		call	putwiz1	; force TCP/IP mode
0E2E          		ldx	a,NvKPALVTR
0E2E  DD7E1D  		DB	0DDH,a*8+46H,NvKPALVTR
0E31  1E2F    		mvi	e,sn$kpalvtr
0E33  B7      		ora	a
0E34  C45B0B  		cnz	putwiz1
0E37  1E04    		mvi	e,sn$prt
0E39  0602    		mvi	b,2
0E3B  CD560E  		call	setsok
0E3E  1E0C    		mvi	e,sn$dipr
0E40  0606    		mvi	b,6	; DIPR and DPORT
0E42  CD560E  		call	setsok
0E45          	rest1:
0E45  012000  		lxi	b,32
0E48          		dadx	b
0E48  DD09    		DB	0DDH,b*8+09H
0E4A  3E20    		mvi	a,001$00$000b	; socket BSB incr value
0E4C  82      		add	d
0E4D  57      		mov	d,a
0E4E  C1      		pop	b
0E4F          		djnz	rest0
0E4F  10CE    		DB	10H,rest0-$-1
0E51  3A1D24  		lda	nvbuf+pmagic	; our node id
0E54  B7      		ora	a	; NC
0E55  C9      		ret
		
		; IX = base data buffer for socket, D = socket BSB, E = offset, B = length
		; destroys HL, B, C
0E56          	setsok:
0E56          		pushix
0E56  DDE5    		DB	0DDH,0E5H
0E58  E1      		pop	h
0E59  D5      		push	d
0E5A  1600    		mvi	d,0
0E5C  19      		dad	d	; HL points to data in 'buf'
0E5D  D1      		pop	d
0E5E  CD8D0B  		call	wizset
0E61  C9      		ret
		
0E62          	cksum32:
0E62  210000  		lxi	h,0
0E65  110000  		lxi	d,0
0E68          	cks0:	ldx	a,+0
0E68  DD7E00  		DB	0DDH,a*8+46H,+0
0E6B          		inxix
0E6B  DD23    		DB	0DDH,23H
0E6D  83      		add	e
0E6E  5F      		mov	e,a
0E6F          		jrnc	cks1
0E6F  3007    		DB	30H,cks1-$-1
0E71  14      		inr	d
0E72          		jrnz	cks1
0E72  2004    		DB	20H,cks1-$-1
0E74  2C      		inr	l
0E75          		jrnz	cks1
0E75  2001    		DB	20H,cks1-$-1
0E77  24      		inr	h
0E78  0B      	cks1:	dcx	b
0E79  78      		mov	a,b
0E7A  B1      		ora	c
0E7B          		jrnz	cks0
0E7B  20EB    		DB	20H,cks0-$-1
0E7D  C9      		ret
		
		; Validates checksum in 'buf'
		; return: NZ on error
0E7E          	vcksum:
0E7E          		lxix	nvbuf
0E7E  DD21    		DB	0DDH,21H
0E80  0024    		DW	nvbuf
0E82  01FC01  		lxi	b,508
0E85  CD620E  		call	cksum32
0E88          		lbcd	nvbuf+510
0E88  ED4B    		DB	0EDH,4BH
0E8A  FE25    		DW	nvbuf+510
0E8C  78      		mov	a,b	;
0E8D  B1      		ora	c	; check first half zero
0E8E          		dsbc	b
0E8E  ED42    		DB	0EDH,b*8+42H
0E90  C0      		rnz
0E91          		lbcd	nvbuf+508
0E91  ED4B    		DB	0EDH,4BH
0E93  FC25    		DW	nvbuf+508
0E95  B0      		ora	b	;
0E96  B1      		ora	c	; check second half zero
0E97  EB      		xchg
0E98          		dsbc	b
0E98  ED42    		DB	0EDH,b*8+42H
0E9A  C0      		rnz
0E9B  B7      		ora	a	; was checksum all zero?
0E9C          		jrz	vcksm0
0E9C  2802    		DB	28H,vcksm0-$-1
0E9E  AF      		xra	a	; ZR
0E9F  C9      		ret
0EA0  3C      	vcksm0:	inr	a	; NZ
0EA1  C9      		ret
		
		; Get a block of data from NVRAM to 'buf'
		; HL = nvram address, DE = length (always multiple of 256)
0EA2          	nvget:
0EA2  3E02    		mvi	a,NVSCS
0EA4  D341    		out	spi$ctl
0EA6  3E03    		mvi	a,NVRD
0EA8  D340    		out	spi$dat
0EAA  7C      		mov	a,h
0EAB  D340    		out	spi$dat
0EAD  7D      		mov	a,l
0EAE  D340    		out	spi$dat
0EB0  DB40    		in	spi$dat	; prime pump
0EB2  0E40    		mvi	c,spi$dat
0EB4  210024  		lxi	h,nvbuf
0EB7  43      		mov	b,e
0EB8          	nvget0:	inir	; B = 0 after
0EB8  EDB2    		DB	0EDH,0B2H
0EBA  15      		dcr	d
0EBB          		jrnz	nvget0
0EBB  20FB    		DB	20H,nvget0-$-1
0EBD  AF      		xra	a	; not SCS
0EBE  D341    		out	spi$ctl
0EC0  C9      		ret
		endif
		
0000          	if terminal
		endif
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Set BAUD command
0EC1          	setber:
0EC1  3E07    		mvi	a,BEL
0EC3  CD9805  		call	conout
0EC6  E1      		pop	h
0EC7  C9      		ret
		
0EC8          	setbr:
0EC8  212D0F  		lxi	h,ratems
0ECB  CD3406  		call	msgout
0ECE  CD8705  		call	conin
0ED1  E6DF    		ani	11011111b	; toupper
0ED3  4F      		mov	c,a
0ED4  CD9805  		call	conout
0ED7  D641    		sui	'A'
0ED9  FE0E    		cpi	'O'-'A'
0EDB          		jrnc	setber
0EDB  30E4    		DB	30H,setber-$-1
0EDD  5F      		mov	e,a
0EDE  1600    		mvi	d,0
0EE0  21350F  		lxi	h,brtab
0EE3  19      		dad	d
0EE4  19      		dad	d
0EE5  19      		dad	d
0EE6  19      		dad	d
0EE7  5E      		mov	e,m
0EE8  23      		inx	h
0EE9  56      		mov	d,m	; DE=baud divisor
0EEA  23      		inx	h
0EEB  7E      		mov	a,m
0EEC  23      		inx	h
0EED  66      		mov	h,m
0EEE  6F      		mov	l,a	; HL=rate string
0EEF  CD3406  		call	msgout
0EF2  21CD0F  		lxi	h,baudms
0EF5  CD3406  		call	msgout
0EF8  CD2306  		call	waitcr
0EFB  3E1B    		mvi	a,ESC
0EFD  CD9805  		call	conout
0F00  3E72    		mvi	a,'r' ; Set Baud
0F02  CD9805  		call	conout
0F05  79      		mov	a,c ; Baud value
0F06  CD9805  		call	conout
0F09          	setbrf:
0F09  DBED    		in	0edh
0F0B  E660    		ani	01100000b
0F0D  FE60    		cpi	01100000b
0F0F          		jrnz	setbrf	; flush output
0F0F  20F8    		DB	20H,setbrf-$-1
0F11  01A00F  		lxi	b,4000	; delay value ~43mS
0F14          	setbr0:
0F14  0B      		dcx	b
0F15  78      		mov	a,b
0F16  B1      		ora	c
0F17          		jrnz	setbr0
0F17  20FB    		DB	20H,setbr0-$-1
0F19  DBEB    		in	0ebh
0F1B  F680    		ori	10000000b	; divsor latch enable
0F1D  D3EB    		out	0ebh
0F1F  7B      		mov	a,e
0F20  D3E8    		out	0e8h
0F22  7A      		mov	a,d
0F23  D3E9    		out	0e9h
0F25  DBEB    		in	0ebh
0F27  E67F    		ani	01111111b	; divisor latch disable
0F29  D3EB    		out	0ebh
0F2B  E1      		pop	h
0F2C  C9      		ret
		
0F2D  52617465	ratems:	db	'Rate - ',TRM
      202D2000
		
0F35          	brtab:
0F35  17046D0F		dw	1047,	br110
0F39  0003730F		dw	768,	br150
0F3D  8001790F		dw	384,	br300
0F41  C0007F0F		dw	192,	br600
0F45  6000850F		dw	96,	br1200
0F49  40008C0F		dw	64,	br1800
0F4D  3A00930F		dw	58,	br2000
0F51  30009A0F		dw	48,	br2400
0F55  2000A10F		dw	32,	br3600
0F59  1800A80F		dw	24,	br4800
0F5D  1000AF0F		dw	16,	br7200
0F61  0C00B60F		dw	12,	br9600
0F65  0600BD0F		dw	6,	br19200
0F69  0300C50F		dw	3,	br38400
		
0F6D  20283131	br110:	db	' (110',TRM
      3000
0F73  20283135	br150:	db	' (150',TRM
      3000
0F79  20283330	br300:	db	' (300',TRM
      3000
0F7F  20283630	br600:	db	' (600',TRM
      3000
0F85  20283132	br1200:	db	' (1200',TRM
      303000
0F8C  20283138	br1800:	db	' (1800',TRM
      303000
0F93  20283230	br2000:	db	' (2000',TRM
      303000
0F9A  20283234	br2400:	db	' (2400',TRM
      303000
0FA1  20283336	br3600:	db	' (3600',TRM
      303000
0FA8  20283438	br4800:	db	' (4800',TRM
      303000
0FAF  20283732	br7200:	db	' (7200',TRM
      303000
0FB6  20283936	br9600:	db	' (9600',TRM
      303000
0FBD  20283139	br19200: db	' (19200',TRM
      32303000
0FC5  20283338	br38400: db	' (38400',TRM
      34303000
0FCD  20626175	baudms:	db	' baud)',TRM
      642900
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Print ROM version command
0FD4          	prtver:
0FD4  21E20F  		lxi	h,versms
0FD7  CD3406  		call	msgout
0FDA  3AEB0F  		lda	vers
0FDD  CDFA05  		call	hexout
0FE0  E1      		pop	h
0FE1  C9      		ret
		
0FE2  56657273	versms:	db	'Version ',TRM
      696F6E20
      00
0FEB  14      	vers:	db	VERN	; version byte... "1.0"
		
0FEC  0D0A0745	erprom:	db	CR,LF,BEL,'EPROM err',TRM
      50524F4D
      20657272
      00
		
			rept	1000h-$-4
0FF9  FF      		db	0ffh
0FFA  FF      		db	0ffh
0FFB  FF      		db	0ffh
0FFC          	romend:
0FFC  0000    		dw	0
0FFE          	chksum:
0FFE  9045    		dw	04590h	; checksum...
		
0000          	if	($ <> 1000h)
		endif
1000          		end



Statistics:

     4	passes
     0	jr promotions
   420	symbols
  4096	bytes

   703	macro calls
  3785	macro bytes
     0	invented symbols
