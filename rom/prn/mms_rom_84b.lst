		; Z89/Z90 Monitor EPROM 444-84B, by Magnolia Microsystems
		; Z89/Z90/H8-Z80 Monitor EPROM 444-84D, June 29, 2019, drm
0016          	VERN	equ	16h	; ROM version
		
0000          	false	equ	0
FFFF          	true	equ	not false
		
		; TODO: alter version based on config (or some string)
FFFF          	gide	equ	true
FFFF          	wiznet	equ	true
0000          	mms422	equ	false
0000          	remex	equ	false
0000          	corvus	equ	false
0000          	xcomp	equ	false
0000          	terminal equ	false
		
			maclib	z80
**** z80.lib ****
**** mms_rom_84b.asm ****
			$*macro
		
000D          	CR	equ	13
000A          	LF	equ	10
0007          	BEL	equ	7
001B          	ESC	equ	27
0000          	TRM	equ	0
007F          	DEL	equ	127
		
FFFF          	if gide
0080          	GIDE$BA	equ	80h		; GIDE base port
0088          	GIDE$DA	equ	GIDE$BA+8	; GIDE data port
0089          	GIDE$ER	equ	GIDE$BA+9	; GIDE error register
008A          	GIDE$SC	equ	GIDE$BA+10	; GIDE sector count
008B          	GIDE$SE	equ	GIDE$BA+11	; GIDE sector number
008C          	GIDE$CL	equ	GIDE$BA+12	; GIDE cylinder low
008D          	GIDE$CH	equ	GIDE$BA+13	; GIDE cylinder high
008E          	GIDE$DH	equ	GIDE$BA+14	; GIDE drive/head
008F          	GIDE$CS	equ	GIDE$BA+15	; GIDE command/status
		endif
		
FFFF          	if wiznet
		; WIZNET/NVRAM (SPI adapter) defines
0040          	spi	equ	40h	; base port
0040          	spi$dat	equ	spi+0
0041          	spi$ctl	equ	spi+1	; must be spi$dat+1
0041          	spi$sta	equ	spi+1
		
0001          	WZSCS	equ	01b	; /SCS for WIZNET
0002          	NVSCS	equ	10b	; /SCS for NVRAM
		
		; NVRAM constants
		; NVRAM/SEEPROM commands
0003          	NVRD	equ	00000011b
0002          	NVWR	equ	00000010b
0005          	RDSR	equ	00000101b
0006          	WREN	equ	00000110b
		; NVRAM/SEEPROM status bits
0001          	WIP	equ	00000001b
		
		; WIZNET constants
0008          	nsocks	equ	8
0008          	sock0	equ	000$01$000b	; base pattern for Sn_ regs
0014          	txbuf0	equ	000$10$100b	; base pattern for Tx buffer
0018          	rxbuf0	equ	000$11$000b	; base pattern for Rx buffer
		
		; common regs
0001          	gar	equ	1
0005          	subr	equ	5
0009          	shar	equ	9
000F          	sipr	equ	15
0015          	ir	equ	21
0017          	sir	equ	23
001D          	pmagic	equ	29
		
		; socket regs, relative
0000          	sn$mr	equ	0
0001          	sn$cr	equ	1
0002          	sn$ir	equ	2
0003          	sn$sr	equ	3
0004          	sn$prt	equ	4
000C          	sn$dipr	equ	12
0010          	sn$dprt	equ	16
001D          	sn$resv8 equ	29	; reserved
0024          	sn$txwr	equ	36
0026          	sn$rxrsr equ	38
0028          	sn$rxrd	equ	40
002F          	sn$kpalvtr equ	47
		
001D          	NvKPALVTR equ	sn$resv8 ; place to stash keep-alive in nvram
		
		; socket commands
0001          	OPEN	equ	01h
0004          	CONNECT	equ	04h
0008          	DISC	equ	08h
0020          	SEND	equ	20h
0040          	RECV	equ	40h
		
		; socket status
0013          	SOKINIT	equ	13h
0017          	ESTABLISHED equ	17h
		
2280          		org	2280h
2280          	server:	ds	1	; SID, dest of send
2281          	nodeid:	ds	1	; our node id
2282          	cursok:	ds	1	; current socket select patn
2283          	curptr:	ds	2	; into chip mem
2285          	msgptr:	ds	2
2287          	msglen:	ds	2
2289          	totlen:	ds	2
228B          	dma:	ds	2
		
2300          		org	2300h
		msgbuf:	ds	0
2300          	msg$fmt: ds	1
2301          	msg$did: ds	1
2302          	msg$sid: ds	1
2303          	msg$fnc: ds	1
2304          	msg$siz: ds	1
2305          	msg$dat: ds	128
		
2400          		org	2400h
2400          	nvbuf:	ds	512
		endif
		
		; Legacy devices and defines
		
1800          		org	01800h	; H17 Floppy ROM routines
1800          		ds	1014
1BF6          	R$ABORT: ds	35	;00011011.11110110	033.366	R.ABORT
1C19          	CLOCK:	ds	38	;00011100.00011001	034.031 CLOCK
1C3F          	R$READ:	ds	499	;00011100.00111111	034.077	R.READ
1E32          	R$SDP:	ds	107	;			034.062 R.SDP
1E9D          	R$WHD:	ds	28	;00011110.10011101	036.235	R.WHD
1EB9          	R$WNH:	ds	161	;00011110.10111001	036.271	R.WNH
1F5A          	R$CONST: ds	88	;00011111.01011010	037.132	R.CONST
1FB2          		ds	78
		
		; RAM variables, some defined by H17 Floppy ROM
2000          		org	02000h
2000          	ramstart:
2000          		ds	3
2003          	l2003h:	ds	1	; - 02003h
2004          	l2004h:	ds	1	; - 02004h
2005          		ds	3
2008          	l2008h:	ds	1	; - 02008h
2009          	ctl$F0:	ds	1	; - 02009h
200A          		ds	17
201B          	ticcnt:	ds	2	; - 0201bh
201D          	monstk:	ds	2	; - 0201dh
201F          	intvec:
201F          	vrst1:	ds	3	; rst1 jmp vector - 0201fh
2022          	vrst2:	ds	3	; rst2 jmp vector - 02022h
2025          	vrst3:	ds	3	; rst3 jmp vector - 02025h
2028          	vrst4:	ds	3	; rst4 jmp vector - 02028h
202B          	vrst5:	ds	3	; rst5 jmp vector - 0202bh
202E          	vrst6:	ds	3	; rst6 jmp vector - 0202eh
2031          	vrst7:	ds	3	; rst7 jmp vector - 02031h
2034          	l2034h:	ds	2	; - 02034h
2036          	ctl$F2:	ds	1	; - 02036h GPP template/image
2037          	l2037h:	ds	2	; - 02037h
2039          		ds	7
2040          	l2040h:	ds	8
2048          	D$CONST: ds	88+20	; - 02048h	disk constants
20B4          	DECNT:	ds	1	; - 020b4h
20B5          		ds	124
2131          	AIO$UNI: ds	1	; - 02131h
2132          	cmdbuf:	ds	6	; SASI command buffer
2138          	resbuf:	ds	2	; SASI result buffer
213A          		ds	22
2150          	cport:	ds	1	; - 02150h
2151          		ds	1
2152          	SEC$CNT:	ds	1	; - 02152h
2153          	l2153h:	ds	1
2154          		ds	2
2156          	l2156h:	ds	6	; cmdbuf for SASI, segoff for GIDE
215C          		ds	292
		bootbf:	ds	0	; - 02280h
		
3000          	memtest	equ	03000h
C000          	ramboot	equ	0c000h
		
		; Start of ROM code
0000          		org	00000h
		
0000          	rombeg:
0000  C33C04  	rst0:	jmp	init
		
0003  6F6F7420	bootms:	db	'oot ',TRM
      00
		
0008  CDE204  	rst1:	call	intsetup
000B  2A1B20  		lhld	ticcnt
000E  C3B900  		jmp	int1$cont
0000          	if ((high int1$cont) <> 0)
		endif
		
0010          	rst2	equ	$-1	; must be a nop...
0011  CDE204  		call	intsetup
0014  1A      		ldax	d
0015  C38001  		jmp	int2$cont
		
0018  C32520  	rst3:	jmp	vrst3
		
001B  6F2000  	goms:	db	'o ',TRM
001E  0000    		db	0,0
		
0020  C32820  	rst4:	jmp	vrst4
		
FFFF          	if wiznet
0023  C31A0D  		jmp	sndrcv	; 'msgbuf' setup...
0026  8E05    		dw	conout	; pointer, not vector; A=char
		else
		endif
		
0028  C32B20  	rst5:	jmp	vrst5
002B          	delayx:
002B  C35602  		jmp	delay
		
002E  3F00    	qmsg:	db	'?',TRM
		
0030  C32E20  	rst6:	jmp	vrst6
		
FFFF          	if wiznet
0033  C3DD0C  		jmp	wizopen	; 'server' set, D=socket BSB
0036  090D    		dw	wizclose ; 'cursok' set
		else
		endif
		
0038  C33120  	rst7:	jmp	vrst7
		
003B  75627374	subms:	db	'ubstitute ',TRM
      69747574
      652000
0046  726F6720	pcms:	db	'rog Counter ',TRM
      436F756E
      74657220
      00
0053  656D2074	mtms:	db	'em test',TRM
      65737400
005B  4175746F	autbms:	db	'Auto Boot',TRM
      20426F6F
      7400
		
			rept	0066h-$
0065  00      		db	0
0000          	if	($ <> 0066h)
		endif
		
0066          	nmi:
0066  E3      		xthl	; save HL and pop RETADR
0067  E5      		push	h	; put RETADR in new position
0068  F5      		push	psw
0069  2B      		dcx	h
006A  7E      		mov	a,m		; check cause of NMI
006B  FEF0    		cpi	0f0h	; H8 front-panel port
006D          		jrz	port$f0
006D  281B    		DB	28H,port$f0-$-1
006F  FEF1    		cpi	0f1h	; H8 port
0071          		jrz	port$ign
0071  2808    		DB	28H,port$ign-$-1
0073  FEFA    		cpi	0fah	; H8...
0075          		jrz	port$ign
0075  2804    		DB	28H,port$ign-$-1
0077  FEFB    		cpi	0fbh	; H8...
0079          		jrnz	nmi$xit2
0079  202D    		DB	20H,nmi$xit2-$-1
007B          	port$ign:	; ports 0F1H, 0FAH, 0FBH.
007B  2B      		dcx	h
007C  7E      		mov	a,m
007D  FED3    		cpi	0d3h	; OUT
007F          		jrz	nmi$xit2
007F  2827    		DB	28H,nmi$xit2-$-1
0081  FEDB    		cpi	0dbh	; IN
0083          		jrnz	nmi$xit2
0083  2023    		DB	20H,nmi$xit2-$-1
			; IN 0F1H, 0FAH or 0FBH...
0085  F1      		pop	psw
0086  3E00    		mvi	a,000h	; these ports "return" 000h
0088          		jr	nmi$xit	; exit NMI
0088  181F    		DB	18H,nmi$xit-$-1
		
008A          	port$f0:	; H8 front panel port...
008A  2B      		dcx	h
008B  7E      		mov	a,m
008C  FEDB    		cpi	0dbh	; IN
008E          		jrnz	not$in
008E  2005    		DB	20H,not$in-$-1
0090  F1      		pop	psw
0091  3EFF    		mvi	a,0ffh	; simulate input of 0ffh
0093          		jr	nmi$xit
0093  1814    		DB	18H,nmi$xit-$-1
0095          	not$in:
0095  FED3    		cpi	0d3h	; OUT
0097          		jrnz	nmi$xit2
0097  200F    		DB	20H,nmi$xit2-$-1
0099  F1      		pop	psw	; byte to output to 0F0H...
009A  F5      		push	psw	; _  7 6 5 4 3 2 1 0
009B  17      		ral		; 7  6 5 4 3 2 1 0 _
009C  17      		ral		; 6  5 4 3 2 1 0 _ 7
009D  2F      		cma		; 6  5'4'3'2'1'0'_ 7'
009E  17      		ral		; 5' 4'3'2'1'0'_ 7'6
009F  07      		rlc		; 4' 3'2'1'0'_ 7'6 5'
00A0  E603    		ani	003h	; _  _ _ _ _ _ _ 6 5'
00A2  213620  		lxi	h,ctl$F2
00A5  B6      		ora	m
00A6  D3F2    		out	0f2h ; simulate some H8 features
00A8          	nmi$xit2:
00A8  F1      		pop	psw
00A9          	nmi$xit:
00A9  E1      		pop	h
00AA  E3      		xthl
00AB          		retn
00AB  ED45    		DB	0EDH,45H
		
00AD          	int1$1:
00AD  0A      		ldax	b
00AE  0F      		rrc
00AF  DC1F20  		cc	vrst1
00B2          	intret:
00B2  F1      		pop	psw
00B3  F1      		pop	psw
00B4  C1      		pop	b
00B5  D1      		pop	d
00B6  E1      		pop	h
00B7          	nulint:
00B7  FB      		ei
00B8  C9      		ret
		
00B9          	int1$cont:
00B9  23      		inx	h
00BA  221B20  		shld	ticcnt
00BD  010920  		lxi	b,ctl$F0
00C0  0A      		ldax	b
00C1  D3F0    		out	0f0h
00C3  E620    		ani	020h
00C5          		jrnz	intret
00C5  20EB    		DB	20H,intret-$-1
00C7  0B      		dcx	b
00C8          	int1$0:
00C8  0A      		ldax	b
00C9  17      		ral
00CA          		jrc	int1$1
00CA  38E1    		DB	38H,int1$1-$-1
00CC  210A00  		lxi	h,10
00CF  39      		dad	sp
00D0  5E      		mov	e,m
00D1  23      		inx	h
00D2  56      		mov	d,m
00D3  1B      		dcx	d
00D4  1A      		ldax	d
00D5  FE76    		cpi	076h	; HLT
00D7          		jrnz	int1$1
00D7  20D4    		DB	20H,int1$1-$-1
00D9  CD8C05  		call	belout
00DC  3E48    		mvi	a,'H'
00DE  CD8E05  		call	conout
00E1          	re$entry:		; re-entry point for errors, etc.
00E1  210920  		lxi	h,ctl$F0
00E4  36F0    		mvi	m,0f0h	; !beep, 2mS, MON, !SI
00E6  2A1D20  		lhld	monstk
00E9  F9      		sphl
00EA  CD8C05  		call	belout
			;jmp	start
00ED          	start:
00ED  FB      		ei
00EE  21ED00  		lxi	h,start
00F1  E5      		push	h
00F2  21D207  		lxi	h,prompt
00F5  CD3406  		call	msgout
00F8          	prloop:
00F8  CD7805  		call	coninx
00FB  E65F    		ani	01011111b ; toupper
00FD  211B01  		lxi	h,cmdtab
0100  0605    		mvi	b,5
0102          	cmloop:
0102  BE      		cmp	m
0103  23      		inx	h
0104          		jrz	docmd
0104  280D    		DB	28H,docmd-$-1
0106  23      		inx	h
0107  23      		inx	h
0108          		djnz	cmloop
0108  10F8    		DB	10H,cmloop-$-1
010A  4F      		mov	c,a
010B  CDE707  		call	xcmds
010E  CD8C05  		call	belout
0111          		jr	prloop
0111  18E5    		DB	18H,prloop-$-1
		
0113          	docmd:
0113  CD8E05  		call	conout
0116  7E      		mov	a,m
0117  23      		inx	h
0118  66      		mov	h,m
0119  6F      		mov	l,a
011A  E9      		pchl
		
011B          	cmdtab:
011B  47      		db	'G'
011C  5A01    		dw	cmdgo
011E  53      		db	'S'
011F  1A05    		dw	cmdsub
0121  50      		db	'P'
0122  3A01    		dw	cmdpc
0124  42      		db	'B'
0125  9F02    		dw	cmdboot
0127  4D      		db	'M'
0128  4F06    		dw	cmdmt
012A  00      		db	0
		
			; patched-out code?
012B  00      		db	000h
012C  00      		db	000h
012D  00      		db	000h
012E  00      		db	000h
012F  00      		db	000h
0130  00      		db	000h
0131  00      		db	000h
0132  00      		db	000h
0133  00      		db	000h
0134  00      		db	000h
0135  00      		db	000h
0136  00      		db	000h
0137  C31804  		jmp	z47$dati
		
013A          	cmdpc:
013A  214600  		lxi	h,pcms
013D  CD3406  		call	msgout
0140  210C00  		lxi	h,12
0143  39      		dad	sp
0144  5E      		mov	e,m
0145  23      		inx	h
0146  56      		mov	d,m
0147  EB      		xchg
0148  CD6205  		call	inhexcr
014B          		jrc	cmdpc0
014B  3807    		DB	38H,cmdpc0-$-1
014D  CDE105  		call	adrnl
0150  CD6205  		call	inhexcr
0153  D0      		rnc
0154          	cmdpc0:
0154  EB      		xchg
0155          	cmdpc1:
0155  160D    		mvi	d,CR
0157  C39905  		jmp	adrin
		
015A          	cmdgo:
015A  211B00  		lxi	h,goms
015D  CD3406  		call	msgout
0160  210D00  		lxi	h,13
0163  39      		dad	sp
0164  CD6205  		call	inhexcr
0167  DC5501  		cc	cmdpc1	; read HEX until CR
016A  CD2A06  		call	crlf
016D  3ED0    		mvi	a,0d0h	; no-beep, 2mS, !MON, !single-step
016F          		jr	cmdgo0
016F  1808    		DB	18H,cmdgo0-$-1
0171  F3      		di
0172  3A0920  		lda	ctl$F0
0175  EE10    		xri	010h	; toggle single-step
0177  D3F0    		out	0f0h
0179          	cmdgo0:
0179  320920  		sta	ctl$F0
017C  E1      		pop	h
017D  C3B200  		jmp	intret
		
0180          	int2$cont:
0180  F610    		ori	010h	; disable single-step
0182  D3F0    		out	0f0h
0184  12      		stax	d
0185  E620    		ani	020h	; MON active?
0187  C2ED00  		jnz	start	; break to monitor code
018A  C32220  		jmp	vrst2	; else chain to (possible) user code.
		
018D          	take$5:
018D  3E05    		mvi	a,5	; 5 seconds
018F          	take$A:
018F  219F01  		lxi	h,timeout
0192  222020  		shld	vrst1+1
0195  325221  		sta	SEC$CNT
0198  3E01    		mvi	a,1
019A  320820  		sta	l2008h
019D  FB      		ei
019E  C9      		ret
		
019F          	timeout:
019F  211B20  		lxi	h,ticcnt
01A2  AF      		xra	a
01A3  B6      		ora	m
01A4  C0      		rnz
01A5  23      		inx	h
01A6  7E      		mov	a,m
01A7  0F      		rrc
01A8  D8      		rc
			; every 512 ticks... 1024mS
01A9  215221  		lxi	h,SEC$CNT
01AC  35      		dcr	m
01AD  C0      		rnz
01AE          	error:
01AE  2A1D20  		lhld	monstk
01B1  F9      		sphl
01B2  212E00  		lxi	h,qmsg
01B5  CD3406  		call	msgout
01B8  21B700  		lxi	h,nulint
01BB  222020  		shld	vrst1+1
01BE  320820  		sta	l2008h
01C1  DBF2    		in	0f2h
01C3  E603    		ani	00000011b
01C5          		jrnz	error0
01C5  2002    		DB	20H,error0-$-1
01C7  D37F    		out	07fh
01C9          	error0:
01C9  C3E100  		jmp	re$entry
		
01CC          	chkauto:
01CC  215321  		lxi	h,l2153h	; auto-boot disable?
01CF  DBF2    		in	0f2h
01D1  57      		mov	d,a
01D2  EE80    		xri	080h	; toggle auto-boot
01D4  B6      		ora	m
01D5  F8      		rm		; auto-boot OFF
01D6  72      		mov	m,d	; ensure we only fail once... and only on power-up?
01D7  CD0202  		call	gtdfbt
01DA  215B00  		lxi	h,autbms
01DD  CD3406  		call	msgout
01E0  318022  		lxi	sp,bootbf
01E3  C34C03  		jmp	goboot0
		
		; determine device for port 078H
		; return phy drv number in D.
01E6          	gtdev1:
01E6  1600    		mvi	d,0	; Z17
01E8  DBF2    		in	0f2h
01EA          	gtdev0:
01EA  E603    		ani	00000011b	; port 078H device
01EC  C8      		rz		; Z17 (or Z37)
01ED  FE01    		cpi	01b
01EF  1605    		mvi	d,5
01F1  C8      		rz		; Z47
01F2  FE02    		cpi	10b
01F4  1603    		mvi	d,3
01F6  C8      		rz		; Z67/MMS77320
0000          	if mms422
		else
01F7  C3AE01  		jmp	error	; fatal error... not defined
		endif
		
		; determine device for port 078H
		; return phy drv number in D.
01FA          	gtdev2:
01FA  162E    		mvi	d,46	; Z37
01FC  DBF2    		in	0f2h
01FE  0F      		rrc
01FF  0F      		rrc
0200          		jr	gtdev0	; rest are same
0200  18E8    		DB	18H,gtdev0-$-1
		
		; determine default boot device.
0202          	gtdfbt:
0202  110000  		lxi	d,0
0205  DBF2    		in	0f2h
0207  E670    		ani	01110000b	; default boot selection
0209  FE20    		cpi	00100000b	; device at 07CH
020B          		jrz	gtdev1
020B  28D9    		DB	28H,gtdev1-$-1
020D  FE30    		cpi	00110000b	; device at 078H
020F          		jrz	gtdev2
020F  28E9    		DB	28H,gtdev2-$-1
0211  C30B08  		jmp	gtdvtb		; get MMS device
		
		; Check SW501 for installed device.
		; C = desired port pattern, 00=Z17/Z37, 01=Z47, 10=Z67, 11=undefined
		; returns base I/O port adr in B.
0214          	getport:
0214  067C    		mvi	b,07ch
0216  DBF2    		in	0f2h
0218  E603    		ani	003h
021A  B9      		cmp	c
021B  C8      		rz
021C  0678    		mvi	b,078h
021E  DBF2    		in	0f2h
0220  0F      		rrc
0221  0F      		rrc
0222  E603    		ani	003h
0224  B9      		cmp	c
0225  C8      		rz
0226  E1      		pop	h	; discard return address
0227          	s501er:
0227  212D02  		lxi	h,s501ms
022A  C33406  		jmp	msgout
		
022D  53573530	s501ms:	db	'SW501 wrong ',TRM
      31207772
      6F6E6720
      00
		
		; hack to support 3 drives on H17
023A          	m$sdp:
023A  3E0A    		mvi	a,10
023C  32B420  		sta	DECNT
023F  3A3121  		lda	AIO$UNI
0242  F5      		push	psw	; 0,1,2
0243  C6FE    		adi	-2	;
0245  CE03    		aci	3	; 1,2,4
0247  C33C1E  		jmp	R$SDP+10	; hacked R.SDP for 3-drives
		
024A          	inport0:
024A  B7      		ora	a	; NC
		; input from cport+CY
024B          	inportx:
024B  C5      		push	b
024C  3A5021  		lda	cport
024F  CE00    		aci	0
0251  4F      		mov	c,a
0252          		inp	a
0252  ED78    		DB	0EDH,a*8+40H
0254  C1      		pop	b
0255  C9      		ret
		
0256          	delay:
0256  E5      		push	h
0257  211B20  		lxi	h,ticcnt
025A  86      		add	m
025B          	delay0:
025B  BE      		cmp	m
025C          		jrnz	delay0
025C  20FD    		DB	20H,delay0-$-1
025E  E1      		pop	h
025F  C9      		ret
		
0260          	digerr:
0260  CD8C05  		call	belout
0263          		jr	btdig0
0263  1806    		DB	18H,btdig0-$-1
		; Got a digit in boot command, parse it
0265          	btdig:	; boot by phys drive number, E=0
0265  CD8E05  		call	conout	; echo digit
0268  E60F    		ani	00fh	; convert to binary
026A  57      		mov	d,a
026B          	btdig0:
026B  CD7D05  		call	conin	; get another, until term char (C)
026E  B9      		cmp	c
026F          		jrz	gotnum
026F  281D    		DB	28H,gotnum-$-1
0271  FE30    		cpi	'0'
0273          		jrc	digerr
0273  38EB    		DB	38H,digerr-$-1
0275  FE3A    		cpi	'9'+1
0277          		jrnc	digerr
0277  30E7    		DB	30H,digerr-$-1
0279  CD8E05  		call	conout
027C  E60F    		ani	00fh
027E  060A    		mvi	b,10	; add 10 times, i.e. D = (D * 10) + A
0280          	btdig1:
0280  82      		add	d
0281  DAAE01  		jc	error
0284          		djnz	btdig1
0284  10FA    		DB	10H,btdig1-$-1
0286  57      		mov	d,a
0287  FEC8    		cpi	200
0289  D2AE01  		jnc	error
028C          		jr	btdig0
028C  18DD    		DB	18H,btdig0-$-1
		
028E          	gotnum:	; Boot N... "N" in D
028E  7A      		mov	a,d
028F  FE05    		cpi	5
0291  DA4903  		jc	goboot
0294  FE09    		cpi	9
0296  D24903  		jnc	goboot
0299  C6C8    		adi	200	; modify 5..8 to not conflict
029B  57      		mov	d,a
029C  C34903  		jmp	goboot
		
029F          	cmdboot:
029F  210300  		lxi	h,bootms
02A2  CD3406  		call	msgout	; complete (B)oot
02A5  3EC3    		mvi	a,0c3h
02A7  328022  		sta	bootbf	; mark "no string"
02AA  318022  		lxi	sp,bootbf
02AD  CD0202  		call	gtdfbt
02B0  0E0D    		mvi	c,CR	; end input on CR
02B2          		jr	boot0
02B2  1803    		DB	18H,boot0-$-1
02B4          	bterr:
02B4  CD8C05  		call	belout
02B7          	boot0:
02B7  CD7D05  		call	conin
02BA  B9      		cmp	c
02BB  CA4903  		jz	goboot
02BE  1E00    		mvi	e,0
02C0  FE30    		cpi	'0'
02C2          		jrc	nodig
02C2  3804    		DB	38H,nodig-$-1
02C4  FE3A    		cpi	'9'+1
02C6          		jrc	btdig
02C6  389D    		DB	38H,btdig-$-1
02C8          	nodig:	; boot by letter... Boot alpha-
02C8  E65F    		ani	05fh ; toupper
02CA  FE5B    		cpi	'Z'+1
02CC          		jrnc	bterr
02CC  30E6    		DB	30H,bterr-$-1
02CE  FE41    		cpi	'A'
02D0          		jrc	bterr
02D0  38E2    		DB	38H,bterr-$-1
02D2  CD8E05  		call	conout
02D5  CD8E05  		call	conout
02D8  FE42    		cpi	'B'
02DA          		jrc	gotit	; 'A' is synonym for default
02DA  3816    		DB	38H,gotit-$-1
02DC  211A06  		lxi	h,bootb1	; Heath/Zenith device letters
02DF  47      		mov	b,a
02E0          	luboot:
02E0  7E      		mov	a,m
02E1  23      		inx	h
02E2  56      		mov	d,m
02E3  23      		inx	h
02E4  B8      		cmp	b
02E5          		jrz	gotit
02E5  280B    		DB	28H,gotit-$-1
02E7  B7      		ora	a
02E8          		jrnz	luboot
02E8  20F6    		DB	20H,luboot-$-1
02EA  1600    		mvi	d,0
02EC  CD3C08  		call	mmslookup
02EF  DAAE01  		jc	error
02F2          	gotit:
02F2  3E2D    		mvi	a,'-'	; next is optional unit number...
02F4  CD8E05  		call	conout
02F7          		jr	luboot0
02F7  1803    		DB	18H,luboot0-$-1
		
02F9          	lunerr:
02F9  CD8C05  		call	belout
02FC          	luboot0:
02FC  CD7D05  		call	conin
02FF  B9      		cmp	c
0300          		jrz	goboot
0300  2847    		DB	28H,goboot-$-1
0302  FE3A    		cpi	':'
0304          		jrz	colon
0304  2827    		DB	28H,colon-$-1
0306  FE20    		cpi	' '
0308          		jrz	space
0308  281E    		DB	28H,space-$-1
030A  FE30    		cpi	'0'
030C          		jrc	lunerr
030C  38EB    		DB	38H,lunerr-$-1
030E  FE3A    		cpi	'9'+1
0310          		jrnc	lunerr
0310  30E7    		DB	30H,lunerr-$-1
0312  CD8E05  		call	conout
0315  D630    		sui	'0'
0317  5F      		mov	e,a	; single digit (0..9)
0318          	luboot1:
0318  CD7D05  		call	conin
031B  B9      		cmp	c
031C          		jrz	goboot
031C  282B    		DB	28H,goboot-$-1
031E  FE3A    		cpi	':'	; Boot alpha-dig:str
0320          		jrz	colon
0320  280B    		DB	28H,colon-$-1
0322  FE20    		cpi	' '	; cosmetic spaces?
0324          		jrz	space
0324  2802    		DB	28H,space-$-1
0326  3E07    		mvi	a,BEL
0328          	space:
0328  CD8E05  		call	conout
032B          		jr	luboot1
032B  18EB    		DB	18H,luboot1-$-1
		
032D          	colon:	; get arbitrary string as last boot param
032D  0600    		mvi	b,0
032F  218022  		lxi	h,bootbf
0332          	btstr0:
0332  CD8E05  		call	conout
0335  CD7D05  		call	conin
0338  04      		inr	b
0339  23      		inx	h
033A  77      		mov	m,a
033B  B9      		cmp	c
033C          		jrnz	btstr0
033C  20F4    		DB	20H,btstr0-$-1
033E  78      		mov	a,b
033F  328022  		sta	bootbf	; bootbf: <len> <string...> as in CP/M cmd buf
0342  AF      		xra	a	; TRM - string terminator
0343          	btstr1:	; use stack as char array...
0343  F5      		push	psw
0344  33      		inx	sp	; undo half of push
0345  2B      		dcx	h
0346  7E      		mov	a,m
0347          		djnz	btstr1
0347  10FA    		DB	10H,btstr1-$-1
		; D=Phys Drive base number, E=Unit number
		; (or, D=Phys Drive unit, E=0)
0349          	goboot:
0349  CD2A06  		call	crlf
034C          	goboot0:
034C  21AE01  		lxi	h,error
034F  E5      		push	h
0350  CDA207  		call	h17init
0353  7B      		mov	a,e
0354  323121  		sta	AIO$UNI	; relative unit num
0357  82      		add	d
0358  323420  		sta	l2034h	; boot phys drv unit num
035B  7A      		mov	a,d
035C  FE03    		cpi	3	; 0,1,2
035E          		jrc	bz17	; Z17 boot
035E  3809    		DB	38H,bz17-$-1
			; 3,4 not used?
0360  D605    		sui	5
0362  FE04    		cpi	4	; 5,6,7,8
0364          		jrc	bz47	; Z47 boot
0364  3847    		DB	38H,bz47-$-1
0366  C3F307  		jmp	exboot	;
		
0369          	bz17:
0369  83      		add	e
036A  FE03    		cpi	3
036C  D0      		rnc	; invalid Z17 drive
036D  323121  		sta	AIO$UNI
0370  DBF2    		in	0f2h
0372  E603    		ani	00000011b
0374  C22702  		jnz	s501er	; no Z17 installed
0377  3E7C    		mvi	a,07ch
0379  325021  		sta	cport
037C  213A02  		lxi	h,m$sdp
037F  228620  		shld	D$CONST+62
0382  3E0A    		mvi	a,10
0384  47      		mov	b,a	; B = 10, one full revolution?
0385  CD8F01  		call	take$A	; error after 10 seconds...
0388  CD3A02  		call	m$sdp	; hacked R.SDP - setup dev parms (select drive)
038B          	bz17$0:
038B  CD9D1E  		call	R$WHD	; WHD - wait hole detect
038E  CDB91E  		call	R$WNH	; WNH - wait no hole
0391          		djnz	bz17$0	; essentially hang until user inserts a disk...
0391  10F8    		DB	10H,bz17$0-$-1
0393  CDF61B  		call	R$ABORT	; R.ABORT - reset everything
0396  118022  		lxi	d,bootbf	; DMA address
0399  010009  		lxi	b,00900h	; B = 9 (num sectors), C = 0 (residual bytes to read)
039C  210000  		lxi	h,0		; track/sector number to start
039F  CD3F1C  		call	R$READ
03A2  D8      		rc
03A3  E1      		pop	h
03A4          	hxboot:
03A4  21191C  		lxi	h,CLOCK	; CLOCK - standard 2mS handler
03A7  222020  		shld	vrst1+1 ; normal TICK intr routine
03AA  C38022  		jmp	bootbf	; run boot code...
		
03AD          	bz47:
03AD  83      		add	e
03AE  FE04    		cpi	004h
03B0  D0      		rnc
03B1  0F      		rrc
03B2  0F      		rrc
03B3  0F      		rrc
03B4  3C      		inr	a
03B5  5F      		mov	e,a
03B6  0E01    		mvi	c,01b
03B8  CD1402  		call	getport
03BB  78      		mov	a,b
03BC  325021  		sta	cport
03BF  CD8D01  		call	take$5	; error out after 5 seconds...
03C2  3E02    		mvi	a,2
03C4  CD0A04  		call	outport0
03C7  3E02    		mvi	a,2
03C9  CDFD03  		call	z47$cmdo
03CC  7B      		mov	a,e
03CD  CDF903  		call	z47$dato
03D0  CD1804  		call	z47$dati
03D3  E60C    		ani	00ch
03D5  0F      		rrc
03D6  0F      		rrc
03D7  3C      		inr	a
03D8  47      		mov	b,a
03D9  3E01    		mvi	a,1
03DB          	bz47$0:
03DB  87      		add	a
03DC          		djnz	bz47$0
03DC  10FD    		DB	10H,bz47$0-$-1
03DE  1F      		rar
03DF  47      		mov	b,a
03E0  218022  		lxi	h,bootbf
03E3  C5      		push	b
03E4  CD2104  		call	z47$read
03E7  C1      		pop	b
03E8  1C      		inr	e
03E9  CD2104  		call	z47$read
03EC  CD4A02  		call	inport0
03EF  E601    		ani	001h
03F1  C0      		rnz
03F2          	hwboot:
03F2  AF      		xra	a
03F3  320820  		sta	l2008h
03F6  C3A403  		jmp	hxboot
		
03F9          	z47$dato:
03F9  1680    		mvi	d,080h	; TR - date transfer request
03FB          		jr	z47$out0
03FB  1802    		DB	18H,z47$out0-$-1
03FD          	z47$cmdo:
03FD  1620    		mvi	d,020h	; DONE
03FF          	z47$out0:
03FF  37      		stc
0400  F5      		push	psw
0401          	z47$wt0:
0401  CD4A02  		call	inport0
0404  A2      		ana	d
0405          		jrz	z47$wt0
0405  28FA    		DB	28H,z47$wt0-$-1
0407  F1      		pop	psw
0408          		jr	z47$out1
0408  1801    		DB	18H,z47$out1-$-1
040A          	outport0:
040A  B7      		ora	a
040B          	z47$out1:
040B  C5      		push	b
040C  47      		mov	b,a
040D  3A5021  		lda	cport
0410  CE00    		aci	0
0412  4F      		mov	c,a
0413  78      		mov	a,b
0414          		outp	a
0414  ED79    		DB	0EDH,a*8+41H
0416  C1      		pop	b
0417  C9      		ret
		
0418          	z47$dati:
0418  CD4A02  		call	inport0
041B  07      		rlc	; TR
041C          		jrnc	z47$dati
041C  30FA    		DB	30H,z47$dati-$-1
041E  C34B02  		jmp	inportx	; CY=1, input cport+1
		
0421          	z47$read:
0421  3E07    		mvi	a,7	; read thru buffer command
0423  CDFD03  		call	z47$cmdo
0426  AF      		xra	a
0427  CDF903  		call	z47$dato	; params
042A  7B      		mov	a,e
042B  CDF903  		call	z47$dato	; params
042E          	z47$rd0:
042E  0E80    		mvi	c,128
0430          	z47$rd1:
0430  CD1804  		call	z47$dati
0433  77      		mov	m,a
0434  23      		inx	h
0435  0D      		dcr	c
0436          		jrnz	z47$rd1
0436  20F8    		DB	20H,z47$rd1-$-1
0438  05      		dcr	b
0439          		jrnz	z47$rd0
0439  20F3    		DB	20H,z47$rd0-$-1
043B  C9      		ret
		
		; ROM start point - initialize everything
043C          	init:
			; find amount of RAM
043C  21001F  		lxi	h,ramstart-0100h
043F          	ramsiz:
043F  24      		inr	h
0440  7E      		mov	a,m
0441  34      		inr	m
0442  BE      		cmp	m
0443  77      		mov	m,a
0444          		jrnz	ramsiz
0444  20F9    		DB	20H,ramsiz-$-1
0446  2B      		dcx	h
0447  F9      		sphl		; set SP to top of RAM (-1)
0448  E5      		push	h	; save top on stack
0449  21E100  		lxi	h,re$entry
044C  E5      		push	h
			; determine H19 BAUD, by experimentation
044D  0E03    		mvi	c,003h	; br38400
044F          	baud0:
044F  3E83    		mvi	a,083h
0451  D3EB    		out	0ebh
0453  AF      		xra	a
0454  D3E9    		out	0e9h
0456  79      		mov	a,c
0457  D3E8    		out	0e8h
0459  07      		rlc
045A  4F      		mov	c,a
045B  3E03    		mvi	a,003h
045D  D3EB    		out	0ebh
045F  AF      		xra	a
0460  D3E9    		out	0e9h
0462  DBE8    		in	0e8h
0464  21FD04  		lxi	h,initms	; ask H19 for response...
0467  CD3406  		call	msgout
046A  0619    		mvi	b,25	; loop 6400 times... let Rx overrun...
046C          	baud1:
046C  3D      		dcr	a
046D          		jrnz	baud1	; 4096 cycles each
046D  20FD    		DB	20H,baud1-$-1
046F          		djnz	baud1	; +13 * 25... 102725 cycles, about 50mS
046F  10FB    		DB	10H,baud1-$-1
0471  DBED    		in	0edh
0473  1F      		rar
0474  DBE8    		in	0e8h
0476  17      		ral
0477  D697    		sui	097h
0479          		jrnz	baud0
0479  20D4    		DB	20H,baud0-$-1
047B  23      		inx	h
047C  CD3406  		call	msgout
047F  060F    		mvi	b,15	; 15*256 = 3840 loops
0481          	baud2:
0481  3D      		dcr	a
0482          		jrnz	baud2
0482  20FD    		DB	20H,baud2-$-1
0484          		djnz	baud2
0484  10FB    		DB	10H,baud2-$-1
0486  3E0F    		mvi	a,00001111b	; all outputs ON
0488  D3EC    		out	0ech		; OUT2=1 hides 16C2550 intr enable diff
			; compute checksum, compare
048A  010000  		lxi	b,rombeg
048D          		exx
048D  D9      		DB	0D9H
048E  11FC0F  		lxi	d,romend-rombeg
0491  210000  		lxi	h,0
0494  0600    		mvi	b,0
0496          	cksum0:
0496          		exx
0496  D9      		DB	0D9H
0497  0A      		ldax	b
0498  03      		inx	b
0499          		exx
0499  D9      		DB	0D9H
049A  4F      		mov	c,a
049B  09      		dad	b
049C  1B      		dcx	d
049D  7A      		mov	a,d
049E  B3      		ora	e
049F  C29604  		jnz	cksum0
04A2          		lded	chksum
04A2  ED5B    		DB	0EDH,5BH
04A4  FE0F    		DW	chksum
04A6          		dsbc	d
04A6  ED52    		DB	0EDH,d*8+42H
04A8  CAB304  		jz	rom$ok
04AB  21E80F  		lxi	h,erprom
04AE          	msg$die:
04AE  CD3406  		call	msgout
04B1  F3      		di
04B2  76      		hlt
04B3          	rom$ok:
04B3  AF      		xra	a
04B4  325321  		sta	l2153h
04B7  323620  		sta	ctl$F2	; 2mS, Org0 OFF
04BA  3EC9    		mvi	a,0c9h	; RET
04BC  320420  		sta	l2004h
04BF  210050  		lxi	h,05000h	; 0, (beep, 2mS, !MON, !SI)
04C2  220820  		shld	l2008h
04C5  CF      		rst	1	; kick-start clock
04C6  211B20  		lxi	h,ticcnt
04C9  11C800  		lxi	d,0280h-440	; tuned to produce ~0x280 for 2.048MHz
04CC  7E      		mov	a,m
04CD          	tick0:	; wait for next tick of clock...
04CD  BE      		cmp	m
04CE          		jrz	tick0
04CE  28FD    		DB	28H,tick0-$-1
04D0  C605    		adi	5	; +10mS (actually, +8mS from new tick)
04D2          	tick1:
04D2  13      		inx	d	; count CPU cycles for 8mS...
04D3  BE      		cmp	m	; but note: 2mS interrupt overhead,
04D4  BE      		cmp	m	; so count will be low.
04D5          		jrnz	tick1	; each loop = 32 cycles
04D5  20FB    		DB	20H,tick1-$-1
04D7  7A      		mov	a,d
04D8  FE02    		cpi	2	; min 9984 cycles... 1.248MHz...
					; max 18144 cycles... 2.268MHz
04DA          		jrz	intsetup
04DA  2806    		DB	28H,intsetup-$-1
			; Unsupported CPU speed...
04DC  210905  		lxi	h,unsupm
04DF  CD3406  		call	msgout
		
04E2          	intsetup:
04E2  E3      		xthl
04E3  D5      		push	d
04E4  C5      		push	b
04E5  F5      		push	psw
04E6  EB      		xchg
04E7  210A00  		lxi	h,10
04EA  39      		dad	sp
04EB  E5      		push	h
04EC  D5      		push	d
04ED  110920  		lxi	d,ctl$F0
04F0  1A      		ldax	d
04F1  2F      		cma
04F2  E630    		ani	030h
04F4  C8      		rz
04F5  210200  		lxi	h,2
04F8  39      		dad	sp
04F9  221D20  		shld	monstk
04FC  C9      		ret
		
04FD  801B5B3F	initms:	db	080h,ESC,'[?2h',ESC,'Z',TRM
      32681B5A
      00
0506  1B7A00  		db	ESC,'z',TRM
		
0509  556E7375	unsupm:	db	'Unsupp CPU speed',TRM
      70702043
      50552073
      70656564
      00
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Substitute command
051A          	cmdsub:
051A  213B00  		lxi	h,subms
051D  CD3406  		call	msgout
0520  210320  		lxi	h,l2003h
0523  160D    		mvi	d,CR
0525  CD9905  		call	adrin
0528  EB      		xchg
0529          	cmdsub0:
0529  CDE105  		call	adrnl
052C  7E      		mov	a,m
052D  CDF005  		call	hexout
0530  CDEC05  		call	spout
0533          	cmdsub1:
0533  CDCE05  		call	hexin
0536          		jrnc	cmdsub4
0536  3019    		DB	30H,cmdsub4-$-1
0538  FE0D    		cpi	CR
053A          		jrz	cmdsub2
053A  280C    		DB	28H,cmdsub2-$-1
053C  FE2D    		cpi	'-'
053E          		jrz	cmdsub3
053E  280B    		DB	28H,cmdsub3-$-1
0540  FE2E    		cpi	'.'
0542  C8      		rz
0543  CD8C05  		call	belout
0546          		jr	cmdsub1
0546  18EB    		DB	18H,cmdsub1-$-1
0548          	cmdsub2:
0548  23      		inx	h
0549          		jr	cmdsub0
0549  18DE    		DB	18H,cmdsub0-$-1
054B          	cmdsub3:
054B  CD8E05  		call	conout
054E  2B      		dcx	h
054F          		jr	cmdsub0
054F  18D8    		DB	18H,cmdsub0-$-1
0551          	cmdsub4:
0551  3600    		mvi	m,000h
0553          	cmdsub5:
0553  CD8E05  		call	conout
0556  CDC505  		call	hexbin
0559          		rld
0559  ED6F    		DB	0EDH, 6FH
055B  CD6205  		call	inhexcr
055E          		jrnc	cmdsub2
055E  30E8    		DB	30H,cmdsub2-$-1
0560          		jr	cmdsub5
0560  18F1    		DB	18H,cmdsub5-$-1
		
0562          	inhexcr:
0562  CD7D05  		call	conin
0565  FE0D    		cpi	CR
0567  C8      		rz
0568  CDD105  		call	hexchk
056B  3F      		cmc
056C  D8      		rc
056D  CD8C05  		call	belout
0570          		jr	inhexcr
0570  18F0    		DB	18H,inhexcr-$-1
		
		; This loop checks for auto boot while waiting for command input.
		; Theoretically, one could flip the auto-boot dipsw at the MMS: prompt?
0572          	coninx0:
0572  CDCC01  		call	chkauto
0575  CDE607  		call	nulfn	; some patched-out code?
0578          	coninx:
0578  DBED    		in	0edh
057A  0F      		rrc
057B          		jrnc	coninx0
057B  30F5    		DB	30H,coninx0-$-1
057D          	conin:
057D  DBED    		in	0edh
057F  0F      		rrc
0580          		jrnc	conin
0580  30FB    		DB	30H,conin-$-1
0582  DBE8    		in	0e8h
0584  E67F    		ani	07fh
0586  FE7F    		cpi	DEL	; DEL key restarts from anywhere?
0588  CAE100  		jz	re$entry
058B  C9      		ret
		
058C          	belout:
058C  3E07    		mvi	a,BEL
058E          	conout:
058E  F5      		push	psw
058F          	conot1:
058F  DBED    		in	0edh
0591  E620    		ani	00100000b
0593          		jrz	conot1
0593  28FA    		DB	28H,conot1-$-1
0595  F1      		pop	psw
0596  D3E8    		out	0e8h
0598  C9      		ret
		
		; D=term char (e.g. '.' for Substitute)
		; HL=location to store address
0599          	adrin:
0599  E5      		push	h
059A  210000  		lxi	h,0
059D          	adrin0:
059D  D47D05  		cnc	conin
05A0  CDD105  		call	hexchk
05A3          		jrc	adrin1
05A3  380E    		DB	38H,adrin1-$-1
05A5  CD8E05  		call	conout
05A8  CDC505  		call	hexbin
05AB  29      		dad	h
05AC  29      		dad	h
05AD  29      		dad	h
05AE  29      		dad	h
05AF  B5      		ora	l
05B0  6F      		mov	l,a
05B1          		jr	adrin0
05B1  18EA    		DB	18H,adrin0-$-1
05B3          	adrin1:
05B3  BA      		cmp	d
05B4          		jrz	adrin2
05B4  2806    		DB	28H,adrin2-$-1
05B6  CD8C05  		call	belout
05B9  B7      		ora	a
05BA          		jr	adrin0
05BA  18E1    		DB	18H,adrin0-$-1
05BC          	adrin2:
05BC  CD8E05  		call	conout
05BF  EB      		xchg
05C0  E1      		pop	h
05C1  72      		mov	m,d
05C2  2B      		dcx	h
05C3  73      		mov	m,e
05C4  C9      		ret
		
05C5          	hexbin:
05C5  D63A    		sui	'9'+1
05C7          		jrnc	hexbi0
05C7  3002    		DB	30H,hexbi0-$-1
05C9  C607    		adi	7
05CB          	hexbi0:
05CB  C603    		adi	3
05CD  C9      		ret
		
05CE          	hexin:
05CE  CD7D05  		call	conin
05D1          	hexchk:
05D1  FE30    		cpi	'0'
05D3  D8      		rc	
05D4  FE3A    		cpi	'9'+1
05D6  3F      		cmc
05D7  D0      		rnc
05D8  E65F    		ani	05fh	; toupper
05DA  FE41    		cpi	'A'
05DC  D8      		rc	
05DD  FE47    		cpi	'F'+1
05DF  3F      		cmc
05E0  C9      		ret
		
05E1          	adrnl:
05E1  CD2A06  		call	crlf
05E4          	adrout:
05E4  7C      		mov	a,h
05E5  CDF005  		call	hexout
05E8  7D      		mov	a,l
05E9  CDF005  		call	hexout
05EC          	spout:
05EC  3E20    		mvi	a,' '
05EE          		jr	conout
05EE  189E    		DB	18H,conout-$-1
		
05F0          	hexout:
05F0  F5      		push	psw
05F1  07      		rlc
05F2  07      		rlc
05F3  07      		rlc
05F4  07      		rlc
05F5  CDF905  		call	hexdig
05F8  F1      		pop	psw
05F9          	hexdig:
05F9  E60F    		ani	00fh
05FB  C690    		adi	090h
05FD  27      		daa
05FE  CE40    		aci	040h
0600  27      		daa
0601          		jr	conout
0601  188B    		DB	18H,conout-$-1
		
0603  07436B73	cserms:	db	BEL,'Cksum error',TRM
      756D2065
      72726F72
      00
		
		; Special entry points expected by HDOS, or maybe Heath CP/M boot.
			rept	0613h-$
0610  00      		db	0
0611  00      		db	0
0612  00      		db	0
0000          	if	($ <> 0613h)
		endif
0613  C3F903  		jmp	z47$dato ; Must be at 0613
0616  00      		db	0
0617  C3FD03  		jmp	z47$cmdo ; Must be at 0617
		
		; Heath/Zenith device boot table
061A          	bootb1:
061A  4200    		db	'B',0	; Z17
061C  432E    		db	'C',46	; Z37
061E  4405    		db	'D',5	; Z47
0620  4503    		db	'E',3	; Z67
0622  00      		db	0
		
0623          	waitcr:
0623  CD7D05  		call	conin
0626  FE0D    		cpi	CR
0628          		jrnz	waitcr
0628  20F9    		DB	20H,waitcr-$-1
062A          	crlf:
062A  3E0D    		mvi	a,CR
062C  CD8E05  		call	conout
062F  3E0A    		mvi	a,LF
0631  C38E05  		jmp	conout
		
0634          	msgout:
0634  7E      		mov	a,m
0635  B7      		ora	a
0636  C8      		rz
0637  CD8E05  		call	conout
063A  23      		inx	h
063B          		jr	msgout
063B  18F7    		DB	18H,msgout-$-1
		
063D          	cserr:
063D  210306  		lxi	h,cserms
0640          		jr	msgout
0640  18F2    		DB	18H,msgout-$-1
		
0642  546F7020	topms:	db	'Top of Mem: ',TRM
      6F66204D
      656D3A20
      00
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Memory Test command
064F          	cmdmt:
064F  215300  		lxi	h,mtms
0652  CD3406  		call	msgout
0655  CD2306  		call	waitcr
0658  214206  		lxi	h,topms
065B  CD3406  		call	msgout
065E  210000  		lxi	h,0
0661  39      		dad	sp
0662  7C      		mov	a,h
0663  3C      		inr	a
0664          		jrz	cmdmt0
0664  2802    		DB	28H,cmdmt0-$-1
0666  D620    		sui	020h
0668          	cmdmt0:
0668  67      		mov	h,a
0669  2E00    		mvi	l,0
066B  2B      		dcx	h
066C  D630    		sui	'0'
066E  5F      		mov	e,a
066F  CDE405  		call	adrout
0672  CD2A06  		call	crlf
0675  1600    		mvi	d,000h
0677  0E30    		mvi	c,030h
0679  0600    		mvi	b,000h
067B          		exx
067B  D9      		DB	0D9H
067C  21A706  		lxi	h,mtest0
067F  11F12F  		lxi	d,memtest - (mtest1-mtest0)
0682  01FB00  		lxi	b,mtestZ-mtest0
0685          		ldir
0685  EDB0    		DB	0EDH,0B0H
0687  110030  		lxi	d,memtest
068A  21B606  		lxi	h,mtest1
068D  0EEC    		mvi	c,mtestZ-mtest1
068F  AF      		xra	a
0690          		exaf
0690  08      		DB	08H
0691  AF      		xra	a
0692          	cmdmt1:
0692  86      		add	m
0693          		exaf
0693  08      		DB	08H
0694  EB      		xchg
0695  86      		add	m
0696          		exaf
0696  08      		DB	08H
0697  EB      		xchg
0698  23      		inx	h
0699  13      		inx	d
069A  0D      		dcr	c
069B          		jrnz	cmdmt1
069B  20F5    		DB	20H,cmdmt1-$-1
069D  4F      		mov	c,a
069E          		exaf
069E  08      		DB	08H
069F  B9      		cmp	c
06A0  C23D06  		jnz	cserr
06A3  F3      		di
06A4  C3F82F  		jmp	memtest - (mtest1-mtest)
		
		;------------------------------------------------
		; Start of relocated code...
		; Memory Test routine, position-endependent
		;
06A7  040C0408	mtest0:	db	04h,0ch,04h,08h,0ch,08h,20h
      0C0820
		
06AE          	mtest:
06AE  21F12F  		lxi	h,memtest - (mtest1-mtest0)
06B1  01F207  		lxi	b,0700h + 0f2h	; length of unlock sequence, GPIO port
06B4          		outir
06B4  EDB3    		DB	0EDH,0B3H
06B6          	mtest1:		; lands at 03000h - retained relocated code
06B6          		exx
06B6  D9      		DB	0D9H
06B7  62      		mov	h,d
06B8  2E00    		mvi	l,0
06BA  78      		mov	a,b
06BB          		exx
06BB  D9      		DB	0D9H
06BC  4F      		mov	c,a
06BD  0602    		mvi	b,2
06BF          	mtest2:
06BF  79      		mov	a,c
06C0  07      		rlc
06C1  07      		rlc
06C2  07      		rlc
06C3  07      		rlc
06C4  4F      		mov	c,a
06C5  E60F    		ani	00fh
06C7  C690    		adi	090h
06C9  27      		daa
06CA  CE40    		aci	040h
06CC  27      		daa
06CD  D3E8    		out	0e8h
06CF          	mtest3:
06CF  DBED    		in	0edh
06D1  E620    		ani	020h
06D3          		jrz	mtest3
06D3  28FA    		DB	28H,mtest3-$-1
06D5  05      		dcr	b
06D6          		jrnz	mtest2
06D6  20E7    		DB	20H,mtest2-$-1
06D8  3E0D    		mvi	a,CR
06DA  D3E8    		out	0e8h
06DC          		exx
06DC  D9      		DB	0D9H
06DD  78      		mov	a,b
06DE          	mtest4:
06DE  77      		mov	m,a
06DF  C601    		adi	1
06E1  27      		daa
06E2  2C      		inr	l
06E3          		jrnz	mtest4
06E3  20F9    		DB	20H,mtest4-$-1
06E5  24      		inr	h
06E6  0D      		dcr	c
06E7          		jrnz	mtest4
06E7  20F5    		DB	20H,mtest4-$-1
06E9  7C      		mov	a,h
06EA  92      		sub	d
06EB  4F      		mov	c,a
06EC  62      		mov	h,d
06ED  2E00    		mvi	l,0
06EF  78      		mov	a,b
06F0          	mtest5:
06F0  BE      		cmp	m
06F1          		jrnz	mtest9
06F1  2046    		DB	20H,mtest9-$-1
06F3  C601    		adi	1
06F5  27      		daa
06F6  2C      		inr	l
06F7          		jrnz	mtest5
06F7  20F7    		DB	20H,mtest5-$-1
06F9  24      		inr	h
06FA  0D      		dcr	c
06FB          		jrnz	mtest5
06FB  20F3    		DB	20H,mtest5-$-1
06FD          		exx
06FD  D9      		DB	0D9H
06FE  210030  		lxi	h,memtest
0701  110000  		lxi	d,0
0704  01EC00  		lxi	b,mtestZ-mtest1
0707          		exx
0707  D9      		DB	0D9H
0708  7A      		mov	a,d
0709  EE30    		xri	030h
070B  57      		mov	d,a
070C          		jrz	mtest6
070C  2803    		DB	28H,mtest6-$-1
070E  4B      		mov	c,e
070F          		jr	mtest7
070F  180A    		DB	18H,mtest7-$-1
0711          	mtest6:
0711  0E30    		mvi	c,030h
0713  3E01    		mvi	a,001h
0715  80      		add	b
0716  27      		daa
0717  47      		mov	b,a
0718          		exx
0718  D9      		DB	0D9H
0719  EB      		xchg
071A          		exx
071A  D9      		DB	0D9H
071B          	mtest7:
071B          		exx
071B  D9      		DB	0D9H
071C          		ldir
071C  EDB0    		DB	0EDH,0B0H
071E  7A      		mov	a,d
071F  E6F0    		ani	0f0h
0721  67      		mov	h,a
0722  2E00    		mvi	l,0
0724  0EEC    		mvi	c,mtestZ-mtest1
0726  AF      		xra	a
0727          	mtest8:
0727  86      		add	m
0728  23      		inx	h
0729  0D      		dcr	c
072A          		jrnz	mtest8
072A  20FB    		DB	20H,mtest8-$-1
072C  4F      		mov	c,a
072D          		exaf
072D  08      		DB	08H
072E  B9      		cmp	c
072F          		jrnz	mtestE
072F  2049    		DB	20H,mtestE-$-1
0731          		exaf
0731  08      		DB	08H
0732  7A      		mov	a,d
0733  E6F0    		ani	0f0h
0735  67      		mov	h,a
0736  2E00    		mvi	l,0
0738  E9      		pchl
0739          	mtest9:
0739  AE      		xra	m
073A  57      		mov	d,a
073B  3E0A    		mvi	a,LF
073D  D3E8    		out	0e8h
073F          	mtestA:
073F  DBED    		in	0edh
0741  E620    		ani	020h
0743          		jrz	mtestA
0743  28FA    		DB	28H,mtestA-$-1
0745  0E02    		mvi	c,2
0747  0604    		mvi	b,4
0749          	mtestB:
0749  7C      		mov	a,h
074A  07      		rlc
074B  07      		rlc
074C  07      		rlc
074D  07      		rlc
074E  E60F    		ani	00fh
0750  C690    		adi	090h
0752  27      		daa
0753  CE40    		aci	040h
0755  27      		daa
0756  D3E8    		out	0e8h
0758          	mtestC:
0758  DBED    		in	0edh
075A  E620    		ani	020h
075C          		jrz	mtestC
075C  28FA    		DB	28H,mtestC-$-1
075E  29      		dad	h
075F  29      		dad	h
0760  29      		dad	h
0761  29      		dad	h
0762          		djnz	mtestB
0762  10E5    		DB	10H,mtestB-$-1
0764  3E20    		mvi	a,' '
0766  D3E8    		out	0e8h
0768          	mtestD:
0768  DBED    		in	0edh
076A  E620    		ani	020h
076C          		jrz	mtestD
076C  28FA    		DB	28H,mtestD-$-1
076E  0D      		dcr	c
076F  EB      		xchg
0770  0602    		mvi	b,002h
0772          		jrnz	mtestB
0772  20D5    		DB	20H,mtestB-$-1
0774  3E2A    		mvi	a,'*'
0776  D3E8    		out	0e8h
0778          		jr	mtestG
0778  1814    		DB	18H,mtestG-$-1
077A          	mtestE:
077A  DBED    		in	0edh
077C  E620    		ani	020h
077E          		jrz	mtestE
077E  28FA    		DB	28H,mtestE-$-1
0780  3E0A    		mvi	a,LF
0782  D3E8    		out	0e8h
0784          	mtestF:
0784  DBED    		in	0edh
0786  E620    		ani	020h
0788          		jrz	mtestF
0788  28FA    		DB	28H,mtestF-$-1
078A  3E21    		mvi	a,'!'
078C  D3E8    		out	0e8h
078E          	mtestG:
078E  DBED    		in	0edh
0790  E620    		ani	020h
0792          		jrz	mtestG
0792  28FA    		DB	28H,mtestG-$-1
0794  AF      		xra	a
0795  06FA    		mvi	b,0fah
0797          	mtestH:
0797  3D      		dcr	a
0798          		jrnz	mtestH
0798  20FD    		DB	20H,mtestH-$-1
079A          		djnz	mtestH
079A  10FB    		DB	10H,mtestH-$-1
079C  3E07    		mvi	a,BEL
079E  D3E8    		out	0e8h
07A0          		jr	mtestG
07A0  18EC    		DB	18H,mtestG-$-1
		; End of relocated code
07A2          	mtestZ	equ	$
		;------------------------------------------------
		
		; returns with interrupts disabled
07A2          	h17init:
07A2  F3      		di
07A3  AF      		xra	a
07A4  D37F    		out	07fh
07A6  D5      		push	d
07A7  210920  		lxi	h,ctl$F0
07AA  36D0    		mvi	m,0d0h	; !beep, 2mS, !mon, !SI
07AC  215A1F  		lxi	h,R$CONST
07AF  114820  		lxi	d,D$CONST
07B2  015800  		lxi	b,88
07B5          		ldir
07B5  EDB0    		DB	0EDH,0B0H
07B7  6B      		mov	l,e
07B8  62      		mov	h,d
07B9  13      		inx	d
07BA  0E1E    		mvi	c,30
07BC  77      		mov	m,a
07BD          		ldir	; fill l20a0h...
07BD  EDB0    		DB	0EDH,0B0H
07BF  3C      		inr	a	; A=1
07C0  211F20  		lxi	h,intvec	; vector area
07C3          	h17ini0:
07C3  36C3    		mvi	m,0c3h
07C5  23      		inx	h
07C6  36B7    		mvi	m,LOW (nulint-rst0)
07C8  23      		inx	h
07C9  3600    		mvi	m,HIGH (nulint-rst0)
07CB  23      		inx	h
07CC  87      		add	a	; shift left, count 7
07CD  F2C307  		jp	h17ini0
07D0  D1      		pop	d
07D1  C9      		ret
		
07D2  0D0A4D4D	prompt:	db	CR,LF,'MMS: ',TRM
      533A2000
07DA  28632920		db	'(c) 1982 MMS'
      31393832
      204D4D53
		
07E6          	nulfn:
07E6  C9      		ret
		
07E7          	xcmds:
07E7  79      		mov	a,c
0000          	if terminal
		endif
07E8  FE52    		cpi	'R'	; set baud Rate
07EA  CAC40E  		jz	setbr
07ED  FE56    		cpi	'V'	; eprom Version
07EF  CAD00F  		jz	prtver
07F2  C9      		ret
		
		; D=Phys Drive base, E=Unit
		; (or D=Phys Drive unit, E=0)
07F3          	exboot:
0000          	if remex
		endif
07F3  214C08  		lxi	h,devtbl
07F6          	exboot1:
07F6  7A      		mov	a,d
07F7  96      		sub	m
07F8  23      		inx	h
07F9  BE      		cmp	m
07FA          		jrc	exboot2
07FA  3808    		DB	38H,exboot2-$-1
07FC  7E      		mov	a,m
07FD  23      		inx	h
07FE  23      		inx	h
07FF  23      		inx	h
0800  B7      		ora	a
0801          		jrnz	exboot1
0801  20F3    		DB	20H,exboot1-$-1
0803  C9      		ret
		
0804          	exboot2:	; found device, jump to handler
0804  23      		inx	h
0805  4E      		mov	c,m
0806  23      		inx	h
0807  66      		mov	h,m
0808  69      		mov	l,c
0809  83      		add	e
080A  E9      		pchl
		
		; Returns NZ if found, D=phy drv
080B          	gtdvtb:
080B  DBF2    		in	0f2h
080D  E670    		ani	01110000b	; default boot device
080F  07      		rlc
0810  07      		rlc
0811  07      		rlc
0812  07      		rlc
0813  218608  		lxi	h,defbt
0816          	gtdvtb0:
0816  85      		add	l
0817  6F      		mov	l,a
0818  3E00    		mvi	a,0
081A  8C      		adc	h
081B  67      		mov	h,a
081C  7E      		mov	a,m
081D  FEFF    		cpi	0ffh
081F  C8      		rz	; no device
0820  FEFE    		cpi	0feh
0822          		jrz	gtdvtb1	; extended dipsw
0822  2802    		DB	28H,gtdvtb1-$-1
0824  57      		mov	d,a
0825  C9      		ret	; NZ
		
0826          	gtdvtb1:
0826  DB5C    		in	05ch
0828  E6E0    		ani	11100000b	; device
082A  07      		rlc
082B  07      		rlc
082C  07      		rlc
082D  218E08  		lxi	h,auxbt
0830  CD1608  		call	gtdvtb0
0833  C8      		rz	; no device
0834  DB5C    		in	05ch
0836  E61C    		ani	00011100b	; LUN
0838  0F      		rrc
0839  0F      		rrc
083A  5F      		mov	e,a	; D=phy drv, E=LUN
083B  C9      		ret
		
		; lookup letter in MMS table
083C          	mmslookup:
083C  219608  		lxi	h,bootb2
083F          	mmslk0:
083F  7E      		mov	a,m
0840  23      		inx	h
0841  56      		mov	d,m
0842  23      		inx	h
0843  B8      		cmp	b
0844  C8      		rz
0845  B7      		ora	a
0846          		jrnz	mmslk0
0846  20F7    		DB	20H,mmslk0-$-1
0848  1600    		mvi	d,0
084A  37      		stc
084B  C9      		ret
		
		; disk device/drive table by phy drv
084C          	devtbl:
084C  0302    		db	3,2
084E  240A    		dw	bz67
0000          	if remex
		endif
0000          	if corvus
		endif
0850  1D08    		db	29,8
0852  B108    		dw	bm316
0000          	if xcomp
		endif
0854  2801    		db	40,1
0856  070B    		dw	bm318
0858  2E04    		db	46,4
085A  2D09    		dw	bz37
0000          	if mms422
		endif
FFFF          	if wiznet
085C  3C01    		db	60,1
085E  2F0C    		dw	bwiznet
		endif
FFFF          	if gide
0860  4609    		db	70,9
0862  BC09    		dw	bgide
		endif
0864  A804    		db	168,4
0866  140A    		dw	bm320
0868  AC04    		db	172,4
086A  140A    		dw	bm320
086C  B004    		db	176,4
086E  140A    		dw	bm320
0870  B404    		db	180,4
0872  140A    		dw	bm320
0874  B804    		db	184,4
0876  140A    		dw	bm320
0878  BC04    		db	188,4
087A  140A    		dw	bm320
087C  C004    		db	192,4
087E  140A    		dw	bm320
0880  C404    		db	196,4
0882  140A    		dw	bm320
0884  0000    		dw	0
		
0886          	defbt:	; default boot table... port F2 bits 01110000b
0886  21      		db	33	; -000---- MMS 5" floppy 0
0887  1D      		db	29	; -001---- MMS 8" floppy 0
0888  FF      		db	0ffh	; -010---- n/a  (port 7CH)
0889  FF      		db	0ffh	; -011---- n/a  (port 78H)
088A  FF      		db	0ffh	; -100---- none
FFFF          	if gide
088B  46      		db	70	; -101---- GIDE disk part 0
		else
		endif
088C  3C      		db	60	; -110---- Network
088D  FE      		db	0feh	; -111---- redirect to I/O board dipsw
		
088E          	auxbt:	; default boot redirect (aux dipsw) bits 11100000b
0000          	if corvus
		else
088E  FF      		db	0ffh	; 000----- none (was MMS 77314 Corvus)
		endif
0000          	if remex
		else
088F  FF      		db	0ffh	; 001----- none (was MMS 77314 REMEX (Z47))
		endif
0890  FF      		db	0ffh	; 010----- none
0000          	if xcomp
		else
0891  FF      		db	0ffh	; 011----- none
		endif
0892  3C      		db	60	; 100----- Network
0893  A8      		db	168	; 101----- MMS 77320 SASI
FFFF          	if gide
0894  46      		db	70	; 110----- GIDE disk
		else
		endif
0895  FF      		db	0ffh	; 111----- none
		
0896          	bootb2:
0000          	if remex
		endif
0000          	if corvus
		endif
0896  491D    		db	'I',29		; MMS 77316 8"
0898  4A21    		db	'J',33		; MMS 77316 5"
0000          	if xcomp
		endif
089A  4D28    		db	'M',40		; MMS 77318 RAM-disk
0000          	if mms422
		endif
089C  4FA8    		db	'O',168		; SASI ctrl 0
089E  50AC    		db	'P',172		; SASI ctrl 1
08A0  51B0    		db	'Q',176		; SASI ctrl 2
08A2  52B4    		db	'R',180		; SASI ctrl 3
08A4  53B8    		db	'S',184		; SASI ctrl 4
08A6  54BC    		db	'T',188		; SASI ctrl 5
08A8  55C0    		db	'U',192		; SASI ctrl 6
08AA  56C4    		db	'V',196		; SASI ctrl 7
FFFF          	if wiznet
08AC  573C    		db	'W',60		; WIZNET Network
		endif
FFFF          	if gide
08AE  5846    		db	'X',70		; GIDE ctrl/disk
		endif
08B0  00      		db	0
		
0000          	if corvus
		endif
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77316 Floppy boot
08B1          	bm316:
08B1  212809  		lxi	h,int316
08B4  222F20  		shld	vrst6+1
08B7  FE08    		cpi	008h
08B9  D0      		rnc
08BA  F628    		ori	028h
08BC  57      		mov	d,a
08BD  D338    		out	038h
08BF  AF      		xra	a
08C0  D3F2    		out	0f2h	; 2mS intr off
08C2  3E0B    		mvi	a,00bh	; home/restore to track 0
08C4  CD2309  		call	cmd316
08C7  0108CF  		lxi	b,53000
08CA          	bm316$0:
08CA  DB3C    		in	03ch
08CC  07      		rlc
08CD          		jrnc	bm316$1
08CD  3005    		DB	30H,bm316$1-$-1
08CF  0B      		dcx	b
08D0  78      		mov	a,b
08D1  B1      		ora	c
08D2          		jrnz	bm316$0
08D2  20F6    		DB	20H,bm316$0-$-1
08D4          	bm316$1:
08D4  DB3C    		in	03ch
08D6  E699    		ani	099h
08D8  C0      		rnz
08D9  1E19    		mvi	e,019h
08DB          	bm316$2:
08DB  218022  		lxi	h,bootbf
08DE  AF      		xra	a
08DF          	bm316$3:
08DF  3C      		inr	a
08E0  D33E    		out	03eh
08E2  013F00  		lxi	b,003fh
08E5  3E88    		mvi	a,088h
08E7  CD0109  		call	rd316
08EA  E6BF    		ani	0bfh
08EC  7A      		mov	a,d
08ED  D338    		out	038h
08EF          		jrz	bm316$4
08EF  2807    		DB	28H,bm316$4-$-1
08F1  EE40    		xri	040h
08F3  57      		mov	d,a
08F4  1D      		dcr	e
08F5          		jrnz	bm316$2
08F5  20E4    		DB	20H,bm316$2-$-1
08F7  C9      		ret
08F8          	bm316$4:
08F8  DB3E    		in	03eh
08FA  FE02    		cpi	002h
08FC          		jrc	bm316$3
08FC  38E1    		DB	38H,bm316$3-$-1
08FE  C3F203  		jmp	hwboot
		
0901          	rd316:
0901  F5      		push	psw
0902  7A      		mov	a,d
0903  E644    		ani	044h
0905          		jrnz	rd316$5
0905  200F    		DB	20H,rd316$5-$-1
			; 8" DD read special case
0907  7A      		mov	a,d
0908  E6DF    		ani	0dfh
090A  D338    		out	038h
090C  F1      		pop	psw
090D  D33C    		out	03ch
090F  FB      		ei
0910  76      		hlt	; wait for first byte
0911          	rd316$8: ini
0911  EDA2    		DB	0EDH,0A2H
0913  C31109  		jmp	rd316$8
		
0916          	rd316$5:
0916  7A      		mov	a,d
0917  D338    		out	038h
0919  F1      		pop	psw
091A  D33C    		out	03ch
091C  FB      	hlt$ini: ei
091D  76      	rd316$0: hlt
091E          		ini
091E  EDA2    		DB	0EDH,0A2H
0920  C31D09  		jmp	rd316$0
		
0923          	cmd316:
0923  D33C    		out	03ch
0925  FB      	ei$spin: ei
0926          		jr	$-1	; wait for intr to break us out
0926  18FE    		DB	18H,$-1-$-1
		
0928  F1      	int316:	pop	psw
0929  DB3C    		in	03ch
092B  FB      		ei
092C  C9      		ret
		
092D          	bz37:
092D  21B309  		lxi	h,intz37
0930  222920  		shld	vrst4+1
0933  2B      		dcx	h
0934  223720  		shld	l2037h
0937  FE04    		cpi	004h
0939  D0      		rnc
093A  3C      		inr	a
093B  2E08    		mvi	l,008h
093D          	bz37$0:
093D  29      		dad	h
093E  3D      		dcr	a
093F          		jrnz	bz37$0
093F  20FC    		DB	20H,bz37$0-$-1
0941  D379    		out	079h
0943  DBF2    		in	0f2h
0945  E60C    		ani	00ch
0947  C0      		rnz
0948  3E78    		mvi	a,078h
094A  325021  		sta	cport
094D  3ED0    		mvi	a,0d0h
094F  D37A    		out	07ah
0951  7D      		mov	a,l
0952  F608    		ori	008h
0954  57      		mov	d,a
0955  D378    		out	078h
0957  14      		inr	d
0958  1E19    		mvi	e,019h
095A  3E05    		mvi	a,5
095C  CD8F01  		call	take$A
095F  017B14  		lxi	b,0147bh	; mask, port
0962          	bz37$1:
0962  DB7A    		in	07ah
0964  A8      		xra	b
0965  E602    		ani	002h
0967          		jrz	bz37$1
0967  28F9    		DB	28H,bz37$1-$-1
0969          		djnz	bz37$1
0969  10F7    		DB	10H,bz37$1-$-1
096B          	bz37$2:
096B  218022  		lxi	h,bootbf
096E  3E01    		mvi	a,001h
0970  D379    		out	079h
0972  D37A    		out	07ah
0974  7A      		mov	a,d
0975  D378    		out	078h
0977  0604    		mvi	b,004h
0979          	bz37$3:
0979  AF      		xra	a
097A  D379    		out	079h
097C  3E40    		mvi	a,040h
097E  D37A    		out	07ah
0980  CD2509  		call	ei$spin
0983          		djnz	bz37$3
0983  10F4    		DB	10H,bz37$3-$-1
0985  AF      		xra	a
0986  D379    		out	079h
0988  3E0B    		mvi	a,00bh
098A  D37A    		out	07ah
098C  CD2509  		call	ei$spin
098F  7A      		mov	a,d
0990  EE04    		xri	004h
0992  57      		mov	d,a
0993  F602    		ori	002h
0995  D378    		out	078h
0997  3E9C    		mvi	a,09ch
0999  D37A    		out	07ah
099B  CD1C09  		call	hlt$ini
099E  E6EF    		ani	0efh
09A0          		jrnz	bz37$4
09A0  200D    		DB	20H,bz37$4-$-1
09A2  7C      		mov	a,h
09A3  FE2C    		cpi	02ch
09A5          		jrc	bz37$4
09A5  3808    		DB	38H,bz37$4-$-1
09A7  3E08    		mvi	a,008h
09A9  D378    		out	078h
09AB  E1      		pop	h
09AC  C3F203  		jmp	hwboot
09AF          	bz37$4:
09AF  1D      		dcr	e
09B0          		jrnz	bz37$2
09B0  20B9    		DB	20H,bz37$2-$-1
09B2  C9      		ret
		
09B3  DB7A    	intz37:	in	07ah
09B5  E3      		xthl
09B6  2A3720  		lhld	l2037h
09B9  E3      		xthl
09BA  FB      		ei
09BB  C9      		ret
		
0000          	if xcomp
		endif
		
FFFF          	if gide
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; GIDE HDD boot
09BC          	bgide:
09BC  FE09    		cpi	9 ; 9 partitons, max
09BE  D0      		rnc
			; Partition is passed to bootloader, but we need
			; segment offset before we can start.
09BF  D1      		pop	d	; error return address
09C0  C1      		pop	b	; possible string
09C1  C5      		push	b
09C2  D5      		push	d
			; parse a single letter
09C3  210000  		lxi	h,0	; def segment off
09C6  79      		mov	a,c
09C7  FEC3    		cpi	0c3h	; JMP means no string present
09C9          		jrz	nostr
09C9  280D    		DB	28H,nostr-$-1
09CB  78      		mov	a,b
09CC  B7      		ora	a	; limit to 1 char?
09CD  C0      		rnz
09CE  79      		mov	a,c
09CF  E65F    		ani	5fh
09D1  D641    		sui	'A'	; 000sssss = segment ID
09D3  D8      		rc
09D4  07      		rlc
09D5  07      		rlc
09D6  07      		rlc		; sssss000 = segoff: 0000 sssss000 00000000 00000000
09D7  67      		mov	h,a	; swap for little endian SHLD/LHLD
09D8  225621  	nostr:	shld	l2156h	; l2156h[0]=27:24, l2156h[1]=23:16
09DB  7D      		mov	a,l
09DC  F6E0    		ori	11100000b	; LBA mode + std "1" bits
09DE  D38E    		out	GIDE$DH	; LBA 27:4, drive 0, LBA mode
09E0  7C      		mov	a,h
09E1  D38D    		out	GIDE$CH	; LBA 23:16
09E3  AF      		xra	a
09E4  D38C    		out	GIDE$CL	; LBA 15:8
09E6  D38B    		out	GIDE$SE	; LBA 7:0
09E8  3E0A    		mvi	a,10
09EA  D38A    		out	GIDE$SC	; 10 sectors (standard boot length)
09EC  3E20    		mvi	a,20h	; READ SECTORS
09EE  D38F    		out	GIDE$CS
09F0  218022  		lxi	h,bootbf
09F3  0E88    		mvi	c,GIDE$DA
09F5  1E0A    		mvi	e,10
09F7  0600    		mvi	b,0	; should always be 0 after inir
09F9          	bgide0:
09F9  DB8F    		in	GIDE$CS
09FB          		bit	7,a	; busy
09FB  CB7F    		DB	0CBH,7*8+a+40H
09FD          		jrnz	bgide0
09FD  20FA    		DB	20H,bgide0-$-1
09FF          		bit	0,a	; error
09FF  CB47    		DB	0CBH,0*8+a+40H
0A01  C0      		rnz
0A02          		bit	6,a	; ready
0A02  CB77    		DB	0CBH,6*8+a+40H
0A04  C8      		rz
0A05          		bit	3,a	; DRQ
0A05  CB5F    		DB	0CBH,3*8+a+40H
0A07          		jrz	bgide0
0A07  28F0    		DB	28H,bgide0-$-1
0A09          		inir	; 256 bytes
0A09  EDB2    		DB	0EDH,0B2H
0A0B          		inir	; 512 bytes
0A0B  EDB2    		DB	0EDH,0B2H
0A0D  1D      		dcr	e
0A0E          		jrnz	bgide0
0A0E  20E9    		DB	20H,bgide0-$-1
			; final status check?
0A10  E1      		pop	h	; adj stack for possible string
0A11  C3F203  		jmp	hwboot
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77320 SASI HDD boot
0A14          	bm320:
0A14  FE04    		cpi	4 ; 4 units per controller, max
0A16  D0      		rnc
0A17  5F      		mov	e,a	; relative drive num
0A18  7A      		mov	a,d ; phy drv
0A19  D6A8    		sui	168
0A1B  E6FC    		ani	0fch	; Controller num
0A1D  0F      		rrc
0A1E  0F      		rrc
0A1F  53      		mov	d,e ; D = relative drive num
0A20  5F      		mov	e,a ; E = controller num
0A21  7A      		mov	a,d
0A22          		jr	bsasi
0A22  1805    		DB	18H,bsasi-$-1
		
0A24          	bz67:
0A24  FE02    		cpi	2
0A26  D0      		rnc	
0A27  1E00    		mvi	e,0	; Controller 0 only
0A29          	bsasi:
0A29  0F      		rrc
0A2A  0F      		rrc
0A2B  0F      		rrc
0A2C  DD      		db 0ddh
0A2D  67      		mov h,a	; movxh	a	; 0xx00000 = relative drive num (LUN)
0A2E  0E02    		mvi	c,10b
0A30  CD1402  		call	getport
0A33  C0      		rnz
0A34  78      		mov	a,b
0A35  325021  		sta	cport
0A38  3C      		inr	a
0A39  4F      		mov	c,a
0A3A  AF      		xra	a
0A3B          		outp	a
0A3B  ED79    		DB	0EDH,a*8+41H
0A3D  210000  		lxi	h,0		; zero-out command buffer
0A40  223221  		shld	cmdbuf
0A43  223421  		shld	cmdbuf+2
0A46  223621  		shld	cmdbuf+4
0A49  225621  		shld	l2156h	; zero-out ...
0A4C  225821  		shld	l2156h+2
0A4F  325A21  		sta	l2156h+4
0A52  53      		mov	d,e
0A53  3E04    		mvi	a,4	; delay 8mS, also NZ
0A55  B7      		ora	a
0A56  FB      		ei
0A57          	bsasi0:
0A57  C8      		rz
0A58  CD2B00  		call	delayx
0A5B  1E00    		mvi	e,0	; Test Drive Ready
0A5D  CD7A0A  		call	sasi$cmd
0A60  3EFF    		mvi	a,255	; longer delay on retry...
0A62          		jrc	bsasi0
0A62  38F3    		DB	38H,bsasi0-$-1
0A64  1E01    		mvi	e,1	; Recalibrate (Home)
0A66  CD7A0A  		call	sasi$cmd
0A69  D8      		rc
0A6A  210A80  		lxi	h,0800ah	; 10 sectors, retry
0A6D  223621  		shld	cmdbuf+4
0A70  1E08    		mvi	e,8	; Read
0A72  CD7A0A  		call	sasi$cmd
0A75  D8      		rc
0A76  E1      		pop	h
0A77  C3F203  		jmp	hwboot
		
		; send SASI read command, get results
0A7A          	sasi$cmd:
0A7A  F3      		di
0A7B  DD      		db 0ddh	; undocumented Z80 instruction
0A7C  6B      		mov l,e	; movxl	e	; SASI command
0A7D          		sixd	cmdbuf
0A7D  DD22    		DB	0DDH,22H
0A7F  3221    		DW	cmdbuf
0A81  0600    		mvi	b,0	; wait for "not BUSY" first
0A83  1E06    		mvi	e,6	;
0A85  210000  		lxi	h,0	; 0x060000 loop/timeout count
0A88          	sscmd0:
0A88          		inp	a
0A88  ED78    		DB	0EDH,a*8+40H
0A8A  E608    		ani	00001000b
0A8C  B8      		cmp	b
0A8D          		jrz	sscmd1
0A8D  280A    		DB	28H,sscmd1-$-1
0A8F  2B      		dcx	h
0A90  7D      		mov	a,l
0A91  B4      		ora	h
0A92          		jrnz	sscmd0
0A92  20F4    		DB	20H,sscmd0-$-1
0A94  1D      		dcr	e
0A95          		jrnz	sscmd0
0A95  20F1    		DB	20H,sscmd0-$-1
0A97  37      		stc
0A98  C9      		ret
0A99          	sscmd1:
0A99  78      		mov	a,b
0A9A  EE08    		xri	00001000b	; wait for BUSY
0A9C          		jrz	sscmd2		; got BUSY...
0A9C  2810    		DB	28H,sscmd2-$-1
0A9E  47      		mov	b,a
0A9F  0D      		dcr	c
0AA0  AF      		xra	a
0AA1          		outp	a
0AA1  ED79    		DB	0EDH,a*8+41H
0AA3  0C      		inr	c
0AA4  0C      		inr	c
0AA5          		outp	d
0AA5  ED51    		DB	0EDH,d*8+41H
0AA7  0D      		dcr	c
0AA8  3E40    		mvi	a,040h	; SELECT
0AAA          		outp	a
0AAA  ED79    		DB	0EDH,a*8+41H
0AAC          		jr	sscmd0	; wait for BUSY now...
0AAC  18DA    		DB	18H,sscmd0-$-1
		
0AAE          	sscmd2:
0AAE  3E02    		mvi	a,002h	; enable INTR
0AB0          		outp	a
0AB0  ED79    		DB	0EDH,a*8+41H
0AB2  213221  		lxi	h,cmdbuf
0AB5          	sscmd3:
0AB5          		inp	a
0AB5  ED78    		DB	0EDH,a*8+40H
0AB7          		bit	7,a	; REQ
0AB7  CB7F    		DB	0CBH,7*8+a+40H
0AB9          		jrz	sscmd3
0AB9  28FA    		DB	28H,sscmd3-$-1
0ABB          		bit	4,a	; CMD
0ABB  CB67    		DB	0CBH,4*8+a+40H
0ABD          		jrz	sscmd4
0ABD  280A    		DB	28H,sscmd4-$-1
0ABF          		bit	6,a	; MSG
0ABF  CB77    		DB	0CBH,6*8+a+40H
0AC1          		jrz	sscmd6
0AC1  2819    		DB	28H,sscmd6-$-1
0AC3  0D      		dcr	c
0AC4          		outi		; output command byte
0AC4  EDA3    		DB	0EDH,0A3H
0AC6  0C      		inr	c
0AC7          		jr	sscmd3
0AC7  18EC    		DB	18H,sscmd3-$-1
		
0AC9          	sscmd4:
0AC9  218022  		lxi	h,bootbf
0ACC          	sscmd5:
0ACC          		inp	a
0ACC  ED78    		DB	0EDH,a*8+40H
0ACE          		bit	7,a	; REQ
0ACE  CB7F    		DB	0CBH,7*8+a+40H
0AD0          		jrz	sscmd5
0AD0  28FA    		DB	28H,sscmd5-$-1
0AD2          		bit	4,a	; CMD - indicates data done
0AD2  CB67    		DB	0CBH,4*8+a+40H
0AD4          		jrnz	sscmd6
0AD4  2006    		DB	20H,sscmd6-$-1
0AD6  0D      		dcr	c
0AD7          		ini		; input data byte
0AD7  EDA2    		DB	0EDH,0A2H
0AD9  0C      		inr	c
0ADA          		jr	sscmd5
0ADA  18F0    		DB	18H,sscmd5-$-1
0ADC          	sscmd6:
0ADC          		inp	a
0ADC  ED78    		DB	0EDH,a*8+40H
0ADE  E6D0    		ani	0d0h	; REQ, OUT, CMD
0AE0  FE90    		cpi	090h	; must be REQ, CMD
0AE2          		jrnz	sscmd6	; wait for it...
0AE2  20F8    		DB	20H,sscmd6-$-1
0AE4  0D      		dcr	c
0AE5          		inp	l	; result 0
0AE5  ED68    		DB	0EDH,l*8+40H
0AE7  0C      		inr	c
0AE8          	sscmd7:
0AE8          		inp	h	; status
0AE8  ED60    		DB	0EDH,h*8+40H
0AEA  7C      		mov	a,h
0AEB  E6E0    		ani	0e0h	; REG, OUT, MSG
0AED  FEA0    		cpi	0a0h	; must be REQ, MSG
0AEF          		jrnz	sscmd7
0AEF  20F7    		DB	20H,sscmd7-$-1
0AF1  223821  		shld	resbuf	; command results
0AF4  0D      		dcr	c
0AF5          		inp	a	; last data byte
0AF5  ED78    		DB	0EDH,a*8+40H
0AF7  0C      		inr	c
0AF8  FB      		ei
0AF9  B7      		ora	a
0AFA  37      		stc
0AFB  C0      		rnz		; error
0AFC          		bit	0,l	; SASI error bit
0AFC  CB45    		DB	0CBH,0*8+l+40H
0AFE  C0      		rnz
0AFF          		bit	1,l	; or other error?
0AFF  CB4D    		DB	0CBH,1*8+l+40H
0B01  C0      		rnz
0B02          		bit	1,h	; ACK
0B02  CB4C    		DB	0CBH,1*8+h+40H
0B04  C0      		rnz
0B05  AF      		xra	a	; success
0B06  C9      		ret
		
0000          	if remex
		endif
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77318 (RAM-disk) boot
0B07          	bm318:
0B07  F3      		di
0B08  21160B  		lxi	h,l318rt
0B0B  1100C0  		lxi	d,ramboot
0B0E  011E00  		lxi	b,l318sz
0B11          		ldir
0B11  EDB0    		DB	0EDH,0B0H
0B13  C300C0  		jmp	ramboot
		
		; MMS 77318 (RAM-disk) boot loader - relocated to ramboot
0B16          	l318rt:
0B16  2115C0  		lxi	h,ramboot+l318lo
0B19  0608    		mvi	b,l318lz
0B1B  0EF2    		mvi	c,0f2h
0B1D          		outir	; unlock memory and select OS image bank
0B1D  EDB3    		DB	0EDH,0B3H
0B1F  3A0000  		lda	0
0B22  FEC3    		cpi	0c3h	; JMP - does OS look good?
0B24  CA0000  		jz	0	; start OS
0B27          		outi	; re-select ROM bank
0B27  EDA3    		DB	0EDH,0A3H
0B29  FB      		ei
0B2A  C9      		ret	; return to monitor (boot error)
		
		; 77318 Unlock and select bank "E" (16K common + "bank 1")
		; NOTE: "22h" should not be there, left-over cruft from CP/M unlock.
0015          	l318lo	equ	$-l318rt
0B2B  040C0408	l318ul:	db	04h,0ch,04h,08h,0ch,08h,22h,10h
      0C082210
0008          	l318lz	equ	$-l318ul
0B33  00      		db	0	; fall-back to ROM on error...
001E          	l318sz	equ	$-l318rt
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		
0000          	if mms422
		endif
		
FFFF          	if wiznet
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; WIZNET WIZ850io (Network) boot loader
		
0B34          	getwiz1:
0B34  3E01    		mvi	a,WZSCS
0B36  D341    		out	spi$ctl
0B38  0E40    		mvi	c,spi$dat
0B3A  AF      		xra	a
0B3B          		outp	a	; hi adr always 0
0B3B  ED79    		DB	0EDH,a*8+41H
0B3D          		outp	e
0B3D  ED59    		DB	0EDH,e*8+41H
0B3F          		res	2,d
0B3F  CB92    		DB	0CBH,2*8+d+80H
0B41          		outp	d
0B41  ED51    		DB	0EDH,d*8+41H
0B43          		inp	a	; prime MISO
0B43  ED78    		DB	0EDH,a*8+40H
0B45          		inp	a
0B45  ED78    		DB	0EDH,a*8+40H
0B47  F5      		push	psw
0B48  0C      		inr	c	; ctl port
0B49  AF      		xra	a
0B4A          		outp	a	; clear SCS
0B4A  ED79    		DB	0EDH,a*8+41H
0B4C  F1      		pop	psw
0B4D  C9      		ret
		
0B4E          	putwiz1:
0B4E  F5      		push	psw
0B4F  3E01    		mvi	a,WZSCS
0B51  D341    		out	spi$ctl
0B53  0E40    		mvi	c,spi$dat
0B55  AF      		xra	a
0B56          		outp	a	; hi adr always 0
0B56  ED79    		DB	0EDH,a*8+41H
0B58          		outp	e
0B58  ED59    		DB	0EDH,e*8+41H
0B5A          		setb	2,d
0B5A  CBD2    		DB	0CBH,2*8+d+0C0H
0B5C          		outp	d
0B5C  ED51    		DB	0EDH,d*8+41H
0B5E  F1      		pop	psw
0B5F          		outp	a	; data
0B5F  ED79    		DB	0EDH,a*8+41H
0B61  0C      		inr	c	; ctl port
0B62  AF      		xra	a
0B63          		outp	a	; clear SCS
0B63  ED79    		DB	0EDH,a*8+41H
0B65  C9      		ret
		
		; Get 16-bit value from chip
		; Prereq: IDM_AR0 already set, auto-incr on
		; Entry: A=value for IDM_AR1
		; Return: HL=register pair contents
0B66          	getwiz2:
0B66  3E01    		mvi	a,WZSCS
0B68  D341    		out	spi$ctl
0B6A  0E40    		mvi	c,spi$dat
0B6C  AF      		xra	a
0B6D          		outp	a	; hi adr always 0
0B6D  ED79    		DB	0EDH,a*8+41H
0B6F          		outp	e
0B6F  ED59    		DB	0EDH,e*8+41H
0B71          		res	2,d
0B71  CB92    		DB	0CBH,2*8+d+80H
0B73          		outp	d
0B73  ED51    		DB	0EDH,d*8+41H
0B75          		inp	a	; prime MISO
0B75  ED78    		DB	0EDH,a*8+40H
0B77          		inp	h	; data
0B77  ED60    		DB	0EDH,h*8+40H
0B79          		inp	l	; data
0B79  ED68    		DB	0EDH,l*8+40H
0B7B  0C      		inr	c	; ctl port
0B7C  AF      		xra	a
0B7D          		outp	a	; clear SCS
0B7D  ED79    		DB	0EDH,a*8+41H
0B7F  C9      		ret
		
		; HL = output data, E = off, D = BSB, B = len
0B80          	wizset:
0B80  3E01    		mvi	a,WZSCS
0B82  D341    		out	spi$ctl
0B84  0E40    		mvi	c,spi$dat
0B86  AF      		xra	a
0B87          		outp	a	; hi adr always 0
0B87  ED79    		DB	0EDH,a*8+41H
0B89          		outp	e
0B89  ED59    		DB	0EDH,e*8+41H
0B8B          		setb	2,d
0B8B  CBD2    		DB	0CBH,2*8+d+0C0H
0B8D          		outp	d
0B8D  ED51    		DB	0EDH,d*8+41H
0B8F          		outir
0B8F  EDB3    		DB	0EDH,0B3H
0B91  0C      		inr	c	; ctl port
0B92  AF      		xra	a
0B93          		outp	a	; clear SCS
0B93  ED79    		DB	0EDH,a*8+41H
0B95  C9      		ret
		
		; Put 16-bit value to chip
		; Prereq: IDM_AR0 already set, auto-incr on
		; Entry: A=value for IDM_AR1
		;        HL=register pair contents
0B96          	putwiz2:
0B96  3E01    		mvi	a,WZSCS
0B98  D341    		out	spi$ctl
0B9A  0E40    		mvi	c,spi$dat
0B9C  AF      		xra	a
0B9D          		outp	a	; hi adr always 0
0B9D  ED79    		DB	0EDH,a*8+41H
0B9F          		outp	e
0B9F  ED59    		DB	0EDH,e*8+41H
0BA1          		setb	2,d
0BA1  CBD2    		DB	0CBH,2*8+d+0C0H
0BA3          		outp	d
0BA3  ED51    		DB	0EDH,d*8+41H
0BA5          		outp	h	; data to write
0BA5  ED61    		DB	0EDH,h*8+41H
0BA7          		outp	l
0BA7  ED69    		DB	0EDH,l*8+41H
0BA9  0C      		inr	c	; ctl port
0BAA  AF      		xra	a
0BAB          		outp	a	; clear SCS
0BAB  ED79    		DB	0EDH,a*8+41H
0BAD  C9      		ret
		
		; Issue command, wait for complete
		; D=Socket ctl byte
		; Returns: A=Sn_SR
0BAE  47      	wizcmd:	mov	b,a
0BAF  1E01    		mvi	e,sn$cr
0BB1          		setb	2,d
0BB1  CBD2    		DB	0CBH,2*8+d+0C0H
0BB3  3E01    		mvi	a,WZSCS
0BB5  D341    		out	spi$ctl
0BB7  0E40    		mvi	c,spi$dat
0BB9  AF      		xra	a
0BBA          		outp	a	; hi adr always 0
0BBA  ED79    		DB	0EDH,a*8+41H
0BBC          		outp	e
0BBC  ED59    		DB	0EDH,e*8+41H
0BBE          		outp	d
0BBE  ED51    		DB	0EDH,d*8+41H
0BC0          		outp	b	; command
0BC0  ED41    		DB	0EDH,b*8+41H
0BC2  0C      		inr	c	; ctl port
0BC3  AF      		xra	a
0BC4          		outp	a	; clear SCS
0BC4  ED79    		DB	0EDH,a*8+41H
0BC6  CD340B  	wc0:	call	getwiz1
0BC9  B7      		ora	a
0BCA          		jrnz	wc0
0BCA  20FA    		DB	20H,wc0-$-1
0BCC  1E03    		mvi	e,sn$sr
0BCE  CD340B  		call	getwiz1
0BD1  C9      		ret
		
		; HL=socket relative pointer (TX_WR)
		; DE=length (preserved, not used)
		; Returns: HL=msgptr, C=spi$dat
0BD2          	cpsetup:
0BD2  3E01    		mvi	a,WZSCS
0BD4  D341    		out	spi$ctl
0BD6  0E40    		mvi	c,spi$dat
0BD8          		outp	h
0BD8  ED61    		DB	0EDH,h*8+41H
0BDA          		outp	l
0BDA  ED69    		DB	0EDH,l*8+41H
0BDC  3A8222  		lda	cursok
0BDF  B0      		ora	b
0BE0          		outp	a
0BE0  ED79    		DB	0EDH,a*8+41H
0BE2  2A8522  		lhld	msgptr
0BE5  C9      		ret
		
		; length always <= 133 bytes, never overflows OUTIR/INIR
0BE6          	cpyout:
0BE6  0614    		mvi	b,txbuf0
0BE8  CDD20B  		call	cpsetup
0BEB  43      		mov	b,e	; length
0BEC          		outir		; send data
0BEC  EDB3    		DB	0EDH,0B3H
0BEE  228522  		shld	msgptr
0BF1  0C      		inr	c	; ctl port
0BF2  AF      		xra	a
0BF3          		outp	a	; clear SCS
0BF3  ED79    		DB	0EDH,a*8+41H
0BF5  C9      		ret
		
		; HL=socket relative pointer (RX_RD)
		; DE=length
		; Destroys IDM_AR0, IDM_AR1
		; length always <= 133 bytes, never overflows OUTIR/INIR
0BF6          	cpyin:
0BF6  0618    		mvi	b,rxbuf0
0BF8  CDD20B  		call	cpsetup	;
0BFB          		inp	a	; prime MISO
0BFB  ED78    		DB	0EDH,a*8+40H
0BFD  43      		mov	b,e	; fraction of page
0BFE          		inir		; recv data
0BFE  EDB2    		DB	0EDH,0B2H
0C00  228522  		shld	msgptr
0C03  0C      		inr	c	; ctl port
0C04  AF      		xra	a
0C05          		outp	a	; clear SCS
0C05  ED79    		DB	0EDH,a*8+41H
0C07  C9      		ret
		
		; L=bits to reset
		; D=socket base
0C08          	wizsts:
0C08  1E02    		mvi	e,sn$ir
0C0A  CD340B  		call	getwiz1	; destroys C
0C0D  F5      		push	psw
0C0E  A5      		ana	l
0C0F          		jrz	ws0	; don't reset if not set (could race)
0C0F  2804    		DB	28H,ws0-$-1
0C11  7D      		mov	a,l
0C12  CD4E0B  		call	putwiz1
0C15  F1      	ws0:	pop	psw
0C16  C9      		ret
		
		; D=socket BSB, C=bits to check
		; Return: A=status reg
0C17  21007D  	wizist:	lxi	h,32000
0C1A  C5      	wst0:	push	b	; C has status bits to check
0C1B  E5      		push	h
0C1C  69      		mov	l,c
0C1D  CD080C  		call	wizsts
0C20  E1      		pop	h
0C21  C1      		pop	b
0C22  47      		mov	b,a
0C23  A1      		ana	c
0C24          		jrnz	wst1
0C24  2007    		DB	20H,wst1-$-1
0C26  2B      		dcx	h
0C27  7C      		mov	a,h
0C28  B5      		ora	l
0C29          		jrnz	wst0
0C29  20EF    		DB	20H,wst0-$-1
0C2B  37      		stc
0C2C  C9      		ret
0C2D  78      	wst1:	mov	a,b
0C2E  C9      		ret
		
		;	WIZNET boot routine
		;
0C2F          	bwiznet:
0C2F  D5      		push	d
			; extract optional string. must do it now, before we
			; overwrite bootbf.
0C30  110523  		lxi	d,msg$dat	; target for string
0C33  218022  		lxi	h,bootbf
0C36  AF      		xra	a
0C37  320423  		sta	msg$siz
0C3A  7E      		mov	a,m
0C3B  FEC3    		cpi	0c3h	; no string
0C3D          		jrz	nb5
0C3D  2808    		DB	28H,nb5-$-1
0C3F  4F      		mov	c,a
			; we send N+1 bytes, NUL term
0C40  320423  		sta	msg$siz
0C43  0600    		mvi	b,0
0C45          		ldir
0C45  EDB0    		DB	0EDH,0B0H
0C47  AF      	nb5:	xra	a
0C48  12      		stax	d	; NUL term
0C49  D1      		pop	d
0C4A  7B      		mov	a,e	; server id, 0..9
0C4B  328022  		sta	server
			; look at WIZNET hard, init as needed
0C4E  111D00  		lxi	d,pmagic	; D = 0 (comm regs), E = PMAGIC offset
0C51  CD340B  		call	getwiz1
0C54  B7      		ora	a
0C55  CCF10D  		cz	wizcfg	; configure chip from nvram
0C58  D8      		rc
0C59  328122  		sta	nodeid ; our slave (client) ID
			; locate server node id in chip's socket regs.
			;
0C5C  0608    		mvi	b,nsocks
0C5E  110408  		lxi	d,(sock0 shl 8) + sn$prt
0C61          	nb1:
0C61  CD660B  		call	getwiz2	; destroys C,HL
0C64  7C      		mov	a,h
0C65  FE31    		cpi	31h
0C67          		jrnz	nb0
0C67  2006    		DB	20H,nb0-$-1
0C69  3A8022  		lda	server
0C6C  BD      		cmp	l
0C6D          		jrz	nb2	; found server socket
0C6D  2807    		DB	28H,nb2-$-1
0C6F          	nb0:
0C6F  3E20    		mvi	a,001$00$000b
0C71  82      		add	d	; next socket
0C72  57      		mov	d,a
0C73          		djnz	nb1
0C73  10EC    		DB	10H,nb1-$-1
0C75  C9      		ret	; error: server not configured
0C76          	nb2:	; D = server socket BSB
0C76  7A      		mov	a,d
0C77  E6E0    		ani	11100000b
0C79  328222  		sta	cursok
0C7C  CDDD0C  		call	wizopen
0C7F  D8      		rc	; any error
0C80  3E01    		mvi	a,1	; FNC for "boot me"
0C82  320323  		sta	msg$fnc
			; string already setup
0C85          	loop:
0C85  3EB0    		mvi	a,0b0h	; FMT for client boot messages
0C87  320023  		sta	msg$fmt
0C8A  CD1A0D  		call	sndrcv
0C8D  D8      		rc	; network failure
0C8E  3A0023  		lda	msg$fmt
0C91  FEB1    		cpi	0b1h	; FMT for server boot responses
0C93  C0      		rnz
			; TODO: verify SID?
0C94  3A0323  		lda	msg$fnc
0C97  B7      		ora	a
0C98  C8      		rz	; NAK - error
0C99  3D      		dcr	a
0C9A          		jrz	ldmsg
0C9A  2830    		DB	28H,ldmsg-$-1
0C9C  3D      		dcr	a
0C9D          		jrz	stdma
0C9D  2825    		DB	28H,stdma-$-1
0C9F  3D      		dcr	a
0CA0          		jrz	load
0CA0  2809    		DB	28H,load-$-1
0CA2  3D      		dcr	a
0CA3  C0      		rnz	; unsupported FNC
			; done: execute boot code
0CA4  CD090D  		call	wizclose
0CA7  2A0523  		lhld	msg$dat
0CAA  E9      		pchl
0CAB  2A8B22  	load:	lhld	dma
0CAE  EB      		xchg
0CAF  210523  		lxi	h,msg$dat
0CB2  018000  		lxi	b,128
0CB5          		ldir
0CB5  EDB0    		DB	0EDH,0B0H
0CB7  EB      		xchg
0CB8  228B22  		shld	dma
0CBB  AF      	ack:	xra	a	; FNC 0 = ACK
0CBC  320323  		sta	msg$fnc
0CBF  320423  		sta	msg$siz
0CC2          		jr	loop
0CC2  18C1    		DB	18H,loop-$-1
0CC4  2A0523  	stdma:	lhld	msg$dat
0CC7  228B22  		shld	dma
0CCA          		jr	ack
0CCA  18EF    		DB	18H,ack-$-1
0CCC  CD2A06  	ldmsg:	call	crlf
0CCF  210523  		lxi	h,msg$dat
0CD2  7E      	ldm0:	mov	a,m
0CD3  23      		inx	h
0CD4  FE24    		cpi	'$'
0CD6          		jrz	ack
0CD6  28E3    		DB	28H,ack-$-1
0CD8  CD8E05  		call	conout
0CDB          		jr	ldm0
0CDB  18F5    		DB	18H,ldm0-$-1
		
		; D = server socket BSB
0CDD          	wizopen:
0CDD  1E03    		mvi	e,sn$sr
0CDF  CD340B  		call	getwiz1
0CE2  FE17    		cpi	ESTABLISHED
0CE4  C8      		rz	; ready to rock-n-roll...
			; try to open...
0CE5  FE13    		cpi	SOKINIT
0CE7          		jrz	nb4
0CE7  2809    		DB	28H,nb4-$-1
0CE9  3E01    		mvi	a,OPEN
0CEB  CDAE0B  		call	wizcmd
0CEE  FE13    		cpi	SOKINIT
0CF0  37      		stc
0CF1  C0      		rnz	; failed to open (init)
0CF2  1E02    	nb4:	mvi	e,sn$ir	; ensure no lingering bits...
0CF4  3E1F    		mvi	a,00011111b
0CF6  CD4E0B  		call	putwiz1
0CF9  3E04    		mvi	a,CONNECT
0CFB  CDAE0B  		call	wizcmd
0CFE  0E0B    		mvi	c,00001011b	; CON, DISCON, or TIMEOUT
0D00  CD170C  		call	wizist	; returns when one is set, or CY
0D03  D8      		rc
0D04  E601    		ani	00000001b	; need CON
0D06  D601    		sui	00000001b	; CY if bit is 0
0D08  C9      		ret
		
0D09          	wizclose:
0D09  3A8222  		lda	cursok
0D0C  F608    		ori	sock0
0D0E  57      		mov	d,a
0D0F  3E08    		mvi	a,DISC
0D11  CDAE0B  		call	wizcmd
0D14  0E0A    		mvi	c,00001010b	; DISCON, or TIMEOUT
0D16  CD170C  		call	wizist	; returns when one is set, or CY
0D19  C9      		ret	; don't care which result?
		
		;	Send Message on Network, receive response
		;	msgbuf setup with FMT, FNC, LEN, data
		;	msg len always <= 128 (133 total) bytes.
0D1A          	sndrcv:			; BC = message addr
			; TODO: drain/flush receiver
		; begin send phase
0D1A  210023  		lxi	h,msgbuf
0D1D  228522  		shld	msgptr
0D20  3A8222  		lda	cursok
0D23  F608    		ori	sock0
0D25  57      		mov	d,a
			; D=socket patn
0D26  3A8022  		lda	server
0D29  320123  		sta	msg$did	; Set Server ID (dest) in header
0D2C  3A8122  		lda	nodeid
0D2F  320223  		sta	msg$sid	; Set Slave ID (src) in header
0D32  3A0423  		lda	msg$siz	; msg siz (-1)
0D35  C606    		adi	5+1	; hdr, +1 for (-1)
0D37  6F      		mov	l,a
0D38  2600    		mvi	h,0
0D3A  228722  		shld	msglen
0D3D  1E24    		mvi	e,sn$txwr
0D3F  CD660B  		call	getwiz2
0D42  228322  		shld	curptr
0D45  2A8722  		lhld	msglen
0D48          		lbcd	curptr
0D48  ED4B    		DB	0EDH,4BH
0D4A  8322    		DW	curptr
0D4C  09      		dad	b
0D4D  1E24    		mvi	e,sn$txwr
0D4F  CD960B  		call	putwiz2
			; send data
0D52  2A8722  		lhld	msglen
0D55  EB      		xchg
0D56  2A8322  		lhld	curptr
0D59  CDE60B  		call	cpyout
0D5C  3A8222  		lda	cursok
0D5F  F608    		ori	sock0
0D61  57      		mov	d,a
0D62  3E20    		mvi	a,SEND
0D64  CDAE0B  		call	wizcmd
			; ignore Sn_SR?
0D67  0E1A    		mvi	c,00011010b	; SEND_OK bit, TIMEOUT, DISConnect
0D69  CD170C  		call	wizist
0D6C  D8      		rc
0D6D  E610    		ani	00010000b	; SEND_OK
0D6F  37      		stc
0D70  C8      		rz
		; begin recv phase - loop
0D71  3A8222  		lda	cursok	; is D still socket BSB?
0D74  F608    		ori	sock0
0D76  57      		mov	d,a
		;	Receive Message from Network
0D77  210023  		lxi	h,msgbuf
0D7A  228522  		shld	msgptr
0D7D  0E06    		mvi	c,00000110b	; RECV, DISC
0D7F  CD170C  		call	wizist	; check for recv within timeout
0D82          		jrc	rerr
0D82  386A    		DB	38H,rerr-$-1
0D84  E604    		ani	00000100b	; RECV
0D86          		jrz	rerr
0D86  2866    		DB	28H,rerr-$-1
0D88  210000  		lxi	h,0
0D8B  228922  		shld	totlen
0D8E          	rm0:	; D must be socket base...
0D8E  1E26    		mvi	e,sn$rxrsr	; length
0D90  CD660B  		call	getwiz2
0D93  7C      		mov	a,h
0D94  B5      		ora	l
0D95          		jrz	rm0
0D95  28F7    		DB	28H,rm0-$-1
0D97  228722  		shld	msglen		; not CP/NET msg len
0D9A  1E28    		mvi	e,sn$rxrd	; pointer
0D9C  CD660B  		call	getwiz2
0D9F  228322  		shld	curptr
0DA2          		lbcd	msglen	; BC=Sn_RX_RSR
0DA2  ED4B    		DB	0EDH,4BH
0DA4  8722    		DW	msglen
0DA6  2A8922  		lhld	totlen
0DA9  B7      		ora	a
0DAA          		dsbc	b
0DAA  ED42    		DB	0EDH,b*8+42H
0DAC  228922  		shld	totlen	; might be negative...
0DAF          		lbcd	curptr
0DAF  ED4B    		DB	0EDH,4BH
0DB1  8322    		DW	curptr
0DB3  2A8722  		lhld	msglen	; BC=Sn_RX_RD, HL=Sn_RX_RSR
0DB6  09      		dad	b	; HL=nxt RD
0DB7  1E28    		mvi	e,sn$rxrd
0DB9  CD960B  		call	putwiz2
			; DE destroyed...
0DBC          		lded	msglen
0DBC  ED5B    		DB	0EDH,5BH
0DBE  8722    		DW	msglen
0DC0  2A8322  		lhld	curptr
0DC3  CDF60B  		call	cpyin
0DC6  3A8222  		lda	cursok
0DC9  F608    		ori	sock0
0DCB  57      		mov	d,a
0DCC  3E40    		mvi	a,RECV
0DCE  CDAE0B  		call	wizcmd
			; ignore Sn_SR?
0DD1  2A8922  		lhld	totlen	; might be neg (first pass)
0DD4  7C      		mov	a,h
0DD5  B7      		ora	a
0DD6  F2EA0D  		jp	rm1
			; can we guarantee at least msg hdr?
0DD9  3A0423  		lda	msg$siz	; msg siz (-1)
0DDC  C606    		adi	5+1	; header, +1 for (-1)
0DDE  5F      		mov	e,a
0DDF  3E00    		mvi	a,0
0DE1  8F      		adc	a
0DE2  57      		mov	d,a	; true msg len
0DE3  19      		dad	d	; subtract what we already have
0DE4          		jrnc	rerr	; something is wrong, if still neg
0DE4  3008    		DB	30H,rerr-$-1
0DE6  228922  		shld	totlen
0DE9  7C      		mov	a,h
0DEA  B5      	rm1:	ora	l
0DEB          		jrnz	rm0
0DEB  20A1    		DB	20H,rm0-$-1
0DED  C9      		ret	; success (A=0)
		
0DEE          	rerr:
0DEE  AF      	err:	xra	a
0DEF  3D      		dcr	a	; NZ
0DF0  C9      		ret
		
		; Try to read NVRAM config for WIZNET.
		; Returns: A = node id (PMAGIC) or CY if error (no config)
0DF1          	wizcfg:	; restore config from NVRAM
0DF1  210000  		lxi	h,0
0DF4  110002  		lxi	d,512
0DF7  CD9E0E  		call	nvget
0DFA  CD7A0E  		call	vcksum
0DFD  37      		stc
0DFE  C0      		rnz	; checksum wrong - no config available
0DFF  210124  		lxi	h,nvbuf+gar
0E02  1600    		mvi	d,0
0E04  1E01    		mvi	e,gar
0E06  0612    		mvi	b,18	; GAR+SUBR+SHAR+SIPR
0E08  CD800B  		call	wizset
0E0B  3A1D24  		lda	nvbuf+pmagic
0E0E  1E1D    		mvi	e,pmagic
0E10  CD4E0B  		call	putwiz1
0E13          		lxix	nvbuf+32	; start of socket0 data
0E13  DD21    		DB	0DDH,21H
0E15  2024    		DW	nvbuf+32
0E17  1608    		mvi	d,SOCK0
0E19  0608    		mvi	b,8
0E1B          	rest0:
0E1B  C5      		push	b
0E1C          		ldx	a,sn$prt
0E1C  DD7E04  		DB	0DDH,a*8+46H,sn$prt
0E1F  FE31    		cpi	31h
0E21          		jrnz	rest1	; skip unconfigured sockets
0E21  201E    		DB	20H,rest1-$-1
0E23  3E01    		mvi	a,1	; TCP mode
0E25  1E00    		mvi	e,sn$mr
0E27  CD4E0B  		call	putwiz1	; force TCP/IP mode
0E2A          		ldx	a,NvKPALVTR
0E2A  DD7E1D  		DB	0DDH,a*8+46H,NvKPALVTR
0E2D  1E2F    		mvi	e,sn$kpalvtr
0E2F  B7      		ora	a
0E30  C44E0B  		cnz	putwiz1
0E33  1E04    		mvi	e,sn$prt
0E35  0602    		mvi	b,2
0E37  CD520E  		call	setsok
0E3A  1E0C    		mvi	e,sn$dipr
0E3C  0606    		mvi	b,6	; DIPR and DPORT
0E3E  CD520E  		call	setsok
0E41          	rest1:
0E41  012000  		lxi	b,32
0E44          		dadx	b
0E44  DD09    		DB	0DDH,b*8+09H
0E46  3E20    		mvi	a,001$00$000b	; socket BSB incr value
0E48  82      		add	d
0E49  57      		mov	d,a
0E4A  C1      		pop	b
0E4B          		djnz	rest0
0E4B  10CE    		DB	10H,rest0-$-1
0E4D  3A1D24  		lda	nvbuf+pmagic	; our node id
0E50  B7      		ora	a	; NC
0E51  C9      		ret
		
		; IX = base data buffer for socket, D = socket BSB, E = offset, B = length
		; destroys HL, B, C
0E52          	setsok:
0E52          		pushix
0E52  DDE5    		DB	0DDH,0E5H
0E54  E1      		pop	h
0E55  D5      		push	d
0E56  1600    		mvi	d,0
0E58  19      		dad	d	; HL points to data in 'buf'
0E59  D1      		pop	d
0E5A  CD800B  		call	wizset
0E5D  C9      		ret
		
0E5E          	cksum32:
0E5E  210000  		lxi	h,0
0E61  110000  		lxi	d,0
0E64          	cks0:	ldx	a,+0
0E64  DD7E00  		DB	0DDH,a*8+46H,+0
0E67          		inxix
0E67  DD23    		DB	0DDH,23H
0E69  83      		add	e
0E6A  5F      		mov	e,a
0E6B          		jrnc	cks1
0E6B  3007    		DB	30H,cks1-$-1
0E6D  14      		inr	d
0E6E          		jrnz	cks1
0E6E  2004    		DB	20H,cks1-$-1
0E70  2C      		inr	l
0E71          		jrnz	cks1
0E71  2001    		DB	20H,cks1-$-1
0E73  24      		inr	h
0E74  0B      	cks1:	dcx	b
0E75  78      		mov	a,b
0E76  B1      		ora	c
0E77          		jrnz	cks0
0E77  20EB    		DB	20H,cks0-$-1
0E79  C9      		ret
		
		; Validates checksum in 'buf'
		; return: NZ on error
0E7A          	vcksum:
0E7A          		lxix	nvbuf
0E7A  DD21    		DB	0DDH,21H
0E7C  0024    		DW	nvbuf
0E7E  01FC01  		lxi	b,508
0E81  CD5E0E  		call	cksum32
0E84          		lbcd	nvbuf+510
0E84  ED4B    		DB	0EDH,4BH
0E86  FE25    		DW	nvbuf+510
0E88  78      		mov	a,b	;
0E89  B1      		ora	c	; check first half zero
0E8A          		dsbc	b
0E8A  ED42    		DB	0EDH,b*8+42H
0E8C  C0      		rnz
0E8D          		lbcd	nvbuf+508
0E8D  ED4B    		DB	0EDH,4BH
0E8F  FC25    		DW	nvbuf+508
0E91  B0      		ora	b	;
0E92  B1      		ora	c	; check second half zero
0E93  EB      		xchg
0E94          		dsbc	b
0E94  ED42    		DB	0EDH,b*8+42H
0E96  C0      		rnz
0E97  B7      		ora	a	; was checksum all zero?
0E98          		jrz	vcksm0
0E98  2802    		DB	28H,vcksm0-$-1
0E9A  AF      		xra	a	; ZR
0E9B  C9      		ret
0E9C  3C      	vcksm0:	inr	a	; NZ
0E9D  C9      		ret
		
		; Get a block of data from NVRAM to 'buf'
		; HL = nvram address, DE = length (always multiple of 256)
0E9E          	nvget:
0E9E  3E02    		mvi	a,NVSCS
0EA0  D341    		out	spi$ctl
0EA2  3E03    		mvi	a,NVRD
0EA4  D340    		out	spi$dat
0EA6  7C      		mov	a,h
0EA7  D340    		out	spi$dat
0EA9  7D      		mov	a,l
0EAA  D340    		out	spi$dat
0EAC  DB40    		in	spi$dat	; prime pump
0EAE  0E40    		mvi	c,spi$dat
0EB0  210024  		lxi	h,nvbuf
0EB3  43      		mov	b,e
0EB4          	nvget0:	inir	; B = 0 after
0EB4  EDB2    		DB	0EDH,0B2H
0EB6  15      		dcr	d
0EB7          		jrnz	nvget0
0EB7  20FB    		DB	20H,nvget0-$-1
0EB9  AF      		xra	a	; not SCS
0EBA  D341    		out	spi$ctl
0EBC  C9      		ret
		endif
		
0000          	if terminal
		endif
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Set BAUD command
0EBD          	setber:
0EBD  3E07    		mvi	a,BEL
0EBF  CD8E05  		call	conout
0EC2  E1      		pop	h
0EC3  C9      		ret
		
0EC4          	setbr:
0EC4  21290F  		lxi	h,ratems
0EC7  CD3406  		call	msgout
0ECA  CD7D05  		call	conin
0ECD  E6DF    		ani	11011111b	; toupper
0ECF  4F      		mov	c,a
0ED0  CD8E05  		call	conout
0ED3  D641    		sui	'A'
0ED5  FE0E    		cpi	'O'-'A'
0ED7          		jrnc	setber
0ED7  30E4    		DB	30H,setber-$-1
0ED9  5F      		mov	e,a
0EDA  1600    		mvi	d,0
0EDC  21310F  		lxi	h,brtab
0EDF  19      		dad	d
0EE0  19      		dad	d
0EE1  19      		dad	d
0EE2  19      		dad	d
0EE3  5E      		mov	e,m
0EE4  23      		inx	h
0EE5  56      		mov	d,m	; DE=baud divisor
0EE6  23      		inx	h
0EE7  7E      		mov	a,m
0EE8  23      		inx	h
0EE9  66      		mov	h,m
0EEA  6F      		mov	l,a	; HL=rate string
0EEB  CD3406  		call	msgout
0EEE  21C90F  		lxi	h,baudms
0EF1  CD3406  		call	msgout
0EF4  CD2306  		call	waitcr
0EF7  3E1B    		mvi	a,ESC
0EF9  CD8E05  		call	conout
0EFC  3E72    		mvi	a,'r' ; Set Baud
0EFE  CD8E05  		call	conout
0F01  79      		mov	a,c ; Baud value
0F02  CD8E05  		call	conout
0F05          	setbrf:
0F05  DBED    		in	0edh
0F07  E660    		ani	01100000b
0F09  FE60    		cpi	01100000b
0F0B          		jrnz	setbrf	; flush output
0F0B  20F8    		DB	20H,setbrf-$-1
0F0D  01A00F  		lxi	b,4000	; delay value ~43mS
0F10          	setbr0:
0F10  0B      		dcx	b
0F11  78      		mov	a,b
0F12  B1      		ora	c
0F13          		jrnz	setbr0
0F13  20FB    		DB	20H,setbr0-$-1
0F15  DBEB    		in	0ebh
0F17  F680    		ori	10000000b	; divsor latch enable
0F19  D3EB    		out	0ebh
0F1B  7B      		mov	a,e
0F1C  D3E8    		out	0e8h
0F1E  7A      		mov	a,d
0F1F  D3E9    		out	0e9h
0F21  DBEB    		in	0ebh
0F23  E67F    		ani	01111111b	; divisor latch disable
0F25  D3EB    		out	0ebh
0F27  E1      		pop	h
0F28  C9      		ret
		
0F29  52617465	ratems:	db	'Rate - ',TRM
      202D2000
		
0F31          	brtab:
0F31  1704690F		dw	1047,	br110
0F35  00036F0F		dw	768,	br150
0F39  8001750F		dw	384,	br300
0F3D  C0007B0F		dw	192,	br600
0F41  6000810F		dw	96,	br1200
0F45  4000880F		dw	64,	br1800
0F49  3A008F0F		dw	58,	br2000
0F4D  3000960F		dw	48,	br2400
0F51  20009D0F		dw	32,	br3600
0F55  1800A40F		dw	24,	br4800
0F59  1000AB0F		dw	16,	br7200
0F5D  0C00B20F		dw	12,	br9600
0F61  0600B90F		dw	6,	br19200
0F65  0300C10F		dw	3,	br38400
		
0F69  20283131	br110:	db	' (110',TRM
      3000
0F6F  20283135	br150:	db	' (150',TRM
      3000
0F75  20283330	br300:	db	' (300',TRM
      3000
0F7B  20283630	br600:	db	' (600',TRM
      3000
0F81  20283132	br1200:	db	' (1200',TRM
      303000
0F88  20283138	br1800:	db	' (1800',TRM
      303000
0F8F  20283230	br2000:	db	' (2000',TRM
      303000
0F96  20283234	br2400:	db	' (2400',TRM
      303000
0F9D  20283336	br3600:	db	' (3600',TRM
      303000
0FA4  20283438	br4800:	db	' (4800',TRM
      303000
0FAB  20283732	br7200:	db	' (7200',TRM
      303000
0FB2  20283936	br9600:	db	' (9600',TRM
      303000
0FB9  20283139	br19200: db	' (19200',TRM
      32303000
0FC1  20283338	br38400: db	' (38400',TRM
      34303000
0FC9  20626175	baudms:	db	' baud)',TRM
      642900
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Print ROM version command
0FD0          	prtver:
0FD0  21DE0F  		lxi	h,versms
0FD3  CD3406  		call	msgout
0FD6  3AE70F  		lda	vers
0FD9  CDF005  		call	hexout
0FDC  E1      		pop	h
0FDD  C9      		ret
		
0FDE  56657273	versms:	db	'Version ',TRM
      696F6E20
      00
0FE7  16      	vers:	db	VERN	; version byte... "1.0"
		
0FE8  0D0A0745	erprom:	db	CR,LF,BEL,'EPROM err',TRM
      50524F4D
      20657272
      00
		
			rept	1000h-$-4
0FF5  FF      		db	0ffh
0FF6  FF      		db	0ffh
0FF7  FF      		db	0ffh
0FF8  FF      		db	0ffh
0FF9  FF      		db	0ffh
0FFA  FF      		db	0ffh
0FFB  FF      		db	0ffh
0FFC          	romend:
0FFC  0000    		dw	0
0FFE          	chksum:
0FFE  FB4C    		dw	04cfbh	; checksum...
		
0000          	if	($ <> 1000h)
		endif
1000          		end



Statistics:

     4	passes
     0	jr promotions
   422	symbols
  4096	bytes

   700	macro calls
  3785	macro bytes
     0	invented symbols
