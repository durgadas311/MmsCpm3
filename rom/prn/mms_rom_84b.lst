		; Z89/Z90 Monitor EPROM 444-84B, by Magnolia Microsystems
		; Z89/Z90/H8-Z80 Monitor EPROM 444-84D, June 29, 2019, drm
0013          	VERN	equ	13h	; version 1.3
		
			maclib	z80
**** z80.lib ****
**** mms_rom_84b.asm ****
			$*macro
		
000D          	CR	equ	13
000A          	LF	equ	10
0007          	BEL	equ	7
001B          	ESC	equ	27
0000          	TRM	equ	0
007F          	DEL	equ	127
		
0060          	GIDE$DA	equ	060h	; GIDE data port
0061          	GIDE$ER	equ	061h	; GIDE error register
0062          	GIDE$SC	equ	062h	; GIDE sector count
0063          	GIDE$SE	equ	063h	; GIDE sector number
0064          	GIDE$CL	equ	064h	; GIDE cylinder low
0065          	GIDE$CH	equ	065h	; GIDE cylinder high
0066          	GIDE$DH	equ	066h	; GIDE drive/head
0067          	GIDE$CS	equ	067h	; GIDE command/status
		
		; WIZNET/NVRAM (SPI adapter) defines
0040          	spi	equ	40h	; base port
0040          	spi$dat	equ	spi+0
0041          	spi$ctl	equ	spi+1	; must be spi$dat+1
0041          	spi$sta	equ	spi+1
		
0001          	WZSCS	equ	01b	; /SCS for WIZNET
0002          	NVSCS	equ	10b	; /SCS for NVRAM
		
		; NVRAM constants
		; NVRAM/SEEPROM commands
0003          	NVRD	equ	00000011b
0002          	NVWR	equ	00000010b
0005          	RDSR	equ	00000101b
0006          	WREN	equ	00000110b
		; NVRAM/SEEPROM status bits
0001          	WIP	equ	00000001b
		
		; WIZNET constants
0008          	nsocks	equ	8
0008          	sock0	equ	000$01$000b	; base pattern for Sn_ regs
0014          	txbuf0	equ	000$10$100b	; base pattern for Tx buffer
0018          	rxbuf0	equ	000$11$000b	; base pattern for Rx buffer
		
		; common regs
0001          	gar	equ	1
0005          	subr	equ	5
0009          	shar	equ	9
000F          	sipr	equ	15
0015          	ir	equ	21
0017          	sir	equ	23
001D          	pmagic	equ	29
		
		; socket regs, relative
0000          	sn$mr	equ	0
0001          	sn$cr	equ	1
0002          	sn$ir	equ	2
0003          	sn$sr	equ	3
0004          	sn$prt	equ	4
000C          	sn$dipr	equ	12
0010          	sn$dprt	equ	16
0024          	sn$txwr	equ	36
0026          	sn$rxrsr equ	38
0028          	sn$rxrd	equ	40
		
		; socket commands
0001          	OPEN	equ	01h
0004          	CONNECT	equ	04h
0020          	SEND	equ	20h
0040          	RECV	equ	40h
		
		; socket status
0013          	SOKINIT	equ	13h
0017          	ESTABLISHED equ	17h
		
2280          		org	2280h
2280          	server:	ds	1	; SID, dest of send
2281          	nodeid:	ds	1	; our node id
2282          	cursok:	ds	1	; current socket select patn
2283          	curptr:	ds	2	; into chip mem
2285          	msgptr:	ds	2
2287          	msglen:	ds	2
2289          	totlen:	ds	2
228B          	dma:	ds	2
		
2300          		org	2300h
		msgbuf:	ds	0
2300          	msg$fmt: ds	1
2301          	msg$did: ds	1
2302          	msg$sid: ds	1
2303          	msg$fnc: ds	1
2304          	msg$siz: ds	1
2305          	msg$dat: ds	128
		
2400          		org	2400h
2400          	nvbuf:	ds	512
		
		; Legacy devices and defines
		
1800          		org	01800h	; H17 Floppy ROM routines
1800          		ds	1014
1BF6          	R$ABORT: ds	35	;00011011.11110110	033.366	R.ABORT
1C19          	CLOCK:	ds	38	;00011100.00011001	034.031 CLOCK
1C3F          	R$READ:	ds	499	;00011100.00111111	034.077	R.READ
1E32          	R$SDP:	ds	107	;			034.062 R.SDP
1E9D          	R$WHD:	ds	28	;00011110.10011101	036.235	R.WHD
1EB9          	R$WNH:	ds	161	;00011110.10111001	036.271	R.WNH
1F5A          	R$CONST: ds	88	;00011111.01011010	037.132	R.CONST
1FB2          		ds	78
		
		; RAM variables, some defined by H17 Floppy ROM
2000          		org	02000h
2000          	ramstart:
2000          		ds	3
2003          	l2003h:	ds	1	; - 02003h
2004          	l2004h:	ds	1	; - 02004h
2005          		ds	3
2008          	l2008h:	ds	1	; - 02008h
2009          	ctl$F0:	ds	1	; - 02009h
200A          		ds	17
201B          	ticcnt:	ds	2	; - 0201bh
201D          	monstk:	ds	2	; - 0201dh
201F          	intvec:
201F          	vrst1:	ds	3	; rst1 jmp vector - 0201fh
2022          	vrst2:	ds	3	; rst2 jmp vector - 02022h
2025          	vrst3:	ds	3	; rst3 jmp vector - 02025h
2028          	vrst4:	ds	3	; rst4 jmp vector - 02028h
202B          	vrst5:	ds	3	; rst5 jmp vector - 0202bh
202E          	vrst6:	ds	3	; rst6 jmp vector - 0202eh
2031          	vrst7:	ds	3	; rst7 jmp vector - 02031h
2034          	l2034h:	ds	2	; - 02034h
2036          	ctl$F2:	ds	1	; - 02036h GPP template/image
2037          	l2037h:	ds	2	; - 02037h
2039          		ds	7
2040          	l2040h:	ds	8
2048          	D$CONST: ds	88+20	; - 02048h	disk constants
20B4          	DECNT:	ds	1	; - 020b4h
20B5          		ds	124
2131          	AIO$UNI: ds	1	; - 02131h
2132          	cmdbuf:	ds	6	; SASI command buffer
2138          	resbuf:	ds	2	; SASI result buffer
213A          		ds	22
2150          	cport:	ds	1	; - 02150h
2151          		ds	1
2152          	SEC$CNT:	ds	1	; - 02152h
2153          	l2153h:	ds	1
2154          		ds	2
2156          	l2156h:	ds	6	; cmdbuf for SASI, segoff for GIDE
215C          		ds	292
		bootbf:	ds	0	; - 02280h
		
3000          	memtest	equ	03000h
C000          	ramboot	equ	0c000h
		
		; Start of ROM code
0000          		org	00000h
		
0000          	rombeg:
0000  C34604  	rst0:	jmp	init
		
0003  6F6F7420	bootms:	db	'oot ',TRM
      00
		
0008  CDEC04  	rst1:	call	intsetup
000B  2A1B20  		lhld	ticcnt
000E  C3B900  		jmp	int1$cont
0000          	if ((high int1$cont) <> 0)
		endif
		
0010          	rst2	equ	$-1	; must be a nop...
0011  CDEC04  		call	intsetup
0014  1A      		ldax	d
0015  C38001  		jmp	int2$cont
		
0018  C32520  	rst3:	jmp	vrst3
		
001B  6F2000  	goms:	db	'o ',TRM
001E  0000    		db	0,0
		
0020  C32820  	rst4:	jmp	vrst4
		
0023  00000000		db	0,0,0,0,0
      00
		
0028  C32B20  	rst5:	jmp	vrst5
002B          	delayx:
002B  C36002  		jmp	delay
		
002E  3F00    	qmsg:	db	'?',TRM
		
0030  C32E20  	rst6:	jmp	vrst6
		
0033  00000000		db	0,0,0,0,0
      00
		
0038  C33120  	rst7:	jmp	vrst7
		
003B  75627374	subms:	db	'ubstitute ',TRM
      69747574
      652000
0046  726F6772	pcms:	db	'rogram Counter ',TRM
      616D2043
      6F756E74
      65722000
0056  656D6F72	mtms:	db	'emory test',TRM
      79207465
      737400
		
			rept	0066h-$
0061  00      		db	0
0062  00      		db	0
0063  00      		db	0
0064  00      		db	0
0065  00      		db	0
0000          	if	($ <> 0066h)
		endif
		
0066          	nmi:
0066  E3      		xthl	; save HL and pop RETADR
0067  E5      		push	h	; put RETADR in new position
0068  F5      		push	psw
0069  2B      		dcx	h
006A  7E      		mov	a,m		; check cause of NMI
006B  FEF0    		cpi	0f0h	; H8 front-panel port
006D          		jrz	port$f0
006D  281B    		DB	28H,port$f0-$-1
006F  FEF1    		cpi	0f1h	; H8 port
0071          		jrz	port$ign
0071  2808    		DB	28H,port$ign-$-1
0073  FEFA    		cpi	0fah	; H8...
0075          		jrz	port$ign
0075  2804    		DB	28H,port$ign-$-1
0077  FEFB    		cpi	0fbh	; H8...
0079          		jrnz	nmi$xit2
0079  202D    		DB	20H,nmi$xit2-$-1
007B          	port$ign:	; ports 0F1H, 0FAH, 0FBH.
007B  2B      		dcx	h
007C  7E      		mov	a,m
007D  FED3    		cpi	0d3h	; OUT
007F          		jrz	nmi$xit2
007F  2827    		DB	28H,nmi$xit2-$-1
0081  FEDB    		cpi	0dbh	; IN
0083          		jrnz	nmi$xit2
0083  2023    		DB	20H,nmi$xit2-$-1
			; IN 0F1H, 0FAH or 0FBH...
0085  F1      		pop	psw
0086  3E00    		mvi	a,000h	; these ports "return" 000h
0088          		jr	nmi$xit	; exit NMI
0088  181F    		DB	18H,nmi$xit-$-1
		
008A          	port$f0:	; H8 front panel port...
008A  2B      		dcx	h
008B  7E      		mov	a,m
008C  FEDB    		cpi	0dbh	; IN
008E          		jrnz	not$in
008E  2005    		DB	20H,not$in-$-1
0090  F1      		pop	psw
0091  3EFF    		mvi	a,0ffh	; simulate input of 0ffh
0093          		jr	nmi$xit
0093  1814    		DB	18H,nmi$xit-$-1
0095          	not$in:
0095  FED3    		cpi	0d3h	; OUT
0097          		jrnz	nmi$xit2
0097  200F    		DB	20H,nmi$xit2-$-1
0099  F1      		pop	psw	; byte to output to 0F0H...
009A  F5      		push	psw	; _  7 6 5 4 3 2 1 0
009B  17      		ral		; 7  6 5 4 3 2 1 0 _
009C  17      		ral		; 6  5 4 3 2 1 0 _ 7
009D  2F      		cma		; 6  5'4'3'2'1'0'_ 7'
009E  17      		ral		; 5' 4'3'2'1'0'_ 7'6
009F  07      		rlc		; 4' 3'2'1'0'_ 7'6 5'
00A0  E603    		ani	003h	; _  _ _ _ _ _ _ 6 5'
00A2  213620  		lxi	h,ctl$F2
00A5  B6      		ora	m
00A6  D3F2    		out	0f2h ; simulate some H8 features
00A8          	nmi$xit2:
00A8  F1      		pop	psw
00A9          	nmi$xit:
00A9  E1      		pop	h
00AA  E3      		xthl
00AB          		retn
00AB  ED45    		DB	0EDH,45H
		
00AD          	int1$1:
00AD  0A      		ldax	b
00AE  0F      		rrc
00AF  DC1F20  		cc	vrst1
00B2          	intret:
00B2  F1      		pop	psw
00B3  F1      		pop	psw
00B4  C1      		pop	b
00B5  D1      		pop	d
00B6  E1      		pop	h
00B7          	nulint:
00B7  FB      		ei
00B8  C9      		ret
		
00B9          	int1$cont:
00B9  23      		inx	h
00BA  221B20  		shld	ticcnt
00BD  010920  		lxi	b,ctl$F0
00C0  0A      		ldax	b
00C1  D3F0    		out	0f0h
00C3  E620    		ani	020h
00C5          		jrnz	intret
00C5  20EB    		DB	20H,intret-$-1
00C7  0B      		dcx	b
00C8          	int1$0:
00C8  0A      		ldax	b
00C9  17      		ral
00CA          		jrc	int1$1
00CA  38E1    		DB	38H,int1$1-$-1
00CC  210A00  		lxi	h,10
00CF  39      		dad	sp
00D0  5E      		mov	e,m
00D1  23      		inx	h
00D2  56      		mov	d,m
00D3  1B      		dcx	d
00D4  1A      		ldax	d
00D5  FE76    		cpi	076h	; HLT
00D7          		jrnz	int1$1
00D7  20D4    		DB	20H,int1$1-$-1
00D9  CD9605  		call	belout
00DC  3E48    		mvi	a,'H'
00DE  CD9805  		call	conout
00E1          	re$entry:		; re-entry point for errors, etc.
00E1  210920  		lxi	h,ctl$F0
00E4  36F0    		mvi	m,0f0h	; !beep, 2mS, MON, !SI
00E6  2A1D20  		lhld	monstk
00E9  F9      		sphl
00EA  CD9605  		call	belout
			;jmp	start
00ED          	start:
00ED  FB      		ei
00EE  21ED00  		lxi	h,start
00F1  E5      		push	h
00F2  21E707  		lxi	h,prompt
00F5  CD3406  		call	msgout
00F8          	prloop:
00F8  CD8205  		call	coninx
00FB  E65F    		ani	01011111b ; toupper
00FD  211B01  		lxi	h,cmdtab
0100  0605    		mvi	b,5
0102          	cmloop:
0102  BE      		cmp	m
0103  23      		inx	h
0104          		jrz	docmd
0104  280D    		DB	28H,docmd-$-1
0106  23      		inx	h
0107  23      		inx	h
0108          		djnz	cmloop
0108  10F8    		DB	10H,cmloop-$-1
010A  4F      		mov	c,a
010B  CDFC07  		call	xcmds
010E  CD9605  		call	belout
0111          		jr	prloop
0111  18E5    		DB	18H,prloop-$-1
		
0113          	docmd:
0113  CD9805  		call	conout
0116  7E      		mov	a,m
0117  23      		inx	h
0118  66      		mov	h,m
0119  6F      		mov	l,a
011A  E9      		pchl
		
011B          	cmdtab:
011B  47      		db	'G'
011C  5A01    		dw	cmdgo
011E  53      		db	'S'
011F  2405    		dw	cmdsub
0121  50      		db	'P'
0122  3A01    		dw	cmdpc
0124  42      		db	'B'
0125  A902    		dw	cmdboot
0127  4D      		db	'M'
0128  6306    		dw	cmdmt
012A  00      		db	0
		
			; patched-out code?
012B  00      		db	000h
012C  00      		db	000h
012D  00      		db	000h
012E  00      		db	000h
012F  00      		db	000h
0130  00      		db	000h
0131  00      		db	000h
0132  00      		db	000h
0133  00      		db	000h
0134  00      		db	000h
0135  00      		db	000h
0136  00      		db	000h
0137  C32204  		jmp	z47$dati
		
013A          	cmdpc:
013A  214600  		lxi	h,pcms
013D  CD3406  		call	msgout
0140  210C00  		lxi	h,12
0143  39      		dad	sp
0144  5E      		mov	e,m
0145  23      		inx	h
0146  56      		mov	d,m
0147  EB      		xchg
0148  CD6C05  		call	inhexcr
014B          		jrc	cmdpc0
014B  3807    		DB	38H,cmdpc0-$-1
014D  CDEB05  		call	adrnl
0150  CD6C05  		call	inhexcr
0153  D0      		rnc
0154          	cmdpc0:
0154  EB      		xchg
0155          	cmdpc1:
0155  160D    		mvi	d,CR
0157  C3A305  		jmp	adrin
		
015A          	cmdgo:
015A  211B00  		lxi	h,goms
015D  CD3406  		call	msgout
0160  210D00  		lxi	h,13
0163  39      		dad	sp
0164  CD6C05  		call	inhexcr
0167  DC5501  		cc	cmdpc1	; read HEX until CR
016A  CD2A06  		call	crlf
016D  3ED0    		mvi	a,0d0h	; no-beep, 2mS, !MON, !single-step
016F          		jr	cmdgo0
016F  1808    		DB	18H,cmdgo0-$-1
0171  F3      		di
0172  3A0920  		lda	ctl$F0
0175  EE10    		xri	010h	; toggle single-step
0177  D3F0    		out	0f0h
0179          	cmdgo0:
0179  320920  		sta	ctl$F0
017C  E1      		pop	h
017D  C3B200  		jmp	intret
		
0180          	int2$cont:
0180  F610    		ori	010h	; disable single-step
0182  D3F0    		out	0f0h
0184  12      		stax	d
0185  E620    		ani	020h	; MON active?
0187  C2ED00  		jnz	start	; break to monitor code
018A  C32220  		jmp	vrst2	; else chain to (possible) user code.
		
018D          	take$5:
018D  3E05    		mvi	a,5	; 5 seconds
018F          	take$A:
018F  219F01  		lxi	h,timeout
0192  222020  		shld	vrst1+1
0195  325221  		sta	SEC$CNT
0198  3E01    		mvi	a,1
019A  320820  		sta	l2008h
019D  FB      		ei
019E  C9      		ret
		
019F          	timeout:
019F  211B20  		lxi	h,ticcnt
01A2  AF      		xra	a
01A3  B6      		ora	m
01A4  C0      		rnz
01A5  23      		inx	h
01A6  7E      		mov	a,m
01A7  0F      		rrc
01A8  D8      		rc
			; every 512 ticks... 1024mS
01A9  215221  		lxi	h,SEC$CNT
01AC  35      		dcr	m
01AD  C0      		rnz
01AE          	error:
01AE  2A1D20  		lhld	monstk
01B1  F9      		sphl
01B2  212E00  		lxi	h,qmsg
01B5  CD3406  		call	msgout
01B8  21B700  		lxi	h,nulint
01BB  222020  		shld	vrst1+1
01BE  320820  		sta	l2008h
01C1  DBF2    		in	0f2h
01C3  E603    		ani	00000011b
01C5          		jrnz	error0
01C5  2002    		DB	20H,error0-$-1
01C7  D37F    		out	07fh
01C9          	error0:
01C9  C3E100  		jmp	re$entry
		
01CC          	chkauto:
01CC  215321  		lxi	h,l2153h	; auto-boot disable?
01CF  DBF2    		in	0f2h
01D1  57      		mov	d,a
01D2  EE80    		xri	080h	; toggle auto-boot
01D4  B6      		ora	m
01D5  F8      		rm		; auto-boot OFF
01D6  72      		mov	m,d	; ensure we only fail once... and only on power-up?
01D7  CD0C02  		call	gtdfbt
01DA  21E601  		lxi	h,autbms
01DD  CD3406  		call	msgout
01E0  318022  		lxi	sp,bootbf
01E3  C35603  		jmp	goboot0
		
01E6  4175746F	autbms:	db	'Auto Boot',TRM
      20426F6F
      7400
		
		; determine device for port 078H
		; return phy drv number in D.
01F0          	gtdev1:
01F0  1600    		mvi	d,0	; Z17
01F2  DBF2    		in	0f2h
01F4          	gtdev0:
01F4  E603    		ani	00000011b	; port 078H device
01F6  C8      		rz		; Z17 (or Z37)
01F7  FE01    		cpi	01b
01F9  1605    		mvi	d,5
01FB  C8      		rz		; Z47
01FC  FE02    		cpi	10b
01FE  1603    		mvi	d,3
0200  C8      		rz		; Z67/MMS77320
0201  C3AE01  		jmp	error	; fatal error... not defined
		
		; determine device for port 078H
		; return phy drv number in D.
0204          	gtdev2:
0204  162E    		mvi	d,46	; Z37
0206  DBF2    		in	0f2h
0208  0F      		rrc
0209  0F      		rrc
020A          		jr	gtdev0	; rest are same
020A  18E8    		DB	18H,gtdev0-$-1
		
		; determine default boot device.
020C          	gtdfbt:
020C  110000  		lxi	d,0
020F  DBF2    		in	0f2h
0211  E670    		ani	01110000b	; default boot selection
0213  FE20    		cpi	00100000b	; device at 07CH
0215          		jrz	gtdev1
0215  28D9    		DB	28H,gtdev1-$-1
0217  FE30    		cpi	00110000b	; device at 078H
0219          		jrz	gtdev2
0219  28E9    		DB	28H,gtdev2-$-1
021B  C32008  		jmp	gtdvtb		; get MMS device
		
		; Check SW501 for installed device.
		; C = desired port pattern, 00=Z17/Z37, 01=Z47, 10=Z67, 11=undefined
		; returns base I/O port adr in B.
021E          	getport:
021E  067C    		mvi	b,07ch
0220  DBF2    		in	0f2h
0222  E603    		ani	003h
0224  B9      		cmp	c
0225  C8      		rz
0226  0678    		mvi	b,078h
0228  DBF2    		in	0f2h
022A  0F      		rrc
022B  0F      		rrc
022C  E603    		ani	003h
022E  B9      		cmp	c
022F  C8      		rz
0230  E1      		pop	h	; discard return address
0231          	s501er:
0231  213702  		lxi	h,s501ms
0234  C33406  		jmp	msgout
		
0237  53573530	s501ms:	db	'SW501 wrong ',TRM
      31207772
      6F6E6720
      00
		
		; hack to support 3 drives on H17
0244          	m$sdp:
0244  3E0A    		mvi	a,10
0246  32B420  		sta	DECNT
0249  3A3121  		lda	AIO$UNI
024C  F5      		push	psw	; 0,1,2
024D  C6FE    		adi	-2	;
024F  CE03    		aci	3	; 1,2,4
0251  C33C1E  		jmp	R$SDP+10	; hacked R.SDP for 3-drives
		
0254          	inport0:
0254  B7      		ora	a	; NC
		; input from cport+CY
0255          	inportx:
0255  C5      		push	b
0256  3A5021  		lda	cport
0259  CE00    		aci	0
025B  4F      		mov	c,a
025C          		inp	a
025C  ED78    		DB	0EDH,a*8+40H
025E  C1      		pop	b
025F  C9      		ret
		
0260          	delay:
0260  E5      		push	h
0261  211B20  		lxi	h,ticcnt
0264  86      		add	m
0265          	delay0:
0265  BE      		cmp	m
0266          		jrnz	delay0
0266  20FD    		DB	20H,delay0-$-1
0268  E1      		pop	h
0269  C9      		ret
		
026A          	digerr:
026A  CD9605  		call	belout
026D          		jr	btdig0
026D  1806    		DB	18H,btdig0-$-1
		; Got a digit in boot command, parse it
026F          	btdig:	; boot by phys drive number, E=0
026F  CD9805  		call	conout	; echo digit
0272  E60F    		ani	00fh	; convert to binary
0274  57      		mov	d,a
0275          	btdig0:
0275  CD8705  		call	conin	; get another, until term char (C)
0278  B9      		cmp	c
0279          		jrz	gotnum
0279  281D    		DB	28H,gotnum-$-1
027B  FE30    		cpi	'0'
027D          		jrc	digerr
027D  38EB    		DB	38H,digerr-$-1
027F  FE3A    		cpi	'9'+1
0281          		jrnc	digerr
0281  30E7    		DB	30H,digerr-$-1
0283  CD9805  		call	conout
0286  E60F    		ani	00fh
0288  060A    		mvi	b,10	; add 10 times, i.e. D = (D * 10) + A
028A          	btdig1:
028A  82      		add	d
028B  DAAE01  		jc	error
028E          		djnz	btdig1
028E  10FA    		DB	10H,btdig1-$-1
0290  57      		mov	d,a
0291  FEC8    		cpi	200
0293  D2AE01  		jnc	error
0296          		jr	btdig0
0296  18DD    		DB	18H,btdig0-$-1
		
0298          	gotnum:	; Boot N... "N" in D
0298  7A      		mov	a,d
0299  FE05    		cpi	5
029B  DA5303  		jc	goboot
029E  FE09    		cpi	9
02A0  D25303  		jnc	goboot
02A3  C6C8    		adi	200	; modify 5..8 to not conflict
02A5  57      		mov	d,a
02A6  C35303  		jmp	goboot
		
02A9          	cmdboot:
02A9  210300  		lxi	h,bootms
02AC  CD3406  		call	msgout	; complete (B)oot
02AF  3EC3    		mvi	a,0c3h
02B1  328022  		sta	bootbf	; mark "no string"
02B4  318022  		lxi	sp,bootbf
02B7  CD0C02  		call	gtdfbt
02BA  0E0D    		mvi	c,CR	; end input on CR
02BC          		jr	boot0
02BC  1803    		DB	18H,boot0-$-1
02BE          	bterr:
02BE  CD9605  		call	belout
02C1          	boot0:
02C1  CD8705  		call	conin
02C4  B9      		cmp	c
02C5  CA5303  		jz	goboot
02C8  1E00    		mvi	e,0
02CA  FE30    		cpi	'0'
02CC          		jrc	nodig
02CC  3804    		DB	38H,nodig-$-1
02CE  FE3A    		cpi	'9'+1
02D0          		jrc	btdig
02D0  389D    		DB	38H,btdig-$-1
02D2          	nodig:	; boot by letter... Boot alpha-
02D2  E65F    		ani	05fh ; toupper
02D4  FE5B    		cpi	'Z'+1
02D6          		jrnc	bterr
02D6  30E6    		DB	30H,bterr-$-1
02D8  FE41    		cpi	'A'
02DA          		jrc	bterr
02DA  38E2    		DB	38H,bterr-$-1
02DC  CD9805  		call	conout
02DF  CD9805  		call	conout
02E2  FE42    		cpi	'B'
02E4          		jrc	gotit	; 'A' is synonym for default
02E4  3816    		DB	38H,gotit-$-1
02E6  211A06  		lxi	h,bootb1	; Heath/Zenith device letters
02E9  47      		mov	b,a
02EA          	luboot:
02EA  7E      		mov	a,m
02EB  23      		inx	h
02EC  56      		mov	d,m
02ED  23      		inx	h
02EE  B8      		cmp	b
02EF          		jrz	gotit
02EF  280B    		DB	28H,gotit-$-1
02F1  B7      		ora	a
02F2          		jrnz	luboot
02F2  20F6    		DB	20H,luboot-$-1
02F4  1600    		mvi	d,0
02F6  CD5208  		call	mmslookup
02F9  DAAE01  		jc	error
02FC          	gotit:
02FC  3E2D    		mvi	a,'-'	; next is optional unit number...
02FE  CD9805  		call	conout
0301          		jr	luboot0
0301  1803    		DB	18H,luboot0-$-1
		
0303          	lunerr:
0303  CD9605  		call	belout
0306          	luboot0:
0306  CD8705  		call	conin
0309  B9      		cmp	c
030A          		jrz	goboot
030A  2847    		DB	28H,goboot-$-1
030C  FE3A    		cpi	':'
030E          		jrz	colon
030E  2827    		DB	28H,colon-$-1
0310  FE20    		cpi	' '
0312          		jrz	space
0312  281E    		DB	28H,space-$-1
0314  FE30    		cpi	'0'
0316          		jrc	lunerr
0316  38EB    		DB	38H,lunerr-$-1
0318  FE3A    		cpi	'9'+1
031A          		jrnc	lunerr
031A  30E7    		DB	30H,lunerr-$-1
031C  CD9805  		call	conout
031F  D630    		sui	'0'
0321  5F      		mov	e,a	; single digit (0..9)
0322          	luboot1:
0322  CD8705  		call	conin
0325  B9      		cmp	c
0326          		jrz	goboot
0326  282B    		DB	28H,goboot-$-1
0328  FE3A    		cpi	':'	; Boot alpha-dig:str
032A          		jrz	colon
032A  280B    		DB	28H,colon-$-1
032C  FE20    		cpi	' '	; cosmetic spaces?
032E          		jrz	space
032E  2802    		DB	28H,space-$-1
0330  3E07    		mvi	a,BEL
0332          	space:
0332  CD9805  		call	conout
0335          		jr	luboot1
0335  18EB    		DB	18H,luboot1-$-1
		
0337          	colon:	; get arbitrary string as last boot param
0337  0600    		mvi	b,0
0339  218022  		lxi	h,bootbf
033C          	btstr0:
033C  CD9805  		call	conout
033F  CD8705  		call	conin
0342  04      		inr	b
0343  23      		inx	h
0344  77      		mov	m,a
0345  B9      		cmp	c
0346          		jrnz	btstr0
0346  20F4    		DB	20H,btstr0-$-1
0348  78      		mov	a,b
0349  328022  		sta	bootbf	; bootbf: <len> <string...> as in CP/M cmd buf
034C  AF      		xra	a	; TRM - string terminator
034D          	btstr1:	; use stack as char array...
034D  F5      		push	psw
034E  33      		inx	sp	; undo half of push
034F  2B      		dcx	h
0350  7E      		mov	a,m
0351          		djnz	btstr1
0351  10FA    		DB	10H,btstr1-$-1
		; D=Phys Drive base number, E=Unit number
		; (or, D=Phys Drive unit, E=0)
0353          	goboot:
0353  CD2A06  		call	crlf
0356          	goboot0:
0356  21AE01  		lxi	h,error
0359  E5      		push	h
035A  CDB707  		call	h17init
035D  7B      		mov	a,e
035E  323121  		sta	AIO$UNI	; relative unit num
0361  82      		add	d
0362  323420  		sta	l2034h	; boot phys drv unit num
0365  7A      		mov	a,d
0366  FE03    		cpi	3	; 0,1,2
0368          		jrc	bz17	; Z17 boot
0368  3809    		DB	38H,bz17-$-1
			; 3,4 not used?
036A  D605    		sui	5
036C  FE04    		cpi	4	; 5,6,7,8
036E          		jrc	bz47	; Z47 boot
036E  3847    		DB	38H,bz47-$-1
0370  C30808  		jmp	exboot	;
		
0373          	bz17:
0373  83      		add	e
0374  FE03    		cpi	3
0376  D0      		rnc	; invalid Z17 drive
0377  323121  		sta	AIO$UNI
037A  DBF2    		in	0f2h
037C  E603    		ani	00000011b
037E  C23102  		jnz	s501er	; no Z17 installed
0381  3E7C    		mvi	a,07ch
0383  325021  		sta	cport
0386  214402  		lxi	h,m$sdp
0389  228620  		shld	D$CONST+62
038C  3E0A    		mvi	a,10
038E  47      		mov	b,a	; B = 10, one full revolution?
038F  CD8F01  		call	take$A	; error after 10 seconds...
0392  CD4402  		call	m$sdp	; hacked R.SDP - setup dev parms (select drive)
0395          	bz17$0:
0395  CD9D1E  		call	R$WHD	; WHD - wait hole detect
0398  CDB91E  		call	R$WNH	; WNH - wait no hole
039B          		djnz	bz17$0	; essentially hang until user inserts a disk...
039B  10F8    		DB	10H,bz17$0-$-1
039D  CDF61B  		call	R$ABORT	; R.ABORT - reset everything
03A0  118022  		lxi	d,bootbf	; DMA address
03A3  010009  		lxi	b,00900h	; B = 9 (num sectors), C = 0 (residual bytes to read)
03A6  210000  		lxi	h,0		; track/sector number to start
03A9  CD3F1C  		call	R$READ
03AC  D8      		rc
03AD  E1      		pop	h
03AE          	hxboot:
03AE  21191C  		lxi	h,CLOCK	; CLOCK - standard 2mS handler
03B1  222020  		shld	vrst1+1 ; normal TICK intr routine
03B4  C38022  		jmp	bootbf	; run boot code...
		
03B7          	bz47:
03B7  83      		add	e
03B8  FE04    		cpi	004h
03BA  D0      		rnc
03BB  0F      		rrc
03BC  0F      		rrc
03BD  0F      		rrc
03BE  3C      		inr	a
03BF  5F      		mov	e,a
03C0  0E01    		mvi	c,01b
03C2  CD1E02  		call	getport
03C5  78      		mov	a,b
03C6  325021  		sta	cport
03C9  CD8D01  		call	take$5	; error out after 5 seconds...
03CC  3E02    		mvi	a,2
03CE  CD1404  		call	outport0
03D1  3E02    		mvi	a,2
03D3  CD0704  		call	z47$cmdo
03D6  7B      		mov	a,e
03D7  CD0304  		call	z47$dato
03DA  CD2204  		call	z47$dati
03DD  E60C    		ani	00ch
03DF  0F      		rrc
03E0  0F      		rrc
03E1  3C      		inr	a
03E2  47      		mov	b,a
03E3  3E01    		mvi	a,1
03E5          	bz47$0:
03E5  87      		add	a
03E6          		djnz	bz47$0
03E6  10FD    		DB	10H,bz47$0-$-1
03E8  1F      		rar
03E9  47      		mov	b,a
03EA  218022  		lxi	h,bootbf
03ED  C5      		push	b
03EE  CD2B04  		call	z47$read
03F1  C1      		pop	b
03F2  1C      		inr	e
03F3  CD2B04  		call	z47$read
03F6  CD5402  		call	inport0
03F9  E601    		ani	001h
03FB  C0      		rnz
03FC          	hwboot:
03FC  AF      		xra	a
03FD  320820  		sta	l2008h
0400  C3AE03  		jmp	hxboot
		
0403          	z47$dato:
0403  1680    		mvi	d,080h	; TR - date transfer request
0405          		jr	z47$out0
0405  1802    		DB	18H,z47$out0-$-1
0407          	z47$cmdo:
0407  1620    		mvi	d,020h	; DONE
0409          	z47$out0:
0409  37      		stc
040A  F5      		push	psw
040B          	z47$wt0:
040B  CD5402  		call	inport0
040E  A2      		ana	d
040F          		jrz	z47$wt0
040F  28FA    		DB	28H,z47$wt0-$-1
0411  F1      		pop	psw
0412          		jr	z47$out1
0412  1801    		DB	18H,z47$out1-$-1
0414          	outport0:
0414  B7      		ora	a
0415          	z47$out1:
0415  C5      		push	b
0416  47      		mov	b,a
0417  3A5021  		lda	cport
041A  CE00    		aci	0
041C  4F      		mov	c,a
041D  78      		mov	a,b
041E          		outp	a
041E  ED79    		DB	0EDH,a*8+41H
0420  C1      		pop	b
0421  C9      		ret
		
0422          	z47$dati:
0422  CD5402  		call	inport0
0425  07      		rlc	; TR
0426          		jrnc	z47$dati
0426  30FA    		DB	30H,z47$dati-$-1
0428  C35502  		jmp	inportx	; CY=1, input cport+1
		
042B          	z47$read:
042B  3E07    		mvi	a,7	; read thru buffer command
042D  CD0704  		call	z47$cmdo
0430  AF      		xra	a
0431  CD0304  		call	z47$dato	; params
0434  7B      		mov	a,e
0435  CD0304  		call	z47$dato	; params
0438          	z47$rd0:
0438  0E80    		mvi	c,128
043A          	z47$rd1:
043A  CD2204  		call	z47$dati
043D  77      		mov	m,a
043E  23      		inx	h
043F  0D      		dcr	c
0440          		jrnz	z47$rd1
0440  20F8    		DB	20H,z47$rd1-$-1
0442  05      		dcr	b
0443          		jrnz	z47$rd0
0443  20F3    		DB	20H,z47$rd0-$-1
0445  C9      		ret
		
		; ROM start point - initialize everything
0446          	init:
			; find amount of RAM
0446  21001F  		lxi	h,ramstart-0100h
0449          	ramsiz:
0449  24      		inr	h
044A  7E      		mov	a,m
044B  34      		inr	m
044C  BE      		cmp	m
044D  77      		mov	m,a
044E          		jrnz	ramsiz
044E  20F9    		DB	20H,ramsiz-$-1
0450  2B      		dcx	h
0451  F9      		sphl		; set SP to top of RAM (-1)
0452  E5      		push	h	; save top on stack
0453  21E100  		lxi	h,re$entry
0456  E5      		push	h
			; determine H19 BAUD, by experimentation
0457  0E03    		mvi	c,003h	; br38400
0459          	baud0:
0459  3E83    		mvi	a,083h
045B  D3EB    		out	0ebh
045D  AF      		xra	a
045E  D3E9    		out	0e9h
0460  79      		mov	a,c
0461  D3E8    		out	0e8h
0463  07      		rlc
0464  4F      		mov	c,a
0465  3E03    		mvi	a,003h
0467  D3EB    		out	0ebh
0469  AF      		xra	a
046A  D3E9    		out	0e9h
046C  DBE8    		in	0e8h
046E  210705  		lxi	h,initms	; ask H19 for response...
0471  CD3406  		call	msgout
0474  0619    		mvi	b,25	; loop 6400 times... let Rx overrun...
0476          	baud1:
0476  3D      		dcr	a
0477          		jrnz	baud1	; 4096 cycles each
0477  20FD    		DB	20H,baud1-$-1
0479          		djnz	baud1	; +13 * 25... 102725 cycles, about 50mS
0479  10FB    		DB	10H,baud1-$-1
047B  DBED    		in	0edh
047D  1F      		rar
047E  DBE8    		in	0e8h
0480  17      		ral
0481  D697    		sui	097h
0483          		jrnz	baud0
0483  20D4    		DB	20H,baud0-$-1
0485  23      		inx	h
0486  CD3406  		call	msgout
0489  060F    		mvi	b,15	; 15*256 = 3840 loops
048B          	baud2:
048B  3D      		dcr	a
048C          		jrnz	baud2
048C  20FD    		DB	20H,baud2-$-1
048E          		djnz	baud2
048E  10FB    		DB	10H,baud2-$-1
0490  3E0F    		mvi	a,00001111b	; all outputs ON
0492  D3EC    		out	0ech		; OUT2=1 hides 16C2550 intr enable diff
			; compute checksum, compare
0494  010000  		lxi	b,rombeg
0497          		exx
0497  D9      		DB	0D9H
0498  11FC0F  		lxi	d,romend-rombeg
049B  210000  		lxi	h,0
049E  0600    		mvi	b,0
04A0          	cksum0:
04A0          		exx
04A0  D9      		DB	0D9H
04A1  0A      		ldax	b
04A2  03      		inx	b
04A3          		exx
04A3  D9      		DB	0D9H
04A4  4F      		mov	c,a
04A5  09      		dad	b
04A6  1B      		dcx	d
04A7  7A      		mov	a,d
04A8  B3      		ora	e
04A9  C2A004  		jnz	cksum0
04AC          		lded	chksum
04AC  ED5B    		DB	0EDH,5BH
04AE  FE0F    		DW	chksum
04B0          		dsbc	d
04B0  ED52    		DB	0EDH,d*8+42H
04B2  CABD04  		jz	rom$ok
04B5  21A30F  		lxi	h,erprom
04B8          	msg$die:
04B8  CD3406  		call	msgout
04BB  F3      		di
04BC  76      		hlt
04BD          	rom$ok:
04BD  AF      		xra	a
04BE  325321  		sta	l2153h
04C1  323620  		sta	ctl$F2	; 2mS, Org0 OFF
04C4  3EC9    		mvi	a,0c9h	; RET
04C6  320420  		sta	l2004h
04C9  210050  		lxi	h,05000h	; 0, (beep, 2mS, !MON, !SI)
04CC  220820  		shld	l2008h
04CF  CF      		rst	1	; kick-start clock
04D0  211B20  		lxi	h,ticcnt
04D3  11C800  		lxi	d,0280h-440	; tuned to produce ~0x280 for 2.048MHz
04D6  7E      		mov	a,m
04D7          	tick0:	; wait for next tick of clock...
04D7  BE      		cmp	m
04D8          		jrz	tick0
04D8  28FD    		DB	28H,tick0-$-1
04DA  C605    		adi	5	; +10mS (actually, +8mS from new tick)
04DC          	tick1:
04DC  13      		inx	d	; count CPU cycles for 8mS...
04DD  BE      		cmp	m	; but note: 2mS interrupt overhead,
04DE  BE      		cmp	m	; so count will be low.
04DF          		jrnz	tick1	; each loop = 32 cycles
04DF  20FB    		DB	20H,tick1-$-1
04E1  7A      		mov	a,d
04E2  FE02    		cpi	2	; min 9984 cycles... 1.248MHz...
					; max 18144 cycles... 2.268MHz
04E4          		jrz	intsetup
04E4  2806    		DB	28H,intsetup-$-1
			; Unsupported CPU speed...
04E6  211305  		lxi	h,unsupm
04E9  CD3406  		call	msgout
		
04EC          	intsetup:
04EC  E3      		xthl
04ED  D5      		push	d
04EE  C5      		push	b
04EF  F5      		push	psw
04F0  EB      		xchg
04F1  210A00  		lxi	h,10
04F4  39      		dad	sp
04F5  E5      		push	h
04F6  D5      		push	d
04F7  110920  		lxi	d,ctl$F0
04FA  1A      		ldax	d
04FB  2F      		cma
04FC  E630    		ani	030h
04FE  C8      		rz
04FF  210200  		lxi	h,2
0502  39      		dad	sp
0503  221D20  		shld	monstk
0506  C9      		ret
		
0507  801B5B3F	initms:	db	080h,ESC,'[?2h',ESC,'Z',TRM
      32681B5A
      00
0510  1B7A00  		db	ESC,'z',TRM
		
0513  556E7375	unsupm:	db	'Unsupp CPU speed',TRM
      70702043
      50552073
      70656564
      00
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Substitute command
0524          	cmdsub:
0524  213B00  		lxi	h,subms
0527  CD3406  		call	msgout
052A  210320  		lxi	h,l2003h
052D  160D    		mvi	d,CR
052F  CDA305  		call	adrin
0532  EB      		xchg
0533          	cmdsub0:
0533  CDEB05  		call	adrnl
0536  7E      		mov	a,m
0537  CDFA05  		call	hexout
053A  CDF605  		call	spout
053D          	cmdsub1:
053D  CDD805  		call	hexin
0540          		jrnc	cmdsub4
0540  3019    		DB	30H,cmdsub4-$-1
0542  FE0D    		cpi	CR
0544          		jrz	cmdsub2
0544  280C    		DB	28H,cmdsub2-$-1
0546  FE2D    		cpi	'-'
0548          		jrz	cmdsub3
0548  280B    		DB	28H,cmdsub3-$-1
054A  FE2E    		cpi	'.'
054C  C8      		rz
054D  CD9605  		call	belout
0550          		jr	cmdsub1
0550  18EB    		DB	18H,cmdsub1-$-1
0552          	cmdsub2:
0552  23      		inx	h
0553          		jr	cmdsub0
0553  18DE    		DB	18H,cmdsub0-$-1
0555          	cmdsub3:
0555  CD9805  		call	conout
0558  2B      		dcx	h
0559          		jr	cmdsub0
0559  18D8    		DB	18H,cmdsub0-$-1
055B          	cmdsub4:
055B  3600    		mvi	m,000h
055D          	cmdsub5:
055D  CD9805  		call	conout
0560  CDCF05  		call	hexbin
0563          		rld
0563  ED6F    		DB	0EDH, 6FH
0565  CD6C05  		call	inhexcr
0568          		jrnc	cmdsub2
0568  30E8    		DB	30H,cmdsub2-$-1
056A          		jr	cmdsub5
056A  18F1    		DB	18H,cmdsub5-$-1
		
056C          	inhexcr:
056C  CD8705  		call	conin
056F  FE0D    		cpi	CR
0571  C8      		rz
0572  CDDB05  		call	hexchk
0575  3F      		cmc
0576  D8      		rc
0577  CD9605  		call	belout
057A          		jr	inhexcr
057A  18F0    		DB	18H,inhexcr-$-1
		
		; This loop checks for auto boot while waiting for command input.
		; Theoretically, one could flip the auto-boot dipsw at the MMS: prompt?
057C          	coninx0:
057C  CDCC01  		call	chkauto
057F  CDFB07  		call	nulfn	; some patched-out code?
0582          	coninx:
0582  DBED    		in	0edh
0584  0F      		rrc
0585          		jrnc	coninx0
0585  30F5    		DB	30H,coninx0-$-1
0587          	conin:
0587  DBED    		in	0edh
0589  0F      		rrc
058A          		jrnc	conin
058A  30FB    		DB	30H,conin-$-1
058C  DBE8    		in	0e8h
058E  E67F    		ani	07fh
0590  FE7F    		cpi	DEL	; DEL key restarts from anywhere?
0592  CAE100  		jz	re$entry
0595  C9      		ret
		
0596          	belout:
0596  3E07    		mvi	a,BEL
0598          	conout:
0598  F5      		push	psw
0599          	conot1:
0599  DBED    		in	0edh
059B  E620    		ani	00100000b
059D          		jrz	conot1
059D  28FA    		DB	28H,conot1-$-1
059F  F1      		pop	psw
05A0  D3E8    		out	0e8h
05A2  C9      		ret
		
		; D=term char (e.g. '.' for Substitute)
		; HL=location to store address
05A3          	adrin:
05A3  E5      		push	h
05A4  210000  		lxi	h,0
05A7          	adrin0:
05A7  D48705  		cnc	conin
05AA  CDDB05  		call	hexchk
05AD          		jrc	adrin1
05AD  380E    		DB	38H,adrin1-$-1
05AF  CD9805  		call	conout
05B2  CDCF05  		call	hexbin
05B5  29      		dad	h
05B6  29      		dad	h
05B7  29      		dad	h
05B8  29      		dad	h
05B9  B5      		ora	l
05BA  6F      		mov	l,a
05BB          		jr	adrin0
05BB  18EA    		DB	18H,adrin0-$-1
05BD          	adrin1:
05BD  BA      		cmp	d
05BE          		jrz	adrin2
05BE  2806    		DB	28H,adrin2-$-1
05C0  CD9605  		call	belout
05C3  B7      		ora	a
05C4          		jr	adrin0
05C4  18E1    		DB	18H,adrin0-$-1
05C6          	adrin2:
05C6  CD9805  		call	conout
05C9  EB      		xchg
05CA  E1      		pop	h
05CB  72      		mov	m,d
05CC  2B      		dcx	h
05CD  73      		mov	m,e
05CE  C9      		ret
		
05CF          	hexbin:
05CF  D63A    		sui	'9'+1
05D1          		jrnc	hexbi0
05D1  3002    		DB	30H,hexbi0-$-1
05D3  C607    		adi	7
05D5          	hexbi0:
05D5  C603    		adi	3
05D7  C9      		ret
		
05D8          	hexin:
05D8  CD8705  		call	conin
05DB          	hexchk:
05DB  FE30    		cpi	'0'
05DD  D8      		rc	
05DE  FE3A    		cpi	'9'+1
05E0  3F      		cmc
05E1  D0      		rnc
05E2  E65F    		ani	05fh	; toupper
05E4  FE41    		cpi	'A'
05E6  D8      		rc	
05E7  FE47    		cpi	'F'+1
05E9  3F      		cmc
05EA  C9      		ret
		
05EB          	adrnl:
05EB  CD2A06  		call	crlf
05EE          	adrout:
05EE  7C      		mov	a,h
05EF  CDFA05  		call	hexout
05F2  7D      		mov	a,l
05F3  CDFA05  		call	hexout
05F6          	spout:
05F6  3E20    		mvi	a,' '
05F8          		jr	conout
05F8  189E    		DB	18H,conout-$-1
		
05FA          	hexout:
05FA  F5      		push	psw
05FB  07      		rlc
05FC  07      		rlc
05FD  07      		rlc
05FE  07      		rlc
05FF  CD0306  		call	hexdig
0602  F1      		pop	psw
0603          	hexdig:
0603  E60F    		ani	00fh
0605  C690    		adi	090h
0607  27      		daa
0608  CE40    		aci	040h
060A  27      		daa
060B          		jr	conout
060B  188B    		DB	18H,conout-$-1
		
		; Special entry points expected by HDOS, or maybe Heath CP/M boot.
			rept	0613h-$
060D  00      		db	0
060E  00      		db	0
060F  00      		db	0
0610  00      		db	0
0611  00      		db	0
0612  00      		db	0
0000          	if	($ <> 0613h)
		endif
0613  C30304  		jmp	z47$dato ; Must be at 0613
0616  00      		db	0
0617  C30704  		jmp	z47$cmdo ; Must be at 0617
		
		; Heath/Zenith device boot table
061A          	bootb1:
061A  4200    		db	'B',0	; Z17
061C  432E    		db	'C',46	; Z37
061E  4405    		db	'D',5	; Z47
0620  4503    		db	'E',3	; Z67
0622  00      		db	0
		
0623          	waitcr:
0623  CD8705  		call	conin
0626  FE0D    		cpi	CR
0628          		jrnz	waitcr
0628  20F9    		DB	20H,waitcr-$-1
062A          	crlf:
062A  3E0D    		mvi	a,CR
062C  CD9805  		call	conout
062F  3E0A    		mvi	a,LF
0631  C39805  		jmp	conout
		
0634          	msgout:
0634  7E      		mov	a,m
0635  B7      		ora	a
0636  C8      		rz
0637  CD9805  		call	conout
063A  23      		inx	h
063B          		jr	msgout
063B  18F7    		DB	18H,msgout-$-1
		
063D          	cserr:
063D  214306  		lxi	h,cserms
0640  C33406  		jmp	msgout
		
0643  07436865	cserms:	db	BEL,'Checksum error',TRM
      636B7375
      6D206572
      726F7200
		
0653  546F7020	topms:	db	'Top of Memory: ',TRM
      6F66204D
      656D6F72
      793A2000
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Memory Test command
0663          	cmdmt:
0663  215600  		lxi	h,mtms
0666  CD3406  		call	msgout
0669  CD2306  		call	waitcr
066C  215306  		lxi	h,topms
066F  CD3406  		call	msgout
0672  210000  		lxi	h,0
0675  39      		dad	sp
0676  7C      		mov	a,h
0677  3C      		inr	a
0678          		jrz	cmdmt0
0678  2802    		DB	28H,cmdmt0-$-1
067A  D620    		sui	020h
067C          	cmdmt0:
067C  67      		mov	h,a
067D  2E00    		mvi	l,0
067F  2B      		dcx	h
0680  D630    		sui	'0'
0682  5F      		mov	e,a
0683  CDEE05  		call	adrout
0686  CD2A06  		call	crlf
0689  1600    		mvi	d,000h
068B  0E30    		mvi	c,030h
068D  0600    		mvi	b,000h
068F          		exx
068F  D9      		DB	0D9H
0690  21BC06  		lxi	h,mtest0
0693  11F12F  		lxi	d,memtest - (mtest1-mtest0)
0696  01FB00  		lxi	b,mtestZ-mtest0
0699          		ldir
0699  EDB0    		DB	0EDH,0B0H
069B  110030  		lxi	d,memtest
069E  21CB06  		lxi	h,mtest1
06A1  0EEC    		mvi	c,mtestZ-mtest1
06A3  AF      		xra	a
06A4          		exaf
06A4  08      		DB	08H
06A5  AF      		xra	a
06A6          	cmdmt1:
06A6  86      		add	m
06A7          		exaf
06A7  08      		DB	08H
06A8  EB      		xchg
06A9  86      		add	m
06AA          		exaf
06AA  08      		DB	08H
06AB  EB      		xchg
06AC  23      		inx	h
06AD  13      		inx	d
06AE  0D      		dcr	c
06AF  C2A606  		jnz	cmdmt1
06B2  4F      		mov	c,a
06B3          		exaf
06B3  08      		DB	08H
06B4  B9      		cmp	c
06B5  C23D06  		jnz	cserr
06B8  F3      		di
06B9  C3F82F  		jmp	memtest - (mtest1-mtest)
		
		;------------------------------------------------
		; Start of relocated code...
		; Memory Test routine, position-endependent
		;
06BC  040C0408	mtest0:	db	04h,0ch,04h,08h,0ch,08h,20h
      0C0820
		
06C3          	mtest:
06C3  21F12F  		lxi	h,memtest - (mtest1-mtest0)
06C6  01F207  		lxi	b,0700h + 0f2h	; length of unlock sequence, GPIO port
06C9          		outir
06C9  EDB3    		DB	0EDH,0B3H
06CB          	mtest1:		; lands at 03000h - retained relocated code
06CB          		exx
06CB  D9      		DB	0D9H
06CC  62      		mov	h,d
06CD  2E00    		mvi	l,0
06CF  78      		mov	a,b
06D0          		exx
06D0  D9      		DB	0D9H
06D1  4F      		mov	c,a
06D2  0602    		mvi	b,2
06D4          	mtest2:
06D4  79      		mov	a,c
06D5  07      		rlc
06D6  07      		rlc
06D7  07      		rlc
06D8  07      		rlc
06D9  4F      		mov	c,a
06DA  E60F    		ani	00fh
06DC  C690    		adi	090h
06DE  27      		daa
06DF  CE40    		aci	040h
06E1  27      		daa
06E2  D3E8    		out	0e8h
06E4          	mtest3:
06E4  DBED    		in	0edh
06E6  E620    		ani	020h
06E8          		jrz	mtest3
06E8  28FA    		DB	28H,mtest3-$-1
06EA  05      		dcr	b
06EB          		jrnz	mtest2
06EB  20E7    		DB	20H,mtest2-$-1
06ED  3E0D    		mvi	a,CR
06EF  D3E8    		out	0e8h
06F1          		exx
06F1  D9      		DB	0D9H
06F2  78      		mov	a,b
06F3          	mtest4:
06F3  77      		mov	m,a
06F4  C601    		adi	1
06F6  27      		daa
06F7  2C      		inr	l
06F8          		jrnz	mtest4
06F8  20F9    		DB	20H,mtest4-$-1
06FA  24      		inr	h
06FB  0D      		dcr	c
06FC          		jrnz	mtest4
06FC  20F5    		DB	20H,mtest4-$-1
06FE  7C      		mov	a,h
06FF  92      		sub	d
0700  4F      		mov	c,a
0701  62      		mov	h,d
0702  2E00    		mvi	l,0
0704  78      		mov	a,b
0705          	mtest5:
0705  BE      		cmp	m
0706          		jrnz	mtest9
0706  2046    		DB	20H,mtest9-$-1
0708  C601    		adi	1
070A  27      		daa
070B  2C      		inr	l
070C          		jrnz	mtest5
070C  20F7    		DB	20H,mtest5-$-1
070E  24      		inr	h
070F  0D      		dcr	c
0710          		jrnz	mtest5
0710  20F3    		DB	20H,mtest5-$-1
0712          		exx
0712  D9      		DB	0D9H
0713  210030  		lxi	h,memtest
0716  110000  		lxi	d,0
0719  01EC00  		lxi	b,mtestZ-mtest1
071C          		exx
071C  D9      		DB	0D9H
071D  7A      		mov	a,d
071E  EE30    		xri	030h
0720  57      		mov	d,a
0721          		jrz	mtest6
0721  2803    		DB	28H,mtest6-$-1
0723  4B      		mov	c,e
0724          		jr	mtest7
0724  180A    		DB	18H,mtest7-$-1
0726          	mtest6:
0726  0E30    		mvi	c,030h
0728  3E01    		mvi	a,001h
072A  80      		add	b
072B  27      		daa
072C  47      		mov	b,a
072D          		exx
072D  D9      		DB	0D9H
072E  EB      		xchg
072F          		exx
072F  D9      		DB	0D9H
0730          	mtest7:
0730          		exx
0730  D9      		DB	0D9H
0731          		ldir
0731  EDB0    		DB	0EDH,0B0H
0733  7A      		mov	a,d
0734  E6F0    		ani	0f0h
0736  67      		mov	h,a
0737  2E00    		mvi	l,0
0739  0EEC    		mvi	c,mtestZ-mtest1
073B  AF      		xra	a
073C          	mtest8:
073C  86      		add	m
073D  23      		inx	h
073E  0D      		dcr	c
073F          		jrnz	mtest8
073F  20FB    		DB	20H,mtest8-$-1
0741  4F      		mov	c,a
0742          		exaf
0742  08      		DB	08H
0743  B9      		cmp	c
0744          		jrnz	mtestE
0744  2049    		DB	20H,mtestE-$-1
0746          		exaf
0746  08      		DB	08H
0747  7A      		mov	a,d
0748  E6F0    		ani	0f0h
074A  67      		mov	h,a
074B  2E00    		mvi	l,0
074D  E9      		pchl
074E          	mtest9:
074E  AE      		xra	m
074F  57      		mov	d,a
0750  3E0A    		mvi	a,LF
0752  D3E8    		out	0e8h
0754          	mtestA:
0754  DBED    		in	0edh
0756  E620    		ani	020h
0758          		jrz	mtestA
0758  28FA    		DB	28H,mtestA-$-1
075A  0E02    		mvi	c,2
075C  0604    		mvi	b,4
075E          	mtestB:
075E  7C      		mov	a,h
075F  07      		rlc
0760  07      		rlc
0761  07      		rlc
0762  07      		rlc
0763  E60F    		ani	00fh
0765  C690    		adi	090h
0767  27      		daa
0768  CE40    		aci	040h
076A  27      		daa
076B  D3E8    		out	0e8h
076D          	mtestC:
076D  DBED    		in	0edh
076F  E620    		ani	020h
0771          		jrz	mtestC
0771  28FA    		DB	28H,mtestC-$-1
0773  29      		dad	h
0774  29      		dad	h
0775  29      		dad	h
0776  29      		dad	h
0777          		djnz	mtestB
0777  10E5    		DB	10H,mtestB-$-1
0779  3E20    		mvi	a,' '
077B  D3E8    		out	0e8h
077D          	mtestD:
077D  DBED    		in	0edh
077F  E620    		ani	020h
0781          		jrz	mtestD
0781  28FA    		DB	28H,mtestD-$-1
0783  0D      		dcr	c
0784  EB      		xchg
0785  0602    		mvi	b,002h
0787          		jrnz	mtestB
0787  20D5    		DB	20H,mtestB-$-1
0789  3E2A    		mvi	a,'*'
078B  D3E8    		out	0e8h
078D          		jr	mtestG
078D  1814    		DB	18H,mtestG-$-1
078F          	mtestE:
078F  DBED    		in	0edh
0791  E620    		ani	020h
0793          		jrz	mtestE
0793  28FA    		DB	28H,mtestE-$-1
0795  3E0A    		mvi	a,LF
0797  D3E8    		out	0e8h
0799          	mtestF:
0799  DBED    		in	0edh
079B  E620    		ani	020h
079D          		jrz	mtestF
079D  28FA    		DB	28H,mtestF-$-1
079F  3E21    		mvi	a,'!'
07A1  D3E8    		out	0e8h
07A3          	mtestG:
07A3  DBED    		in	0edh
07A5  E620    		ani	020h
07A7          		jrz	mtestG
07A7  28FA    		DB	28H,mtestG-$-1
07A9  AF      		xra	a
07AA  06FA    		mvi	b,0fah
07AC          	mtestH:
07AC  3D      		dcr	a
07AD          		jrnz	mtestH
07AD  20FD    		DB	20H,mtestH-$-1
07AF          		djnz	mtestH
07AF  10FB    		DB	10H,mtestH-$-1
07B1  3E07    		mvi	a,BEL
07B3  D3E8    		out	0e8h
07B5          		jr	mtestG
07B5  18EC    		DB	18H,mtestG-$-1
		; End of relocated code
07B7          	mtestZ	equ	$
		;------------------------------------------------
		
		; returns with interrupts disabled
07B7          	h17init:
07B7  F3      		di
07B8  AF      		xra	a
07B9  D37F    		out	07fh
07BB  D5      		push	d
07BC  210920  		lxi	h,ctl$F0
07BF  36D0    		mvi	m,0d0h	; !beep, 2mS, !mon, !SI
07C1  215A1F  		lxi	h,R$CONST
07C4  114820  		lxi	d,D$CONST
07C7  015800  		lxi	b,88
07CA          		ldir
07CA  EDB0    		DB	0EDH,0B0H
07CC  6B      		mov	l,e
07CD  62      		mov	h,d
07CE  13      		inx	d
07CF  0E1E    		mvi	c,30
07D1  77      		mov	m,a
07D2          		ldir	; fill l20a0h...
07D2  EDB0    		DB	0EDH,0B0H
07D4  3C      		inr	a	; A=1
07D5  211F20  		lxi	h,intvec	; vector area
07D8          	h17ini0:
07D8  36C3    		mvi	m,0c3h
07DA  23      		inx	h
07DB  36B7    		mvi	m,LOW (nulint-rst0)
07DD  23      		inx	h
07DE  3600    		mvi	m,HIGH (nulint-rst0)
07E0  23      		inx	h
07E1  87      		add	a	; shift left, count 7
07E2  F2D807  		jp	h17ini0
07E5  D1      		pop	d
07E6  C9      		ret
		
07E7  0D0A4D4D	prompt:	db	CR,LF,'MMS: ',TRM
      533A2000
07EF  28632920		db	'(c) 1982 MMS'
      31393832
      204D4D53
		
07FB          	nulfn:
07FB  C9      		ret
		
07FC          	xcmds:
07FC  79      		mov	a,c
07FD  FE52    		cpi	'R'	; set baud Rate
07FF  CA7C0E  		jz	setbr
0802  FE56    		cpi	'V'	; eprom Version
0804  CA8B0F  		jz	prtver
0807  C9      		ret
		
		; D=Phys Drive base, E=Unit
		; (or D=Phys Drive unit, E=0)
0808          	exboot:
0808  216208  		lxi	h,devtbl
080B          	exboot1:
080B  7A      		mov	a,d
080C  96      		sub	m
080D  23      		inx	h
080E  BE      		cmp	m
080F          		jrc	exboot2
080F  3808    		DB	38H,exboot2-$-1
0811  7E      		mov	a,m
0812  23      		inx	h
0813  23      		inx	h
0814  23      		inx	h
0815  B7      		ora	a
0816          		jrnz	exboot1
0816  20F3    		DB	20H,exboot1-$-1
0818  C9      		ret
		
0819          	exboot2:	; found device, jump to handler
0819  23      		inx	h
081A  4E      		mov	c,m
081B  23      		inx	h
081C  66      		mov	h,m
081D  69      		mov	l,c
081E  83      		add	e
081F  E9      		pchl
		
		; Returns NZ if found, D=phy drv
0820          	gtdvtb:
0820  DBF2    		in	0f2h
0822  E670    		ani	01110000b	; default boot device
0824  07      		rlc
0825  07      		rlc
0826  07      		rlc
0827  07      		rlc
0828  219C08  		lxi	h,defbt
082B          	gtdvtb0:
082B  85      		add	l
082C  6F      		mov	l,a
082D  3E00    		mvi	a,0
082F  8C      		adc	h
0830  67      		mov	h,a
0831  7E      		mov	a,m
0832  FEFF    		cpi	0ffh
0834  C8      		rz	; no device
0835  FEFE    		cpi	0feh
0837  CA3C08  		jz	gtdvtb1	; extended dipsw
083A  57      		mov	d,a
083B  C9      		ret	; NZ
		
083C          	gtdvtb1:
083C  DB5C    		in	05ch
083E  E6E0    		ani	11100000b	; device
0840  07      		rlc
0841  07      		rlc
0842  07      		rlc
0843  21A408  		lxi	h,auxbt
0846  CD2B08  		call	gtdvtb0
0849  C8      		rz	; no device
084A  DB5C    		in	05ch
084C  E61C    		ani	00011100b	; LUN
084E  0F      		rrc
084F  0F      		rrc
0850  5F      		mov	e,a	; D=phy drv, E=LUN
0851  C9      		ret
		
		; lookup letter in MMS table
0852          	mmslookup:
0852  21AC08  		lxi	h,bootb2
0855          	mmslk0:
0855  7E      		mov	a,m
0856  23      		inx	h
0857  56      		mov	d,m
0858  23      		inx	h
0859  B8      		cmp	b
085A  C8      		rz
085B  B7      		ora	a
085C          		jrnz	mmslk0
085C  20F7    		DB	20H,mmslk0-$-1
085E  1600    		mvi	d,0
0860  37      		stc
0861  C9      		ret
		
		; disk device/drive table by phy drv
0862          	devtbl:
0862  0302    		db	3,2
0864  3C0A    		dw	bz67
0866  1D08    		db	29,8
0868  C708    		dw	bm316
086A  2801    		db	40,1
086C  1F0B    		dw	bm318
086E  2E04    		db	46,4
0870  4409    		dw	bz37
0872  3C01    		db	60,1
0874  1F0C    		dw	bwiznet
0876  4609    		db	70,9
0878  D309    		dw	bgide
087A  A804    		db	168,4
087C  2B0A    		dw	bm320
087E  AC04    		db	172,4
0880  2B0A    		dw	bm320
0882  B004    		db	176,4
0884  2B0A    		dw	bm320
0886  B404    		db	180,4
0888  2B0A    		dw	bm320
088A  B804    		db	184,4
088C  2B0A    		dw	bm320
088E  BC04    		db	188,4
0890  2B0A    		dw	bm320
0892  C004    		db	192,4
0894  2B0A    		dw	bm320
0896  C404    		db	196,4
0898  2B0A    		dw	bm320
089A  0000    		dw	0
		
089C          	defbt:	; default boot table... port F2 bits 01110000b
089C  21      		db	33	; -000---- MMS 5" floppy 0
089D  1D      		db	29	; -001---- MMS 8" floppy 0
089E  FF      		db	0ffh	; -010---- n/a  (port 7CH)
089F  FF      		db	0ffh	; -011---- n/a  (port 78H)
08A0  FF      		db	0ffh	; -100---- none
08A1  46      		db	70	; -101---- GIDE disk part 0
08A2  3C      		db	60	; -110---- WIZNET Network
08A3  FE      		db	0feh	; -111---- redirect to I/O board dipsw
		
08A4          	auxbt:	; default boot redirect (aux dipsw) bits 11100000b
08A4  FF      		db	0ffh	; 000----- none (was MMS 77314 Corvus)
08A5  FF      		db	0ffh	; 001----- none (was MMS 77314 REMEX (Z47))
08A6  FF      		db	0ffh	; 010----- none
08A7  25      		db	37	; 011----- MMS 77317 XCOMP
08A8  3C      		db	60	; 100----- WIZNET Network
08A9  A8      		db	168	; 101----- MMS 77320 SASI
08AA  46      		db	70	; 110----- GIDE disk
08AB  FF      		db	0ffh	; 111----- none
		
08AC          	bootb2:
08AC  491D    		db	'I',29		; MMS 77316 8"
08AE  4A21    		db	'J',33		; MMS 77316 5"
08B0  4D28    		db	'M',40		; MMS 77318 RAM-disk
08B2  4FA8    		db	'O',168		; SASI ctrl 0
08B4  50AC    		db	'P',172		; SASI ctrl 1
08B6  51B0    		db	'Q',176		; SASI ctrl 2
08B8  52B4    		db	'R',180		; SASI ctrl 3
08BA  53B8    		db	'S',184		; SASI ctrl 4
08BC  54BC    		db	'T',188		; SASI ctrl 5
08BE  55C0    		db	'U',192		; SASI ctrl 6
08C0  56C4    		db	'V',196		; SASI ctrl 7
08C2  573C    		db	'W',60		; WIZNET Network
08C4  5846    		db	'X',70		; GIDE ctrl/disk
08C6  00      		db	0
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77316 Floppy boot
08C7          	bm316:
08C7  213F09  		lxi	h,int316
08CA  222F20  		shld	vrst6+1
08CD  FE08    		cpi	008h
08CF  D0      		rnc
08D0  F628    		ori	028h
08D2  57      		mov	d,a
08D3  D338    		out	038h
08D5  AF      		xra	a
08D6  D3F2    		out	0f2h	; 2mS intr off
08D8  3E0B    		mvi	a,00bh	; home/restore to track 0
08DA  CD3A09  		call	cmd316
08DD  0108CF  		lxi	b,53000
08E0          	bm316$0:
08E0  DB3C    		in	03ch
08E2  07      		rlc
08E3          		jrnc	bm316$1
08E3  3005    		DB	30H,bm316$1-$-1
08E5  0B      		dcx	b
08E6  78      		mov	a,b
08E7  B1      		ora	c
08E8          		jrnz	bm316$0
08E8  20F6    		DB	20H,bm316$0-$-1
08EA          	bm316$1:
08EA  DB3C    		in	03ch
08EC  E699    		ani	099h
08EE  C0      		rnz
08EF  1E19    		mvi	e,019h
08F1          	bm316$2:
08F1  218022  		lxi	h,bootbf
08F4  AF      		xra	a
08F5          	bm316$3:
08F5  3C      		inr	a
08F6  D33E    		out	03eh
08F8  013F00  		lxi	b,003fh
08FB  3E88    		mvi	a,088h
08FD  CD1809  		call	rd316
0900  E6BF    		ani	0bfh
0902  7A      		mov	a,d
0903  D338    		out	038h
0905  CA0F09  		jz	bm316$4
0908  EE40    		xri	040h
090A  57      		mov	d,a
090B  1D      		dcr	e
090C          		jrnz	bm316$2
090C  20E3    		DB	20H,bm316$2-$-1
090E  C9      		ret
090F          	bm316$4:
090F  DB3E    		in	03eh
0911  FE02    		cpi	002h
0913          		jrc	bm316$3
0913  38E0    		DB	38H,bm316$3-$-1
0915  C3FC03  		jmp	hwboot
		
0918          	rd316:
0918  F5      		push	psw
0919  7A      		mov	a,d
091A  E644    		ani	044h
091C          		jrnz	rd316$5
091C  200F    		DB	20H,rd316$5-$-1
			; 8" DD read special case
091E  7A      		mov	a,d
091F  E6DF    		ani	0dfh
0921  D338    		out	038h
0923  F1      		pop	psw
0924  D33C    		out	03ch
0926  FB      		ei
0927  76      		hlt	; wait for first byte
0928          	rd316$8: ini
0928  EDA2    		DB	0EDH,0A2H
092A  C32809  		jmp	rd316$8
		
092D          	rd316$5:
092D  7A      		mov	a,d
092E  D338    		out	038h
0930  F1      		pop	psw
0931  D33C    		out	03ch
0933  FB      	hlt$ini: ei
0934  76      	rd316$0: hlt
0935          		ini
0935  EDA2    		DB	0EDH,0A2H
0937  C33409  		jmp	rd316$0
		
093A          	cmd316:
093A  D33C    		out	03ch
093C  FB      	ei$spin: ei
093D          		jr	$-1	; wait for intr to break us out
093D  18FE    		DB	18H,$-1-$-1
		
093F  F1      	int316:	pop	psw
0940  DB3C    		in	03ch
0942  FB      		ei
0943  C9      		ret
		
0944          	bz37:
0944  21CA09  		lxi	h,intz37
0947  222920  		shld	vrst4+1
094A  2B      		dcx	h
094B  223720  		shld	l2037h
094E  FE04    		cpi	004h
0950  D0      		rnc
0951  3C      		inr	a
0952  2E08    		mvi	l,008h
0954          	bz37$0:
0954  29      		dad	h
0955  3D      		dcr	a
0956          		jrnz	bz37$0
0956  20FC    		DB	20H,bz37$0-$-1
0958  D379    		out	079h
095A  DBF2    		in	0f2h
095C  E60C    		ani	00ch
095E  C0      		rnz
095F  3E78    		mvi	a,078h
0961  325021  		sta	cport
0964  3ED0    		mvi	a,0d0h
0966  D37A    		out	07ah
0968  7D      		mov	a,l
0969  F608    		ori	008h
096B  57      		mov	d,a
096C  D378    		out	078h
096E  14      		inr	d
096F  1E19    		mvi	e,019h
0971  3E05    		mvi	a,5
0973  CD8F01  		call	take$A
0976  017B14  		lxi	b,0147bh	; mask, port
0979          	bz37$1:
0979  DB7A    		in	07ah
097B  A8      		xra	b
097C  E602    		ani	002h
097E          		jrz	bz37$1
097E  28F9    		DB	28H,bz37$1-$-1
0980          		djnz	bz37$1
0980  10F7    		DB	10H,bz37$1-$-1
0982          	bz37$2:
0982  218022  		lxi	h,bootbf
0985  3E01    		mvi	a,001h
0987  D379    		out	079h
0989  D37A    		out	07ah
098B  7A      		mov	a,d
098C  D378    		out	078h
098E  0604    		mvi	b,004h
0990          	bz37$3:
0990  AF      		xra	a
0991  D379    		out	079h
0993  3E40    		mvi	a,040h
0995  D37A    		out	07ah
0997  CD3C09  		call	ei$spin
099A          		djnz	bz37$3
099A  10F4    		DB	10H,bz37$3-$-1
099C  AF      		xra	a
099D  D379    		out	079h
099F  3E0B    		mvi	a,00bh
09A1  D37A    		out	07ah
09A3  CD3C09  		call	ei$spin
09A6  7A      		mov	a,d
09A7  EE04    		xri	004h
09A9  57      		mov	d,a
09AA  F602    		ori	002h
09AC  D378    		out	078h
09AE  3E9C    		mvi	a,09ch
09B0  D37A    		out	07ah
09B2  CD3309  		call	hlt$ini
09B5  E6EF    		ani	0efh
09B7          		jrnz	bz37$4
09B7  200D    		DB	20H,bz37$4-$-1
09B9  7C      		mov	a,h
09BA  FE2C    		cpi	02ch
09BC          		jrc	bz37$4
09BC  3808    		DB	38H,bz37$4-$-1
09BE  3E08    		mvi	a,008h
09C0  D378    		out	078h
09C2  E1      		pop	h
09C3  C3FC03  		jmp	hwboot
09C6          	bz37$4:
09C6  1D      		dcr	e
09C7          		jrnz	bz37$2
09C7  20B9    		DB	20H,bz37$2-$-1
09C9  C9      		ret
		
09CA  DB7A    	intz37:	in	07ah
09CC  E3      		xthl
09CD  2A3720  		lhld	l2037h
09D0  E3      		xthl
09D1  FB      		ei
09D2  C9      		ret
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; GIDE HDD boot
09D3          	bgide:
09D3  FE09    		cpi	9 ; 9 partitons, max
09D5  D0      		rnc
			; Partition is passed to bootloader, but we need
			; segment offset before we can start.
09D6  D1      		pop	d	; error return address
09D7  C1      		pop	b	; possible string
09D8  C5      		push	b
09D9  D5      		push	d
			; parse a single letter
09DA  210000  		lxi	h,0	; def segment off
09DD  79      		mov	a,c
09DE  FEC3    		cpi	0c3h	; JMP means no string present
09E0          		jrz	nostr
09E0  280D    		DB	28H,nostr-$-1
09E2  78      		mov	a,b
09E3  B7      		ora	a	; limit to 1 char?
09E4  C0      		rnz
09E5  79      		mov	a,c
09E6  E65F    		ani	5fh
09E8  D641    		sui	'A'	; 000sssss = segment ID
09EA  D8      		rc
09EB  07      		rlc
09EC  07      		rlc
09ED  07      		rlc		; sssss000 = segoff: 0000 sssss000 00000000 00000000
09EE  67      		mov	h,a	; swap for little endian SHLD/LHLD
09EF  225621  	nostr:	shld	l2156h	; l2156h[0]=27:24, l2156h[1]=23:16
09F2  7D      		mov	a,l
09F3  F6E0    		ori	11100000b	; LBA mode + std "1" bits
09F5  D366    		out	GIDE$DH	; LBA 27:4, drive 0, LBA mode
09F7  7C      		mov	a,h
09F8  D365    		out	GIDE$CH	; LBA 23:16
09FA  AF      		xra	a
09FB  D364    		out	GIDE$CL	; LBA 15:8
09FD  D363    		out	GIDE$SE	; LBA 7:0
09FF  3E0A    		mvi	a,10
0A01  D362    		out	GIDE$SC	; 10 sectors (standard boot length)
0A03  3E20    		mvi	a,20h	; READ SECTORS
0A05  D367    		out	GIDE$CS
0A07  218022  		lxi	h,bootbf
0A0A  0E60    		mvi	c,GIDE$DA
0A0C  1E0A    		mvi	e,10
0A0E  0600    		mvi	b,0	; should always be 0 after inir
0A10          	bgide0:
0A10  DB67    		in	GIDE$CS
0A12          		bit	7,a	; busy
0A12  CB7F    		DB	0CBH,7*8+a+40H
0A14          		jrnz	bgide0
0A14  20FA    		DB	20H,bgide0-$-1
0A16          		bit	0,a	; error
0A16  CB47    		DB	0CBH,0*8+a+40H
0A18  C0      		rnz
0A19          		bit	6,a	; ready
0A19  CB77    		DB	0CBH,6*8+a+40H
0A1B  C8      		rz
0A1C          		bit	3,a	; DRQ
0A1C  CB5F    		DB	0CBH,3*8+a+40H
0A1E          		jrz	bgide0
0A1E  28F0    		DB	28H,bgide0-$-1
0A20          		inir	; 256 bytes
0A20  EDB2    		DB	0EDH,0B2H
0A22          		inir	; 512 bytes
0A22  EDB2    		DB	0EDH,0B2H
0A24  1D      		dcr	e
0A25          		jrnz	bgide0
0A25  20E9    		DB	20H,bgide0-$-1
			; final status check?
0A27  E1      		pop	h	; adj stack for possible string
0A28  C3FC03  		jmp	hwboot
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77320 SASI HDD boot
0A2B          	bm320:
0A2B  FE04    		cpi	4 ; 4 units per controller, max
0A2D  D0      		rnc
0A2E  5F      		mov	e,a	; relative drive num
0A2F  7A      		mov	a,d ; phy drv
0A30  D6A8    		sui	168
0A32  E6FC    		ani	0fch	; Controller num
0A34  0F      		rrc
0A35  0F      		rrc
0A36  53      		mov	d,e ; D = relative drive num
0A37  5F      		mov	e,a ; E = controller num
0A38  7A      		mov	a,d
0A39  C3410A  		jmp	bsasi
		
0A3C          	bz67:
0A3C  FE02    		cpi	2
0A3E  D0      		rnc	
0A3F  1E00    		mvi	e,0	; Controller 0 only
0A41          	bsasi:
0A41  0F      		rrc
0A42  0F      		rrc
0A43  0F      		rrc
0A44  DD      		db 0ddh
0A45  67      		mov h,a	; movxh	a	; 0xx00000 = relative drive num (LUN)
0A46  0E02    		mvi	c,10b
0A48  CD1E02  		call	getport
0A4B  C0      		rnz
0A4C  78      		mov	a,b
0A4D  325021  		sta	cport
0A50  3C      		inr	a
0A51  4F      		mov	c,a
0A52  AF      		xra	a
0A53          		outp	a
0A53  ED79    		DB	0EDH,a*8+41H
0A55  210000  		lxi	h,0		; zero-out command buffer
0A58  223221  		shld	cmdbuf
0A5B  223421  		shld	cmdbuf+2
0A5E  223621  		shld	cmdbuf+4
0A61  225621  		shld	l2156h	; zero-out ...
0A64  225821  		shld	l2156h+2
0A67  325A21  		sta	l2156h+4
0A6A  53      		mov	d,e
0A6B  3E04    		mvi	a,4	; delay 8mS, also NZ
0A6D  B7      		ora	a
0A6E  FB      		ei
0A6F          	bsasi0:
0A6F  C8      		rz
0A70  CD2B00  		call	delayx
0A73  1E00    		mvi	e,0	; Test Drive Ready
0A75  CD920A  		call	sasi$cmd
0A78  3EFF    		mvi	a,255	; longer delay on retry...
0A7A          		jrc	bsasi0
0A7A  38F3    		DB	38H,bsasi0-$-1
0A7C  1E01    		mvi	e,1	; Recalibrate (Home)
0A7E  CD920A  		call	sasi$cmd
0A81  D8      		rc
0A82  210A80  		lxi	h,0800ah	; 10 sectors, retry
0A85  223621  		shld	cmdbuf+4
0A88  1E08    		mvi	e,8	; Read
0A8A  CD920A  		call	sasi$cmd
0A8D  D8      		rc
0A8E  E1      		pop	h
0A8F  C3FC03  		jmp	hwboot
		
		; send SASI read command, get results
0A92          	sasi$cmd:
0A92  F3      		di
0A93  DD      		db 0ddh	; undocumented Z80 instruction
0A94  6B      		mov l,e	; movxl	e	; SASI command
0A95          		sixd	cmdbuf
0A95  DD22    		DB	0DDH,22H
0A97  3221    		DW	cmdbuf
0A99  0600    		mvi	b,0	; wait for "not BUSY" first
0A9B  1E06    		mvi	e,6	;
0A9D  210000  		lxi	h,0	; 0x060000 loop/timeout count
0AA0          	sscmd0:
0AA0          		inp	a
0AA0  ED78    		DB	0EDH,a*8+40H
0AA2  E608    		ani	00001000b
0AA4  B8      		cmp	b
0AA5          		jrz	sscmd1
0AA5  280A    		DB	28H,sscmd1-$-1
0AA7  2B      		dcx	h
0AA8  7D      		mov	a,l
0AA9  B4      		ora	h
0AAA          		jrnz	sscmd0
0AAA  20F4    		DB	20H,sscmd0-$-1
0AAC  1D      		dcr	e
0AAD          		jrnz	sscmd0
0AAD  20F1    		DB	20H,sscmd0-$-1
0AAF  37      		stc
0AB0  C9      		ret
0AB1          	sscmd1:
0AB1  78      		mov	a,b
0AB2  EE08    		xri	00001000b	; wait for BUSY
0AB4          		jrz	sscmd2		; got BUSY...
0AB4  2810    		DB	28H,sscmd2-$-1
0AB6  47      		mov	b,a
0AB7  0D      		dcr	c
0AB8  AF      		xra	a
0AB9          		outp	a
0AB9  ED79    		DB	0EDH,a*8+41H
0ABB  0C      		inr	c
0ABC  0C      		inr	c
0ABD          		outp	d
0ABD  ED51    		DB	0EDH,d*8+41H
0ABF  0D      		dcr	c
0AC0  3E40    		mvi	a,040h	; SELECT
0AC2          		outp	a
0AC2  ED79    		DB	0EDH,a*8+41H
0AC4          		jr	sscmd0	; wait for BUSY now...
0AC4  18DA    		DB	18H,sscmd0-$-1
		
0AC6          	sscmd2:
0AC6  3E02    		mvi	a,002h	; enable INTR
0AC8          		outp	a
0AC8  ED79    		DB	0EDH,a*8+41H
0ACA  213221  		lxi	h,cmdbuf
0ACD          	sscmd3:
0ACD          		inp	a
0ACD  ED78    		DB	0EDH,a*8+40H
0ACF          		bit	7,a	; REQ
0ACF  CB7F    		DB	0CBH,7*8+a+40H
0AD1          		jrz	sscmd3
0AD1  28FA    		DB	28H,sscmd3-$-1
0AD3          		bit	4,a	; CMD
0AD3  CB67    		DB	0CBH,4*8+a+40H
0AD5          		jrz	sscmd4
0AD5  280A    		DB	28H,sscmd4-$-1
0AD7          		bit	6,a	; MSG
0AD7  CB77    		DB	0CBH,6*8+a+40H
0AD9          		jrz	sscmd6
0AD9  2819    		DB	28H,sscmd6-$-1
0ADB  0D      		dcr	c
0ADC          		outi		; output command byte
0ADC  EDA3    		DB	0EDH,0A3H
0ADE  0C      		inr	c
0ADF          		jr	sscmd3
0ADF  18EC    		DB	18H,sscmd3-$-1
		
0AE1          	sscmd4:
0AE1  218022  		lxi	h,bootbf
0AE4          	sscmd5:
0AE4          		inp	a
0AE4  ED78    		DB	0EDH,a*8+40H
0AE6          		bit	7,a	; REQ
0AE6  CB7F    		DB	0CBH,7*8+a+40H
0AE8          		jrz	sscmd5
0AE8  28FA    		DB	28H,sscmd5-$-1
0AEA          		bit	4,a	; CMD - indicates data done
0AEA  CB67    		DB	0CBH,4*8+a+40H
0AEC          		jrnz	sscmd6
0AEC  2006    		DB	20H,sscmd6-$-1
0AEE  0D      		dcr	c
0AEF          		ini		; input data byte
0AEF  EDA2    		DB	0EDH,0A2H
0AF1  0C      		inr	c
0AF2          		jr	sscmd5
0AF2  18F0    		DB	18H,sscmd5-$-1
0AF4          	sscmd6:
0AF4          		inp	a
0AF4  ED78    		DB	0EDH,a*8+40H
0AF6  E6D0    		ani	0d0h	; REQ, OUT, CMD
0AF8  FE90    		cpi	090h	; must be REQ, CMD
0AFA          		jrnz	sscmd6	; wait for it...
0AFA  20F8    		DB	20H,sscmd6-$-1
0AFC  0D      		dcr	c
0AFD          		inp	l	; result 0
0AFD  ED68    		DB	0EDH,l*8+40H
0AFF  0C      		inr	c
0B00          	sscmd7:
0B00          		inp	h	; status
0B00  ED60    		DB	0EDH,h*8+40H
0B02  7C      		mov	a,h
0B03  E6E0    		ani	0e0h	; REG, OUT, MSG
0B05  FEA0    		cpi	0a0h	; must be REQ, MSG
0B07          		jrnz	sscmd7
0B07  20F7    		DB	20H,sscmd7-$-1
0B09  223821  		shld	resbuf	; command results
0B0C  0D      		dcr	c
0B0D          		inp	a	; last data byte
0B0D  ED78    		DB	0EDH,a*8+40H
0B0F  0C      		inr	c
0B10  FB      		ei
0B11  B7      		ora	a
0B12  37      		stc
0B13  C0      		rnz		; error
0B14          		bit	0,l	; SASI error bit
0B14  CB45    		DB	0CBH,0*8+l+40H
0B16  C0      		rnz
0B17          		bit	1,l	; or other error?
0B17  CB4D    		DB	0CBH,1*8+l+40H
0B19  C0      		rnz
0B1A          		bit	1,h	; ACK
0B1A  CB4C    		DB	0CBH,1*8+h+40H
0B1C  C0      		rnz
0B1D  AF      		xra	a	; success
0B1E  C9      		ret
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77318 (RAM-disk) boot
0B1F          	bm318:
0B1F  F3      		di
0B20  212E0B  		lxi	h,l318rt
0B23  1100C0  		lxi	d,ramboot
0B26  011E00  		lxi	b,l318sz
0B29          		ldir
0B29  EDB0    		DB	0EDH,0B0H
0B2B  C300C0  		jmp	ramboot
		
		; MMS 77318 (RAM-disk) boot loader - relocated to ramboot
0B2E          	l318rt:
0B2E  2115C0  		lxi	h,ramboot+l318lo
0B31  0608    		mvi	b,l318lz
0B33  0EF2    		mvi	c,0f2h
0B35          		outir	; unlock memory and select OS image bank
0B35  EDB3    		DB	0EDH,0B3H
0B37  3A0000  		lda	0
0B3A  FEC3    		cpi	0c3h	; JMP - does OS look good?
0B3C  CA0000  		jz	0	; start OS
0B3F          		outi	; re-select ROM bank
0B3F  EDA3    		DB	0EDH,0A3H
0B41  FB      		ei
0B42  C9      		ret	; return to monitor (boot error)
		
		; 77318 Unlock and select bank "E" (16K common + "bank 1")
		; NOTE: "22h" should not be there, left-over cruft from CP/M unlock.
0015          	l318lo	equ	$-l318rt
0B43  040C0408	l318ul:	db	04h,0ch,04h,08h,0ch,08h,22h,10h
      0C082210
0008          	l318lz	equ	$-l318ul
0B4B  00      		db	0	; fall-back to ROM on error...
001E          	l318sz	equ	$-l318rt
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; WIZNET WIZ850io (Network) boot loader
		
0B4C          	getwiz1:
0B4C  3E01    		mvi	a,WZSCS
0B4E  D341    		out	spi$ctl
0B50  0E40    		mvi	c,spi$dat
0B52          		outz	; hi adr byte always 0
0B52  ED71    		DB	0EDH, 71H
0B54          		outp	e
0B54  ED59    		DB	0EDH,e*8+41H
0B56          		res	2,d
0B56  CB92    		DB	0CBH,2*8+d+80H
0B58          		outp	d
0B58  ED51    		DB	0EDH,d*8+41H
0B5A          		inz	; prime MISO
0B5A  ED70    		DB	0EDH, 70H
0B5C          		inp	a
0B5C  ED78    		DB	0EDH,a*8+40H
0B5E  0C      		inr	c	; ctl port
0B5F          		outz		; clear SCS
0B5F  ED71    		DB	0EDH, 71H
0B61  C9      		ret
		
0B62          	putwiz1:
0B62  F5      		push	psw
0B63  3E01    		mvi	a,WZSCS
0B65  D341    		out	spi$ctl
0B67  F1      		pop	psw
0B68  0E40    		mvi	c,spi$dat
0B6A          		outz	; hi adr byte always 0
0B6A  ED71    		DB	0EDH, 71H
0B6C          		outp	e
0B6C  ED59    		DB	0EDH,e*8+41H
0B6E          		setb	2,d
0B6E  CBD2    		DB	0CBH,2*8+d+0C0H
0B70          		outp	d
0B70  ED51    		DB	0EDH,d*8+41H
0B72          		outp	a	; data
0B72  ED79    		DB	0EDH,a*8+41H
0B74  0C      		inr	c	; ctl port
0B75          		outz		; clear SCS
0B75  ED71    		DB	0EDH, 71H
0B77  C9      		ret
		
		; Get 16-bit value from chip
		; Prereq: IDM_AR0 already set, auto-incr on
		; Entry: A=value for IDM_AR1
		; Return: HL=register pair contents
0B78          	getwiz2:
0B78  3E01    		mvi	a,WZSCS
0B7A  D341    		out	spi$ctl
0B7C  0E40    		mvi	c,spi$dat
0B7E          		outz	; hi adr byte always 0
0B7E  ED71    		DB	0EDH, 71H
0B80          		outp	e
0B80  ED59    		DB	0EDH,e*8+41H
0B82          		res	2,d
0B82  CB92    		DB	0CBH,2*8+d+80H
0B84          		outp	d
0B84  ED51    		DB	0EDH,d*8+41H
0B86          		inz	; prime MISO
0B86  ED70    		DB	0EDH, 70H
0B88          		inp	h	; data
0B88  ED60    		DB	0EDH,h*8+40H
0B8A          		inp	l	; data
0B8A  ED68    		DB	0EDH,l*8+40H
0B8C  0C      		inr	c	; ctl port
0B8D          		outz		; clear SCS
0B8D  ED71    		DB	0EDH, 71H
0B8F  C9      		ret
		
		; HL = output data, E = off, D = BSB, B = len
0B90          	wizset:
0B90  3E01    		mvi	a,WZSCS
0B92  D341    		out	spi$ctl
0B94  0E40    		mvi	c,spi$dat
0B96          		outz		; hi adr always 0
0B96  ED71    		DB	0EDH, 71H
0B98          		outp	e
0B98  ED59    		DB	0EDH,e*8+41H
0B9A          		setb	2,d
0B9A  CBD2    		DB	0CBH,2*8+d+0C0H
0B9C          		outp	d
0B9C  ED51    		DB	0EDH,d*8+41H
0B9E          		outir
0B9E  EDB3    		DB	0EDH,0B3H
0BA0  0C      		inr	c	; ctl port
0BA1          		outz		; clear SCS
0BA1  ED71    		DB	0EDH, 71H
0BA3  C9      		ret
		
		; Put 16-bit value to chip
		; Prereq: IDM_AR0 already set, auto-incr on
		; Entry: A=value for IDM_AR1
		;        HL=register pair contents
0BA4          	putwiz2:
0BA4  3E01    		mvi	a,WZSCS
0BA6  D341    		out	spi$ctl
0BA8  0E40    		mvi	c,spi$dat
0BAA          		outz	; hi adr byte always 0
0BAA  ED71    		DB	0EDH, 71H
0BAC          		outp	e
0BAC  ED59    		DB	0EDH,e*8+41H
0BAE          		setb	2,d
0BAE  CBD2    		DB	0CBH,2*8+d+0C0H
0BB0          		outp	d
0BB0  ED51    		DB	0EDH,d*8+41H
0BB2          		outp	h	; data to write
0BB2  ED61    		DB	0EDH,h*8+41H
0BB4          		outp	l
0BB4  ED69    		DB	0EDH,l*8+41H
0BB6  0C      		inr	c	; ctl port
0BB7          		outz		; clear SCS
0BB7  ED71    		DB	0EDH, 71H
0BB9  C9      		ret
		
		; Issue command, wait for complete
		; D=Socket ctl byte
		; Returns: A=Sn_SR
0BBA  47      	wizcmd:	mov	b,a
0BBB  1E01    		mvi	e,sn$cr
0BBD          		setb	2,d
0BBD  CBD2    		DB	0CBH,2*8+d+0C0H
0BBF  3E01    		mvi	a,WZSCS
0BC1  D341    		out	spi$ctl
0BC3  0E40    		mvi	c,spi$dat
0BC5          		outz	; hi adr byte always 0
0BC5  ED71    		DB	0EDH, 71H
0BC7          		outp	e
0BC7  ED59    		DB	0EDH,e*8+41H
0BC9          		outp	d
0BC9  ED51    		DB	0EDH,d*8+41H
0BCB          		outp	b	; command
0BCB  ED41    		DB	0EDH,b*8+41H
0BCD  0C      		inr	c	; ctl port
0BCE          		outz		; clear SCS
0BCE  ED71    		DB	0EDH, 71H
0BD0  CD4C0B  	wc0:	call	getwiz1
0BD3  B7      		ora	a
0BD4          		jrnz	wc0
0BD4  20FA    		DB	20H,wc0-$-1
0BD6  1E03    		mvi	e,sn$sr
0BD8  CD4C0B  		call	getwiz1
0BDB  C9      		ret
		
		; HL=socket relative pointer (TX_WR)
		; DE=length (preserved, not used)
		; Returns: HL=msgptr, C=spi$dat
0BDC          	cpsetup:
0BDC  3E01    		mvi	a,WZSCS
0BDE  D341    		out	spi$ctl
0BE0  0E40    		mvi	c,spi$dat
0BE2          		outp	h
0BE2  ED61    		DB	0EDH,h*8+41H
0BE4          		outp	l
0BE4  ED69    		DB	0EDH,l*8+41H
0BE6  3A8222  		lda	cursok
0BE9  B0      		ora	b
0BEA          		outp	a
0BEA  ED79    		DB	0EDH,a*8+41H
0BEC  2A8522  		lhld	msgptr
0BEF  C9      		ret
		
		; length always <= 133 bytes, never overflows OUTIR/INIR
0BF0          	cpyout:
0BF0  0614    		mvi	b,txbuf0
0BF2  CDDC0B  		call	cpsetup
0BF5  43      		mov	b,e	; length
0BF6          		outir		; send data
0BF6  EDB3    		DB	0EDH,0B3H
0BF8  228522  		shld	msgptr
0BFB  0C      		inr	c	; ctl port
0BFC          		outz		; clear SCS
0BFC  ED71    		DB	0EDH, 71H
0BFE  C9      		ret
		
		; HL=socket relative pointer (RX_RD)
		; DE=length
		; Destroys IDM_AR0, IDM_AR1
		; length always <= 133 bytes, never overflows OUTIR/INIR
0BFF          	cpyin:
0BFF  0618    		mvi	b,rxbuf0
0C01  CDDC0B  		call	cpsetup	;
0C04          		inz	; prime MISO
0C04  ED70    		DB	0EDH, 70H
0C06  43      		mov	b,e	; fraction of page
0C07          		inir		; recv data
0C07  EDB2    		DB	0EDH,0B2H
0C09  228522  		shld	msgptr
0C0C  0C      		inr	c	; ctl port
0C0D          		outz		; clear SCS
0C0D  ED71    		DB	0EDH, 71H
0C0F  C9      		ret
		
		; L=bits to reset
		; D=socket base
0C10          	wizsts:
0C10  1E02    		mvi	e,sn$ir
0C12  CD4C0B  		call	getwiz1	; destroys C
0C15  F5      		push	psw
0C16  A5      		ana	l
0C17          		jrz	ws0	; don't reset if not set (could race)
0C17  2804    		DB	28H,ws0-$-1
0C19  7D      		mov	a,l
0C1A  CD620B  		call	putwiz1
0C1D  F1      	ws0:	pop	psw
0C1E  C9      		ret
		
		;	WIZNET boot routine
		;
0C1F          	bwiznet:
0C1F  D5      		push	d
			; extract optional string. must do it now, before we
			; overwrite bootbf.
0C20  218022  		lxi	h,bootbf
0C23  7E      		mov	a,m
0C24  4F      		mov	c,a
			; we send N+1 bytes, NUL term
0C25  320423  		sta	msg$siz
0C28  0600    		mvi	b,0
0C2A  110523  		lxi	d,msg$dat
0C2D          		ldir
0C2D  EDB0    		DB	0EDH,0B0H
0C2F  AF      		xra	a
0C30  12      		stax	d	; NUL term
0C31  D1      		pop	d
0C32  7B      		mov	a,e	; server id, 0..9
0C33  328022  		sta	server
			; look at WIZNET hard, init as needed
0C36  111D00  		lxi	d,pmagic	; D = 0 (comm regs), E = PMAGIC offset
0C39  CD4C0B  		call	getwiz1
0C3C  B7      		ora	a
0C3D  CCB80D  		cz	wizcfg	; configure chip from nvram
0C40  D8      		rc
0C41  328122  		sta	nodeid ; our slave (client) ID
			; locate server node id in chip's socket regs.
			;
0C44  0608    		mvi	b,nsocks
0C46  110408  		lxi	d,(sock0 shl 8) + sn$prt
0C49          	nb1:
0C49  CD780B  		call	getwiz2	; destroys C,HL
0C4C  7C      		mov	a,h
0C4D  FE31    		cpi	31h
0C4F          		jrnz	nb0
0C4F  2006    		DB	20H,nb0-$-1
0C51  3A8022  		lda	server
0C54  BD      		cmp	l
0C55          		jrz	nb2	; found server socket
0C55  2807    		DB	28H,nb2-$-1
0C57          	nb0:
0C57  3E20    		mvi	a,001$00$000b
0C59  82      		add	d	; next socket
0C5A  57      		mov	d,a
0C5B          		djnz	nb1
0C5B  10EC    		DB	10H,nb1-$-1
0C5D  C9      		ret	; error: server not configured
0C5E          	nb2:	; D = server socket BSB
0C5E  7A      		mov	a,d
0C5F  E6E0    		ani	11100000b
0C61  328222  		sta	cursok
0C64  1E03    		mvi	e,sn$sr
0C66  CD4C0B  		call	getwiz1
0C69  FE17    		cpi	ESTABLISHED
0C6B          		jrz	nb3	; ready to rock-n-roll...
0C6B  2814    		DB	28H,nb3-$-1
			; try to open...
0C6D  FE13    		cpi	SOKINIT
0C6F          		jrz	nb4
0C6F  2808    		DB	28H,nb4-$-1
0C71  3E01    		mvi	a,OPEN
0C73  CDBA0B  		call	wizcmd
0C76  FE13    		cpi	SOKINIT
0C78  C0      		rnz	; failed to open (init)
0C79  3E04    	nb4:	mvi	a,CONNECT
0C7B  CDBA0B  		call	wizcmd
0C7E  FE17    		cpi	ESTABLISHED
0C80  C0      		rnz	; failed to open (connect)
0C81          	nb3:
0C81  3E01    		mvi	a,1	; FNC for "boot me"
0C83  320323  		sta	msg$fnc
			; string already setup
0C86          	loop:
0C86  3E20    		mvi	a,020h	; FMT for client boot messages
0C88  320023  		sta	msg$fmt
0C8B  CDE70C  		call	sndrcv
0C8E  D8      		rc	; network failure
0C8F  3A0023  		lda	msg$fmt
0C92  FE21    		cpi	021h	; FMT for server boot responses
0C94  C0      		rnz
			; TODO: verify SID?
0C95  3A0323  		lda	msg$fnc
0C98  B7      		ora	a
0C99  C8      		rz	; NAK - error
0C9A  3D      		dcr	a
0C9B          		jrz	ldmsg
0C9B  2826    		DB	28H,ldmsg-$-1
0C9D  3D      		dcr	a
0C9E          		jrz	stdma
0C9E  281B    		DB	28H,stdma-$-1
0CA0  3D      		dcr	a
0CA1          		jrz	load
0CA1  2806    		DB	28H,load-$-1
0CA3  3D      		dcr	a
0CA4  C0      		rnz	; unsupported FNC
			; done: execute boot code
			; TODO: enable ORG0 (MMS77318?)
0CA5  2A0523  		lhld	msg$dat
0CA8  E9      		pchl
0CA9  2A8B22  	load:	lhld	dma
0CAC  EB      		xchg
0CAD  210523  		lxi	h,msg$dat
0CB0  018000  		lxi	b,128
0CB3          		ldir
0CB3  EDB0    		DB	0EDH,0B0H
0CB5  AF      	ack:	xra	a	; FNC 0 = ACK
0CB6  320323  		sta	msg$fnc
0CB9          		jr	loop
0CB9  18CB    		DB	18H,loop-$-1
0CBB  2A0523  	stdma:	lhld	msg$dat
0CBE  228B22  		shld	dma
0CC1          		jr	ack
0CC1  18F2    		DB	18H,ack-$-1
0CC3  210523  	ldmsg:	lxi	h,msg$dat
0CC6  7E      	ldm0:	mov	a,m
0CC7  23      		inx	h
0CC8  FE24    		cpi	'$'
0CCA          		jrz	ack
0CCA  28E9    		DB	28H,ack-$-1
0CCC  CD9805  		call	conout
0CCF          		jr	ldm0
0CCF  18F5    		DB	18H,ldm0-$-1
		
		; Wait for message response, with timeout.
		; D = socket BSB (preserved).
0CD1          	check:
0CD1  21007D  		lxi	h,32000	; do check for sane receive time...
0CD4  E5      	chk0:	push	h
0CD5  2E04    		mvi	l,00000100b	; RECV data available bit
0CD7  CD100C  		call	wizsts
0CDA  A5      		ana	l	; RECV data available
0CDB          		jrnz	chk4	; D=socket
0CDB  2008    		DB	20H,chk4-$-1
0CDD  E1      		pop	h
0CDE  2B      		dcx	h
0CDF  7C      		mov	a,h
0CE0  B5      		ora	l
0CE1          		jrnz	chk0
0CE1  20F1    		DB	20H,chk0-$-1
0CE3  37      		stc	; CY = error
0CE4  C9      		ret
0CE5  E1      	chk4:	pop	h
0CE6  C9      		ret
		
		;	Send Message on Network, receive response
		;	msgbuf setup with FMT, FNC, LEN, data
		;	msg len always <= 128 (133 total) bytes.
0CE7          	sndrcv:			; BC = message addr
			; TODO: drain/flush receiver
		; begin send phase
0CE7  210023  		lxi	h,msgbuf
0CEA  228522  		shld	msgptr
0CED  3A8222  		lda	cursok
0CF0  F608    		ori	sock0
0CF2  57      		mov	d,a
			; D=socket patn
0CF3  3A8022  		lda	server
0CF6  320123  		sta	msg$did	; Set Server ID (dest) in header
0CF9  3A8122  		lda	nodeid
0CFC  320223  		sta	msg$sid	; Set Slave ID (src) in header
0CFF  3A0423  		lda	msg$siz	; msg siz (-1)
0D02  C606    		adi	5+1	; hdr, +1 for (-1)
0D04  6F      		mov	l,a
0D05  2600    		mvi	h,0
0D07  228722  		shld	msglen
0D0A  1E24    		mvi	e,sn$txwr
0D0C  CD780B  		call	getwiz2
0D0F  228322  		shld	curptr
0D12  2A8722  		lhld	msglen
0D15          		lbcd	curptr
0D15  ED4B    		DB	0EDH,4BH
0D17  8322    		DW	curptr
0D19  09      		dad	b
0D1A  1E24    		mvi	e,sn$txwr
0D1C  CDA40B  		call	putwiz2
			; send data
0D1F  2A8722  		lhld	msglen
0D22  EB      		xchg
0D23  2A8322  		lhld	curptr
0D26  CDF00B  		call	cpyout
0D29  3A8222  		lda	cursok
0D2C  F608    		ori	sock0
0D2E  57      		mov	d,a
0D2F  3E20    		mvi	a,SEND
0D31  CDBA0B  		call	wizcmd
			; ignore Sn_SR?
0D34  2E10    		mvi	l,00010000b	; SEND_OK bit
0D36  CD100C  		call	wizsts
0D39  2F      		cma	; want "0" on success
0D3A  A5      		ana	l	; SEND_OK
0D3B  37      		stc
0D3C  C0      		rnz	; CY = failure (here: send failed)
		; begin recv phase - loop
0D3D  3A8222  		lda	cursok	; is D still socket BSB?
0D40  F608    		ori	sock0
0D42  57      		mov	d,a
		;	Receive Message from Network
0D43  210023  		lxi	h,msgbuf
0D46  228522  		shld	msgptr
0D49  CDD10C  		call	check	; check for recv within timeout
0D4C          		jrc	rerr
0D4C  3867    		DB	38H,rerr-$-1
0D4E  210000  		lxi	h,0
0D51  228922  		shld	totlen
0D54          	rm0:	; D must be socket base...
0D54  1E26    		mvi	e,sn$rxrsr	; length
0D56  CD780B  		call	getwiz2
0D59  7C      		mov	a,h
0D5A  B5      		ora	l
0D5B          		jrz	rm0
0D5B  28F7    		DB	28H,rm0-$-1
0D5D  228722  		shld	msglen		; not CP/NET msg len
0D60  1E28    		mvi	e,sn$rxrd	; pointer
0D62  CD780B  		call	getwiz2
0D65  228322  		shld	curptr
0D68          		lbcd	msglen	; BC=Sn_RX_RSR
0D68  ED4B    		DB	0EDH,4BH
0D6A  8722    		DW	msglen
0D6C  2A8922  		lhld	totlen
0D6F  B7      		ora	a
0D70          		dsbc	b
0D70  ED42    		DB	0EDH,b*8+42H
0D72  228922  		shld	totlen	; might be negative...
0D75          		lbcd	curptr
0D75  ED4B    		DB	0EDH,4BH
0D77  8322    		DW	curptr
0D79  2A8722  		lhld	msglen	; BC=Sn_RX_RD, HL=Sn_RX_RSR
0D7C  09      		dad	b	; HL=nxt RD
0D7D  1E28    		mvi	e,sn$rxrd
0D7F  CDA40B  		call	putwiz2
			; DE destroyed...
0D82          		lded	msglen
0D82  ED5B    		DB	0EDH,5BH
0D84  8722    		DW	msglen
0D86  2A8322  		lhld	curptr
0D89  CDFF0B  		call	cpyin
0D8C  3A8222  		lda	cursok
0D8F  F608    		ori	sock0
0D91  57      		mov	d,a
0D92  3E40    		mvi	a,RECV
0D94  CDBA0B  		call	wizcmd
			; ignore Sn_SR?
0D97  2A8922  		lhld	totlen	; might be neg (first pass)
0D9A  7C      		mov	a,h
0D9B  B7      		ora	a
0D9C  F2B00D  		jp	rm1
			; can we guarantee at least msg hdr?
0D9F  3A0423  		lda	msg$siz	; msg siz (-1)
0DA2  C606    		adi	5+1	; header, +1 for (-1)
0DA4  5F      		mov	e,a
0DA5  3E00    		mvi	a,0
0DA7  8F      		adc	a
0DA8  57      		mov	d,a	; true msg len
0DA9  19      		dad	d	; subtract what we already have
0DAA          		jrnc	rerr	; something is wrong, if still neg
0DAA  3009    		DB	30H,rerr-$-1
0DAC  228922  		shld	totlen
0DAF  7C      		mov	a,h
0DB0  B5      	rm1:	ora	l
0DB1  C2540D  		jnz	rm0
0DB4  C9      		ret	; success (A=0)
		
0DB5          	rerr:
0DB5  AF      	err:	xra	a
0DB6  3D      		dcr	a	; NZ
0DB7  C9      		ret
		
		; Try to read NVRAM config for WIZNET.
		; Returns: A = node id (PMAGIC) or CY if error (no config)
0DB8          	wizcfg:	; restore config from NVRAM
0DB8  210000  		lxi	h,0
0DBB  110002  		lxi	d,512
0DBE  CD560E  		call	nvget
0DC1  CD3C0E  		call	vcksum
0DC4  37      		stc
0DC5  C0      		rnz	; checksum wrong - no config available
0DC6  210124  		lxi	h,nvbuf+gar
0DC9  1600    		mvi	d,0
0DCB  1E01    		mvi	e,gar
0DCD  0612    		mvi	b,18	; GAR+SUBR+SHAR+SIPR
0DCF  CD900B  		call	wizset
0DD2  211D24  		lxi	h,nvbuf+pmagic
0DD5  1600    		mvi	d,0
0DD7  1E1D    		mvi	e,pmagic
0DD9  0601    		mvi	b,1
0DDB  CD900B  		call	wizset
0DDE          		lxix	nvbuf+32	; start of socket0 data
0DDE  DD21    		DB	0DDH,21H
0DE0  2024    		DW	nvbuf+32
0DE2  1608    		mvi	d,SOCK0
0DE4  0608    		mvi	b,8
0DE6          	rest0:
0DE6  C5      		push	b
0DE7          		ldx	a,sn$prt
0DE7  DD7E04  		DB	0DDH,a*8+46H,sn$prt
0DEA  FE31    		cpi	31h
0DEC          		jrnz	rest1	; skip unconfigured sockets
0DEC  200E    		DB	20H,rest1-$-1
0DEE  1E04    		mvi	e,sn$prt
0DF0  0602    		mvi	b,2
0DF2  CD0D0E  		call	setsok
0DF5  1E0C    		mvi	e,sn$dipr
0DF7  0606    		mvi	b,6	; DIPR and DPORT
0DF9  CD0D0E  		call	setsok
0DFC          	rest1:
0DFC  012000  		lxi	b,32
0DFF          		dadx	b
0DFF  DD09    		DB	0DDH,b*8+09H
0E01  3E20    		mvi	a,001$00$000b	; socket BSB incr value
0E03  82      		add	d
0E04  57      		mov	d,a
0E05  C1      		pop	b
0E06          		djnz	rest0
0E06  10DE    		DB	10H,rest0-$-1
0E08  3A1D24  		lda	nvbuf+pmagic	; our node id
0E0B  B7      		ora	a	; NC
0E0C  C9      		ret
		
		; IX = base data buffer for socket, D = socket BSB, E = offset, B = length
		; destroys HL, B, C
0E0D          	setsok:
0E0D          		pushix
0E0D  DDE5    		DB	0DDH,0E5H
0E0F  E1      		pop	h
0E10  D5      		push	d
0E11  1600    		mvi	d,0
0E13  19      		dad	d	; HL points to data in 'buf'
0E14  D1      		pop	d
0E15  CD900B  		call	wizset
0E18  C9      		ret
		
		; Set socket MR to TCP.
		; D = socket BSB (result of "getsokn")
		; Destroys all registers except D.
0E19          	settcp:
0E19  3E01    		mvi	a,1	; TCP mode
0E1B  1E00    		mvi	e,sn$mr
0E1D  C3620B  		jmp	putwiz1	; force TCP/IP mode
		
0E20          	cksum32:
0E20  210000  		lxi	h,0
0E23  110000  		lxi	d,0
0E26          	cks0:	ldx	a,+0
0E26  DD7E00  		DB	0DDH,a*8+46H,+0
0E29          		inxix
0E29  DD23    		DB	0DDH,23H
0E2B  83      		add	e
0E2C  5F      		mov	e,a
0E2D          		jrnc	cks1
0E2D  3007    		DB	30H,cks1-$-1
0E2F  14      		inr	d
0E30          		jrnz	cks1
0E30  2004    		DB	20H,cks1-$-1
0E32  2C      		inr	l
0E33          		jrnz	cks1
0E33  2001    		DB	20H,cks1-$-1
0E35  24      		inr	h
0E36  0B      	cks1:	dcx	b
0E37  78      		mov	a,b
0E38  B1      		ora	c
0E39          		jrnz	cks0
0E39  20EB    		DB	20H,cks0-$-1
0E3B  C9      		ret
		
		; Validates checksum in 'buf'
		; return: NZ on error
0E3C          	vcksum:
0E3C          		lxix	nvbuf
0E3C  DD21    		DB	0DDH,21H
0E3E  0024    		DW	nvbuf
0E40  01FC01  		lxi	b,508
0E43  CD200E  		call	cksum32
0E46          		lbcd	nvbuf+510
0E46  ED4B    		DB	0EDH,4BH
0E48  FE25    		DW	nvbuf+510
0E4A  B7      		ora	a
0E4B          		dsbc	b
0E4B  ED42    		DB	0EDH,b*8+42H
0E4D  C0      		rnz
0E4E          		lbcd	nvbuf+508
0E4E  ED4B    		DB	0EDH,4BH
0E50  FC25    		DW	nvbuf+508
0E52  EB      		xchg
0E53          		dsbc	b	; CY is clear
0E53  ED42    		DB	0EDH,b*8+42H
0E55  C9      		ret
		
		; Get a block of data from NVRAM to 'buf'
		; HL = nvram address, DE = length (always multiple of 256)
0E56          	nvget:
0E56  3E02    		mvi	a,NVSCS
0E58  D341    		out	spi$ctl
0E5A  3E03    		mvi	a,NVRD
0E5C  D340    		out	spi$dat
0E5E  7C      		mov	a,h
0E5F  D340    		out	spi$dat
0E61  7D      		mov	a,l
0E62  D340    		out	spi$dat
0E64  DB40    		in	spi$dat	; prime pump
0E66  0E40    		mvi	c,spi$dat
0E68  210024  		lxi	h,nvbuf
0E6B  43      		mov	b,e
0E6C          	nvget0:	inir	; B = 0 after
0E6C  EDB2    		DB	0EDH,0B2H
0E6E  15      		dcr	d
0E6F          		jrnz	nvget0
0E6F  20FB    		DB	20H,nvget0-$-1
0E71  AF      		xra	a	; not SCS
0E72  D341    		out	spi$ctl
0E74  C9      		ret
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Set BAUD command
0E75          	setber:
0E75  3E07    		mvi	a,BEL
0E77  CD9805  		call	conout
0E7A  E1      		pop	h
0E7B  C9      		ret
		
0E7C          	setbr:
0E7C  21E40E  		lxi	h,ratems
0E7F  CD3406  		call	msgout
0E82  CD8705  		call	conin
0E85  E6DF    		ani	11011111b	; toupper
0E87  4F      		mov	c,a
0E88  CD9805  		call	conout
0E8B  D641    		sui	'A'
0E8D  FE0E    		cpi	'O'-'A'
0E8F  D2750E  		jnc	setber
0E92  5F      		mov	e,a
0E93  1600    		mvi	d,0
0E95  21EC0E  		lxi	h,brtab
0E98  19      		dad	d
0E99  19      		dad	d
0E9A  19      		dad	d
0E9B  19      		dad	d
0E9C  5E      		mov	e,m
0E9D  23      		inx	h
0E9E  56      		mov	d,m	; DE=baud divisor
0E9F  23      		inx	h
0EA0  7E      		mov	a,m
0EA1  23      		inx	h
0EA2  66      		mov	h,m
0EA3  6F      		mov	l,a	; HL=rate string
0EA4  CD3406  		call	msgout
0EA7  21840F  		lxi	h,baudms
0EAA  CD3406  		call	msgout
0EAD  CD2306  		call	waitcr
0EB0  3E1B    		mvi	a,ESC
0EB2  CD9805  		call	conout
0EB5  3E72    		mvi	a,'r' ; Set Baud
0EB7  CD9805  		call	conout
0EBA  79      		mov	a,c ; Baud value
0EBB  CD9805  		call	conout
0EBE          	setbrf:
0EBE  DBED    		in	0edh
0EC0  E660    		ani	01100000b
0EC2  FE60    		cpi	01100000b
0EC4  C2BE0E  		jnz	setbrf	; flush output
0EC7  01A00F  		lxi	b,4000	; delay value ~43mS
0ECA          	setbr0:
0ECA  0B      		dcx	b
0ECB  78      		mov	a,b
0ECC  B1      		ora	c
0ECD  C2CA0E  		jnz	setbr0
0ED0  DBEB    		in	0ebh
0ED2  F680    		ori	10000000b	; divsor latch enable
0ED4  D3EB    		out	0ebh
0ED6  7B      		mov	a,e
0ED7  D3E8    		out	0e8h
0ED9  7A      		mov	a,d
0EDA  D3E9    		out	0e9h
0EDC  DBEB    		in	0ebh
0EDE  E67F    		ani	01111111b	; divisor latch disable
0EE0  D3EB    		out	0ebh
0EE2  E1      		pop	h
0EE3  C9      		ret
		
0EE4  52617465	ratems:	db	'Rate - ',TRM
      202D2000
		
0EEC          	brtab:
0EEC  1704240F		dw	1047,	br110
0EF0  00032A0F		dw	768,	br150
0EF4  8001300F		dw	384,	br300
0EF8  C000360F		dw	192,	br600
0EFC  60003C0F		dw	96,	br1200
0F00  4000430F		dw	64,	br1800
0F04  3A004A0F		dw	58,	br2000
0F08  3000510F		dw	48,	br2400
0F0C  2000580F		dw	32,	br3600
0F10  18005F0F		dw	24,	br4800
0F14  1000660F		dw	16,	br7200
0F18  0C006D0F		dw	12,	br9600
0F1C  0600740F		dw	6,	br19200
0F20  03007C0F		dw	3,	br38400
		
0F24  20283131	br110:	db	' (110',TRM
      3000
0F2A  20283135	br150:	db	' (150',TRM
      3000
0F30  20283330	br300:	db	' (300',TRM
      3000
0F36  20283630	br600:	db	' (600',TRM
      3000
0F3C  20283132	br1200:	db	' (1200',TRM
      303000
0F43  20283138	br1800:	db	' (1800',TRM
      303000
0F4A  20283230	br2000:	db	' (2000',TRM
      303000
0F51  20283234	br2400:	db	' (2400',TRM
      303000
0F58  20283336	br3600:	db	' (3600',TRM
      303000
0F5F  20283438	br4800:	db	' (4800',TRM
      303000
0F66  20283732	br7200:	db	' (7200',TRM
      303000
0F6D  20283936	br9600:	db	' (9600',TRM
      303000
0F74  20283139	br19200: db	' (19200',TRM
      32303000
0F7C  20283338	br38400: db	' (38400',TRM
      34303000
0F84  20626175	baudms:	db	' baud)',TRM
      642900
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Print ROM version command
0F8B          	prtver:
0F8B  21990F  		lxi	h,versms
0F8E  CD3406  		call	msgout
0F91  3AA20F  		lda	vers
0F94  CDFA05  		call	hexout
0F97  E1      		pop	h
0F98  C9      		ret
		
0F99  56657273	versms:	db	'Version ',TRM
      696F6E20
      00
0FA2  13      	vers:	db	VERN	; version byte... "1.0"
		
0FA3  0D0A0745	erprom:	db	CR,LF,BEL,'EPROM err',TRM
      50524F4D
      20657272
      00
		
			rept	1000h-$-4
0FB0  FF      		db	0ffh
0FB1  FF      		db	0ffh
0FB2  FF      		db	0ffh
0FB3  FF      		db	0ffh
0FB4  FF      		db	0ffh
0FB5  FF      		db	0ffh
0FB6  FF      		db	0ffh
0FB7  FF      		db	0ffh
0FB8  FF      		db	0ffh
0FB9  FF      		db	0ffh
0FBA  FF      		db	0ffh
0FBB  FF      		db	0ffh
0FBC  FF      		db	0ffh
0FBD  FF      		db	0ffh
0FBE  FF      		db	0ffh
0FBF  FF      		db	0ffh
0FC0  FF      		db	0ffh
0FC1  FF      		db	0ffh
0FC2  FF      		db	0ffh
0FC3  FF      		db	0ffh
0FC4  FF      		db	0ffh
0FC5  FF      		db	0ffh
0FC6  FF      		db	0ffh
0FC7  FF      		db	0ffh
0FC8  FF      		db	0ffh
0FC9  FF      		db	0ffh
0FCA  FF      		db	0ffh
0FCB  FF      		db	0ffh
0FCC  FF      		db	0ffh
0FCD  FF      		db	0ffh
0FCE  FF      		db	0ffh
0FCF  FF      		db	0ffh
0FD0  FF      		db	0ffh
0FD1  FF      		db	0ffh
0FD2  FF      		db	0ffh
0FD3  FF      		db	0ffh
0FD4  FF      		db	0ffh
0FD5  FF      		db	0ffh
0FD6  FF      		db	0ffh
0FD7  FF      		db	0ffh
0FD8  FF      		db	0ffh
0FD9  FF      		db	0ffh
0FDA  FF      		db	0ffh
0FDB  FF      		db	0ffh
0FDC  FF      		db	0ffh
0FDD  FF      		db	0ffh
0FDE  FF      		db	0ffh
0FDF  FF      		db	0ffh
0FE0  FF      		db	0ffh
0FE1  FF      		db	0ffh
0FE2  FF      		db	0ffh
0FE3  FF      		db	0ffh
0FE4  FF      		db	0ffh
0FE5  FF      		db	0ffh
0FE6  FF      		db	0ffh
0FE7  FF      		db	0ffh
0FE8  FF      		db	0ffh
0FE9  FF      		db	0ffh
0FEA  FF      		db	0ffh
0FEB  FF      		db	0ffh
0FEC  FF      		db	0ffh
0FED  FF      		db	0ffh
0FEE  FF      		db	0ffh
0FEF  FF      		db	0ffh
0FF0  FF      		db	0ffh
0FF1  FF      		db	0ffh
0FF2  FF      		db	0ffh
0FF3  FF      		db	0ffh
0FF4  FF      		db	0ffh
0FF5  FF      		db	0ffh
0FF6  FF      		db	0ffh
0FF7  FF      		db	0ffh
0FF8  FF      		db	0ffh
0FF9  FF      		db	0ffh
0FFA  FF      		db	0ffh
0FFB  FF      		db	0ffh
0FFC          	romend:
0FFC  0000    		dw	0
0FFE          	chksum:
0FFE  1C65    		dw	0651ch	; checksum...
		
0000          	if	($ <> 1000h)
		endif
1000          		end



Statistics:

     4	passes
     0	jr promotions
   406	symbols
  4096	bytes

   741	macro calls
  3785	macro bytes
     0	invented symbols
