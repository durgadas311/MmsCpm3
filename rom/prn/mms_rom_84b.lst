		; Z89/Z90 Monitor EPROM 444-84B, by Magnolia Microsystems
		; Z89/Z90/H8-Z80 Monitor EPROM 444-84D, June 29, 2019, drm
0017          	VERN	equ	017h	; ROM version
		
0000          	false	equ	0
FFFF          	true	equ	not false
		
		; TODO: alter version based on config (or some string)
FFFF          	gide	equ	true
FFFF          	wiznet	equ	true
0000          	mms422	equ	false
0000          	remex	equ	false
0000          	corvus	equ	false
0000          	xcomp	equ	false
0000          	terminal equ	false
0000          	verify	equ	false
		
			maclib	z80
**** z80.lib ****
**** mms_rom_84b.asm ****
			$*macro
		
000D          	CR	equ	13
000A          	LF	equ	10
0007          	BEL	equ	7
001B          	ESC	equ	27
0000          	TRM	equ	0
007F          	DEL	equ	127
		
FFFF          	if gide
0080          	GIDE$BA	equ	80h		; GIDE base port
0088          	GIDE$DA	equ	GIDE$BA+8	; GIDE data port
0089          	GIDE$ER	equ	GIDE$BA+9	; GIDE error register (read)
0089          	GIDE$FR	equ	GIDE$BA+9	; GIDE feature register (write)
008A          	GIDE$SC	equ	GIDE$BA+10	; GIDE sector count
008B          	GIDE$SE	equ	GIDE$BA+11	; GIDE sector number
008C          	GIDE$CL	equ	GIDE$BA+12	; GIDE cylinder low
008D          	GIDE$CH	equ	GIDE$BA+13	; GIDE cylinder high
008E          	GIDE$DH	equ	GIDE$BA+14	; GIDE drive/head
008F          	GIDE$CS	equ	GIDE$BA+15	; GIDE command/status
		endif
		
FFFF          	if wiznet
		; WIZNET/NVRAM (SPI adapter) defines
0040          	spi	equ	40h	; base port
0040          	spi$dat	equ	spi+0
0041          	spi$ctl	equ	spi+1	; must be spi$dat+1
0041          	spi$sta	equ	spi+1
		
0001          	WZSCS	equ	01b	; /SCS for WIZNET
0002          	NVSCS	equ	10b	; /SCS for NVRAM
		
		; NVRAM constants
		; NVRAM/SEEPROM commands
0003          	NVRD	equ	00000011b
0002          	NVWR	equ	00000010b
0005          	RDSR	equ	00000101b
0006          	WREN	equ	00000110b
		; NVRAM/SEEPROM status bits
0001          	WIP	equ	00000001b
		
		; WIZNET constants
0008          	nsocks	equ	8
0008          	sock0	equ	000$01$000b	; base pattern for Sn_ regs
0014          	txbuf0	equ	000$10$100b	; base pattern for Tx buffer
0018          	rxbuf0	equ	000$11$000b	; base pattern for Rx buffer
		
		; common regs
0001          	gar	equ	1
0005          	subr	equ	5
0009          	shar	equ	9
000F          	sipr	equ	15
0015          	ir	equ	21
0017          	sir	equ	23
001D          	pmagic	equ	29
		
		; socket regs, relative
0000          	sn$mr	equ	0
0001          	sn$cr	equ	1
0002          	sn$ir	equ	2
0003          	sn$sr	equ	3
0004          	sn$prt	equ	4
000C          	sn$dipr	equ	12
0010          	sn$dprt	equ	16
001D          	sn$resv8 equ	29	; reserved
0024          	sn$txwr	equ	36
0026          	sn$rxrsr equ	38
0028          	sn$rxrd	equ	40
002F          	sn$kpalvtr equ	47
		
001D          	NvKPALVTR equ	sn$resv8 ; place to stash keep-alive in nvram
		
		; socket commands
0001          	OPEN	equ	01h
0004          	CONNECT	equ	04h
0008          	DISC	equ	08h
0020          	SEND	equ	20h
0040          	RECV	equ	40h
		
		; socket status
0013          	SOKINIT	equ	13h
0017          	ESTABLISHED equ	17h
		
2280          		org	2280h
2280          	server:	ds	1	; SID, dest of send
2281          	nodeid:	ds	1	; our node id
2282          	cursok:	ds	1	; current socket select patn
2283          	curptr:	ds	2	; into chip mem
2285          	msgptr:	ds	2
2287          	msglen:	ds	2
2289          	totlen:	ds	2
228B          	dma:	ds	2
		
2300          		org	2300h
		msgbuf:	ds	0
2300          	msg$fmt: ds	1
2301          	msg$did: ds	1
2302          	msg$sid: ds	1
2303          	msg$fnc: ds	1
2304          	msg$siz: ds	1
2305          	msg$dat: ds	128
		
2400          		org	2400h
2400          	nvbuf:	ds	512
		endif
		
		; Legacy devices and defines
		
1800          		org	01800h	; H17 Floppy ROM routines
1800          		ds	1014
1BF6          	R$ABORT: ds	35	;00011011.11110110	033.366	R.ABORT
1C19          	CLOCK:	ds	38	;00011100.00011001	034.031 CLOCK
1C3F          	R$READ:	ds	499	;00011100.00111111	034.077	R.READ
1E32          	R$SDP:	ds	107	;			034.062 R.SDP
1E9D          	R$WHD:	ds	28	;00011110.10011101	036.235	R.WHD
1EB9          	R$WNH:	ds	161	;00011110.10111001	036.271	R.WNH
1F5A          	R$CONST: ds	88	;00011111.01011010	037.132	R.CONST
1FB2          		ds	78
		
		; RAM variables, some defined by H17 Floppy ROM
2000          		org	02000h
2000          	ramstart:
2000          		ds	3
2003          	l2003h:	ds	1	; - 02003h
2004          	l2004h:	ds	1	; - 02004h
2005          		ds	3
2008          	l2008h:	ds	1	; - 02008h
2009          	ctl$F0:	ds	1	; - 02009h
200A          		ds	17
201B          	ticcnt:	ds	2	; - 0201bh
201D          	monstk:	ds	2	; - 0201dh
201F          	intvec:
201F          	vrst1:	ds	3	; rst1 jmp vector - 0201fh
2022          	vrst2:	ds	3	; rst2 jmp vector - 02022h
2025          	vrst3:	ds	3	; rst3 jmp vector - 02025h
2028          	vrst4:	ds	3	; rst4 jmp vector - 02028h
202B          	vrst5:	ds	3	; rst5 jmp vector - 0202bh
202E          	vrst6:	ds	3	; rst6 jmp vector - 0202eh
2031          	vrst7:	ds	3	; rst7 jmp vector - 02031h
2034          	l2034h:	ds	2	; - 02034h
2036          	ctl$F2:	ds	1	; - 02036h GPP template/image
2037          	l2037h:	ds	2	; - 02037h
2039          		ds	7
2040          	l2040h:	ds	8
2048          	D$CONST: ds	88+20	; - 02048h	disk constants
20B4          	DECNT:	ds	1	; - 020b4h
20B5          		ds	124
2131          	AIO$UNI: ds	1	; - 02131h
2132          	cmdbuf:	ds	6	; SASI command buffer
2138          	resbuf:	ds	2	; SASI result buffer
213A          		ds	22
2150          	cport:	ds	1	; - 02150h
2151          		ds	1
2152          	SEC$CNT:	ds	1	; - 02152h
2153          	l2153h:	ds	1
2154          		ds	2
2156          	l2156h:	ds	6	; cmdbuf for SASI, segoff for GIDE
215C          		ds	292
		bootbf:	ds	0	; - 02280h
		
3000          	memtest	equ	03000h
C000          	ramboot	equ	0c000h
		
		; Start of ROM code
0000          		org	00000h
		
0000          	rombeg:
0000  C33C04  	rst0:	jmp	init
		
0003  6F6F7420	bootms:	db	'oot ',TRM
      00
		
0008  CDC004  	rst1:	call	intsetup
000B  2A1B20  		lhld	ticcnt
000E  C3B900  		jmp	int1$cont
0000          	if ((high int1$cont) <> 0)
		endif
		
0010          	rst2	equ	$-1	; must be a nop...
0011  CDC004  		call	intsetup
0014  1A      		ldax	d
0015  C38001  		jmp	int2$cont
		
0018  C32520  	rst3:	jmp	vrst3
		
001B  6F2000  	goms:	db	'o ',TRM
001E  0000    		db	0,0
		
0020  C32820  	rst4:	jmp	vrst4
		
FFFF          	if wiznet
0023  C3230D  		jmp	sndrcv	; 'msgbuf' setup...
0026  6C05    		dw	conout	; pointer, not vector; A=char
		else
		endif
		
0028  C32B20  	rst5:	jmp	vrst5
002B          	delayx:
002B  C35602  		jmp	delay
		
002E  3F00    	qmsg:	db	'?',TRM
		
0030  C32E20  	rst6:	jmp	vrst6
		
FFFF          	if wiznet
0033  C3E60C  		jmp	wizopen	; 'server' set, D=socket BSB
0036  120D    		dw	wizclose ; 'cursok' set
		else
		endif
		
0038  C33120  	rst7:	jmp	vrst7
		
003B  75627374	subms:	db	'ubstitute ',TRM
      69747574
      652000
0046  726F6720	pcms:	db	'rog Counter ',TRM
      436F756E
      74657220
      00
0053  656D2074	mtms:	db	'em test',TRM
      65737400
005B  4175746F	autbms:	db	'Auto Boot',TRM
      20426F6F
      7400
		
			rept	0066h-$
0065  00      		db	0
0000          	if	($ <> 0066h)
		endif
		
0066          	nmi:
0066  E3      		xthl	; save HL and pop RETADR
0067  E5      		push	h	; put RETADR in new position
0068  F5      		push	psw
0069  2B      		dcx	h
006A  7E      		mov	a,m		; check cause of NMI
006B  FEF0    		cpi	0f0h	; H8 front-panel port
006D          		jrz	port$f0
006D  281B    		DB	28H,port$f0-$-1
006F  FEF1    		cpi	0f1h	; H8 port
0071          		jrz	port$ign
0071  2808    		DB	28H,port$ign-$-1
0073  FEFA    		cpi	0fah	; H8...
0075          		jrz	port$ign
0075  2804    		DB	28H,port$ign-$-1
0077  FEFB    		cpi	0fbh	; H8...
0079          		jrnz	nmi$xit2
0079  202D    		DB	20H,nmi$xit2-$-1
007B          	port$ign:	; ports 0F1H, 0FAH, 0FBH.
007B  2B      		dcx	h
007C  7E      		mov	a,m
007D  FED3    		cpi	0d3h	; OUT
007F          		jrz	nmi$xit2
007F  2827    		DB	28H,nmi$xit2-$-1
0081  FEDB    		cpi	0dbh	; IN
0083          		jrnz	nmi$xit2
0083  2023    		DB	20H,nmi$xit2-$-1
			; IN 0F1H, 0FAH or 0FBH...
0085  F1      		pop	psw
0086  3E00    		mvi	a,000h	; these ports "return" 000h
0088          		jr	nmi$xit	; exit NMI
0088  181F    		DB	18H,nmi$xit-$-1
		
008A          	port$f0:	; H8 front panel port...
008A  2B      		dcx	h
008B  7E      		mov	a,m
008C  FEDB    		cpi	0dbh	; IN
008E          		jrnz	not$in
008E  2005    		DB	20H,not$in-$-1
0090  F1      		pop	psw
0091  3EFF    		mvi	a,0ffh	; simulate input of 0ffh
0093          		jr	nmi$xit
0093  1814    		DB	18H,nmi$xit-$-1
0095          	not$in:
0095  FED3    		cpi	0d3h	; OUT
0097          		jrnz	nmi$xit2
0097  200F    		DB	20H,nmi$xit2-$-1
0099  F1      		pop	psw	; byte to output to 0F0H...
009A  F5      		push	psw	; _  7 6 5 4 3 2 1 0
009B  17      		ral		; 7  6 5 4 3 2 1 0 _
009C  17      		ral		; 6  5 4 3 2 1 0 _ 7
009D  2F      		cma		; 6  5'4'3'2'1'0'_ 7'
009E  17      		ral		; 5' 4'3'2'1'0'_ 7'6
009F  07      		rlc		; 4' 3'2'1'0'_ 7'6 5'
00A0  E603    		ani	003h	; _  _ _ _ _ _ _ 6 5'
00A2  213620  		lxi	h,ctl$F2
00A5  B6      		ora	m
00A6  D3F2    		out	0f2h ; simulate some H8 features
00A8          	nmi$xit2:
00A8  F1      		pop	psw
00A9          	nmi$xit:
00A9  E1      		pop	h
00AA  E3      		xthl
00AB          		retn
00AB  ED45    		DB	0EDH,45H
		
00AD          	int1$1:
00AD  0A      		ldax	b
00AE  0F      		rrc
00AF  DC1F20  		cc	vrst1
00B2          	intret:
00B2  F1      		pop	psw
00B3  F1      		pop	psw
00B4  C1      		pop	b
00B5  D1      		pop	d
00B6  E1      		pop	h
00B7          	nulint:
00B7  FB      		ei
00B8  C9      		ret
		
00B9          	int1$cont:
00B9  23      		inx	h
00BA  221B20  		shld	ticcnt
00BD  010920  		lxi	b,ctl$F0
00C0  0A      		ldax	b
00C1  D3F0    		out	0f0h
00C3  E620    		ani	020h
00C5          		jrnz	intret
00C5  20EB    		DB	20H,intret-$-1
00C7  0B      		dcx	b
00C8          	int1$0:
00C8  0A      		ldax	b
00C9  17      		ral
00CA          		jrc	int1$1
00CA  38E1    		DB	38H,int1$1-$-1
00CC  210A00  		lxi	h,10
00CF  39      		dad	sp
00D0  5E      		mov	e,m
00D1  23      		inx	h
00D2  56      		mov	d,m
00D3  1B      		dcx	d
00D4  1A      		ldax	d
00D5  FE76    		cpi	076h	; HLT
00D7          		jrnz	int1$1
00D7  20D4    		DB	20H,int1$1-$-1
00D9  CD6A05  		call	belout
00DC  3E48    		mvi	a,'H'
00DE  CD6C05  		call	conout
00E1          	re$entry:		; re-entry point for errors, etc.
00E1  210920  		lxi	h,ctl$F0
00E4  36F0    		mvi	m,0f0h	; !beep, 2mS, MON, !SI
00E6  2A1D20  		lhld	monstk
00E9  F9      		sphl
00EA  CD6A05  		call	belout
			;jmp	start
00ED          	start:
00ED  FB      		ei
00EE  21ED00  		lxi	h,start
00F1  E5      		push	h
00F2  21D207  		lxi	h,prompt
00F5  CD3406  		call	msgout
00F8          	prloop:
00F8  CD5605  		call	coninx
00FB  E65F    		ani	01011111b ; toupper
00FD  211B01  		lxi	h,cmdtab
0100  0605    		mvi	b,5
0102          	cmloop:
0102  BE      		cmp	m
0103  23      		inx	h
0104          		jrz	docmd
0104  280D    		DB	28H,docmd-$-1
0106  23      		inx	h
0107  23      		inx	h
0108          		djnz	cmloop
0108  10F8    		DB	10H,cmloop-$-1
010A  4F      		mov	c,a
010B  CDE707  		call	xcmds
010E  CD6A05  		call	belout
0111          		jr	prloop
0111  18E5    		DB	18H,prloop-$-1
		
0113          	docmd:
0113  CD6C05  		call	conout
0116  7E      		mov	a,m
0117  23      		inx	h
0118  66      		mov	h,m
0119  6F      		mov	l,a
011A  E9      		pchl
		
011B          	cmdtab:
011B  47      		db	'G'
011C  5A01    		dw	cmdgo
011E  53      		db	'S'
011F  F804    		dw	cmdsub
0121  50      		db	'P'
0122  3A01    		dw	cmdpc
0124  42      		db	'B'
0125  9F02    		dw	cmdboot
0127  4D      		db	'M'
0128  4F06    		dw	cmdmt
012A  00      		db	0
		
			; patched-out code?
012B  00      		db	000h
012C  00      		db	000h
012D  00      		db	000h
012E  00      		db	000h
012F  00      		db	000h
0130  00      		db	000h
0131  00      		db	000h
0132  00      		db	000h
0133  00      		db	000h
0134  00      		db	000h
0135  00      		db	000h
0136  00      		db	000h
0137  C31804  		jmp	z47$dati
		
013A          	cmdpc:
013A  214600  		lxi	h,pcms
013D  CD3406  		call	msgout
0140  210C00  		lxi	h,12
0143  39      		dad	sp
0144  5E      		mov	e,m
0145  23      		inx	h
0146  56      		mov	d,m
0147  EB      		xchg
0148  CD4005  		call	inhexcr
014B          		jrc	cmdpc0
014B  3807    		DB	38H,cmdpc0-$-1
014D  CDBF05  		call	adrnl
0150  CD4005  		call	inhexcr
0153  D0      		rnc
0154          	cmdpc0:
0154  EB      		xchg
0155          	cmdpc1:
0155  160D    		mvi	d,CR
0157  C37705  		jmp	adrin
		
015A          	cmdgo:
015A  211B00  		lxi	h,goms
015D  CD3406  		call	msgout
0160  210D00  		lxi	h,13
0163  39      		dad	sp
0164  CD4005  		call	inhexcr
0167  DC5501  		cc	cmdpc1	; read HEX until CR
016A  CD2A06  		call	crlf
016D  3ED0    		mvi	a,0d0h	; no-beep, 2mS, !MON, !single-step
016F          		jr	cmdgo0
016F  1808    		DB	18H,cmdgo0-$-1
0171  F3      		di
0172  3A0920  		lda	ctl$F0
0175  EE10    		xri	010h	; toggle single-step
0177  D3F0    		out	0f0h
0179          	cmdgo0:
0179  320920  		sta	ctl$F0
017C  E1      		pop	h
017D  C3B200  		jmp	intret
		
0180          	int2$cont:
0180  F610    		ori	010h	; disable single-step
0182  D3F0    		out	0f0h
0184  12      		stax	d
0185  E620    		ani	020h	; MON active?
0187  C2ED00  		jnz	start	; break to monitor code
018A  C32220  		jmp	vrst2	; else chain to (possible) user code.
		
018D          	take$5:
018D  3E05    		mvi	a,5	; 5 seconds
018F          	take$A:
018F  219F01  		lxi	h,timeout
0192  222020  		shld	vrst1+1
0195  325221  		sta	SEC$CNT
0198  3E01    		mvi	a,1
019A  320820  		sta	l2008h
019D  FB      		ei
019E  C9      		ret
		
019F          	timeout:
019F  211B20  		lxi	h,ticcnt
01A2  AF      		xra	a
01A3  B6      		ora	m
01A4  C0      		rnz
01A5  23      		inx	h
01A6  7E      		mov	a,m
01A7  0F      		rrc
01A8  D8      		rc
			; every 512 ticks... 1024mS
01A9  215221  		lxi	h,SEC$CNT
01AC  35      		dcr	m
01AD  C0      		rnz
01AE          	error:
01AE  2A1D20  		lhld	monstk
01B1  F9      		sphl
01B2  212E00  		lxi	h,qmsg
01B5  CD3406  		call	msgout
01B8  21B700  		lxi	h,nulint
01BB  222020  		shld	vrst1+1
01BE  320820  		sta	l2008h
01C1  DBF2    		in	0f2h
01C3  E603    		ani	00000011b
01C5          		jrnz	error0
01C5  2002    		DB	20H,error0-$-1
01C7  D37F    		out	07fh
01C9          	error0:
01C9  C3E100  		jmp	re$entry
		
01CC          	chkauto:
01CC  215321  		lxi	h,l2153h	; auto-boot disable?
01CF  DBF2    		in	0f2h
01D1  57      		mov	d,a
01D2  EE80    		xri	080h	; toggle auto-boot
01D4  B6      		ora	m
01D5  F8      		rm		; auto-boot OFF
01D6  72      		mov	m,d	; ensure we only fail once... and only on power-up?
01D7  CD0202  		call	gtdfbt
01DA  215B00  		lxi	h,autbms
01DD  CD3406  		call	msgout
01E0  318022  		lxi	sp,bootbf
01E3  C34C03  		jmp	goboot0
		
		; determine device for port 078H
		; return phy drv number in D.
01E6          	gtdev1:
01E6  1600    		mvi	d,0	; Z17
01E8  DBF2    		in	0f2h
01EA          	gtdev0:
01EA  E603    		ani	00000011b	; port 078H device
01EC  C8      		rz		; Z17 (or Z37)
01ED  FE01    		cpi	01b
01EF  1605    		mvi	d,5
01F1  C8      		rz		; Z47
01F2  FE02    		cpi	10b
01F4  1603    		mvi	d,3
01F6  C8      		rz		; Z67/MMS77320
0000          	if mms422
		else
01F7  C3AE01  		jmp	error	; fatal error... not defined
		endif
		
		; determine device for port 078H
		; return phy drv number in D.
01FA          	gtdev2:
01FA  162E    		mvi	d,46	; Z37
01FC  DBF2    		in	0f2h
01FE  0F      		rrc
01FF  0F      		rrc
0200          		jr	gtdev0	; rest are same
0200  18E8    		DB	18H,gtdev0-$-1
		
		; determine default boot device.
0202          	gtdfbt:
0202  110000  		lxi	d,0
0205  DBF2    		in	0f2h
0207  E670    		ani	01110000b	; default boot selection
0209  FE20    		cpi	00100000b	; device at 07CH
020B          		jrz	gtdev1
020B  28D9    		DB	28H,gtdev1-$-1
020D  FE30    		cpi	00110000b	; device at 078H
020F          		jrz	gtdev2
020F  28E9    		DB	28H,gtdev2-$-1
0211  C30B08  		jmp	gtdvtb		; get MMS device
		
		; Check SW501 for installed device.
		; C = desired port pattern, 00=Z17/Z37, 01=Z47, 10=Z67, 11=undefined
		; returns base I/O port adr in B.
0214          	getport:
0214  067C    		mvi	b,07ch
0216  DBF2    		in	0f2h
0218  E603    		ani	003h
021A  B9      		cmp	c
021B  C8      		rz
021C  0678    		mvi	b,078h
021E  DBF2    		in	0f2h
0220  0F      		rrc
0221  0F      		rrc
0222  E603    		ani	003h
0224  B9      		cmp	c
0225  C8      		rz
0226  E1      		pop	h	; discard return address
0227          	s501er:
0227  212D02  		lxi	h,s501ms
022A  C33406  		jmp	msgout
		
022D  53573530	s501ms:	db	'SW501 wrong ',TRM
      31207772
      6F6E6720
      00
		
		; hack to support 3 drives on H17
023A          	m$sdp:
023A  3E0A    		mvi	a,10
023C  32B420  		sta	DECNT
023F  3A3121  		lda	AIO$UNI
0242  F5      		push	psw	; 0,1,2
0243  C6FE    		adi	-2	;
0245  CE03    		aci	3	; 1,2,4
0247  C33C1E  		jmp	R$SDP+10	; hacked R.SDP for 3-drives
		
024A          	inport0:
024A  B7      		ora	a	; NC
		; input from cport+CY
024B          	inportx:
024B  C5      		push	b
024C  3A5021  		lda	cport
024F  CE00    		aci	0
0251  4F      		mov	c,a
0252          		inp	a
0252  ED78    		DB	0EDH,a*8+40H
0254  C1      		pop	b
0255  C9      		ret
		
0256          	delay:
0256  E5      		push	h
0257  211B20  		lxi	h,ticcnt
025A  86      		add	m
025B          	delay0:
025B  BE      		cmp	m
025C          		jrnz	delay0
025C  20FD    		DB	20H,delay0-$-1
025E  E1      		pop	h
025F  C9      		ret
		
0260          	digerr:
0260  CD6A05  		call	belout
0263          		jr	btdig0
0263  1806    		DB	18H,btdig0-$-1
		; Got a digit in boot command, parse it
0265          	btdig:	; boot by phys drive number, E=0
0265  CD6C05  		call	conout	; echo digit
0268  E60F    		ani	00fh	; convert to binary
026A  57      		mov	d,a
026B          	btdig0:
026B  CD5B05  		call	conin	; get another, until term char (C)
026E  B9      		cmp	c
026F          		jrz	gotnum
026F  281D    		DB	28H,gotnum-$-1
0271  FE30    		cpi	'0'
0273          		jrc	digerr
0273  38EB    		DB	38H,digerr-$-1
0275  FE3A    		cpi	'9'+1
0277          		jrnc	digerr
0277  30E7    		DB	30H,digerr-$-1
0279  CD6C05  		call	conout
027C  E60F    		ani	00fh
027E  060A    		mvi	b,10	; add 10 times, i.e. D = (D * 10) + A
0280          	btdig1:
0280  82      		add	d
0281  DAAE01  		jc	error
0284          		djnz	btdig1
0284  10FA    		DB	10H,btdig1-$-1
0286  57      		mov	d,a
0287  FEC8    		cpi	200
0289  D2AE01  		jnc	error
028C          		jr	btdig0
028C  18DD    		DB	18H,btdig0-$-1
		
028E          	gotnum:	; Boot N... "N" in D
028E  7A      		mov	a,d
028F  FE05    		cpi	5
0291  DA4903  		jc	goboot
0294  FE09    		cpi	9
0296  D24903  		jnc	goboot
0299  C6C8    		adi	200	; modify 5..8 to not conflict
029B  57      		mov	d,a
029C  C34903  		jmp	goboot
		
029F          	cmdboot:
029F  210300  		lxi	h,bootms
02A2  CD3406  		call	msgout	; complete (B)oot
02A5  3EC3    		mvi	a,0c3h
02A7  328022  		sta	bootbf	; mark "no string"
02AA  318022  		lxi	sp,bootbf
02AD  CD0202  		call	gtdfbt
02B0  0E0D    		mvi	c,CR	; end input on CR
02B2          		jr	boot0
02B2  1803    		DB	18H,boot0-$-1
02B4          	bterr:
02B4  CD6A05  		call	belout
02B7          	boot0:
02B7  CD5B05  		call	conin
02BA  B9      		cmp	c
02BB  CA4903  		jz	goboot
02BE  1E00    		mvi	e,0
02C0  FE30    		cpi	'0'
02C2          		jrc	nodig
02C2  3804    		DB	38H,nodig-$-1
02C4  FE3A    		cpi	'9'+1
02C6          		jrc	btdig
02C6  389D    		DB	38H,btdig-$-1
02C8          	nodig:	; boot by letter... Boot alpha-
02C8  E65F    		ani	05fh ; toupper
02CA  FE5B    		cpi	'Z'+1
02CC          		jrnc	bterr
02CC  30E6    		DB	30H,bterr-$-1
02CE  FE41    		cpi	'A'
02D0          		jrc	bterr
02D0  38E2    		DB	38H,bterr-$-1
02D2  CD6C05  		call	conout
02D5  CD6C05  		call	conout
02D8  FE42    		cpi	'B'
02DA          		jrc	gotit	; 'A' is synonym for default
02DA  3816    		DB	38H,gotit-$-1
02DC  211A06  		lxi	h,bootb1	; Heath/Zenith device letters
02DF  47      		mov	b,a
02E0          	luboot:
02E0  7E      		mov	a,m
02E1  23      		inx	h
02E2  56      		mov	d,m
02E3  23      		inx	h
02E4  B8      		cmp	b
02E5          		jrz	gotit
02E5  280B    		DB	28H,gotit-$-1
02E7  B7      		ora	a
02E8          		jrnz	luboot
02E8  20F6    		DB	20H,luboot-$-1
02EA  1600    		mvi	d,0
02EC  CD3C08  		call	mmslookup
02EF  DAAE01  		jc	error
02F2          	gotit:
02F2  3E2D    		mvi	a,'-'	; next is optional unit number...
02F4  CD6C05  		call	conout
02F7          		jr	luboot0
02F7  1803    		DB	18H,luboot0-$-1
		
02F9          	lunerr:
02F9  CD6A05  		call	belout
02FC          	luboot0:
02FC  CD5B05  		call	conin
02FF  B9      		cmp	c
0300          		jrz	goboot
0300  2847    		DB	28H,goboot-$-1
0302  FE3A    		cpi	':'
0304          		jrz	colon
0304  2827    		DB	28H,colon-$-1
0306  FE20    		cpi	' '
0308          		jrz	space
0308  281E    		DB	28H,space-$-1
030A  FE30    		cpi	'0'
030C          		jrc	lunerr
030C  38EB    		DB	38H,lunerr-$-1
030E  FE3A    		cpi	'9'+1
0310          		jrnc	lunerr
0310  30E7    		DB	30H,lunerr-$-1
0312  CD6C05  		call	conout
0315  D630    		sui	'0'
0317  5F      		mov	e,a	; single digit (0..9)
0318          	luboot1:
0318  CD5B05  		call	conin
031B  B9      		cmp	c
031C          		jrz	goboot
031C  282B    		DB	28H,goboot-$-1
031E  FE3A    		cpi	':'	; Boot alpha-dig:str
0320          		jrz	colon
0320  280B    		DB	28H,colon-$-1
0322  FE20    		cpi	' '	; cosmetic spaces?
0324          		jrz	space
0324  2802    		DB	28H,space-$-1
0326  3E07    		mvi	a,BEL
0328          	space:
0328  CD6C05  		call	conout
032B          		jr	luboot1
032B  18EB    		DB	18H,luboot1-$-1
		
032D          	colon:	; get arbitrary string as last boot param
032D  0600    		mvi	b,0
032F  218022  		lxi	h,bootbf
0332          	btstr0:
0332  CD6C05  		call	conout
0335  CD5B05  		call	conin
0338  04      		inr	b
0339  23      		inx	h
033A  77      		mov	m,a
033B  B9      		cmp	c
033C          		jrnz	btstr0
033C  20F4    		DB	20H,btstr0-$-1
033E  78      		mov	a,b
033F  328022  		sta	bootbf	; bootbf: <len> <string...> as in CP/M cmd buf
0342  AF      		xra	a	; TRM - string terminator
0343          	btstr1:	; use stack as char array...
0343  F5      		push	psw
0344  33      		inx	sp	; undo half of push
0345  2B      		dcx	h
0346  7E      		mov	a,m
0347          		djnz	btstr1
0347  10FA    		DB	10H,btstr1-$-1
		; D=Phys Drive base number, E=Unit number
		; (or, D=Phys Drive unit, E=0)
0349          	goboot:
0349  CD2A06  		call	crlf
034C          	goboot0:
034C  21AE01  		lxi	h,error
034F  E5      		push	h
0350  CDA207  		call	h17init
0353  7B      		mov	a,e
0354  323121  		sta	AIO$UNI	; relative unit num
0357  82      		add	d
0358  323420  		sta	l2034h	; boot phys drv unit num
035B  7A      		mov	a,d
035C  FE03    		cpi	3	; 0,1,2
035E          		jrc	bz17	; Z17 boot
035E  3809    		DB	38H,bz17-$-1
			; 3,4 not used?
0360  D605    		sui	5
0362  FE04    		cpi	4	; 5,6,7,8
0364          		jrc	bz47	; Z47 boot
0364  3847    		DB	38H,bz47-$-1
0366  C3F307  		jmp	exboot	;
		
0369          	bz17:
0369  83      		add	e
036A  FE03    		cpi	3
036C  D0      		rnc	; invalid Z17 drive
036D  323121  		sta	AIO$UNI
0370  DBF2    		in	0f2h
0372  E603    		ani	00000011b
0374  C22702  		jnz	s501er	; no Z17 installed
0377  3E7C    		mvi	a,07ch
0379  325021  		sta	cport
037C  213A02  		lxi	h,m$sdp
037F  228620  		shld	D$CONST+62
0382  3E0A    		mvi	a,10
0384  47      		mov	b,a	; B = 10, one full revolution?
0385  CD8F01  		call	take$A	; error after 10 seconds...
0388  CD3A02  		call	m$sdp	; hacked R.SDP - setup dev parms (select drive)
038B          	bz17$0:
038B  CD9D1E  		call	R$WHD	; WHD - wait hole detect
038E  CDB91E  		call	R$WNH	; WNH - wait no hole
0391          		djnz	bz17$0	; essentially hang until user inserts a disk...
0391  10F8    		DB	10H,bz17$0-$-1
0393  CDF61B  		call	R$ABORT	; R.ABORT - reset everything
0396  118022  		lxi	d,bootbf	; DMA address
0399  010009  		lxi	b,00900h	; B = 9 (num sectors), C = 0 (residual bytes to read)
039C  210000  		lxi	h,0		; track/sector number to start
039F  CD3F1C  		call	R$READ
03A2  D8      		rc
03A3  E1      		pop	h
03A4          	hxboot:
03A4  21191C  		lxi	h,CLOCK	; CLOCK - standard 2mS handler
03A7  222020  		shld	vrst1+1 ; normal TICK intr routine
03AA  C38022  		jmp	bootbf	; run boot code...
		
03AD          	bz47:
03AD  83      		add	e
03AE  FE04    		cpi	004h
03B0  D0      		rnc
03B1  0F      		rrc
03B2  0F      		rrc
03B3  0F      		rrc
03B4  3C      		inr	a
03B5  5F      		mov	e,a
03B6  0E01    		mvi	c,01b
03B8  CD1402  		call	getport
03BB  78      		mov	a,b
03BC  325021  		sta	cport
03BF  CD8D01  		call	take$5	; error out after 5 seconds...
03C2  3E02    		mvi	a,2
03C4  CD0A04  		call	outport0
03C7  3E02    		mvi	a,2
03C9  CDFD03  		call	z47$cmdo
03CC  7B      		mov	a,e
03CD  CDF903  		call	z47$dato
03D0  CD1804  		call	z47$dati
03D3  E60C    		ani	00ch
03D5  0F      		rrc
03D6  0F      		rrc
03D7  3C      		inr	a
03D8  47      		mov	b,a
03D9  3E01    		mvi	a,1
03DB          	bz47$0:
03DB  87      		add	a
03DC          		djnz	bz47$0
03DC  10FD    		DB	10H,bz47$0-$-1
03DE  1F      		rar
03DF  47      		mov	b,a
03E0  218022  		lxi	h,bootbf
03E3  C5      		push	b
03E4  CD2104  		call	z47$read
03E7  C1      		pop	b
03E8  1C      		inr	e
03E9  CD2104  		call	z47$read
03EC  CD4A02  		call	inport0
03EF  E601    		ani	001h
03F1  C0      		rnz
03F2          	hwboot:
03F2  AF      		xra	a
03F3  320820  		sta	l2008h
03F6  C3A403  		jmp	hxboot
		
03F9          	z47$dato:
03F9  1680    		mvi	d,080h	; TR - date transfer request
03FB          		jr	z47$out0
03FB  1802    		DB	18H,z47$out0-$-1
03FD          	z47$cmdo:
03FD  1620    		mvi	d,020h	; DONE
03FF          	z47$out0:
03FF  37      		stc
0400  F5      		push	psw
0401          	z47$wt0:
0401  CD4A02  		call	inport0
0404  A2      		ana	d
0405          		jrz	z47$wt0
0405  28FA    		DB	28H,z47$wt0-$-1
0407  F1      		pop	psw
0408          		jr	z47$out1
0408  1801    		DB	18H,z47$out1-$-1
040A          	outport0:
040A  B7      		ora	a
040B          	z47$out1:
040B  C5      		push	b
040C  47      		mov	b,a
040D  3A5021  		lda	cport
0410  CE00    		aci	0
0412  4F      		mov	c,a
0413  78      		mov	a,b
0414          		outp	a
0414  ED79    		DB	0EDH,a*8+41H
0416  C1      		pop	b
0417  C9      		ret
		
0418          	z47$dati:
0418  CD4A02  		call	inport0
041B  07      		rlc	; TR
041C          		jrnc	z47$dati
041C  30FA    		DB	30H,z47$dati-$-1
041E  C34B02  		jmp	inportx	; CY=1, input cport+1
		
0421          	z47$read:
0421  3E07    		mvi	a,7	; read thru buffer command
0423  CDFD03  		call	z47$cmdo
0426  AF      		xra	a
0427  CDF903  		call	z47$dato	; params
042A  7B      		mov	a,e
042B  CDF903  		call	z47$dato	; params
042E          	z47$rd0:
042E  0E80    		mvi	c,128
0430          	z47$rd1:
0430  CD1804  		call	z47$dati
0433  77      		mov	m,a
0434  23      		inx	h
0435  0D      		dcr	c
0436          		jrnz	z47$rd1
0436  20F8    		DB	20H,z47$rd1-$-1
0438  05      		dcr	b
0439          		jrnz	z47$rd0
0439  20F3    		DB	20H,z47$rd0-$-1
043B  C9      		ret
		
		; ROM start point - initialize everything
043C          	init:
			; find amount of RAM
043C  21001F  		lxi	h,ramstart-0100h
043F          	ramsiz:
043F  24      		inr	h
0440  7E      		mov	a,m
0441  34      		inr	m
0442  BE      		cmp	m
0443  77      		mov	m,a
0444          		jrnz	ramsiz
0444  20F9    		DB	20H,ramsiz-$-1
0446  2B      		dcx	h
0447  F9      		sphl		; set SP to top of RAM (-1)
0448  E5      		push	h	; save top on stack
0449  21E100  		lxi	h,re$entry
044C  E5      		push	h
			; determine H19 BAUD, by experimentation
044D  0E03    		mvi	c,003h	; br38400
044F          	baud0:
044F  3E83    		mvi	a,083h
0451  D3EB    		out	0ebh
0453  AF      		xra	a
0454  D3E9    		out	0e9h
0456  79      		mov	a,c
0457  D3E8    		out	0e8h
0459  07      		rlc
045A  4F      		mov	c,a
045B  3E03    		mvi	a,003h
045D  D3EB    		out	0ebh
045F  AF      		xra	a
0460  D3E9    		out	0e9h
0462  DBE8    		in	0e8h
0464  21DB04  		lxi	h,initms	; ask H19 for response...
0467  CD3406  		call	msgout
046A  0619    		mvi	b,25	; loop 6400 times... let Rx overrun...
046C          	baud1:
046C  3D      		dcr	a
046D          		jrnz	baud1	; 4096 cycles each
046D  20FD    		DB	20H,baud1-$-1
046F          		djnz	baud1	; +13 * 25... 102725 cycles, about 50mS
046F  10FB    		DB	10H,baud1-$-1
0471  DBED    		in	0edh
0473  1F      		rar
0474  DBE8    		in	0e8h
0476  17      		ral
0477  D697    		sui	097h
0479          		jrnz	baud0
0479  20D4    		DB	20H,baud0-$-1
047B  23      		inx	h
047C  CD3406  		call	msgout
047F  060F    		mvi	b,15	; 15*256 = 3840 loops
0481          	baud2:
0481  3D      		dcr	a
0482          		jrnz	baud2
0482  20FD    		DB	20H,baud2-$-1
0484          		djnz	baud2
0484  10FB    		DB	10H,baud2-$-1
0486  3E0F    		mvi	a,00001111b	; all outputs ON
0488  D3EC    		out	0ech		; OUT2=1 hides 16C2550 intr enable diff
0000          	if verify
		else
048A          		jr	rom$ok
048A  1805    		DB	18H,rom$ok-$-1
		endif
048C          	msg$die:
048C  CD3406  		call	msgout
048F  F3      		di
0490  76      		hlt
0491          	rom$ok:
0491  AF      		xra	a
0492  325321  		sta	l2153h
0495  323620  		sta	ctl$F2	; 2mS, Org0 OFF
0498  3EC9    		mvi	a,0c9h	; RET
049A  320420  		sta	l2004h
049D  210050  		lxi	h,05000h	; 0, (beep, 2mS, !MON, !SI)
04A0  220820  		shld	l2008h
04A3  CF      		rst	1	; kick-start clock
04A4  211B20  		lxi	h,ticcnt
04A7  11C800  		lxi	d,0280h-440	; tuned to produce ~0x280 for 2.048MHz
04AA  7E      		mov	a,m
04AB          	tick0:	; wait for next tick of clock...
04AB  BE      		cmp	m
04AC          		jrz	tick0
04AC  28FD    		DB	28H,tick0-$-1
04AE  C605    		adi	5	; +10mS (actually, +8mS from new tick)
04B0          	tick1:
04B0  13      		inx	d	; count CPU cycles for 8mS...
04B1  BE      		cmp	m	; but note: 2mS interrupt overhead,
04B2  BE      		cmp	m	; so count will be low.
04B3          		jrnz	tick1	; each loop = 32 cycles
04B3  20FB    		DB	20H,tick1-$-1
04B5  7A      		mov	a,d
04B6  FE02    		cpi	2	; min 9984 cycles... 1.248MHz...
					; max 18144 cycles... 2.268MHz
04B8          		jrz	intsetup
04B8  2806    		DB	28H,intsetup-$-1
			; Unsupported CPU speed...
04BA  21E704  		lxi	h,unsupm
04BD  CD3406  		call	msgout
		
04C0          	intsetup:
04C0  E3      		xthl
04C1  D5      		push	d
04C2  C5      		push	b
04C3  F5      		push	psw
04C4  EB      		xchg
04C5  210A00  		lxi	h,10
04C8  39      		dad	sp
04C9  E5      		push	h
04CA  D5      		push	d
04CB  110920  		lxi	d,ctl$F0
04CE  1A      		ldax	d
04CF  2F      		cma
04D0  E630    		ani	030h
04D2  C8      		rz
04D3  210200  		lxi	h,2
04D6  39      		dad	sp
04D7  221D20  		shld	monstk
04DA  C9      		ret
		
04DB  801B5B3F	initms:	db	080h,ESC,'[?2h',ESC,'Z',TRM
      32681B5A
      00
04E4  1B7A00  		db	ESC,'z',TRM
		
04E7  556E7375	unsupm:	db	'Unsupp CPU speed',TRM
      70702043
      50552073
      70656564
      00
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Substitute command
04F8          	cmdsub:
04F8  213B00  		lxi	h,subms
04FB  CD3406  		call	msgout
04FE  210320  		lxi	h,l2003h
0501  160D    		mvi	d,CR
0503  CD7705  		call	adrin
0506  EB      		xchg
0507          	cmdsub0:
0507  CDBF05  		call	adrnl
050A  7E      		mov	a,m
050B  CDCE05  		call	hexout
050E  CDCA05  		call	spout
0511          	cmdsub1:
0511  CDAC05  		call	hexin
0514          		jrnc	cmdsub4
0514  3019    		DB	30H,cmdsub4-$-1
0516  FE0D    		cpi	CR
0518          		jrz	cmdsub2
0518  280C    		DB	28H,cmdsub2-$-1
051A  FE2D    		cpi	'-'
051C          		jrz	cmdsub3
051C  280B    		DB	28H,cmdsub3-$-1
051E  FE2E    		cpi	'.'
0520  C8      		rz
0521  CD6A05  		call	belout
0524          		jr	cmdsub1
0524  18EB    		DB	18H,cmdsub1-$-1
0526          	cmdsub2:
0526  23      		inx	h
0527          		jr	cmdsub0
0527  18DE    		DB	18H,cmdsub0-$-1
0529          	cmdsub3:
0529  CD6C05  		call	conout
052C  2B      		dcx	h
052D          		jr	cmdsub0
052D  18D8    		DB	18H,cmdsub0-$-1
052F          	cmdsub4:
052F  3600    		mvi	m,000h
0531          	cmdsub5:
0531  CD6C05  		call	conout
0534  CDA305  		call	hexbin
0537          		rld
0537  ED6F    		DB	0EDH, 6FH
0539  CD4005  		call	inhexcr
053C          		jrnc	cmdsub2
053C  30E8    		DB	30H,cmdsub2-$-1
053E          		jr	cmdsub5
053E  18F1    		DB	18H,cmdsub5-$-1
		
0540          	inhexcr:
0540  CD5B05  		call	conin
0543  FE0D    		cpi	CR
0545  C8      		rz
0546  CDAF05  		call	hexchk
0549  3F      		cmc
054A  D8      		rc
054B  CD6A05  		call	belout
054E          		jr	inhexcr
054E  18F0    		DB	18H,inhexcr-$-1
		
		; This loop checks for auto boot while waiting for command input.
		; Theoretically, one could flip the auto-boot dipsw at the MMS: prompt?
0550          	coninx0:
0550  CDCC01  		call	chkauto
0553  CDE607  		call	nulfn	; some patched-out code?
0556          	coninx:
0556  DBED    		in	0edh
0558  0F      		rrc
0559          		jrnc	coninx0
0559  30F5    		DB	30H,coninx0-$-1
055B          	conin:
055B  DBED    		in	0edh
055D  0F      		rrc
055E          		jrnc	conin
055E  30FB    		DB	30H,conin-$-1
0560  DBE8    		in	0e8h
0562  E67F    		ani	07fh
0564  FE7F    		cpi	DEL	; DEL key restarts from anywhere?
0566  CAE100  		jz	re$entry
0569  C9      		ret
		
056A          	belout:
056A  3E07    		mvi	a,BEL
056C          	conout:
056C  F5      		push	psw
056D          	conot1:
056D  DBED    		in	0edh
056F  E620    		ani	00100000b
0571          		jrz	conot1
0571  28FA    		DB	28H,conot1-$-1
0573  F1      		pop	psw
0574  D3E8    		out	0e8h
0576  C9      		ret
		
		; D=term char (e.g. '.' for Substitute)
		; HL=location to store address
0577          	adrin:
0577  E5      		push	h
0578  210000  		lxi	h,0
057B          	adrin0:
057B  D45B05  		cnc	conin
057E  CDAF05  		call	hexchk
0581          		jrc	adrin1
0581  380E    		DB	38H,adrin1-$-1
0583  CD6C05  		call	conout
0586  CDA305  		call	hexbin
0589  29      		dad	h
058A  29      		dad	h
058B  29      		dad	h
058C  29      		dad	h
058D  B5      		ora	l
058E  6F      		mov	l,a
058F          		jr	adrin0
058F  18EA    		DB	18H,adrin0-$-1
0591          	adrin1:
0591  BA      		cmp	d
0592          		jrz	adrin2
0592  2806    		DB	28H,adrin2-$-1
0594  CD6A05  		call	belout
0597  B7      		ora	a
0598          		jr	adrin0
0598  18E1    		DB	18H,adrin0-$-1
059A          	adrin2:
059A  CD6C05  		call	conout
059D  EB      		xchg
059E  E1      		pop	h
059F  72      		mov	m,d
05A0  2B      		dcx	h
05A1  73      		mov	m,e
05A2  C9      		ret
		
05A3          	hexbin:
05A3  D63A    		sui	'9'+1
05A5          		jrnc	hexbi0
05A5  3002    		DB	30H,hexbi0-$-1
05A7  C607    		adi	7
05A9          	hexbi0:
05A9  C603    		adi	3
05AB  C9      		ret
		
05AC          	hexin:
05AC  CD5B05  		call	conin
05AF          	hexchk:
05AF  FE30    		cpi	'0'
05B1  D8      		rc	
05B2  FE3A    		cpi	'9'+1
05B4  3F      		cmc
05B5  D0      		rnc
05B6  E65F    		ani	05fh	; toupper
05B8  FE41    		cpi	'A'
05BA  D8      		rc	
05BB  FE47    		cpi	'F'+1
05BD  3F      		cmc
05BE  C9      		ret
		
05BF          	adrnl:
05BF  CD2A06  		call	crlf
05C2          	adrout:
05C2  7C      		mov	a,h
05C3  CDCE05  		call	hexout
05C6  7D      		mov	a,l
05C7  CDCE05  		call	hexout
05CA          	spout:
05CA  3E20    		mvi	a,' '
05CC          		jr	conout
05CC  189E    		DB	18H,conout-$-1
		
05CE          	hexout:
05CE  F5      		push	psw
05CF  07      		rlc
05D0  07      		rlc
05D1  07      		rlc
05D2  07      		rlc
05D3  CDD705  		call	hexdig
05D6  F1      		pop	psw
05D7          	hexdig:
05D7  E60F    		ani	00fh
05D9  C690    		adi	090h
05DB  27      		daa
05DC  CE40    		aci	040h
05DE  27      		daa
05DF          		jr	conout
05DF  188B    		DB	18H,conout-$-1
		
05E1  07436B73	cserms:	db	BEL,'Cksum error',TRM
      756D2065
      72726F72
      00
		
		; Special entry points expected by HDOS, or maybe Heath CP/M boot.
			rept	0613h-$
05EE  00      		db	0
05EF  00      		db	0
05F0  00      		db	0
05F1  00      		db	0
05F2  00      		db	0
05F3  00      		db	0
05F4  00      		db	0
05F5  00      		db	0
05F6  00      		db	0
05F7  00      		db	0
05F8  00      		db	0
05F9  00      		db	0
05FA  00      		db	0
05FB  00      		db	0
05FC  00      		db	0
05FD  00      		db	0
05FE  00      		db	0
05FF  00      		db	0
0600  00      		db	0
0601  00      		db	0
0602  00      		db	0
0603  00      		db	0
0604  00      		db	0
0605  00      		db	0
0606  00      		db	0
0607  00      		db	0
0608  00      		db	0
0609  00      		db	0
060A  00      		db	0
060B  00      		db	0
060C  00      		db	0
060D  00      		db	0
060E  00      		db	0
060F  00      		db	0
0610  00      		db	0
0611  00      		db	0
0612  00      		db	0
0000          	if	($ <> 0613h)
		endif
0613  C3F903  		jmp	z47$dato ; Must be at 0613
0616  00      		db	0
0617  C3FD03  		jmp	z47$cmdo ; Must be at 0617
		
		; Heath/Zenith device boot table
061A          	bootb1:
061A  4200    		db	'B',0	; Z17
061C  432E    		db	'C',46	; Z37
061E  4405    		db	'D',5	; Z47
0620  4503    		db	'E',3	; Z67
0622  00      		db	0
		
0623          	waitcr:
0623  CD5B05  		call	conin
0626  FE0D    		cpi	CR
0628          		jrnz	waitcr
0628  20F9    		DB	20H,waitcr-$-1
062A          	crlf:
062A  3E0D    		mvi	a,CR
062C  CD6C05  		call	conout
062F  3E0A    		mvi	a,LF
0631  C36C05  		jmp	conout
		
0634          	msgout:
0634  7E      		mov	a,m
0635  B7      		ora	a
0636  C8      		rz
0637  CD6C05  		call	conout
063A  23      		inx	h
063B          		jr	msgout
063B  18F7    		DB	18H,msgout-$-1
		
063D          	cserr:
063D  21E105  		lxi	h,cserms
0640          		jr	msgout
0640  18F2    		DB	18H,msgout-$-1
		
0642  546F7020	topms:	db	'Top of Mem: ',TRM
      6F66204D
      656D3A20
      00
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Memory Test command
064F          	cmdmt:
064F  215300  		lxi	h,mtms
0652  CD3406  		call	msgout
0655  CD2306  		call	waitcr
0658  214206  		lxi	h,topms
065B  CD3406  		call	msgout
065E  210000  		lxi	h,0
0661  39      		dad	sp
0662  7C      		mov	a,h
0663  3C      		inr	a
0664          		jrz	cmdmt0
0664  2802    		DB	28H,cmdmt0-$-1
0666  D620    		sui	020h
0668          	cmdmt0:
0668  67      		mov	h,a
0669  2E00    		mvi	l,0
066B  2B      		dcx	h
066C  D630    		sui	'0'
066E  5F      		mov	e,a
066F  CDC205  		call	adrout
0672  CD2A06  		call	crlf
0675  1600    		mvi	d,000h
0677  0E30    		mvi	c,030h
0679  0600    		mvi	b,000h
067B          		exx
067B  D9      		DB	0D9H
067C  21A706  		lxi	h,mtest0
067F  11F12F  		lxi	d,memtest - (mtest1-mtest0)
0682  01FB00  		lxi	b,mtestZ-mtest0
0685          		ldir
0685  EDB0    		DB	0EDH,0B0H
0687  110030  		lxi	d,memtest
068A  21B606  		lxi	h,mtest1
068D  0EEC    		mvi	c,mtestZ-mtest1
068F  AF      		xra	a
0690          		exaf
0690  08      		DB	08H
0691  AF      		xra	a
0692          	cmdmt1:
0692  86      		add	m
0693          		exaf
0693  08      		DB	08H
0694  EB      		xchg
0695  86      		add	m
0696          		exaf
0696  08      		DB	08H
0697  EB      		xchg
0698  23      		inx	h
0699  13      		inx	d
069A  0D      		dcr	c
069B          		jrnz	cmdmt1
069B  20F5    		DB	20H,cmdmt1-$-1
069D  4F      		mov	c,a
069E          		exaf
069E  08      		DB	08H
069F  B9      		cmp	c
06A0  C23D06  		jnz	cserr
06A3  F3      		di
06A4  C3F82F  		jmp	memtest - (mtest1-mtest)
		
		;------------------------------------------------
		; Start of relocated code...
		; Memory Test routine, position-endependent
		;
06A7  040C0408	mtest0:	db	04h,0ch,04h,08h,0ch,08h,20h
      0C0820
		
06AE          	mtest:
06AE  21F12F  		lxi	h,memtest - (mtest1-mtest0)
06B1  01F207  		lxi	b,0700h + 0f2h	; length of unlock sequence, GPIO port
06B4          		outir
06B4  EDB3    		DB	0EDH,0B3H
06B6          	mtest1:		; lands at 03000h - retained relocated code
06B6          		exx
06B6  D9      		DB	0D9H
06B7  62      		mov	h,d
06B8  2E00    		mvi	l,0
06BA  78      		mov	a,b
06BB          		exx
06BB  D9      		DB	0D9H
06BC  4F      		mov	c,a
06BD  0602    		mvi	b,2
06BF          	mtest2:
06BF  79      		mov	a,c
06C0  07      		rlc
06C1  07      		rlc
06C2  07      		rlc
06C3  07      		rlc
06C4  4F      		mov	c,a
06C5  E60F    		ani	00fh
06C7  C690    		adi	090h
06C9  27      		daa
06CA  CE40    		aci	040h
06CC  27      		daa
06CD  D3E8    		out	0e8h
06CF          	mtest3:
06CF  DBED    		in	0edh
06D1  E620    		ani	020h
06D3          		jrz	mtest3
06D3  28FA    		DB	28H,mtest3-$-1
06D5  05      		dcr	b
06D6          		jrnz	mtest2
06D6  20E7    		DB	20H,mtest2-$-1
06D8  3E0D    		mvi	a,CR
06DA  D3E8    		out	0e8h
06DC          		exx
06DC  D9      		DB	0D9H
06DD  78      		mov	a,b
06DE          	mtest4:
06DE  77      		mov	m,a
06DF  C601    		adi	1
06E1  27      		daa
06E2  2C      		inr	l
06E3          		jrnz	mtest4
06E3  20F9    		DB	20H,mtest4-$-1
06E5  24      		inr	h
06E6  0D      		dcr	c
06E7          		jrnz	mtest4
06E7  20F5    		DB	20H,mtest4-$-1
06E9  7C      		mov	a,h
06EA  92      		sub	d
06EB  4F      		mov	c,a
06EC  62      		mov	h,d
06ED  2E00    		mvi	l,0
06EF  78      		mov	a,b
06F0          	mtest5:
06F0  BE      		cmp	m
06F1          		jrnz	mtest9
06F1  2046    		DB	20H,mtest9-$-1
06F3  C601    		adi	1
06F5  27      		daa
06F6  2C      		inr	l
06F7          		jrnz	mtest5
06F7  20F7    		DB	20H,mtest5-$-1
06F9  24      		inr	h
06FA  0D      		dcr	c
06FB          		jrnz	mtest5
06FB  20F3    		DB	20H,mtest5-$-1
06FD          		exx
06FD  D9      		DB	0D9H
06FE  210030  		lxi	h,memtest
0701  110000  		lxi	d,0
0704  01EC00  		lxi	b,mtestZ-mtest1
0707          		exx
0707  D9      		DB	0D9H
0708  7A      		mov	a,d
0709  EE30    		xri	030h
070B  57      		mov	d,a
070C          		jrz	mtest6
070C  2803    		DB	28H,mtest6-$-1
070E  4B      		mov	c,e
070F          		jr	mtest7
070F  180A    		DB	18H,mtest7-$-1
0711          	mtest6:
0711  0E30    		mvi	c,030h
0713  3E01    		mvi	a,001h
0715  80      		add	b
0716  27      		daa
0717  47      		mov	b,a
0718          		exx
0718  D9      		DB	0D9H
0719  EB      		xchg
071A          		exx
071A  D9      		DB	0D9H
071B          	mtest7:
071B          		exx
071B  D9      		DB	0D9H
071C          		ldir
071C  EDB0    		DB	0EDH,0B0H
071E  7A      		mov	a,d
071F  E6F0    		ani	0f0h
0721  67      		mov	h,a
0722  2E00    		mvi	l,0
0724  0EEC    		mvi	c,mtestZ-mtest1
0726  AF      		xra	a
0727          	mtest8:
0727  86      		add	m
0728  23      		inx	h
0729  0D      		dcr	c
072A          		jrnz	mtest8
072A  20FB    		DB	20H,mtest8-$-1
072C  4F      		mov	c,a
072D          		exaf
072D  08      		DB	08H
072E  B9      		cmp	c
072F          		jrnz	mtestE
072F  2049    		DB	20H,mtestE-$-1
0731          		exaf
0731  08      		DB	08H
0732  7A      		mov	a,d
0733  E6F0    		ani	0f0h
0735  67      		mov	h,a
0736  2E00    		mvi	l,0
0738  E9      		pchl
0739          	mtest9:
0739  AE      		xra	m
073A  57      		mov	d,a
073B  3E0A    		mvi	a,LF
073D  D3E8    		out	0e8h
073F          	mtestA:
073F  DBED    		in	0edh
0741  E620    		ani	020h
0743          		jrz	mtestA
0743  28FA    		DB	28H,mtestA-$-1
0745  0E02    		mvi	c,2
0747  0604    		mvi	b,4
0749          	mtestB:
0749  7C      		mov	a,h
074A  07      		rlc
074B  07      		rlc
074C  07      		rlc
074D  07      		rlc
074E  E60F    		ani	00fh
0750  C690    		adi	090h
0752  27      		daa
0753  CE40    		aci	040h
0755  27      		daa
0756  D3E8    		out	0e8h
0758          	mtestC:
0758  DBED    		in	0edh
075A  E620    		ani	020h
075C          		jrz	mtestC
075C  28FA    		DB	28H,mtestC-$-1
075E  29      		dad	h
075F  29      		dad	h
0760  29      		dad	h
0761  29      		dad	h
0762          		djnz	mtestB
0762  10E5    		DB	10H,mtestB-$-1
0764  3E20    		mvi	a,' '
0766  D3E8    		out	0e8h
0768          	mtestD:
0768  DBED    		in	0edh
076A  E620    		ani	020h
076C          		jrz	mtestD
076C  28FA    		DB	28H,mtestD-$-1
076E  0D      		dcr	c
076F  EB      		xchg
0770  0602    		mvi	b,002h
0772          		jrnz	mtestB
0772  20D5    		DB	20H,mtestB-$-1
0774  3E2A    		mvi	a,'*'
0776  D3E8    		out	0e8h
0778          		jr	mtestG
0778  1814    		DB	18H,mtestG-$-1
077A          	mtestE:
077A  DBED    		in	0edh
077C  E620    		ani	020h
077E          		jrz	mtestE
077E  28FA    		DB	28H,mtestE-$-1
0780  3E0A    		mvi	a,LF
0782  D3E8    		out	0e8h
0784          	mtestF:
0784  DBED    		in	0edh
0786  E620    		ani	020h
0788          		jrz	mtestF
0788  28FA    		DB	28H,mtestF-$-1
078A  3E21    		mvi	a,'!'
078C  D3E8    		out	0e8h
078E          	mtestG:
078E  DBED    		in	0edh
0790  E620    		ani	020h
0792          		jrz	mtestG
0792  28FA    		DB	28H,mtestG-$-1
0794  AF      		xra	a
0795  06FA    		mvi	b,0fah
0797          	mtestH:
0797  3D      		dcr	a
0798          		jrnz	mtestH
0798  20FD    		DB	20H,mtestH-$-1
079A          		djnz	mtestH
079A  10FB    		DB	10H,mtestH-$-1
079C  3E07    		mvi	a,BEL
079E  D3E8    		out	0e8h
07A0          		jr	mtestG
07A0  18EC    		DB	18H,mtestG-$-1
		; End of relocated code
07A2          	mtestZ	equ	$
		;------------------------------------------------
		
		; returns with interrupts disabled
07A2          	h17init:
07A2  F3      		di
07A3  AF      		xra	a
07A4  D37F    		out	07fh
07A6  D5      		push	d
07A7  210920  		lxi	h,ctl$F0
07AA  36D0    		mvi	m,0d0h	; !beep, 2mS, !mon, !SI
07AC  215A1F  		lxi	h,R$CONST
07AF  114820  		lxi	d,D$CONST
07B2  015800  		lxi	b,88
07B5          		ldir
07B5  EDB0    		DB	0EDH,0B0H
07B7  6B      		mov	l,e
07B8  62      		mov	h,d
07B9  13      		inx	d
07BA  0E1E    		mvi	c,30
07BC  77      		mov	m,a
07BD          		ldir	; fill l20a0h...
07BD  EDB0    		DB	0EDH,0B0H
07BF  3C      		inr	a	; A=1
07C0  211F20  		lxi	h,intvec	; vector area
07C3          	h17ini0:
07C3  36C3    		mvi	m,0c3h
07C5  23      		inx	h
07C6  36B7    		mvi	m,LOW (nulint-rst0)
07C8  23      		inx	h
07C9  3600    		mvi	m,HIGH (nulint-rst0)
07CB  23      		inx	h
07CC  87      		add	a	; shift left, count 7
07CD  F2C307  		jp	h17ini0
07D0  D1      		pop	d
07D1  C9      		ret
		
07D2  0D0A4D4D	prompt:	db	CR,LF,'MMS: ',TRM
      533A2000
07DA  28632920		db	'(c) 1982 MMS'
      31393832
      204D4D53
		
07E6          	nulfn:
07E6  C9      		ret
		
07E7          	xcmds:
07E7  79      		mov	a,c
0000          	if terminal
		endif
07E8  FE52    		cpi	'R'	; set baud Rate
07EA  CACD0E  		jz	setbr
07ED  FE56    		cpi	'V'	; eprom Version
07EF  CAD90F  		jz	prtver
07F2  C9      		ret
		
		; D=Phys Drive base, E=Unit
		; (or D=Phys Drive unit, E=0)
07F3          	exboot:
0000          	if remex
		endif
07F3  214C08  		lxi	h,devtbl
07F6          	exboot1:
07F6  7A      		mov	a,d
07F7  96      		sub	m
07F8  23      		inx	h
07F9  BE      		cmp	m
07FA          		jrc	exboot2
07FA  3808    		DB	38H,exboot2-$-1
07FC  7E      		mov	a,m
07FD  23      		inx	h
07FE  23      		inx	h
07FF  23      		inx	h
0800  B7      		ora	a
0801          		jrnz	exboot1
0801  20F3    		DB	20H,exboot1-$-1
0803  C9      		ret
		
0804          	exboot2:	; found device, jump to handler
0804  23      		inx	h
0805  4E      		mov	c,m
0806  23      		inx	h
0807  66      		mov	h,m
0808  69      		mov	l,c
0809  83      		add	e
080A  E9      		pchl
		
		; Returns NZ if found, D=phy drv
080B          	gtdvtb:
080B  DBF2    		in	0f2h
080D  E670    		ani	01110000b	; default boot device
080F  07      		rlc
0810  07      		rlc
0811  07      		rlc
0812  07      		rlc
0813  218608  		lxi	h,defbt
0816          	gtdvtb0:
0816  85      		add	l
0817  6F      		mov	l,a
0818  3E00    		mvi	a,0
081A  8C      		adc	h
081B  67      		mov	h,a
081C  7E      		mov	a,m
081D  FEFF    		cpi	0ffh
081F  C8      		rz	; no device
0820  FEFE    		cpi	0feh
0822          		jrz	gtdvtb1	; extended dipsw
0822  2802    		DB	28H,gtdvtb1-$-1
0824  57      		mov	d,a
0825  C9      		ret	; NZ
		
0826          	gtdvtb1:
0826  DB5C    		in	05ch
0828  E6E0    		ani	11100000b	; device
082A  07      		rlc
082B  07      		rlc
082C  07      		rlc
082D  218E08  		lxi	h,auxbt
0830  CD1608  		call	gtdvtb0
0833  C8      		rz	; no device
0834  DB5C    		in	05ch
0836  E61C    		ani	00011100b	; LUN
0838  0F      		rrc
0839  0F      		rrc
083A  5F      		mov	e,a	; D=phy drv, E=LUN
083B  C9      		ret
		
		; lookup letter in MMS table
083C          	mmslookup:
083C  219608  		lxi	h,bootb2
083F          	mmslk0:
083F  7E      		mov	a,m
0840  23      		inx	h
0841  56      		mov	d,m
0842  23      		inx	h
0843  B8      		cmp	b
0844  C8      		rz
0845  B7      		ora	a
0846          		jrnz	mmslk0
0846  20F7    		DB	20H,mmslk0-$-1
0848  1600    		mvi	d,0
084A  37      		stc
084B  C9      		ret
		
		; disk device/drive table by phy drv
084C          	devtbl:
084C  0302    		db	3,2
084E  2D0A    		dw	bz67
0000          	if remex
		endif
0000          	if corvus
		endif
0850  1D08    		db	29,8
0852  B108    		dw	bm316
0000          	if xcomp
		endif
0854  2801    		db	40,1
0856  100B    		dw	bm318
0858  2E04    		db	46,4
085A  2D09    		dw	bz37
0000          	if mms422
		endif
FFFF          	if wiznet
085C  3C01    		db	60,1
085E  380C    		dw	bwiznet
		endif
FFFF          	if gide
0860  4609    		db	70,9
0862  BC09    		dw	bgide
		endif
0864  A804    		db	168,4
0866  1D0A    		dw	bm320
0868  AC04    		db	172,4
086A  1D0A    		dw	bm320
086C  B004    		db	176,4
086E  1D0A    		dw	bm320
0870  B404    		db	180,4
0872  1D0A    		dw	bm320
0874  B804    		db	184,4
0876  1D0A    		dw	bm320
0878  BC04    		db	188,4
087A  1D0A    		dw	bm320
087C  C004    		db	192,4
087E  1D0A    		dw	bm320
0880  C404    		db	196,4
0882  1D0A    		dw	bm320
0884  0000    		dw	0
		
0886          	defbt:	; default boot table... port F2 bits 01110000b
0886  21      		db	33	; -000---- MMS 5" floppy 0
0887  1D      		db	29	; -001---- MMS 8" floppy 0
0888  FF      		db	0ffh	; -010---- n/a  (port 7CH)
0889  FF      		db	0ffh	; -011---- n/a  (port 78H)
088A  FF      		db	0ffh	; -100---- none
FFFF          	if gide
088B  46      		db	70	; -101---- GIDE disk part 0
		else
		endif
088C  3C      		db	60	; -110---- Network
088D  FE      		db	0feh	; -111---- redirect to I/O board dipsw
		
088E          	auxbt:	; default boot redirect (aux dipsw) bits 11100000b
0000          	if corvus
		else
088E  FF      		db	0ffh	; 000----- none (was MMS 77314 Corvus)
		endif
0000          	if remex
		else
088F  FF      		db	0ffh	; 001----- none (was MMS 77314 REMEX (Z47))
		endif
0890  FF      		db	0ffh	; 010----- none
0000          	if xcomp
		else
0891  FF      		db	0ffh	; 011----- none
		endif
0892  3C      		db	60	; 100----- Network
0893  A8      		db	168	; 101----- MMS 77320 SASI
FFFF          	if gide
0894  46      		db	70	; 110----- GIDE disk
		else
		endif
0895  FF      		db	0ffh	; 111----- none
		
0896          	bootb2:
0000          	if remex
		endif
0000          	if corvus
		endif
0896  491D    		db	'I',29		; MMS 77316 8"
0898  4A21    		db	'J',33		; MMS 77316 5"
0000          	if xcomp
		endif
089A  4D28    		db	'M',40		; MMS 77318 RAM-disk
0000          	if mms422
		endif
089C  4FA8    		db	'O',168		; SASI ctrl 0
089E  50AC    		db	'P',172		; SASI ctrl 1
08A0  51B0    		db	'Q',176		; SASI ctrl 2
08A2  52B4    		db	'R',180		; SASI ctrl 3
08A4  53B8    		db	'S',184		; SASI ctrl 4
08A6  54BC    		db	'T',188		; SASI ctrl 5
08A8  55C0    		db	'U',192		; SASI ctrl 6
08AA  56C4    		db	'V',196		; SASI ctrl 7
FFFF          	if wiznet
08AC  573C    		db	'W',60		; WIZNET Network
		endif
FFFF          	if gide
08AE  5846    		db	'X',70		; GIDE ctrl/disk
		endif
08B0  00      		db	0
		
0000          	if corvus
		endif
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77316 Floppy boot
08B1          	bm316:
08B1  212809  		lxi	h,int316
08B4  222F20  		shld	vrst6+1
08B7  FE08    		cpi	008h
08B9  D0      		rnc
08BA  F628    		ori	028h
08BC  57      		mov	d,a
08BD  D338    		out	038h
08BF  AF      		xra	a
08C0  D3F2    		out	0f2h	; 2mS intr off
08C2  3E0B    		mvi	a,00bh	; home/restore to track 0
08C4  CD2309  		call	cmd316
08C7  0108CF  		lxi	b,53000
08CA          	bm316$0:
08CA  DB3C    		in	03ch
08CC  07      		rlc
08CD          		jrnc	bm316$1
08CD  3005    		DB	30H,bm316$1-$-1
08CF  0B      		dcx	b
08D0  78      		mov	a,b
08D1  B1      		ora	c
08D2          		jrnz	bm316$0
08D2  20F6    		DB	20H,bm316$0-$-1
08D4          	bm316$1:
08D4  DB3C    		in	03ch
08D6  E699    		ani	099h
08D8  C0      		rnz
08D9  1E19    		mvi	e,019h
08DB          	bm316$2:
08DB  218022  		lxi	h,bootbf
08DE  AF      		xra	a
08DF          	bm316$3:
08DF  3C      		inr	a
08E0  D33E    		out	03eh
08E2  013F00  		lxi	b,003fh
08E5  3E88    		mvi	a,088h
08E7  CD0109  		call	rd316
08EA  E6BF    		ani	0bfh
08EC  7A      		mov	a,d
08ED  D338    		out	038h
08EF          		jrz	bm316$4
08EF  2807    		DB	28H,bm316$4-$-1
08F1  EE40    		xri	040h
08F3  57      		mov	d,a
08F4  1D      		dcr	e
08F5          		jrnz	bm316$2
08F5  20E4    		DB	20H,bm316$2-$-1
08F7  C9      		ret
08F8          	bm316$4:
08F8  DB3E    		in	03eh
08FA  FE02    		cpi	002h
08FC          		jrc	bm316$3
08FC  38E1    		DB	38H,bm316$3-$-1
08FE  C3F203  		jmp	hwboot
		
0901          	rd316:
0901  F5      		push	psw
0902  7A      		mov	a,d
0903  E644    		ani	044h
0905          		jrnz	rd316$5
0905  200F    		DB	20H,rd316$5-$-1
			; 8" DD read special case
0907  7A      		mov	a,d
0908  E6DF    		ani	0dfh
090A  D338    		out	038h
090C  F1      		pop	psw
090D  D33C    		out	03ch
090F  FB      		ei
0910  76      		hlt	; wait for first byte
0911          	rd316$8: ini
0911  EDA2    		DB	0EDH,0A2H
0913  C31109  		jmp	rd316$8
		
0916          	rd316$5:
0916  7A      		mov	a,d
0917  D338    		out	038h
0919  F1      		pop	psw
091A  D33C    		out	03ch
091C  FB      	hlt$ini: ei
091D  76      	rd316$0: hlt
091E          		ini
091E  EDA2    		DB	0EDH,0A2H
0920  C31D09  		jmp	rd316$0
		
0923          	cmd316:
0923  D33C    		out	03ch
0925  FB      	ei$spin: ei
0926          		jr	$-1	; wait for intr to break us out
0926  18FE    		DB	18H,$-1-$-1
		
0928  F1      	int316:	pop	psw
0929  DB3C    		in	03ch
092B  FB      		ei
092C  C9      		ret
		
092D          	bz37:
092D  21B309  		lxi	h,intz37
0930  222920  		shld	vrst4+1
0933  2B      		dcx	h
0934  223720  		shld	l2037h
0937  FE04    		cpi	004h
0939  D0      		rnc
093A  3C      		inr	a
093B  2E08    		mvi	l,008h
093D          	bz37$0:
093D  29      		dad	h
093E  3D      		dcr	a
093F          		jrnz	bz37$0
093F  20FC    		DB	20H,bz37$0-$-1
0941  D379    		out	079h
0943  DBF2    		in	0f2h
0945  E60C    		ani	00ch
0947  C0      		rnz
0948  3E78    		mvi	a,078h
094A  325021  		sta	cport
094D  3ED0    		mvi	a,0d0h
094F  D37A    		out	07ah
0951  7D      		mov	a,l
0952  F608    		ori	008h
0954  57      		mov	d,a
0955  D378    		out	078h
0957  14      		inr	d
0958  1E19    		mvi	e,019h
095A  3E05    		mvi	a,5
095C  CD8F01  		call	take$A
095F  017B14  		lxi	b,0147bh	; mask, port
0962          	bz37$1:
0962  DB7A    		in	07ah
0964  A8      		xra	b
0965  E602    		ani	002h
0967          		jrz	bz37$1
0967  28F9    		DB	28H,bz37$1-$-1
0969          		djnz	bz37$1
0969  10F7    		DB	10H,bz37$1-$-1
096B          	bz37$2:
096B  218022  		lxi	h,bootbf
096E  3E01    		mvi	a,001h
0970  D379    		out	079h
0972  D37A    		out	07ah
0974  7A      		mov	a,d
0975  D378    		out	078h
0977  0604    		mvi	b,004h
0979          	bz37$3:
0979  AF      		xra	a
097A  D379    		out	079h
097C  3E40    		mvi	a,040h
097E  D37A    		out	07ah
0980  CD2509  		call	ei$spin
0983          		djnz	bz37$3
0983  10F4    		DB	10H,bz37$3-$-1
0985  AF      		xra	a
0986  D379    		out	079h
0988  3E0B    		mvi	a,00bh
098A  D37A    		out	07ah
098C  CD2509  		call	ei$spin
098F  7A      		mov	a,d
0990  EE04    		xri	004h
0992  57      		mov	d,a
0993  F602    		ori	002h
0995  D378    		out	078h
0997  3E9C    		mvi	a,09ch
0999  D37A    		out	07ah
099B  CD1C09  		call	hlt$ini
099E  E6EF    		ani	0efh
09A0          		jrnz	bz37$4
09A0  200D    		DB	20H,bz37$4-$-1
09A2  7C      		mov	a,h
09A3  FE2C    		cpi	02ch
09A5          		jrc	bz37$4
09A5  3808    		DB	38H,bz37$4-$-1
09A7  3E08    		mvi	a,008h
09A9  D378    		out	078h
09AB  E1      		pop	h
09AC  C3F203  		jmp	hwboot
09AF          	bz37$4:
09AF  1D      		dcr	e
09B0          		jrnz	bz37$2
09B0  20B9    		DB	20H,bz37$2-$-1
09B2  C9      		ret
		
09B3  DB7A    	intz37:	in	07ah
09B5  E3      		xthl
09B6  2A3720  		lhld	l2037h
09B9  E3      		xthl
09BA  FB      		ei
09BB  C9      		ret
		
0000          	if xcomp
		endif
		
FFFF          	if gide
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; GIDE HDD boot
09BC          	bgide:
09BC  FE09    		cpi	9 ; 9 partitons, max
09BE  D0      		rnc
			; Partition is passed to bootloader, but we need
			; segment offset before we can start.
09BF  D1      		pop	d	; error return address
09C0  C1      		pop	b	; possible string
09C1  C5      		push	b
09C2  D5      		push	d
			; parse a single letter
09C3  210000  		lxi	h,0	; def segment off
09C6  225821  		shld	l2156h+2
09C9  225A21  		shld	l2156h+4
09CC  79      		mov	a,c
09CD  FEC3    		cpi	0c3h	; JMP means no string present
09CF          		jrz	nostr
09CF  280D    		DB	28H,nostr-$-1
09D1  78      		mov	a,b
09D2  B7      		ora	a	; limit to 1 char?
09D3  C0      		rnz
09D4  79      		mov	a,c
09D5  E65F    		ani	5fh
09D7  D641    		sui	'A'	; 000sssss = segment ID
09D9  D8      		rc
09DA  07      		rlc
09DB  07      		rlc
09DC  07      		rlc		; sssss000 = segoff: 0000 sssss000 00000000 00000000
09DD  67      		mov	h,a	; swap for little endian SHLD/LHLD
09DE  225621  	nostr:	shld	l2156h	; l2156h[0]=27:24, l2156h[1]=23:16
09E1  AF      		xra	a
09E2  D389    		out	GIDE$FR	; needed after power-on?
09E4  7D      		mov	a,l
09E5  F6E0    		ori	11100000b	; LBA mode + std "1" bits
09E7  D38E    		out	GIDE$DH	; LBA 27:4, drive 0, LBA mode
09E9  7C      		mov	a,h
09EA  D38D    		out	GIDE$CH	; LBA 23:16
09EC  AF      		xra	a
09ED  D38C    		out	GIDE$CL	; LBA 15:8
09EF  D38B    		out	GIDE$SE	; LBA 7:0
09F1  3E0A    		mvi	a,10
09F3  D38A    		out	GIDE$SC	; 10 sectors (standard boot length)
09F5  3E20    		mvi	a,20h	; READ SECTORS
09F7  D38F    		out	GIDE$CS
09F9  218022  		lxi	h,bootbf
09FC  0E88    		mvi	c,GIDE$DA
09FE  1E0A    		mvi	e,10
0A00  0600    		mvi	b,0	; should always be 0 after inir
0A02          	bgide0:
0A02  DB8F    		in	GIDE$CS
0A04          		bit	7,a	; busy
0A04  CB7F    		DB	0CBH,7*8+a+40H
0A06          		jrnz	bgide0
0A06  20FA    		DB	20H,bgide0-$-1
0A08          		bit	0,a	; error
0A08  CB47    		DB	0CBH,0*8+a+40H
0A0A  C0      		rnz
0A0B          		bit	6,a	; ready
0A0B  CB77    		DB	0CBH,6*8+a+40H
0A0D  C8      		rz
0A0E          		bit	3,a	; DRQ
0A0E  CB5F    		DB	0CBH,3*8+a+40H
0A10          		jrz	bgide0
0A10  28F0    		DB	28H,bgide0-$-1
0A12          		inir	; 256 bytes
0A12  EDB2    		DB	0EDH,0B2H
0A14          		inir	; 512 bytes
0A14  EDB2    		DB	0EDH,0B2H
0A16  1D      		dcr	e
0A17          		jrnz	bgide0
0A17  20E9    		DB	20H,bgide0-$-1
			; final status check?
0A19  E1      		pop	h	; adj stack for possible string
0A1A  C3F203  		jmp	hwboot
		endif
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77320 SASI HDD boot
0A1D          	bm320:
0A1D  FE04    		cpi	4 ; 4 units per controller, max
0A1F  D0      		rnc
0A20  5F      		mov	e,a	; relative drive num
0A21  7A      		mov	a,d ; phy drv
0A22  D6A8    		sui	168
0A24  E6FC    		ani	0fch	; Controller num
0A26  0F      		rrc
0A27  0F      		rrc
0A28  53      		mov	d,e ; D = relative drive num
0A29  5F      		mov	e,a ; E = controller num
0A2A  7A      		mov	a,d
0A2B          		jr	bsasi
0A2B  1805    		DB	18H,bsasi-$-1
		
0A2D          	bz67:
0A2D  FE02    		cpi	2
0A2F  D0      		rnc	
0A30  1E00    		mvi	e,0	; Controller 0 only
0A32          	bsasi:
0A32  0F      		rrc
0A33  0F      		rrc
0A34  0F      		rrc
0A35  DD      		db 0ddh
0A36  67      		mov h,a	; movxh	a	; 0xx00000 = relative drive num (LUN)
0A37  0E02    		mvi	c,10b
0A39  CD1402  		call	getport
0A3C  C0      		rnz
0A3D  78      		mov	a,b
0A3E  325021  		sta	cport
0A41  3C      		inr	a
0A42  4F      		mov	c,a
0A43  AF      		xra	a
0A44          		outp	a
0A44  ED79    		DB	0EDH,a*8+41H
0A46  210000  		lxi	h,0		; zero-out command buffer
0A49  223221  		shld	cmdbuf
0A4C  223421  		shld	cmdbuf+2
0A4F  223621  		shld	cmdbuf+4
0A52  225621  		shld	l2156h	; zero-out ...
0A55  225821  		shld	l2156h+2
0A58  325A21  		sta	l2156h+4
0A5B  53      		mov	d,e
0A5C  3E04    		mvi	a,4	; delay 8mS, also NZ
0A5E  B7      		ora	a
0A5F  FB      		ei
0A60          	bsasi0:
0A60  C8      		rz
0A61  CD2B00  		call	delayx
0A64  1E00    		mvi	e,0	; Test Drive Ready
0A66  CD830A  		call	sasi$cmd
0A69  3EFF    		mvi	a,255	; longer delay on retry...
0A6B          		jrc	bsasi0
0A6B  38F3    		DB	38H,bsasi0-$-1
0A6D  1E01    		mvi	e,1	; Recalibrate (Home)
0A6F  CD830A  		call	sasi$cmd
0A72  D8      		rc
0A73  210A80  		lxi	h,0800ah	; 10 sectors, retry
0A76  223621  		shld	cmdbuf+4
0A79  1E08    		mvi	e,8	; Read
0A7B  CD830A  		call	sasi$cmd
0A7E  D8      		rc
0A7F  E1      		pop	h
0A80  C3F203  		jmp	hwboot
		
		; send SASI read command, get results
0A83          	sasi$cmd:
0A83  F3      		di
0A84  DD      		db 0ddh	; undocumented Z80 instruction
0A85  6B      		mov l,e	; movxl	e	; SASI command
0A86          		sixd	cmdbuf
0A86  DD22    		DB	0DDH,22H
0A88  3221    		DW	cmdbuf
0A8A  0600    		mvi	b,0	; wait for "not BUSY" first
0A8C  1E06    		mvi	e,6	;
0A8E  210000  		lxi	h,0	; 0x060000 loop/timeout count
0A91          	sscmd0:
0A91          		inp	a
0A91  ED78    		DB	0EDH,a*8+40H
0A93  E608    		ani	00001000b
0A95  B8      		cmp	b
0A96          		jrz	sscmd1
0A96  280A    		DB	28H,sscmd1-$-1
0A98  2B      		dcx	h
0A99  7D      		mov	a,l
0A9A  B4      		ora	h
0A9B          		jrnz	sscmd0
0A9B  20F4    		DB	20H,sscmd0-$-1
0A9D  1D      		dcr	e
0A9E          		jrnz	sscmd0
0A9E  20F1    		DB	20H,sscmd0-$-1
0AA0  37      		stc
0AA1  C9      		ret
0AA2          	sscmd1:
0AA2  78      		mov	a,b
0AA3  EE08    		xri	00001000b	; wait for BUSY
0AA5          		jrz	sscmd2		; got BUSY...
0AA5  2810    		DB	28H,sscmd2-$-1
0AA7  47      		mov	b,a
0AA8  0D      		dcr	c
0AA9  AF      		xra	a
0AAA          		outp	a
0AAA  ED79    		DB	0EDH,a*8+41H
0AAC  0C      		inr	c
0AAD  0C      		inr	c
0AAE          		outp	d
0AAE  ED51    		DB	0EDH,d*8+41H
0AB0  0D      		dcr	c
0AB1  3E40    		mvi	a,040h	; SELECT
0AB3          		outp	a
0AB3  ED79    		DB	0EDH,a*8+41H
0AB5          		jr	sscmd0	; wait for BUSY now...
0AB5  18DA    		DB	18H,sscmd0-$-1
		
0AB7          	sscmd2:
0AB7  3E02    		mvi	a,002h	; enable INTR
0AB9          		outp	a
0AB9  ED79    		DB	0EDH,a*8+41H
0ABB  213221  		lxi	h,cmdbuf
0ABE          	sscmd3:
0ABE          		inp	a
0ABE  ED78    		DB	0EDH,a*8+40H
0AC0          		bit	7,a	; REQ
0AC0  CB7F    		DB	0CBH,7*8+a+40H
0AC2          		jrz	sscmd3
0AC2  28FA    		DB	28H,sscmd3-$-1
0AC4          		bit	4,a	; CMD
0AC4  CB67    		DB	0CBH,4*8+a+40H
0AC6          		jrz	sscmd4
0AC6  280A    		DB	28H,sscmd4-$-1
0AC8          		bit	6,a	; MSG
0AC8  CB77    		DB	0CBH,6*8+a+40H
0ACA          		jrz	sscmd6
0ACA  2819    		DB	28H,sscmd6-$-1
0ACC  0D      		dcr	c
0ACD          		outi		; output command byte
0ACD  EDA3    		DB	0EDH,0A3H
0ACF  0C      		inr	c
0AD0          		jr	sscmd3
0AD0  18EC    		DB	18H,sscmd3-$-1
		
0AD2          	sscmd4:
0AD2  218022  		lxi	h,bootbf
0AD5          	sscmd5:
0AD5          		inp	a
0AD5  ED78    		DB	0EDH,a*8+40H
0AD7          		bit	7,a	; REQ
0AD7  CB7F    		DB	0CBH,7*8+a+40H
0AD9          		jrz	sscmd5
0AD9  28FA    		DB	28H,sscmd5-$-1
0ADB          		bit	4,a	; CMD - indicates data done
0ADB  CB67    		DB	0CBH,4*8+a+40H
0ADD          		jrnz	sscmd6
0ADD  2006    		DB	20H,sscmd6-$-1
0ADF  0D      		dcr	c
0AE0          		ini		; input data byte
0AE0  EDA2    		DB	0EDH,0A2H
0AE2  0C      		inr	c
0AE3          		jr	sscmd5
0AE3  18F0    		DB	18H,sscmd5-$-1
0AE5          	sscmd6:
0AE5          		inp	a
0AE5  ED78    		DB	0EDH,a*8+40H
0AE7  E6D0    		ani	0d0h	; REQ, OUT, CMD
0AE9  FE90    		cpi	090h	; must be REQ, CMD
0AEB          		jrnz	sscmd6	; wait for it...
0AEB  20F8    		DB	20H,sscmd6-$-1
0AED  0D      		dcr	c
0AEE          		inp	l	; result 0
0AEE  ED68    		DB	0EDH,l*8+40H
0AF0  0C      		inr	c
0AF1          	sscmd7:
0AF1          		inp	h	; status
0AF1  ED60    		DB	0EDH,h*8+40H
0AF3  7C      		mov	a,h
0AF4  E6E0    		ani	0e0h	; REG, OUT, MSG
0AF6  FEA0    		cpi	0a0h	; must be REQ, MSG
0AF8          		jrnz	sscmd7
0AF8  20F7    		DB	20H,sscmd7-$-1
0AFA  223821  		shld	resbuf	; command results
0AFD  0D      		dcr	c
0AFE          		inp	a	; last data byte
0AFE  ED78    		DB	0EDH,a*8+40H
0B00  0C      		inr	c
0B01  FB      		ei
0B02  B7      		ora	a
0B03  37      		stc
0B04  C0      		rnz		; error
0B05          		bit	0,l	; SASI error bit
0B05  CB45    		DB	0CBH,0*8+l+40H
0B07  C0      		rnz
0B08          		bit	1,l	; or other error?
0B08  CB4D    		DB	0CBH,1*8+l+40H
0B0A  C0      		rnz
0B0B          		bit	1,h	; ACK
0B0B  CB4C    		DB	0CBH,1*8+h+40H
0B0D  C0      		rnz
0B0E  AF      		xra	a	; success
0B0F  C9      		ret
		
0000          	if remex
		endif
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; MMS 77318 (RAM-disk) boot
0B10          	bm318:
0B10  F3      		di
0B11  211F0B  		lxi	h,l318rt
0B14  1100C0  		lxi	d,ramboot
0B17  011E00  		lxi	b,l318sz
0B1A          		ldir
0B1A  EDB0    		DB	0EDH,0B0H
0B1C  C300C0  		jmp	ramboot
		
		; MMS 77318 (RAM-disk) boot loader - relocated to ramboot
0B1F          	l318rt:
0B1F  2115C0  		lxi	h,ramboot+l318lo
0B22  0608    		mvi	b,l318lz
0B24  0EF2    		mvi	c,0f2h
0B26          		outir	; unlock memory and select OS image bank
0B26  EDB3    		DB	0EDH,0B3H
0B28  3A0000  		lda	0
0B2B  FEC3    		cpi	0c3h	; JMP - does OS look good?
0B2D  CA0000  		jz	0	; start OS
0B30          		outi	; re-select ROM bank
0B30  EDA3    		DB	0EDH,0A3H
0B32  FB      		ei
0B33  C9      		ret	; return to monitor (boot error)
		
		; 77318 Unlock and select bank "E" (16K common + "bank 1")
		; NOTE: "22h" should not be there, left-over cruft from CP/M unlock.
0015          	l318lo	equ	$-l318rt
0B34  040C0408	l318ul:	db	04h,0ch,04h,08h,0ch,08h,22h,10h
      0C082210
0008          	l318lz	equ	$-l318ul
0B3C  00      		db	0	; fall-back to ROM on error...
001E          	l318sz	equ	$-l318rt
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		
0000          	if mms422
		endif
		
FFFF          	if wiznet
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; WIZNET WIZ850io (Network) boot loader
		
0B3D          	getwiz1:
0B3D  3E01    		mvi	a,WZSCS
0B3F  D341    		out	spi$ctl
0B41  0E40    		mvi	c,spi$dat
0B43  AF      		xra	a
0B44          		outp	a	; hi adr always 0
0B44  ED79    		DB	0EDH,a*8+41H
0B46          		outp	e
0B46  ED59    		DB	0EDH,e*8+41H
0B48          		res	2,d
0B48  CB92    		DB	0CBH,2*8+d+80H
0B4A          		outp	d
0B4A  ED51    		DB	0EDH,d*8+41H
0B4C          		inp	a	; prime MISO
0B4C  ED78    		DB	0EDH,a*8+40H
0B4E          		inp	a
0B4E  ED78    		DB	0EDH,a*8+40H
0B50  F5      		push	psw
0B51  0C      		inr	c	; ctl port
0B52  AF      		xra	a
0B53          		outp	a	; clear SCS
0B53  ED79    		DB	0EDH,a*8+41H
0B55  F1      		pop	psw
0B56  C9      		ret
		
0B57          	putwiz1:
0B57  F5      		push	psw
0B58  3E01    		mvi	a,WZSCS
0B5A  D341    		out	spi$ctl
0B5C  0E40    		mvi	c,spi$dat
0B5E  AF      		xra	a
0B5F          		outp	a	; hi adr always 0
0B5F  ED79    		DB	0EDH,a*8+41H
0B61          		outp	e
0B61  ED59    		DB	0EDH,e*8+41H
0B63          		setb	2,d
0B63  CBD2    		DB	0CBH,2*8+d+0C0H
0B65          		outp	d
0B65  ED51    		DB	0EDH,d*8+41H
0B67  F1      		pop	psw
0B68          		outp	a	; data
0B68  ED79    		DB	0EDH,a*8+41H
0B6A  0C      		inr	c	; ctl port
0B6B  AF      		xra	a
0B6C          		outp	a	; clear SCS
0B6C  ED79    		DB	0EDH,a*8+41H
0B6E  C9      		ret
		
		; Get 16-bit value from chip
		; Prereq: IDM_AR0 already set, auto-incr on
		; Entry: A=value for IDM_AR1
		; Return: HL=register pair contents
0B6F          	getwiz2:
0B6F  3E01    		mvi	a,WZSCS
0B71  D341    		out	spi$ctl
0B73  0E40    		mvi	c,spi$dat
0B75  AF      		xra	a
0B76          		outp	a	; hi adr always 0
0B76  ED79    		DB	0EDH,a*8+41H
0B78          		outp	e
0B78  ED59    		DB	0EDH,e*8+41H
0B7A          		res	2,d
0B7A  CB92    		DB	0CBH,2*8+d+80H
0B7C          		outp	d
0B7C  ED51    		DB	0EDH,d*8+41H
0B7E          		inp	a	; prime MISO
0B7E  ED78    		DB	0EDH,a*8+40H
0B80          		inp	h	; data
0B80  ED60    		DB	0EDH,h*8+40H
0B82          		inp	l	; data
0B82  ED68    		DB	0EDH,l*8+40H
0B84  0C      		inr	c	; ctl port
0B85  AF      		xra	a
0B86          		outp	a	; clear SCS
0B86  ED79    		DB	0EDH,a*8+41H
0B88  C9      		ret
		
		; HL = output data, E = off, D = BSB, B = len
0B89          	wizset:
0B89  3E01    		mvi	a,WZSCS
0B8B  D341    		out	spi$ctl
0B8D  0E40    		mvi	c,spi$dat
0B8F  AF      		xra	a
0B90          		outp	a	; hi adr always 0
0B90  ED79    		DB	0EDH,a*8+41H
0B92          		outp	e
0B92  ED59    		DB	0EDH,e*8+41H
0B94          		setb	2,d
0B94  CBD2    		DB	0CBH,2*8+d+0C0H
0B96          		outp	d
0B96  ED51    		DB	0EDH,d*8+41H
0B98          		outir
0B98  EDB3    		DB	0EDH,0B3H
0B9A  0C      		inr	c	; ctl port
0B9B  AF      		xra	a
0B9C          		outp	a	; clear SCS
0B9C  ED79    		DB	0EDH,a*8+41H
0B9E  C9      		ret
		
		; Put 16-bit value to chip
		; Prereq: IDM_AR0 already set, auto-incr on
		; Entry: A=value for IDM_AR1
		;        HL=register pair contents
0B9F          	putwiz2:
0B9F  3E01    		mvi	a,WZSCS
0BA1  D341    		out	spi$ctl
0BA3  0E40    		mvi	c,spi$dat
0BA5  AF      		xra	a
0BA6          		outp	a	; hi adr always 0
0BA6  ED79    		DB	0EDH,a*8+41H
0BA8          		outp	e
0BA8  ED59    		DB	0EDH,e*8+41H
0BAA          		setb	2,d
0BAA  CBD2    		DB	0CBH,2*8+d+0C0H
0BAC          		outp	d
0BAC  ED51    		DB	0EDH,d*8+41H
0BAE          		outp	h	; data to write
0BAE  ED61    		DB	0EDH,h*8+41H
0BB0          		outp	l
0BB0  ED69    		DB	0EDH,l*8+41H
0BB2  0C      		inr	c	; ctl port
0BB3  AF      		xra	a
0BB4          		outp	a	; clear SCS
0BB4  ED79    		DB	0EDH,a*8+41H
0BB6  C9      		ret
		
		; Issue command, wait for complete
		; D=Socket ctl byte
		; Returns: A=Sn_SR
0BB7  47      	wizcmd:	mov	b,a
0BB8  1E01    		mvi	e,sn$cr
0BBA          		setb	2,d
0BBA  CBD2    		DB	0CBH,2*8+d+0C0H
0BBC  3E01    		mvi	a,WZSCS
0BBE  D341    		out	spi$ctl
0BC0  0E40    		mvi	c,spi$dat
0BC2  AF      		xra	a
0BC3          		outp	a	; hi adr always 0
0BC3  ED79    		DB	0EDH,a*8+41H
0BC5          		outp	e
0BC5  ED59    		DB	0EDH,e*8+41H
0BC7          		outp	d
0BC7  ED51    		DB	0EDH,d*8+41H
0BC9          		outp	b	; command
0BC9  ED41    		DB	0EDH,b*8+41H
0BCB  0C      		inr	c	; ctl port
0BCC  AF      		xra	a
0BCD          		outp	a	; clear SCS
0BCD  ED79    		DB	0EDH,a*8+41H
0BCF  CD3D0B  	wc0:	call	getwiz1
0BD2  B7      		ora	a
0BD3          		jrnz	wc0
0BD3  20FA    		DB	20H,wc0-$-1
0BD5  1E03    		mvi	e,sn$sr
0BD7  CD3D0B  		call	getwiz1
0BDA  C9      		ret
		
		; HL=socket relative pointer (TX_WR)
		; DE=length (preserved, not used)
		; Returns: HL=msgptr, C=spi$dat
0BDB          	cpsetup:
0BDB  3E01    		mvi	a,WZSCS
0BDD  D341    		out	spi$ctl
0BDF  0E40    		mvi	c,spi$dat
0BE1          		outp	h
0BE1  ED61    		DB	0EDH,h*8+41H
0BE3          		outp	l
0BE3  ED69    		DB	0EDH,l*8+41H
0BE5  3A8222  		lda	cursok
0BE8  B0      		ora	b
0BE9          		outp	a
0BE9  ED79    		DB	0EDH,a*8+41H
0BEB  2A8522  		lhld	msgptr
0BEE  C9      		ret
		
		; length always <= 133 bytes, never overflows OUTIR/INIR
0BEF          	cpyout:
0BEF  0614    		mvi	b,txbuf0
0BF1  CDDB0B  		call	cpsetup
0BF4  43      		mov	b,e	; length
0BF5          		outir		; send data
0BF5  EDB3    		DB	0EDH,0B3H
0BF7  228522  		shld	msgptr
0BFA  0C      		inr	c	; ctl port
0BFB  AF      		xra	a
0BFC          		outp	a	; clear SCS
0BFC  ED79    		DB	0EDH,a*8+41H
0BFE  C9      		ret
		
		; HL=socket relative pointer (RX_RD)
		; DE=length
		; Destroys IDM_AR0, IDM_AR1
		; length always <= 133 bytes, never overflows OUTIR/INIR
0BFF          	cpyin:
0BFF  0618    		mvi	b,rxbuf0
0C01  CDDB0B  		call	cpsetup	;
0C04          		inp	a	; prime MISO
0C04  ED78    		DB	0EDH,a*8+40H
0C06  43      		mov	b,e	; fraction of page
0C07          		inir		; recv data
0C07  EDB2    		DB	0EDH,0B2H
0C09  228522  		shld	msgptr
0C0C  0C      		inr	c	; ctl port
0C0D  AF      		xra	a
0C0E          		outp	a	; clear SCS
0C0E  ED79    		DB	0EDH,a*8+41H
0C10  C9      		ret
		
		; L=bits to reset
		; D=socket base
0C11          	wizsts:
0C11  1E02    		mvi	e,sn$ir
0C13  CD3D0B  		call	getwiz1	; destroys C
0C16  F5      		push	psw
0C17  A5      		ana	l
0C18          		jrz	ws0	; don't reset if not set (could race)
0C18  2804    		DB	28H,ws0-$-1
0C1A  7D      		mov	a,l
0C1B  CD570B  		call	putwiz1
0C1E  F1      	ws0:	pop	psw
0C1F  C9      		ret
		
		; D=socket BSB, C=bits to check
		; Return: A=status reg
0C20  21007D  	wizist:	lxi	h,32000
0C23  C5      	wst0:	push	b	; C has status bits to check
0C24  E5      		push	h
0C25  69      		mov	l,c
0C26  CD110C  		call	wizsts
0C29  E1      		pop	h
0C2A  C1      		pop	b
0C2B  47      		mov	b,a
0C2C  A1      		ana	c
0C2D          		jrnz	wst1
0C2D  2007    		DB	20H,wst1-$-1
0C2F  2B      		dcx	h
0C30  7C      		mov	a,h
0C31  B5      		ora	l
0C32          		jrnz	wst0
0C32  20EF    		DB	20H,wst0-$-1
0C34  37      		stc
0C35  C9      		ret
0C36  78      	wst1:	mov	a,b
0C37  C9      		ret
		
		;	WIZNET boot routine
		;
0C38          	bwiznet:
0C38  D5      		push	d
			; extract optional string. must do it now, before we
			; overwrite bootbf.
0C39  110523  		lxi	d,msg$dat	; target for string
0C3C  218022  		lxi	h,bootbf
0C3F  AF      		xra	a
0C40  320423  		sta	msg$siz
0C43  7E      		mov	a,m
0C44  FEC3    		cpi	0c3h	; no string
0C46          		jrz	nb5
0C46  2808    		DB	28H,nb5-$-1
0C48  4F      		mov	c,a
			; we send N+1 bytes, NUL term
0C49  320423  		sta	msg$siz
0C4C  0600    		mvi	b,0
0C4E          		ldir
0C4E  EDB0    		DB	0EDH,0B0H
0C50  AF      	nb5:	xra	a
0C51  12      		stax	d	; NUL term
0C52  D1      		pop	d
0C53  7B      		mov	a,e	; server id, 0..9
0C54  328022  		sta	server
			; look at WIZNET hard, init as needed
0C57  111D00  		lxi	d,pmagic	; D = 0 (comm regs), E = PMAGIC offset
0C5A  CD3D0B  		call	getwiz1
0C5D  B7      		ora	a
0C5E  CCFA0D  		cz	wizcfg	; configure chip from nvram
0C61  D8      		rc
0C62  328122  		sta	nodeid ; our slave (client) ID
			; locate server node id in chip's socket regs.
			;
0C65  0608    		mvi	b,nsocks
0C67  110408  		lxi	d,(sock0 shl 8) + sn$prt
0C6A          	nb1:
0C6A  CD6F0B  		call	getwiz2	; destroys C,HL
0C6D  7C      		mov	a,h
0C6E  FE31    		cpi	31h
0C70          		jrnz	nb0
0C70  2006    		DB	20H,nb0-$-1
0C72  3A8022  		lda	server
0C75  BD      		cmp	l
0C76          		jrz	nb2	; found server socket
0C76  2807    		DB	28H,nb2-$-1
0C78          	nb0:
0C78  3E20    		mvi	a,001$00$000b
0C7A  82      		add	d	; next socket
0C7B  57      		mov	d,a
0C7C          		djnz	nb1
0C7C  10EC    		DB	10H,nb1-$-1
0C7E  C9      		ret	; error: server not configured
0C7F          	nb2:	; D = server socket BSB
0C7F  7A      		mov	a,d
0C80  E6E0    		ani	11100000b
0C82  328222  		sta	cursok
0C85  CDE60C  		call	wizopen
0C88  D8      		rc	; any error
0C89  3E01    		mvi	a,1	; FNC for "boot me"
0C8B  320323  		sta	msg$fnc
			; string already setup
0C8E          	loop:
0C8E  3EB0    		mvi	a,0b0h	; FMT for client boot messages
0C90  320023  		sta	msg$fmt
0C93  CD230D  		call	sndrcv
0C96  D8      		rc	; network failure
0C97  3A0023  		lda	msg$fmt
0C9A  FEB1    		cpi	0b1h	; FMT for server boot responses
0C9C  C0      		rnz
			; TODO: verify SID?
0C9D  3A0323  		lda	msg$fnc
0CA0  B7      		ora	a
0CA1  C8      		rz	; NAK - error
0CA2  3D      		dcr	a
0CA3          		jrz	ldmsg
0CA3  2830    		DB	28H,ldmsg-$-1
0CA5  3D      		dcr	a
0CA6          		jrz	stdma
0CA6  2825    		DB	28H,stdma-$-1
0CA8  3D      		dcr	a
0CA9          		jrz	load
0CA9  2809    		DB	28H,load-$-1
0CAB  3D      		dcr	a
0CAC  C0      		rnz	; unsupported FNC
			; done: execute boot code
0CAD  CD120D  		call	wizclose
0CB0  2A0523  		lhld	msg$dat
0CB3  E9      		pchl
0CB4  2A8B22  	load:	lhld	dma
0CB7  EB      		xchg
0CB8  210523  		lxi	h,msg$dat
0CBB  018000  		lxi	b,128
0CBE          		ldir
0CBE  EDB0    		DB	0EDH,0B0H
0CC0  EB      		xchg
0CC1  228B22  		shld	dma
0CC4  AF      	ack:	xra	a	; FNC 0 = ACK
0CC5  320323  		sta	msg$fnc
0CC8  320423  		sta	msg$siz
0CCB          		jr	loop
0CCB  18C1    		DB	18H,loop-$-1
0CCD  2A0523  	stdma:	lhld	msg$dat
0CD0  228B22  		shld	dma
0CD3          		jr	ack
0CD3  18EF    		DB	18H,ack-$-1
0CD5  CD2A06  	ldmsg:	call	crlf
0CD8  210523  		lxi	h,msg$dat
0CDB  7E      	ldm0:	mov	a,m
0CDC  23      		inx	h
0CDD  FE24    		cpi	'$'
0CDF          		jrz	ack
0CDF  28E3    		DB	28H,ack-$-1
0CE1  CD6C05  		call	conout
0CE4          		jr	ldm0
0CE4  18F5    		DB	18H,ldm0-$-1
		
		; D = server socket BSB
0CE6          	wizopen:
0CE6  1E03    		mvi	e,sn$sr
0CE8  CD3D0B  		call	getwiz1
0CEB  FE17    		cpi	ESTABLISHED
0CED  C8      		rz	; ready to rock-n-roll...
			; try to open...
0CEE  FE13    		cpi	SOKINIT
0CF0          		jrz	nb4
0CF0  2809    		DB	28H,nb4-$-1
0CF2  3E01    		mvi	a,OPEN
0CF4  CDB70B  		call	wizcmd
0CF7  FE13    		cpi	SOKINIT
0CF9  37      		stc
0CFA  C0      		rnz	; failed to open (init)
0CFB  1E02    	nb4:	mvi	e,sn$ir	; ensure no lingering bits...
0CFD  3E1F    		mvi	a,00011111b
0CFF  CD570B  		call	putwiz1
0D02  3E04    		mvi	a,CONNECT
0D04  CDB70B  		call	wizcmd
0D07  0E0B    		mvi	c,00001011b	; CON, DISCON, or TIMEOUT
0D09  CD200C  		call	wizist	; returns when one is set, or CY
0D0C  D8      		rc
0D0D  E601    		ani	00000001b	; need CON
0D0F  D601    		sui	00000001b	; CY if bit is 0
0D11  C9      		ret
		
0D12          	wizclose:
0D12  3A8222  		lda	cursok
0D15  F608    		ori	sock0
0D17  57      		mov	d,a
0D18  3E08    		mvi	a,DISC
0D1A  CDB70B  		call	wizcmd
0D1D  0E0A    		mvi	c,00001010b	; DISCON, or TIMEOUT
0D1F  CD200C  		call	wizist	; returns when one is set, or CY
0D22  C9      		ret	; don't care which result?
		
		;	Send Message on Network, receive response
		;	msgbuf setup with FMT, FNC, LEN, data
		;	msg len always <= 128 (133 total) bytes.
0D23          	sndrcv:			; BC = message addr
			; TODO: drain/flush receiver
		; begin send phase
0D23  210023  		lxi	h,msgbuf
0D26  228522  		shld	msgptr
0D29  3A8222  		lda	cursok
0D2C  F608    		ori	sock0
0D2E  57      		mov	d,a
			; D=socket patn
0D2F  3A8022  		lda	server
0D32  320123  		sta	msg$did	; Set Server ID (dest) in header
0D35  3A8122  		lda	nodeid
0D38  320223  		sta	msg$sid	; Set Slave ID (src) in header
0D3B  3A0423  		lda	msg$siz	; msg siz (-1)
0D3E  C606    		adi	5+1	; hdr, +1 for (-1)
0D40  6F      		mov	l,a
0D41  2600    		mvi	h,0
0D43  228722  		shld	msglen
0D46  1E24    		mvi	e,sn$txwr
0D48  CD6F0B  		call	getwiz2
0D4B  228322  		shld	curptr
0D4E  2A8722  		lhld	msglen
0D51          		lbcd	curptr
0D51  ED4B    		DB	0EDH,4BH
0D53  8322    		DW	curptr
0D55  09      		dad	b
0D56  1E24    		mvi	e,sn$txwr
0D58  CD9F0B  		call	putwiz2
			; send data
0D5B  2A8722  		lhld	msglen
0D5E  EB      		xchg
0D5F  2A8322  		lhld	curptr
0D62  CDEF0B  		call	cpyout
0D65  3A8222  		lda	cursok
0D68  F608    		ori	sock0
0D6A  57      		mov	d,a
0D6B  3E20    		mvi	a,SEND
0D6D  CDB70B  		call	wizcmd
			; ignore Sn_SR?
0D70  0E1A    		mvi	c,00011010b	; SEND_OK bit, TIMEOUT, DISConnect
0D72  CD200C  		call	wizist
0D75  D8      		rc
0D76  E610    		ani	00010000b	; SEND_OK
0D78  37      		stc
0D79  C8      		rz
		; begin recv phase - loop
0D7A  3A8222  		lda	cursok	; is D still socket BSB?
0D7D  F608    		ori	sock0
0D7F  57      		mov	d,a
		;	Receive Message from Network
0D80  210023  		lxi	h,msgbuf
0D83  228522  		shld	msgptr
0D86  0E06    		mvi	c,00000110b	; RECV, DISC
0D88  CD200C  		call	wizist	; check for recv within timeout
0D8B          		jrc	rerr
0D8B  386A    		DB	38H,rerr-$-1
0D8D  E604    		ani	00000100b	; RECV
0D8F          		jrz	rerr
0D8F  2866    		DB	28H,rerr-$-1
0D91  210000  		lxi	h,0
0D94  228922  		shld	totlen
0D97          	rm0:	; D must be socket base...
0D97  1E26    		mvi	e,sn$rxrsr	; length
0D99  CD6F0B  		call	getwiz2
0D9C  7C      		mov	a,h
0D9D  B5      		ora	l
0D9E          		jrz	rm0
0D9E  28F7    		DB	28H,rm0-$-1
0DA0  228722  		shld	msglen		; not CP/NET msg len
0DA3  1E28    		mvi	e,sn$rxrd	; pointer
0DA5  CD6F0B  		call	getwiz2
0DA8  228322  		shld	curptr
0DAB          		lbcd	msglen	; BC=Sn_RX_RSR
0DAB  ED4B    		DB	0EDH,4BH
0DAD  8722    		DW	msglen
0DAF  2A8922  		lhld	totlen
0DB2  B7      		ora	a
0DB3          		dsbc	b
0DB3  ED42    		DB	0EDH,b*8+42H
0DB5  228922  		shld	totlen	; might be negative...
0DB8          		lbcd	curptr
0DB8  ED4B    		DB	0EDH,4BH
0DBA  8322    		DW	curptr
0DBC  2A8722  		lhld	msglen	; BC=Sn_RX_RD, HL=Sn_RX_RSR
0DBF  09      		dad	b	; HL=nxt RD
0DC0  1E28    		mvi	e,sn$rxrd
0DC2  CD9F0B  		call	putwiz2
			; DE destroyed...
0DC5          		lded	msglen
0DC5  ED5B    		DB	0EDH,5BH
0DC7  8722    		DW	msglen
0DC9  2A8322  		lhld	curptr
0DCC  CDFF0B  		call	cpyin
0DCF  3A8222  		lda	cursok
0DD2  F608    		ori	sock0
0DD4  57      		mov	d,a
0DD5  3E40    		mvi	a,RECV
0DD7  CDB70B  		call	wizcmd
			; ignore Sn_SR?
0DDA  2A8922  		lhld	totlen	; might be neg (first pass)
0DDD  7C      		mov	a,h
0DDE  B7      		ora	a
0DDF  F2F30D  		jp	rm1
			; can we guarantee at least msg hdr?
0DE2  3A0423  		lda	msg$siz	; msg siz (-1)
0DE5  C606    		adi	5+1	; header, +1 for (-1)
0DE7  5F      		mov	e,a
0DE8  3E00    		mvi	a,0
0DEA  8F      		adc	a
0DEB  57      		mov	d,a	; true msg len
0DEC  19      		dad	d	; subtract what we already have
0DED          		jrnc	rerr	; something is wrong, if still neg
0DED  3008    		DB	30H,rerr-$-1
0DEF  228922  		shld	totlen
0DF2  7C      		mov	a,h
0DF3  B5      	rm1:	ora	l
0DF4          		jrnz	rm0
0DF4  20A1    		DB	20H,rm0-$-1
0DF6  C9      		ret	; success (A=0)
		
0DF7          	rerr:
0DF7  AF      	err:	xra	a
0DF8  3D      		dcr	a	; NZ
0DF9  C9      		ret
		
		; Try to read NVRAM config for WIZNET.
		; Returns: A = node id (PMAGIC) or CY if error (no config)
0DFA          	wizcfg:	; restore config from NVRAM
0DFA  210000  		lxi	h,0
0DFD  110002  		lxi	d,512
0E00  CDA70E  		call	nvget
0E03  CD830E  		call	vcksum
0E06  37      		stc
0E07  C0      		rnz	; checksum wrong - no config available
0E08  210124  		lxi	h,nvbuf+gar
0E0B  1600    		mvi	d,0
0E0D  1E01    		mvi	e,gar
0E0F  0612    		mvi	b,18	; GAR+SUBR+SHAR+SIPR
0E11  CD890B  		call	wizset
0E14  3A1D24  		lda	nvbuf+pmagic
0E17  1E1D    		mvi	e,pmagic
0E19  CD570B  		call	putwiz1
0E1C          		lxix	nvbuf+32	; start of socket0 data
0E1C  DD21    		DB	0DDH,21H
0E1E  2024    		DW	nvbuf+32
0E20  1608    		mvi	d,SOCK0
0E22  0608    		mvi	b,8
0E24          	rest0:
0E24  C5      		push	b
0E25          		ldx	a,sn$prt
0E25  DD7E04  		DB	0DDH,a*8+46H,sn$prt
0E28  FE31    		cpi	31h
0E2A          		jrnz	rest1	; skip unconfigured sockets
0E2A  201E    		DB	20H,rest1-$-1
0E2C  3E01    		mvi	a,1	; TCP mode
0E2E  1E00    		mvi	e,sn$mr
0E30  CD570B  		call	putwiz1	; force TCP/IP mode
0E33          		ldx	a,NvKPALVTR
0E33  DD7E1D  		DB	0DDH,a*8+46H,NvKPALVTR
0E36  1E2F    		mvi	e,sn$kpalvtr
0E38  B7      		ora	a
0E39  C4570B  		cnz	putwiz1
0E3C  1E04    		mvi	e,sn$prt
0E3E  0602    		mvi	b,2
0E40  CD5B0E  		call	setsok
0E43  1E0C    		mvi	e,sn$dipr
0E45  0606    		mvi	b,6	; DIPR and DPORT
0E47  CD5B0E  		call	setsok
0E4A          	rest1:
0E4A  012000  		lxi	b,32
0E4D          		dadx	b
0E4D  DD09    		DB	0DDH,b*8+09H
0E4F  3E20    		mvi	a,001$00$000b	; socket BSB incr value
0E51  82      		add	d
0E52  57      		mov	d,a
0E53  C1      		pop	b
0E54          		djnz	rest0
0E54  10CE    		DB	10H,rest0-$-1
0E56  3A1D24  		lda	nvbuf+pmagic	; our node id
0E59  B7      		ora	a	; NC
0E5A  C9      		ret
		
		; IX = base data buffer for socket, D = socket BSB, E = offset, B = length
		; destroys HL, B, C
0E5B          	setsok:
0E5B          		pushix
0E5B  DDE5    		DB	0DDH,0E5H
0E5D  E1      		pop	h
0E5E  D5      		push	d
0E5F  1600    		mvi	d,0
0E61  19      		dad	d	; HL points to data in 'buf'
0E62  D1      		pop	d
0E63  CD890B  		call	wizset
0E66  C9      		ret
		
0E67          	cksum32:
0E67  210000  		lxi	h,0
0E6A  110000  		lxi	d,0
0E6D          	cks0:	ldx	a,+0
0E6D  DD7E00  		DB	0DDH,a*8+46H,+0
0E70          		inxix
0E70  DD23    		DB	0DDH,23H
0E72  83      		add	e
0E73  5F      		mov	e,a
0E74          		jrnc	cks1
0E74  3007    		DB	30H,cks1-$-1
0E76  14      		inr	d
0E77          		jrnz	cks1
0E77  2004    		DB	20H,cks1-$-1
0E79  2C      		inr	l
0E7A          		jrnz	cks1
0E7A  2001    		DB	20H,cks1-$-1
0E7C  24      		inr	h
0E7D  0B      	cks1:	dcx	b
0E7E  78      		mov	a,b
0E7F  B1      		ora	c
0E80          		jrnz	cks0
0E80  20EB    		DB	20H,cks0-$-1
0E82  C9      		ret
		
		; Validates checksum in 'buf'
		; return: NZ on error
0E83          	vcksum:
0E83          		lxix	nvbuf
0E83  DD21    		DB	0DDH,21H
0E85  0024    		DW	nvbuf
0E87  01FC01  		lxi	b,508
0E8A  CD670E  		call	cksum32
0E8D          		lbcd	nvbuf+510
0E8D  ED4B    		DB	0EDH,4BH
0E8F  FE25    		DW	nvbuf+510
0E91  78      		mov	a,b	;
0E92  B1      		ora	c	; check first half zero
0E93          		dsbc	b
0E93  ED42    		DB	0EDH,b*8+42H
0E95  C0      		rnz
0E96          		lbcd	nvbuf+508
0E96  ED4B    		DB	0EDH,4BH
0E98  FC25    		DW	nvbuf+508
0E9A  B0      		ora	b	;
0E9B  B1      		ora	c	; check second half zero
0E9C  EB      		xchg
0E9D          		dsbc	b
0E9D  ED42    		DB	0EDH,b*8+42H
0E9F  C0      		rnz
0EA0  B7      		ora	a	; was checksum all zero?
0EA1          		jrz	vcksm0
0EA1  2802    		DB	28H,vcksm0-$-1
0EA3  AF      		xra	a	; ZR
0EA4  C9      		ret
0EA5  3C      	vcksm0:	inr	a	; NZ
0EA6  C9      		ret
		
		; Get a block of data from NVRAM to 'buf'
		; HL = nvram address, DE = length (always multiple of 256)
0EA7          	nvget:
0EA7  3E02    		mvi	a,NVSCS
0EA9  D341    		out	spi$ctl
0EAB  3E03    		mvi	a,NVRD
0EAD  D340    		out	spi$dat
0EAF  7C      		mov	a,h
0EB0  D340    		out	spi$dat
0EB2  7D      		mov	a,l
0EB3  D340    		out	spi$dat
0EB5  DB40    		in	spi$dat	; prime pump
0EB7  0E40    		mvi	c,spi$dat
0EB9  210024  		lxi	h,nvbuf
0EBC  43      		mov	b,e
0EBD          	nvget0:	inir	; B = 0 after
0EBD  EDB2    		DB	0EDH,0B2H
0EBF  15      		dcr	d
0EC0          		jrnz	nvget0
0EC0  20FB    		DB	20H,nvget0-$-1
0EC2  AF      		xra	a	; not SCS
0EC3  D341    		out	spi$ctl
0EC5  C9      		ret
		endif
		
0000          	if terminal
		endif
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Set BAUD command
0EC6          	setber:
0EC6  3E07    		mvi	a,BEL
0EC8  CD6C05  		call	conout
0ECB  E1      		pop	h
0ECC  C9      		ret
		
0ECD          	setbr:
0ECD  21320F  		lxi	h,ratems
0ED0  CD3406  		call	msgout
0ED3  CD5B05  		call	conin
0ED6  E6DF    		ani	11011111b	; toupper
0ED8  4F      		mov	c,a
0ED9  CD6C05  		call	conout
0EDC  D641    		sui	'A'
0EDE  FE0E    		cpi	'O'-'A'
0EE0          		jrnc	setber
0EE0  30E4    		DB	30H,setber-$-1
0EE2  5F      		mov	e,a
0EE3  1600    		mvi	d,0
0EE5  213A0F  		lxi	h,brtab
0EE8  19      		dad	d
0EE9  19      		dad	d
0EEA  19      		dad	d
0EEB  19      		dad	d
0EEC  5E      		mov	e,m
0EED  23      		inx	h
0EEE  56      		mov	d,m	; DE=baud divisor
0EEF  23      		inx	h
0EF0  7E      		mov	a,m
0EF1  23      		inx	h
0EF2  66      		mov	h,m
0EF3  6F      		mov	l,a	; HL=rate string
0EF4  CD3406  		call	msgout
0EF7  21D20F  		lxi	h,baudms
0EFA  CD3406  		call	msgout
0EFD  CD2306  		call	waitcr
0F00  3E1B    		mvi	a,ESC
0F02  CD6C05  		call	conout
0F05  3E72    		mvi	a,'r' ; Set Baud
0F07  CD6C05  		call	conout
0F0A  79      		mov	a,c ; Baud value
0F0B  CD6C05  		call	conout
0F0E          	setbrf:
0F0E  DBED    		in	0edh
0F10  E660    		ani	01100000b
0F12  FE60    		cpi	01100000b
0F14          		jrnz	setbrf	; flush output
0F14  20F8    		DB	20H,setbrf-$-1
0F16  01A00F  		lxi	b,4000	; delay value ~43mS
0F19          	setbr0:
0F19  0B      		dcx	b
0F1A  78      		mov	a,b
0F1B  B1      		ora	c
0F1C          		jrnz	setbr0
0F1C  20FB    		DB	20H,setbr0-$-1
0F1E  DBEB    		in	0ebh
0F20  F680    		ori	10000000b	; divsor latch enable
0F22  D3EB    		out	0ebh
0F24  7B      		mov	a,e
0F25  D3E8    		out	0e8h
0F27  7A      		mov	a,d
0F28  D3E9    		out	0e9h
0F2A  DBEB    		in	0ebh
0F2C  E67F    		ani	01111111b	; divisor latch disable
0F2E  D3EB    		out	0ebh
0F30  E1      		pop	h
0F31  C9      		ret
		
0F32  52617465	ratems:	db	'Rate - ',TRM
      202D2000
		
0F3A          	brtab:
0F3A  1704720F		dw	1047,	br110
0F3E  0003780F		dw	768,	br150
0F42  80017E0F		dw	384,	br300
0F46  C000840F		dw	192,	br600
0F4A  60008A0F		dw	96,	br1200
0F4E  4000910F		dw	64,	br1800
0F52  3A00980F		dw	58,	br2000
0F56  30009F0F		dw	48,	br2400
0F5A  2000A60F		dw	32,	br3600
0F5E  1800AD0F		dw	24,	br4800
0F62  1000B40F		dw	16,	br7200
0F66  0C00BB0F		dw	12,	br9600
0F6A  0600C20F		dw	6,	br19200
0F6E  0300CA0F		dw	3,	br38400
		
0F72  20283131	br110:	db	' (110',TRM
      3000
0F78  20283135	br150:	db	' (150',TRM
      3000
0F7E  20283330	br300:	db	' (300',TRM
      3000
0F84  20283630	br600:	db	' (600',TRM
      3000
0F8A  20283132	br1200:	db	' (1200',TRM
      303000
0F91  20283138	br1800:	db	' (1800',TRM
      303000
0F98  20283230	br2000:	db	' (2000',TRM
      303000
0F9F  20283234	br2400:	db	' (2400',TRM
      303000
0FA6  20283336	br3600:	db	' (3600',TRM
      303000
0FAD  20283438	br4800:	db	' (4800',TRM
      303000
0FB4  20283732	br7200:	db	' (7200',TRM
      303000
0FBB  20283936	br9600:	db	' (9600',TRM
      303000
0FC2  20283139	br19200: db	' (19200',TRM
      32303000
0FCA  20283338	br38400: db	' (38400',TRM
      34303000
0FD2  20626175	baudms:	db	' baud)',TRM
      642900
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Print ROM version command
0FD9          	prtver:
0FD9  21E70F  		lxi	h,versms
0FDC  CD3406  		call	msgout
0FDF  3AF00F  		lda	vers
0FE2  CDCE05  		call	hexout
0FE5  E1      		pop	h
0FE6  C9      		ret
		
0FE7  56657273	versms:	db	'Version ',TRM
      696F6E20
      00
0FF0  17      	vers:	db	VERN	; version byte... "1.0"
		
0000          	if verify
		else
			rept	1000h-$
0FF1  FF      		db	0ffh
0FF2  FF      		db	0ffh
0FF3  FF      		db	0ffh
0FF4  FF      		db	0ffh
0FF5  FF      		db	0ffh
0FF6  FF      		db	0ffh
0FF7  FF      		db	0ffh
0FF8  FF      		db	0ffh
0FF9  FF      		db	0ffh
0FFA  FF      		db	0ffh
0FFB  FF      		db	0ffh
0FFC  FF      		db	0ffh
0FFD  FF      		db	0ffh
0FFE  FF      		db	0ffh
0FFF  FF      		db	0ffh
		endif
		
0000          	if	($ <> 1000h)
		endif
1000          		end



Statistics:

     4	passes
     0	jr promotions
   420	symbols
  4096	bytes

   740	macro calls
  3785	macro bytes
     0	invented symbols
