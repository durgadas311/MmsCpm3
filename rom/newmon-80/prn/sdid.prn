                ; program to initialize and identify an SDCard attached to an H8xSPI
                	maclib core
                
 0040 =         spi	equ	40h
                
 0040 =         spi?wr	equ	spi+0
 0040 =         spi?rd	equ	spi+0
 0041 =         spi?ctl	equ	spi+1
                
 0001 =         CS0	equ	00000001b
 0002 =         CS1	equ	00000010b
 0004 =         CS2	equ	00000100b
 0008 =         CS3	equ	00001000b
 0004 =         NUMCS	equ	4
 0004 =         SDSCS0	equ	CS2	; SCS for SDCard 0
 0008 =         SDSCS1	equ	CS3	; SCS for SDCard 1
 0002 =         NUMSD	equ	2
                
 0040 =         CMDST	equ	01000000b	; command start bits
                
 000D =         CR	equ	13
 000A =         LF	equ	10
                
                	cseg
 0000 C30600    	jmp	start
                
 0003 0408      cstab:	db	SDSCS0,SDSCS1
 0005 05        retry:	db	5
                
 0006 313605    start:	lxi	sp,stack
 0009 3E04      	mvi	a,SDSCS0	; default
 000B 322801    	sta	curcs
 000E 218022    	lxi	h,2280h	; NUL terminated
 0011 23        	inx	h	; skip length
                	; skip program name
 0012 7E        skp0:	mov	a,m
 0013 23        	inx	h
 0014 B7        	ora	a
 0015 CA2300    	jz	skp1
 0018 FE20      	cpi	' '
 001A C21200    	jnz	skp0
 001D CD9501    	call	parcs	; curcs revised if needed
 0020 DA2201    	jc	error
                skp1:
 0023 F3        	di	; don't need/want interrupts
                	; waive 1mS delay... we are well past that...
 0024 CDE701    	call	run74	; must cycle >= 74 clocks
                
                	; CMD0 - enter SPI mode
 0027 212A01    	lxi	h,cmd0
 002A 1601      	mvi	d,1
 002C 1E01      	mvi	e,1	; turn off SCS
 002E CD0A02    	call	sdcmd
 0031 DA1901    	jc	fail
 0034 3A3001    	lda	cmd0+6	; R1
 0037 FE01      	cpi	00000001b	; IDLE bit set?
 0039 C21901    	jnz	fail
 003C 213101    	lxi	h,cmd8
 003F 1605      	mvi	d,5
 0041 1E01      	mvi	e,1	; turn off SCS
 0043 CD0A02    	call	sdcmd
 0046 DA1901    	jc	fail
 0049 3A3701    	lda	cmd8+6
 004C FE01      	cpi	00000001b	; no error, IDLE bit still set
 004E CA5B00    	jz	ok8
 0051 E604      	ani	0100b	; Illegal Command
 0053 CA1901    	jz	fail	; must be some other error - fatal
                	; CMD8 not recognized, SD1 card... (not supported?)
 0056 3E00      	mvi	a,0
 0058 324401    	sta	acmd41+1
                ok8:
 005B 3E05      	mvi	a,5
 005D 320500    	sta	retry
                init:	; this could take a long time... don't flood console
 0060 214301    	lxi	h,acmd41
 0063 1601      	mvi	d,1
 0065 CDF001    	call	doacmd
 0068 DA1901    	jc	fail
 006B 3A4901    	lda	acmd41+6
 006E FE00      	cpi	00000000b	; READY?
 0070 CA8500    	jz	init0
 0073 E67E      	ani	01111110b	; any errors?
 0075 CA6000    	jz	init
 0078 3A0500    	lda	retry
 007B 3D        	dcr	a
 007C 320500    	sta	retry
 007F C26000    	jnz	init
 0082 C31901    	jmp	fail
                init0:	; done with init
                	; now try CMD58 if applicable
 0085 3A4401    	lda	acmd41+1
 0088 B7        	ora	a
 0089 CA9600    	jz	next
                	; SD2... get CMD58
 008C 214A01    	lxi	h,cmd58
 008F 1605      	mvi	d,5
 0091 1E01      	mvi	e,1	; turn off SCS
 0093 CD0A02    	call	sdcmd
                next:
                	; read CID...
 0096 216301    	lxi	h,cmd10
 0099 1601      	mvi	d,1
 009B 1E00      	mvi	e,0	; leave SCS on
 009D CD0A02    	call	sdcmd
 00A0 DA1901    	jc	fail
 00A3 3A6901    	lda	cmd10+6
 00A6 B7        	ora	a
 00A7 C2D900    	jnz	bad
 00AA 219604    	lxi	h,cid
 00AD 011001    	lxi	b,0110h	; 16 bytes, 1 loop
 00B0 CD3902    	call	sdblk	; turns off SCS
 00B3 DAD600    	jc	badblk
                	; read CSD...
 00B6 215C01    	lxi	h,cmd9
 00B9 1601      	mvi	d,1
 00BB 1E00      	mvi	e,0	; leave SCS on
 00BD CD0A02    	call	sdcmd
 00C0 DA1901    	jc	fail
 00C3 3A6201    	lda	cmd9+6
 00C6 B7        	ora	a
 00C7 C2D900    	jnz	bad
 00CA 21A604    	lxi	h,csd
 00CD 011001    	lxi	b,0110h	; 16 bytes, 1 loop
 00D0 CD3902    	call	sdblk	; turns off SCS
 00D3 D2DF00    	jnc	done
 00D6 CD6A01    badblk:	call	hexout
 00D9 AF        bad:	xra	a
 00DA D341      	out	spi?ctl	; SCS off
 00DC C31901    	jmp	fail
                done:
 00DF FB        	ei
 00E0 3A2901    	lda	dmp
 00E3 B7        	ora	a
 00E4 CA0B01    	jz	nodmp
 00E7 CD1B00    	call	crlf
 00EA 214403    	lxi	h,cidmsg
 00ED CD4400    	call	msgout
 00F0 219604    	lxi	h,cid
 00F3 CD4204    	call	dmpline
 00F6 CD1B00    	call	crlf
 00F9 214A03    	lxi	h,csdmsg
 00FC CD4400    	call	msgout
 00FF 21A604    	lxi	h,csd
 0102 CD4204    	call	dmpline
 0105 CD1B00    	call	crlf
 0108 C31401    	jmp	exit
                
 010B CD6302    nodmp:	call	prcid
 010E CDED02    	call	prcsd
 0111 CD1B00    	call	crlf
                exit:
 0114 FB        	ei
 0115 2A1E00    	lhld	retmon
 0118 E9        	pchl
                
 0119 21D601    fail:	lxi	h,failms
 011C CD4400    exit0:	call	msgout
 011F C31401    	jmp	exit
                
 0122 21C501    error:	lxi	h,synerr
 0125 C31C01    	jmp	exit0
                
 0128 04        curcs:	db	SDSCS0
 0129 00        dmp:	db	0
                
                ; command is always 6 bytes (?)
                ; From RomWBW:
                ;    AT LEAST ONE SD CARD IS KNOWN TO FAIL ANY COMMAND
                ;    WHERE THE CRC POSITION IS NOT $FF
                ; This explains the problems with "Samsung 32Pro",
                ; although that card only requires the end-command bit.
 012A 4000000000cmd0:	db	CMDST+0,0,0,0,0,95h
 0130 00        	db	0
 0131 48000001AAcmd8:	db	CMDST+8,0,0,01h,0aah,87h
 0137 0000000000	db	0,0,0,0,0
 013C 7700000000cmd55:	db	CMDST+55,0,0,0,0,1
 0142 00        	db	0
 0143 6940000000acmd41:	db	CMDST+41,40h,0,0,0,1
 0149 00        	db	0
 014A 7A00000000cmd58:	db	CMDST+58,0,0,0,0,1
 0150 0000000000ocr:	db	0,0,0,0,0
 0155 5100000000cmd17:	db	CMDST+17,0,0,0,0,1
 015B 00        	db	0
 015C 4900000000cmd9:	db	CMDST+9,0,0,0,0,1	; SEND_CSD
 0162 00        	db	0
 0163 4A00000000cmd10:	db	CMDST+10,0,0,0,0,1	; SEND_CID
 0169 00        	db	0
                
                hexout:
 016A F5        	push	psw
 016B 0F        	rrc
 016C 0F        	rrc
 016D 0F        	rrc
 016E 0F        	rrc
 016F CD7301    	call	hexdig
 0172 F1        	pop	psw
                hexdig:
 0173 E60F      	ani	0fh
 0175 C690      	adi	90h
 0177 27        	daa
 0178 CE40      	aci	40h
 017A 27        	daa
 017B C38F01    	jmp	chrout
                
 017E 3E20      space:	mvi	a,' '
 0180 C38F01    	jmp	chrout
                
 0183 3E2F      slash:	mvi	a,'/'
 0185 C38F01    	jmp	chrout
                
 0188 3E2E      point:	mvi	a,'.'
 018A C38F01    	jmp	chrout
                
 018D 3E22      quote:	mvi	a,'"'
                	;jmp	chrout
                
 018F E5        chrout:	push	h
 0190 2A2600    	lhld	conout
 0193 E3        	xthl
 0194 C9        	ret
                
                ; parse for "CS#" and update 'curcs'
                parcs:
 0195 7E        par9:	mov	a,m
 0196 B7        	ora	a
 0197 C8        	rz
 0198 23        	inx	h
 0199 FE20      	cpi	' '
 019B CA9501    	jz	par9
 019E FE30      	cpi	'0'
 01A0 D8        	rc
 01A1 FE32      	cpi	'0'+NUMSD
 01A3 D2B801    	jnc	par0
                	; check for NUL?
 01A6 D630      	sui	'0'
 01A8 4F        	mov	c,a
 01A9 0600      	mvi	b,0
 01AB EB        	xchg
 01AC 210300    	lxi	h,cstab
 01AF 09        	dad	b
 01B0 7E        	mov	a,m
 01B1 322801    	sta	curcs
 01B4 EB        	xchg
 01B5 C39501    	jmp	par9
 01B8 E65F      par0:	ani	01011111b
 01BA FE44      	cpi	'D'
 01BC C29501    	jnz	par9	; error?
 01BF 322901    	sta	dmp
 01C2 C39501    	jmp	par9
                
 01C5 0D0A2A2A2Asynerr:	db	CR,LF,'*** syntax ***',0
 01D6 0D0A2A2A2Afailms:	db	CR,LF,'*** failed ***',0
                
                ; run-out at least 74 clock cycles... with SCS off...
 01E7 060A      run74:	mvi	b,10	; 80 cycles
 01E9 DB40      run740:	in	spi?rd
 01EB 05C2E901  	dcr b ! jnz	run740
 01EF C9        	ret
                
                ; always turns off SCS
                doacmd:
 01F0 E5        	push	h
 01F1 D5        	push	d
 01F2 213C01    	lxi	h,cmd55
 01F5 1601      	mvi	d,1
 01F7 1E00      	mvi	e,0	; do not turn off SCS
 01F9 CD0A02    	call	sdcmd
                	; ignore results? CMD55 never gives error?
 01FC D1        	pop	d
 01FD E1        	pop	h
 01FE 1E01      	mvi	e,1	; do turn off SCS
 0200 CD0A02    	call	sdcmd
 0203 F5        	push	psw
                	; for some reason, this is required (at least for ACMD41)
                	; when certain cards (Flexon) are in-socket during power up.
                	; If the card is re-seated after power up, this is not needed.
                	; Unclear if this is a MT011 anomaly or universal.
 0204 DB40      	in	spi?rd
 0206 DB40      	in	spi?rd
 0208 F1        	pop	psw
 0209 C9        	ret
                
                ; send (6 byte) command to SDCard, get response.
                ; HL=command+response buffer, D=response length
                ; return A=response code (00=success), HL=idle length, DE=gap length
                sdcmd:
 020A 3A2801    	lda	curcs
 020D D341      	out	spi?ctl	; SCS on
 020F 0E40      	mvi	c,spi?rd
                	; wait for idle
                	; TODO: timeout this loop
 0211 E5        	push	h	; save command+response buffer
 0212 DB40      sdcmd0:	in	spi?rd
 0214 FEFF      	cpi	0ffh
 0216 C21202    	jnz	sdcmd0
 0219 E1        	pop	h	; command buffer back
 021A 0606      	mvi	b,6
 021C CD8B04    	call	outir
 021F DB40      	in	spi?rd	; prime the pump
                	; TODO: timeout this loop
 0221 DB40      sdcmd2:	in	spi?rd
 0223 FEFF      	cpi	0ffh
 0225 CA2102    	jz	sdcmd2
 0228 42        	mov	b,d
 0229 77        	mov	m,a
 022A 23        	inx	h
 022B 05        	dcr	b
 022C CA3202    	jz	sdcmd4
 022F CD8004    	call	inir	; rest of response
 0232 7B        sdcmd4:	mov	a,e	; SCS flag
 0233 B7        	ora	a
 0234 C8        	rz
 0235 AF        	xra	a
 0236 D341      	out	spi?ctl	; SCS off
 0238 C9        	ret
                
                ; read a 512-byte data block, with packet header and CRC (ignored).
                ; READ command was already sent and responded to.
                ; HL=buffer, BC=length* (multiple of 256)
                ; return CY on error (A=error), DE=gap length
                sdblk:
 0239 C5        	push	b
 023A 3A2801    	lda	curcs
 023D D341      	out	spi?ctl	; SCS on
 023F 0E40      	mvi	c,spi?rd
                	; wait for packet header (or error)
                	; TODO: timeout this loop
 0241 DB40      sdblk0:	in	spi?rd
 0243 FEFF      	cpi	0ffh
 0245 CA4102    	jz	sdblk0
 0248 D1        	pop	d		; length to DE
 0249 FEFE      	cpi	11111110b	; data start
 024B 37        	stc	; else must be error
 024C C25C02    	jnz	sdblk2
 024F 43        	mov	b,e
 0250 CD8004    sdblk3:	call	inir
 0253 15        	dcr	d
 0254 C25002    	jnz	sdblk3
 0257 DB40      	in	spi?rd	; CRC 1
 0259 DB40      	in	spi?rd	; CRC 2
 025B AF        	xra	a	; NC
 025C F5        sdblk2:	push	psw
 025D AF        	xra	a
 025E D341      	out	spi?ctl	; SCS off
 0260 F1        	pop	psw
 0261 C9        	ret
                
                procr:	; ocr: 00 C0 FF 80 =? 80FFC000 = pwrup, 2.7-3.6V
 0262 C9        	ret
                
 0263 219604    prcid:	lxi	h,cid
 0266 CD1B00    	call	crlf
 0269 7E        	mov	a,m	; +0	; MID
 026A CD6A01    	call	hexout
 026D CD7E01    	call	space
 0270 CD8D01    	call	quote
 0273 23        	inx	h
 0274 7E        	mov	a,m	; +1	; OID[0]
 0275 CD8F01    	call	chrout
 0278 23        	inx	h
 0279 7E        	mov	a,m	; +2	; OID[1]
 027A CD8F01    	call	chrout
 027D CD8D01    	call	quote
 0280 CD7E01    	call	space
 0283 CD8D01    	call	quote
 0286 23        	inx	h
 0287 7E        	mov	a,m	; +3	; PNM[0]
 0288 CD8F01    	call	chrout
 028B 23        	inx	h
 028C 7E        	mov	a,m	; +4	; PNM[1]
 028D CD8F01    	call	chrout
 0290 23        	inx	h
 0291 7E        	mov	a,m	; +5	; PNM[2]
 0292 CD8F01    	call	chrout
 0295 23        	inx	h
 0296 7E        	mov	a,m	; +6	; PNM[3]
 0297 CD8F01    	call	chrout
 029A 23        	inx	h
 029B 7E        	mov	a,m	; +7	; PNM[4]
 029C CD8F01    	call	chrout
 029F CD8D01    	call	quote
 02A2 CD7E01    	call	space
 02A5 23        	inx	h
 02A6 7E        	mov	a,m	; +8	; PRV
 02A7 07        	rlc
 02A8 07        	rlc
 02A9 07        	rlc
 02AA 07        	rlc
 02AB CD7301    	call	hexdig
 02AE CD8801    	call	point
 02B1 7E        	mov	a,m	; +8	; PRV
 02B2 CD7301    	call	hexdig
 02B5 CD7E01    	call	space
                	; s/n - for now, print in hex...
 02B8 23        	inx	h
 02B9 7E        	mov	a,m	; +9	; PSN[0]
 02BA CD6A01    	call	hexout
 02BD 23        	inx	h
 02BE 7E        	mov	a,m	; +10	; PSN[1]
 02BF CD6A01    	call	hexout
 02C2 23        	inx	h
 02C3 7E        	mov	a,m	; +11	; PSN[2]
 02C4 CD6A01    	call	hexout
 02C7 23        	inx	h
 02C8 7E        	mov	a,m	; +12	; PSN[3]
 02C9 CD6A01    	call	hexout
 02CC CD7E01    	call	space
 02CF 23        	inx	h
 02D0 56        	mov	d,m	; +13	; MDT hi
 02D1 23        	inx	h
 02D2 5E        	mov	e,m	; +14	; MDT lo
 02D3 D5        	push	d
 02D4 7B        	mov	a,e
 02D5 E60F      	ani	0fh
 02D7 CD1504    	call	decout
 02DA CD8301    	call	slash
 02DD E1        	pop	h
 02DE 29        	dad	h
 02DF 29        	dad	h
 02E0 29        	dad	h
 02E1 29        	dad	h	; shift year into H
 02E2 5C        	mov	e,h
 02E3 1600      	mvi	d,0
 02E5 21D007    	lxi	h,2000
 02E8 19        	dad	d
 02E9 CDE903    	call	dec16
 02EC C9        	ret
                
 02ED 21A604    prcsd:	lxi	h,csd
 02F0 CD1B00    	call	crlf
 02F3 3E76      	mvi	a,'v'
 02F5 CD8F01    	call	chrout
 02F8 7E        	mov	a,m	; +0
 02F9 E6C0      	ani	11000000b	; CSD_STRUCTURE
 02FB 3E31      	mvi	a,'1'
 02FD CA0203    	jz	v10
 0300 3E32      	mvi	a,'2'
 0302 CD8F01    v10:	call	chrout
 0305 CD8801    	call	point
 0308 3E30      	mvi	a,'0'
 030A CD8F01    	call	chrout
 030D 7E        	mov	a,m	; +0
 030E E6C0      	ani	11000000b	; CSD_STRUCTURE
 0310 C8        	rz	; nothing more for v1.0...
                	; v2.0...
 0311 CD7E01    	call	space
                if 0
                	ldx	l,+7	; C_SIZE...
                	ldx	d,+8
                	ldx	e,+9
                	; TODO: print decimal...
                	mov	a,l
                	call	hexout
                	mov	a,d
                	call	hexout
                	mov	a,e
                	call	hexout
                else
 0314 23        	inx	h	; +1
 0315 23        	inx	h	; +2
 0316 23        	inx	h	; +3
 0317 23        	inx	h	; +4
 0318 23        	inx	h	; +5
 0319 23        	inx	h	; +6
 031A 23        	inx	h	; +7
 031B 46        	mov	b,m	; +7	; C_SIZE << 10
 031C 23        	inx	h
 031D 4E        	mov	c,m	; +8
 031E 23        	inx	h
 031F 56        	mov	d,m	; +9
 0320 1E00      	mvi	e,0	;	BC:DE is << 8, need two more
 0322 3E01      	mvi	a,1	; C_SIZE+1
 0324 82        	add	d
 0325 57        	mov	d,a
 0326 3E00      	mvi	a,0
 0328 89        	adc	c
 0329 4F        	mov	c,a
 032A 3E00      	mvi	a,0
 032C 88        	adc	b
 032D 47        	mov	b,a
 032E CD5303    	call	shl32
 0331 CD5303    	call	shl32
 0334 CD6003    	call	dec32
                endif
 0337 213E03    	lxi	h,blks
 033A CD4400    	call	msgout
 033D C9        	ret
                
 033E 20626C6B73blks:	db	' blks',0
 0344 4349443A20cidmsg:	db	'CID: ',0
 034A 4353443A20csdmsg:	db	'CSD: ',0
 0350 202000    spcs:	db	'  ',0
                
                ; BC:DE <<= 1
                shl32:
 0353 7B        	mov	a,e
 0354 87        	add	a
 0355 5F        	mov	e,a
 0356 7A        	mov	a,d
 0357 17        	ral
 0358 57        	mov	d,a
 0359 79        	mov	a,c
 035A 17        	ral
 035B 4F        	mov	c,a
 035C 78        	mov	a,b
 035D 17        	ral
 035E 47        	mov	b,a
 035F C9        	ret
                
                ; print number in BC:DE
                dec32:
 0360 2E00      	mvi	l,0
 0362 2609      	mvi	h,9
 0364 E5        	push	h	; control vars on stack
 0365 219403    	lxi	h,mlt10
 0368 AF        dd1:	xra	a
 0369 CDCD03    dd0:	call	sub32
 036C 3C        	inr	a
 036D D26903    	jnc	dd0
 0370 CDB803    	call	add32
 0373 E3        	xthl	; control vars in HL
 0374 3D        	dcr	a
 0375 C27D03    	jnz	dd2
 0378 2D        	dcr	l
 0379 2C        	inr	l
 037A CA8403    	jz	dd3
 037D 2E01      dd2:	mvi	l,1
 037F C630      	adi	'0'
 0381 CD8F01    	call	chrout
                dd3:
 0384 25        	dcr	h
 0385 E3        	xthl	; control vars back on stack
 0386 23        	inx	h
 0387 23        	inx	h
 0388 23        	inx	h
 0389 23        	inx	h
 038A C26803    	jnz	dd1
 038D E1        	pop	h
 038E 3E30      	mvi	a,'0'
 0390 83        	add	e
 0391 C38F01    	jmp	chrout
                
                mlt10:
 0394 3B9ACA00  	db	3Bh,9Ah,0CAh,00h	;  1,000,000,000
 0398 05F5E100  	db	05h,0F5h,0E1h,00h	;    100,000,000
 039C 00989680  	db	00h,98h,96h,80h		;     10,000,000
 03A0 000F4240  	db	00h,0Fh,42h,40h		;      1,000,000
 03A4 000186A0  	db	00h,01h,86h,0A0h	;        100,000
 03A8 00002710  	db	00h,00h,27h,10h		;         10,000
 03AC 000003E8  	db	00h,00h,03h,0E8h	;          1,000
 03B0 00000064  	db	00h,00h,00h,64h		;            100
 03B4 0000000A  	db	00h,00h,00h,0ah		;             10
                
                ; BC:DE += (mlt10[HL])
 03B8 F5        add32:	push	psw
 03B9 23        	inx	h
 03BA 23        	inx	h
 03BB 23        	inx	h
 03BC 7B        	mov	a,e
 03BD 86        	add	m
 03BE 5F        	mov	e,a
 03BF 2B        	dcx	h
 03C0 7A        	mov	a,d
 03C1 8E        	adc	m
 03C2 57        	mov	d,a
 03C3 2B        	dcx	h
 03C4 79        	mov	a,c
 03C5 8E        	adc	m
 03C6 4F        	mov	c,a
 03C7 2B        	dcx	h
 03C8 78        	mov	a,b
 03C9 8E        	adc	m
 03CA 47        	mov	b,a
 03CB F1        	pop	psw
 03CC C9        	ret	; CY ignored
                
                ; BC:DE += (mlt10[HL])
 03CD F5        sub32:	push	psw
 03CE 23        	inx	h
 03CF 23        	inx	h
 03D0 23        	inx	h
 03D1 7B        	mov	a,e
 03D2 96        	sub	m
 03D3 5F        	mov	e,a
 03D4 2B        	dcx	h
 03D5 7A        	mov	a,d
 03D6 9E        	sbb	m
 03D7 57        	mov	d,a
 03D8 2B        	dcx	h
 03D9 79        	mov	a,c
 03DA 9E        	sbb	m
 03DB 4F        	mov	c,a
 03DC 2B        	dcx	h
 03DD 78        	mov	a,b
 03DE 9E        	sbb	m
 03DF 47        	mov	b,a
                	; CY = borrow... must preserve
 03E0 DAE603    	jc	sb0
 03E3 F1        	pop	psw
 03E4 B7        	ora	a	; NC
 03E5 C9        	ret
 03E6 F1        sb0:	pop	psw
 03E7 37        	stc
 03E8 C9        	ret
                
                ; print number in HL, 0-9999
                dec16:
 03E9 11E803    	lxi	d,1000
 03EC CD0204    	call	div16
 03EF 116400    	lxi	d,100
 03F2 CD0204    	call	div16
 03F5 110A00    	lxi	d,10
 03F8 CD0204    	call	div16
 03FB 7D        	mov	a,l
 03FC C630      	adi	'0'
 03FE CD8F01    	call	chrout
 0401 C9        	ret
                
 0402 0600      div16:	mvi	b,0
 0404 B7        dv0:	ora	a
 0405 CD3204    	call	dsbc
 0408 04        	inr	b
 0409 D20404    	jnc	dv0
 040C 19        	dad	d
 040D 05        	dcr	b
 040E 3E30      	mvi	a,'0'
 0410 80        	add	b
 0411 CD8F01    	call	chrout
 0414 C9        	ret
                
                ; A=number to print, 0-99
                ; destroys B, C, D, E (and A)
                decout:
 0415 160A      	mvi	d,10
 0417 CD2004    	call	divide
 041A C630      	adi	'0'
 041C CD8F01    	call	chrout
 041F C9        	ret
                
 0420 1E00      divide:	mvi	e,0
 0422 92        div0:	sub	d
 0423 1C        	inr	e
 0424 D22204    	jnc	div0
 0427 82        	add	d
 0428 1D        	dcr	e
 0429 F5        	push	psw	; remainder
 042A 3E30      	mvi	a,'0'
 042C 83        	add	e
 042D CD8F01    	call	chrout
 0430 F1        	pop	psw	; remainder
 0431 C9        	ret
                
 0432 F5        dsbc:	push	psw
 0433 7D        	mov	a,l
 0434 9B        	sbb	e
 0435 6F        	mov	l,a
 0436 7C        	mov	a,h
 0437 9A        	sbb	d
 0438 67        	mov	h,a
 0439 DA3F04    	jc	dsbc0
 043C F1        	pop	psw
 043D B7        	ora	a
 043E C9        	ret
 043F F1        dsbc0:	pop	psw
 0440 37        	stc
 0441 C9        	ret
                
                ; Dump 16 bytes at HL
                dmpline:
 0442 D5        	push	d
 0443 E5        	push	h
                	; blank space provided by dmphex
 0444 E1        	pop	h
 0445 E5        	push	h
 0446 CD5704    	call	dmphex
 0449 215003    	lxi	h,spcs
 044C CD4400    	call	msgout
 044F E1        	pop	h
 0450 E5        	push	h
 0451 CD6804    	call	dmpchr
 0454 E1        	pop	h
 0455 D1        	pop	d
 0456 C9        	ret
                
                dmphex:
 0457 0610      	mvi	b,16
 0459 3E20      dh0:	mvi	a,' '
 045B CD8F01    	call	chrout
 045E 7E        	mov	a,m
 045F CD6A01    	call	hexout
 0462 23        	inx	h
 0463 05C25904  	dcr b ! jnz	dh0
 0467 C9        	ret
                
                dmpchr:
 0468 0610      	mvi	b,16
 046A 7E        dc0:	mov	a,m
 046B FE20      	cpi	' '
 046D DA7504    	jc	dc1
 0470 FE7F      	cpi	'~'+1
 0472 DA7704    	jc	dc2
 0475 3E2E      dc1:	mvi	a,'.'
 0477 CD8F01    dc2:	call	chrout
 047A 23        	inx	h
 047B 05C26A04  	dcr b ! jnz	dc0
 047F C9        	ret
                
 0480 F5        inir:	push	psw
 0481 DB40      inir0:	in	spi?rd
 0483 77        	mov	m,a
 0484 23        	inx	h
 0485 05        	dcr	b
 0486 C28104    	jnz	inir0
 0489 F1        	pop	psw
 048A C9        	ret
                
 048B F5        outir:	push	psw
 048C 7E        outir1:	mov	a,m
 048D D340      	out	spi?wr
 048F 23        	inx	h
 0490 05        	dcr	b
 0491 C28C04    	jnz	outir1
 0494 F1        	pop	psw
 0495 C9        	ret
                
 0496           cid:	ds	16
 04A6           csd:	ds	16
                
 04B6           	ds	128
 0536           stack:	ds	0
                
 0536           	end
