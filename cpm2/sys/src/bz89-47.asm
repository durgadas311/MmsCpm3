;12/27/82  12:35  klf	Version 2.241
********** CP/M LINKABLE BOOT ROUTINE **********
********** Z89-47 EXTENDED BOOT     **********
	DW	MODLEN,(-1)

BASE	EQU	0000H	;ORG FOR RELOC
	MACLIB Z80
	$-MACRO

SPT	EQU	8	;8 (1024 BYTE) SECTORS ON 8"DD
***** PHYSICAL DRIVES ARE ASSIGNED AS FOLLOWS *****
*****					      *****
*****  5 = FIRST 8" DRIVE                    *****
*****  6 = SECOND 8" DRIVE                   *****
*****  7 = THIRD 8" DRIVE                    *****
*****  8 = FOURTH 8" DRIVE                   *****
*****					      *****
***************************************************

***************************************************
**  PORTS AND CONSTANTS
***************************************************
?STAT	EQU	78H
?DATA	EQU	79H

?PORT	EQU	0F2H

?AUX	EQU	0D0H
?PRINTER	EQU	0E0H
?MODEM	EQU	0D8H

?LINE$CTL	EQU	00000011B	;NO PARITY, 1 STOP BIT, 8 DATA BITS
?MOD$CTL	EQU	00001111B	;SET ALL CONTROL LINES TO 'READY'

?S19200 EQU	6	; 19,200 BAUD
?S9600	EQU	12	;  9,600 BAUD
?S4800	EQU	24	;  4,800 BAUD
?S2400	EQU	48	;  2,400 BAUD
?S1200	EQU	96	;  1,200 BAUD
?S600	EQU	192	;    600 BAUD
?S300	EQU	384	;    300 BAUD
?S150	EQU	768	;    150 BAUD
?S110	EQU	1047	;    110 BAUD
***************************************************

***************************************************
** LINKS TO REST OF SYSTEM
***************************************************
@BIOS	EQU	BASE+1600H
@BDOS	EQU	@BIOS-0E00H
***************************************************

***************************************************
** PAGE ZERO ASSIGNMENTS
***************************************************
	ORG	0
?CPM		DS	3
?DEV$STAT	DS	1
?LOGIN$DSK	DS	1
?BDOS		DS	3
?RST1		DS	3
?CLOCK		DS	2
?INT$BYTE	DS	1
?CTL$BYTE	DS	1
		DS	77
?FCB		DS	36
?DMA		DS	128
?TPA		DS	0
***************************************************

***************************************************
** START OF RELOCATABLE DISK BOOT MODULE
***************************************************
	ORG	2280H
BOOT:
	CALL	AROUND		; PUT SECTRS ON STACK
SECTRS	DB	0		; NUMBER OF SECTORS TO BOOT, FROM MOVCPM.COM
			;PATCHED DURING EXECUTION OF MOVCPM
DRIVE	DB	5		; ALSO PATCHED BY ASSIGN PROGRAM
AROUND:
	POP	D		; POINT TO SECTRS
	POP	H		; ADDRESS OF ERROR ROUTINE
	LXI	SP,?STACK
	PUSH	H

***************************************************
*** START OF UNIQUE ROUTINE FOR BOOTING
***************************************************

	IN	?PORT		; GET PORT ADDRESS INFO
	ANI	03H		; ONLY 2 BITS RELEVANT
	DCR	A		; WAS VALUE 1?
	JRZ	GOTDAT		; IF SO, PORTS ARE 7C AND 7D
	MVI	A,78H		; IF NOT, PORTS ARE 78. .
	STA	STAT+1
	INR	A		; AND 79. .
	STA	DATA+1		; WHICH ARE STUFFED INTO (MVI) OP CODES
GOTDAT:
	LXI	H,@BDOS-256	; BIAS FOR BOOT SECTORS THAT
	LDAX	D		; WILL BE RE-LOADED TO MAKE EFFICIENT BOOTING
	INR	A		; ADD IN BOOT-SECTORS
	INR	A		; BECAUSE THEY WILL ALSO BE LOADED
	STAX	D		; STORE UPDATED NUMBER OF SECTORS
	ADI	00000111B	;ROUND UP
	ANI	11111000B	;INTEGER DIVISION
	RRC
	RRC
	RRC			; BY 8
	EXAF			; SAVE RESULT
	INX	D		; POINT TO DRIVE
	LDAX	D		; GET IT
	SUI	5
	CPI	4		; ONLY 4 DRIVES IN THIS GROUPE
	RNC
	RRC
	RRC
	RRC
	ORI	1		; STARTING SECTOR
	STAX	D		; SAVE AT DRIVE
	MVI	A,3		; LOAD SECTOR COUNT
	CALL	COMMAND
	XRA	A		; MSB
	CALL	PUT
	EXAF			; LSB
	CALL	PUT
	MVI	A,7	;READ THRU BUFFER
	CALL	COMMAND
	XRA	A
	CALL	PUT	;TRACK 0
	LDAX	D		; GET CONTENTS OF DRIVE
	CALL	PUT
	DCX	D		; POINT TO SECTRS
	LDAX	D		; GET THAT
	MOV	E,A		; USED AS COUNTER
BT0	CALL	STAT
	ANI	10100001B	;DTR,DONE,ERR
	JRZ	BT0
	ANI	00100001B	;DONE,ERR
	JRNZ	BT1
	INR	C		; MAKES STAT PORT (LEFT IN C) INTO DATA PORT
	INI
	JR	BT0
BT1	CALL	STAT
	ANI	00000001B	;ERR
	RNZ
	DCR	E
	JRNZ	BT0
DONE:
***************************************************
** START OF SYSTEM INITIALIZATION
***************************************************
	DI
* INITIALIZE I/O, ETC
	XRA	A
	OUT	?AUX+4
	OUT	?PRINTER+4
	OUT	?MODEM+4
	MVI	A,?LINE$CTL
	ORI	10000000B	;ENABLE DIVISOR LATCH
	OUT	?AUX+3
	OUT	?PRINTER+3
	OUT	?MODEM+3
* BAUD RATE SETUP:
	LXI	H,?S9600	;AUX SERIAL @ 9600 BAUD
	MOV	A,L
	OUT	?AUX
	MOV	A,H
	OUT	?AUX+1
	LXI	H,?S9600	;PRINTER @ 9600 BAUD
	MOV	A,L
	OUT	?PRINTER
	MOV	A,H
	OUT	?PRINTER+1
	LXI	H,?S300 ;MODEM (PAPER TAPE) @ 300 BAUD
	MOV	A,L
	OUT	?MODEM
	MOV	A,H
	OUT	?MODEM+1
* NOW GET PORTS READY FOR I/O
	MVI	A,?LINE$CTL	;NOW DE-SELECT DIVISOR LATCH
	OUT	?AUX+3
	OUT	?PRINTER+3
	OUT	?MODEM+3
	MVI	A,?MOD$CTL	;SIGNAL 'READY'
	OUT	?AUX+4
	OUT	?PRINTER+4
	OUT	?MODEM+4
	IN	?AUX+5	;RESET ANY STRAY ACTIVITY
	IN	?PRINTER+5
	IN	?MODEM+5
	IN	?AUX
	IN	?PRINTER
	IN	?MODEM
* END OF I/O INITIALIZATION
	LXI	H,?CODE ;SEQUENCE TO MOVE MEMORY-MAP
	MVI	B,?CODE$LEN	;NUMBER OF BYTES IN SEQUENCE
	MVI	C,?PORT ;I/O PORT TO SEND SEQUENCE
	OUTIR
	JMP	@BIOS
?CODE	DB	0000$01$00B
	DB	0000$11$00B
	DB	0000$01$00B
	DB	0000$10$00B
	DB	0000$11$00B
	DB	0000$10$00B
	DB	0010$00$10B	;FOR "-FA" MACHINES
?CODE$LEN	EQU	$-?CODE

STAT:	MVI	C,7CH		; DEFAULT VALUE, MAY BE CHANGED ON ENTRY
	JR	GETIO

DATA:	MVI	C,7DH		; DITTO
GETIO:	INP	A		; READ WHICHEVER
	RET

COMMAND:
	PUSH	PSW
CM0	CALL	STAT
	ANI	00100000B	;DONE
	JRNZ	CM1
	JR	CM0		; TIMEOUT FROM PROM IF NO RESPONSE
ERR	POP	PSW
	POP	H		; CLEAR CALL TO COMMAND OR PUT
	RET			; RETURN TO ERROR ROUTINE
CM1	POP	PSW
	INR	C		; MAKE (C) = DATA PORT
	OUTP	A		; SEND COMMAND
CM2	CALL	STAT
	ANI	00100000B	;DONE
	JRNZ	CM2
	XRA	A
	RET

PUT	PUSH	PSW
PUT1	CALL	STAT
	ANI	10100000B
	JRZ	PUT1
	ANI	00100000B
	JRNZ	ERR
	POP	PSW
	INR	C		; MAKE (C) = DATA PORT
	OUTP	A		; SEND DATA
	ORA	A
	RET

	REPT	(256-($-BOOT)-1) AND 0FFH	; LIMIT REPETITION
	DB	0
	ENDM

ID	DB	3	;BOOT ROUTINE IDENTIFICATION
MODLEN	EQU	$-BOOT	;MUST BE 256 BYTES
?STACK: EQU	$+128

 DB 00000000B,00000000B,00000000B,00000100B,00000000B,00000000B,00000000B,00000000B
 DB 00000000B,00000000B,00000000B,00000000B,00000000B,00000000B,00000000B,00000000B
 DB 00000000B,00000000B,00000000B,00000000B,00000000B,00000000B,00000000B,00000000B
 DB 01000000B,00000000B,00000000B,00000000B,00000000B,00000000B,00000000B,00000000B
	END
