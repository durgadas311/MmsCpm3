 6130 =         vers equ '0a' ; Nov 14, 2021  13:49  drm "MXIOS.ASM"
                ;****************************************************************
                ; MP/M main XIOS module for Z180 on the H8/H89			*
                ; Derived from the MMS 77500 server XIOS			*
                ; Copyright (c) 1983 Magnolia Microsystems			*
                ;****************************************************************
                ; All memory segments are ORGed at 0000.
                ; Uses CP/M Plus format DPBs.
                
                	maclib	z180
                	maclib	cfgsys
                
                	public	@adrv,@pdrv,@rdrv,@side,@trk,@sect
                	public	@dma,@dbnk,@dirbf
                	public	@dstat,@cmode,@dph,@rcnfg,@eops
                	public	@cbnk,@scrcb,@vect,@secnd
                
                	public	xdos,polltb,sysdat
                
                	extrn	@lptbl
                	extrn	?memsl,?bnksl,?bnkck,?xmove,?move	; MMU module
                	extrn	@memstr,@mmerr,@nbnk
                	extrn	?time,?itime,@rtcstr			; RTC module
                
                 if z180
 FFFF =         z180tick	equ	true
 0000 =         h89tick		equ	false
                 else
                  if h89
                z180tick	equ	false
                h89tick		equ	true
                tick$tick	equ	10	; number of 2mS ticks per MP/M tick
                  else
                ; TODO: what to use for tick?
                z180tick	equ	false
                h89tick		equ	false
                  endif
                 endif
                
 0200 =         secsize		equ	512	; largest sector size supported/used
                
 000D =         cr	equ 13
 000A =         lf	equ 10
 0007 =         bell	equ 7
                
 0000 =         cpm	equ	0
 0005 =         bdos	equ	5
                
 0083 =         poll	equ	131
 0085 =         flagset equ	133
                
                ;relative position of elements in buffer headers:
 0000 =         link	equ	0	;link to next headr, or 0
 0002 =         hstpda	equ	2	;Process Descriptor Adr of owner
 0004 =         hstmod	equ	4	;mode pointer (partition address)
 0006 =         pndwrt	equ	6	;pending write flag
 0007 =         hstdsk	equ	7	;host disk
 0008 =         hsttrk	equ	8	;host track
 000A =         hstsec	equ	10	;host sector
 000C =         hstbuf	equ	12	;host buffer address
 000E =         hstbnk	equ	14	;host bank
 000F =         hstmdl	equ	15	;host module entry
 0011 =         hstlen	equ	17	;length of header
                
                 if z180
                ; Z180 registers
 00F4 =         itc	equ	iobase+34h
 00F6 =         rcr	equ	iobase+36h
 00F8 =         mmu$cbr	equ	iobase+38h
 00F9 =         mmu$bbr	equ	iobase+39h
 00FA =         mmu$cbar equ	iobase+3ah
 00E0 =         sar0l	equ	iobase+20h
 00E1 =         sar0h	equ	iobase+21h
 00E2 =         sar0b	equ	iobase+22h
 00E3 =         dar0l	equ	iobase+23h
 00E4 =         dar0h	equ	iobase+24h
 00E5 =         dar0b	equ	iobase+25h
 00E6 =         bcr0l	equ	iobase+26h
 00E7 =         bcr0h	equ	iobase+27h
 00F0 =         dstat	equ	iobase+30h
 00F1 =         dmode	equ	iobase+31h
 00F2 =         dcntl	equ	iobase+32h
 00F3 =         il	equ	iobase+33h
 00CC =         tmdr0l	equ	iobase+0ch
 00CD =         tmdr0h	equ	iobase+0dh
 00CE =         rldr0l	equ	iobase+0eh
 00CF =         rldr0h	equ	iobase+0fh
 00D0 =         tcr	equ	iobase+10h
                 endif
                
                ;-------- Start of Code-producing source -----------
                
                	; Because LINK puts dseg after cseg, and 'combas' is
                	; at the beginning of dseg, GENSYS will enforce that
                	; all of dseg falls in common memory.
                	cseg		; Banked memory
 0000 =         BIOS$0	equ	$
 0000 C30000    	jmp combas	; initial entry on cold start, common base
 0003 C3C000    	jmp wboot	; reentry on program exit, warm start
                
 0006 C30B02    	jmp const	; return console input status
 0009 C31902    	jmp conin	; return console input character
 000C C3F101    	jmp conout	; send console output character
 000F C3EC01    	jmp list	; send list output character
 0012 C3DF01    	jmp auxout	; send auxilliary output character	-NULL
 0015 C3DC01    	jmp auxin	; return auxilliary input character	-NULL
                
 0018 C31F03    	jmp home	; set disks to logical home
 001B C34D02    	jmp seldsk	; select disk drive, return disk parameter info
 001E C32203    	jmp settrk	; set disk track
 0021 C32703    	jmp setsec	; set disk sector
 0024 C32C03    	jmp setdma	; set disk I/O memory address
 0027 C34403    	jmp read	; read physical block(s)
 002A C36803    	jmp write	; write physical block(s)
                
 002D C3E301    	jmp listst	; return list device status
 0030 C33803    	jmp sectrn	; translate logical to physical sector
                
 0033 C30000    	jmp	?memsl
 0036 C3E100    	jmp	poll$dev
 0039 C31601    	jmp	strtclk
 003C C31A01    	jmp	stopclk
 003F C30F01    	jmp	exitreg
 0042 C30C01    	jmp	maxcon
 0045 C3DE00    	jmp	boot	;   sysinit
                ;	jmp	idle	;
 0048 000000    	nop ! nop ! nop	; no idle routine
                
 004B FC00      	dw	polltb	;for RSP's (such as NETWRKIF)
                
 004D           	ds	13	;this puts setup/mode info where they expect it
 005A C3BC01    	jmp	search
 005D C34602    	jmp	setspd	; change CPU speed - platform dependent
 0060           	ds	3
                
                ; These are only static when accessed via XIOSJMP.TBL
 0063           @dstat: ds	1
 0064           speed:	ds	1	; formerly Port F2 image "@intby"
                
 0065 0000      	dw	@lptbl	;logical/physical drive table
 0067 4902      	dw	thread	;module thread
 0069 0000      	dw	0	;?serdp	;test mode validity, HL=memory address of ?serdp
                
 006B           @adrv:	ds	1		; currently selected disk drive
 006C           @pdrv:	ds	1		; physical drive number (MMS)
 006D           @rdrv:	ds	1		; module relative disk drive number
 006E           curmdl: ds	2		; currently selected Disk I/O module address
 0070           @cmode: ds	2
 0072           @dph:	ds	2
                
 0074 0080      icovec: dw	1000000000000000b
 0076 0080      icivec: dw	1000000000000000b
 0078 0000      iaovec: dw	0000000000000000b
 007A 0000      iaivec: dw	0000000000000000b
 007C 0000      ilovec: dw	0000000000000000b
                
 007E 00FFFFFF  defsrc: db	0,0ffh,0ffh,0ffh
 0082 00        tmpdrv: db	0
 0083 00        srctyp: db	000$00$000b	;only bits 3,4 are used (others ignored)
                
                	; for MODULES.COM... well, not quite since not in common memory...
                	; This will be copied to BIOS JMP PAGE, in common memory,
                	; but these strings must also reside in common memory.
 0084 0000      	dw	@memstr
 0086 0000      	dw	@rtcstr
                
 0088 0000      @dma:	dw	0
 008A 0000      wbtrap: dw	0
                
                	dseg
                ;---------- COMMON MEMORY -----------
                ; WARNING: must be on page boundary ('vect' alignment).
                ; Use LINK 'B' option.
 0000 C3C000    combas: jmp	colds
 0003 C30000    swtusr: jmp	$-$
 0006 C30000    swtsys: jmp	$-$
 0009 C30000    pdisp:	jmp	$-$
 000C C30000    xdos:	jmp	$-$
 000F 0000      sysdat: dw	$-$
                
                ; These locations are fixed, after combas block.
 0011 0000      @vect:	dw	$-$
 0013 0000      dbuga:	dw	$-$
 0015 0000      dbugv:	dw	$-$
 0017 0000      biosjmp:dw	$-$
 0019           @dbnk:	ds	1	; bank for user I/O (user DMA addr)
 001A           @eops:	ds	1
 001B           @intby: ds	1	; Port F2 image
                
 001C           @dirbf: ds	128
                
                 if z180
                	; Z180 internal devices interrupt vector table.
                	; If external devices also generate interrupts,
                	; this must be expanded/realigned to compensate.
                	; need 32-byte aligned address:
                	rept	(32 - (($-combas) AND 1fh)) AND 1fh
                	db	0
                	endm
 009C+00        	DB	0
 009D+00        	DB	0
 009E+00        	DB	0
 009F+00        	DB	0
 00A0 DE00      vect:	dw	nulint	; 0 - /INT1
 00A2 DE00      	dw	nulint	; 1 - /INT2
 00A4 3801      	dw	tick	; 2 - PRT0 (TMDR0 -> 0)
 00A6 DE00      	dw	nulint	; 3 - PRT1 (TMDR1 -> 0)
 00A8 DE00      	dw	nulint	; 4 - DMA0
 00AA DE00      	dw	nulint	; 5 - DMA1
 00AC DE00      	dw	nulint	; 6 - CSIO
 00AE DE00      	dw	nulint	; 7 - ASCI0
 00B0 DE00      	dw	nulint	; 8 - ASCI1
 00B2 DE00      	dw	nulint	; 9 - unused by Z180
 00B4 DE00      	dw	nulint	; 10 - unused by Z180
 00B6 DE00      	dw	nulint	; 11 - unused by Z180
 00B8 DE00      	dw	nulint	; 12 - unused by Z180
 00BA DE00      	dw	nulint	; 13 - unused by Z180
 00BC DE00      	dw	nulint	; 14 - unused by Z180
 00BE DE00      	dw	nulint	; 15 - unused by Z180
                 endif
                
                wboot:
                colds:
                 if z180
                	; possible TRAP
                	in0	a,itc
 00C0+ED38F4    	DB	0EDH, A*8+00H, ITC
                	tsti	10000000b	; TRAP bit
 00C3+ED6480    	DB	0EDH, 64H, 10000000B
                	jrnz	trap
 00C6+2005      	DB	20H,TRAP-$-1
                 endif
 00C8 0E00      	mvi	c,0
 00CA C30C00    	jmp	xdos
                
                 if z180
                ; For now, any TRAP is fatal
 00CD 21D300    trap:	lxi	h,trpmsg
 00D0 C31902    	jmp	errx
                
 00D3 0D0A2A5452trpmsg:	db	cr,lf,'*TRAP*',cr,lf,'$'
                 endif
                
 00DE FB        nulint:	ei
                	reti
 00DF+ED4D      	DB	0EDH,4DH
                
                ; C=device to poll, 0-N char I/O devices (input status)
                poll$dev:
 00E1 79        	mov	a,c
 00E2 FE08      	cpi	8
                	jrnc	pd0	; not char I/O...
 00E4+300A      	DB	30H,PD0-$-1
 00E6 51        	mov	d,c
 00E7 D604      	sui	4
 00E9 DA0B02    	jc	const
 00EC 57        	mov	d,a
 00ED C3E801    	jmp	conost
 00F0 0600      pd0:	mvi	b,0
 00F2 21FC00    	lxi	h,polltb
 00F5 09        	dad	b
 00F6 09        	dad	b
 00F7 5E        	mov	e,m
 00F8 23        	inx	h
 00F9 56        	mov	d,m
                	; TODO: check DE=NULL?
 00FA EB        	xchg
 00FB E9        	pchl
                
                ; Devices 8..15, starting at +0...
 00FC 0000000000polltb:	dw	$-$,$-$,$-$,$-$,$-$,$-$,$-$,$-$ ; 8..15 unassigned (yet)
                
 010C 3E00      maxcon: mvi	a,0	;filled in at init from SYSDAT and config
 010E C9        	ret
                
                exitreg:
 010F 3A2001    	lda	preempt
 0112 B7        	ora	a
 0113 C0        	rnz
 0114 FB        	ei
 0115 C9        	ret
                
 0116 3EFF      strtclk: mvi	a,true
                	 jr	sc00
 0118+1802      	DB	18H,SC00-$-1
 011A 3E00      stopclk: mvi	a,false
 011C 322101    sc00:	 sta	clock
 011F C9        	 ret
                
 0120 00        preempt: db	0
 0121 00        clock:	 db	0
                
 0122 0000      @secnd: dw	$-$	;used to do timeouts
                
 0124 00        tps:	db	0	; from system data page on boot
 0125 00        pcnt:	db	0	; pre-scale for interrupts to MP/M ticks
 0126 00        tcnt:	db	0	; must immediately follow pcnt...
                
                second:
 0127 2A2201    	lhld	@secnd
 012A 7C        	mov	a,h
 012B B5        	ora	l
 012C C43702    	cnz	icall
 012F 1E02      	mvi	e,2
 0131 0E85      	mvi	c,flagset
 0133 CD0C00    	call	xdos
                	jr	tk1
 0136+182C      	DB	18H,TK1-$-1
                
                tick:	sspd	istk
 0138+ED73      	DB	0EDH,73H
 013A+BA01      	DW	ISTK
 013C 31BA01    	lxi	sp,intstk
 013F F5        	push	psw
 0140 E5        	push	h
 0141 D5        	push	d
 0142 C5        	push	b
                 if z180tick
                	in0	a,tmdr0l	; reset INT
 0143+ED38CC    	DB	0EDH, A*8+00H, TMDR0L
                 endif
                 if h89tick
                	lda	@intby
                	out	0f2h	; reset INT
                	lxi	h,pcnt
                	dcr	m
                	jrnz	iexit
                	mvi	m,tick$tick
                 endif
 0146 3EFF      	mvi	a,true
 0148 322001    	sta	preempt
 014B 3A2101    	lda	clock
 014E B7        	ora	a
                	jrz	tk0
 014F+2807      	DB	28H,TK0-$-1
 0151 1E01      	mvi	e,1
 0153 0E85      	mvi	c,flagset
 0155 CD0C00    	call	xdos
                tk0:
 0158 212601    	lxi	h,tcnt
 015B 35        	dcr	m
                	jrnz	tk1
 015C+2006      	DB	20H,TK1-$-1
 015E 3A2401    	lda	tps
 0161 77        	mov	m,a
                	jr	second
 0162+18C3      	DB	18H,SECOND-$-1
 0164 3E00      tk1:	mvi	a,false
 0166 322001    	sta	preempt
                 if z180tick
 0169 116F01    	lxi	d,nexti
 016C D5        	push	d
                	reti	; required by Z180?
 016D+ED4D      	DB	0EDH,4DH
                nexti:
                 endif
 016F C1        	pop	b
 0170 D1        	pop	d
 0171 E1        	pop	h
 0172 F1        	pop	psw
                	lspd	istk
 0173+ED7B      	DB	0EDH,07BH
 0175+BA01      	DW	ISTK
 0177 C30900    	jmp	pdisp
                
                 if h89tick
                iexit:
                	pop	b
                	pop	d
                	pop	h
                	pop	psw
                	lspd	istk
                	ei
                	ret
                 endif
                
 017A           	ds	64	;32 levels of stack
 01BA           intstk: ds	0
 01BA 0000      istk:	dw	0
                
                ; SEARCH for a module by device #.
                ;   entry:	C = device # (0-249)
                ;   exit:	[CY] = not found
                ;	   else HL=module address ("init" entry)
                ;		A=device number (relative to module's #0)
                ;
 01BC 114902    search: lxi	d,thread	;C=device number
 01BF EB        snext:	xchg
 01C0 5E        	mov	e,m
 01C1 23        	inx	h
 01C2 56        	mov	d,m
 01C3 23        	inx	h
 01C4 7A        	mov	a,d
 01C5 B3        	ora	e
 01C6 D601      	sui	1	;produce [CY] if DE=0000
 01C8 D8        	rc		;return if device not found, DE=0000
 01C9 79        	mov	a,c
 01CA 96        	sub	m
                	jrc	snext
 01CB+38F2      	DB	38H,SNEXT-$-1
 01CD 23        	inx	h
 01CE BE        	cmp	m
                	jrnc	snext
 01CF+30EE      	DB	30H,SNEXT-$-1
 01D1 23        	inx	h	;point to "init" vector
 01D2 B7        	ora	a	;set [NC] condition
 01D3 C9        	ret
                
 01D4 0000      ciomdl:	dw	0	;character device driver, filled at cold-start.
 01D6 00        cionum:	db	0	;max num cio devices (numcon+numlst)
                
                cinit:	;C=device number (0-11)
 01D7 2AD401    	lhld	ciomdl	; init routine
 01DA 41        	mov	b,c
 01DB E9        	pchl		;jump to modules "init" with B=device #
                
 01DC 3E1A      auxin:	mvi	a,1ah	; EOF
 01DE B7        	ora	a
 01DF C9        auxout:	ret
                
 01E0 F1        nodev:	pop	psw
 01E1 AF        nost:	xra	a	; never ready
 01E2 C9        	ret
                
                ; D=device number
                listst:
 01E3 3A0D01    	lda	maxcon+1
 01E6 82        	add	d
 01E7 57        	mov	d,a	; LST: #0 = con#N+1
                conost:
 01E8 3E09      	mvi	a,9
                	jr	devio
 01EA+1821      	DB	18H,DEVIO-$-1
                
                ; D=device number, C=char
                list:
 01EC 3A0D01    	lda	maxcon+1
 01EF 82        	add	d
 01F0 57        	mov	d,a	; LST: #0 = con#N+1
                conout:
 01F1 C5        	push	b
 01F2 D5        	push	d
 01F3 CDE801    	call	conost	; is ready now?
 01F6 B7        	ora	a
 01F7 C20502    	jnz	co0
 01FA D1        	pop	d
 01FB D5        	push	d
 01FC 7A        	mov	a,d
 01FD C604      	adi	4
 01FF 5F        	mov	e,a
 0200 0E83      	mvi	c,poll
 0202 CD0C00    	call	xdos	; sleep until ready
 0205 D1        co0:	pop	d
 0206 C1        	pop	b
 0207 3E0C      coo:	mvi	a,12
                	jr	devio
 0209+1802      	DB	18H,DEVIO-$-1
                
                ; D=device number
 020B 3E03      const:	mvi	a,3
                	;jr	devio
                
                ; A=JMP tbl off, D=devnum [C=char]
 020D F5        devio:	push	psw
 020E 3AD601    	lda	cionum	;see if device exists
 0211 3D        	dcr	a
 0212 BA        	cmp	d
                	jrc	nodev
 0213+38CB      	DB	38H,NODEV-$-1
 0215 F1        	pop	psw	; driver JMP offset
 0216 42        	mov	b,d	;device number in B for modules
                	jr	indjmp0
 0217+1815      	DB	18H,INDJMP0-$-1
                
                ; D=device number
 0219 D5        conin:	push	d
 021A CD0B02    	call	const	; is ready now?
 021D B7        	ora	a
 021E C22902    	jnz	ci0
 0221 D1        	pop	d
 0222 D5        	push	d
 0223 5A        	mov	e,d
 0224 0E83      	mvi	c,poll
 0226 CD0C00    	call	xdos	; sleep until ready
 0229 D1        ci0:	pop	d
 022A 3E06      	mvi	a,6
                	jr	devio
 022C+18DF      	DB	18H,DEVIO-$-1
                
                ; char I/O driver function calls
                ; A=offset (0,3,6,9,...), B=device number (0..N)
                indjmp0:
 022E 2AD401    	lhld	ciomdl
 0231 85        	add	l	;a=0,3,6,9,12,...
 0232 6F        	mov	l,a
 0233 3E00      	mvi	a,0
 0235 8C        	adc	h
 0236 67        	mov	h,a
 0237 E9        icall:	pchl		;indirect call
                
                
 0238 00        @cbnk:	db	0	; bank for processor operations
 0239           bnkflg: ds	1	;flag for enough memory installed.
                
                getusrbnk:	;finds the bank number for calling process
 023A CD0300    	call	swtusr		; would like better way...
 023D 3A3802    	lda	@cbnk
 0240 321900    	sta	@dbnk
 0243 C30600    	jmp	swtsys
                
                 if h89
                ; CPU clock rate selected, ORG0+2mS handled by user
                cpuspd:	db	00h,10h,04h,14h
                 endif
                
                ; A=0,1,2,3[...] speed index, FF=get current speed
                ; Returns A: FF=error, FE=not supported, 0,1,2,3...=success
                ; Called from user bank, must be in common mem.
                setspd:
                 if h89
                	cpi	0ffh
                	jrz	ssx
                	sta	speed
                	mov	e,a
                	cpi	4
                	mvi	a,0ffh
                	rnc
                	lxi	h,cpuspd
                	mvi	d,0
                	dad	d
                	mov	d,m
                	di
                	lda	@intby
                	ani	11101011b
                	ora	d
                	sta	@intby
                	out	0f2h	; speed changes now
                  if z180tick
                	; there will be a small error until next tick
                	lxi	h,maxclk
                	mov	a,e
                	cpi	3
                	jrz	ss0
                	lxi	h,minclk
                	ora	a
                	jrz	ss0
                ss1:	dad	h
                	dcr	a
                	jrnz	ss1
                ss0:	; HL=timer value for 50Hz tick
                	out0	l,rldr0l	; update timer reload count
                	out0	h,rldr0h	;
                  endif
                ssx:	lda	speed	; always return current speed
                 else
 0246 3EFE      	mvi	a,0feh	; not supported
                 endif
 0248 C9        	ret
                
 0249 =         thread: equ	$	;must be last in dseg (common mem)
                
                	cseg	; rest is in banked memory...
                
 008C 0D0A07    signon: db	cr,lf,bell
                 if h89
                	db	'H8-'
                 endif
                 if rc2014
 008F 5243323031	db	'RC2014-'
                 endif
                ; TODO: other platforms...
                 if z180
 0096 5A313830  	db	'Z180'
                 else
                	db	'Z80'
                 endif
 009A 204D502F4D	db	' MP/M-II v3.00'
 00A8 3061      	dw	vers
 00AA 2020286329	db	'  (c) 1984 DRI and MMS',cr,lf,'$'
                
 00C3 0D0A074E6Fbnkerr:	db	cr,lf,bell,'Not enough memory banks$'
                
                ; Interrupts are disabled
                ; HL = BIOS JMP table
                ; DE = debug entry
                ; C = debug RST num
                boot:
                 if h89
                	; This is H89-specific...
                	mvi	a,defspd
                	sta	speed
                	lda	cpuspd+defspd
                	ori	00100000b	; ORG0 only, right now
                	sta	@intby
                	out	0f2h	; prevent undesirable intrs
                			; Console 8250 should already be off
                 endif
                 if z180
                	; speed things up...
 00DE 3E50      	mvi	a,z$dcntl
                	out0	a,dcntl	; set WAIT states
 00E0+ED39F2    	DB	0EDH, A*8+01H, DCNTL
 00E3 3E00      	mvi	a,z$rcr
                	out0	a,rcr	; set RESFRESH cycles
 00E5+ED39F6    	DB	0EDH, A*8+01H, RCR
                 endif
                	;
                	sded	dbuga
 00E8+ED53      	DB	0EDH,53H
 00EA+1300      	DW	DBUGA
 00EC 221700    	shld	biosjmp
 00EF 79        	mov	a,c
 00F0 87        	add	a
 00F1 87        	add	a
 00F2 87        	add	a
 00F3 6F        	mov	l,a
 00F4 2600      	mvi	h,0
 00F6 221500    	shld	dbugv
                 if z180tick
 00F9 21A000    	lxi	h,vect
 00FC 221100    	shld	@vect
 00FF 7C        	mov	a,h
                	stai
 0100+ED47      	DB	0EDH,47H
                	out0	l,il
 0102+ED29F3    	DB	0EDH, L*8+01H, IL
                 endif
                 if h89tick
                	mvi	a,JMP
                	sta	0008h
                	lxi	h,tick
                	shld	0008h+1
                	lda	@intby
                	ori	02h
                	sta	@intby
                	out	0f2h
                 endif
                
 0105 2A0F00    	lhld	sysdat
 0108 2E7A      	mvi	l,122	;ticks/sec
 010A 7E        	mov	a,m
 010B 322401    	sta	tps
 010E 322601    	sta	tcnt
 0111 2EFC      	mvi	l,252	;XDOS internal data page
 0113 5E        	mov	e,m
 0114 23        	inx	h
 0115 56        	mov	d,m
 0116 210500    	lxi	h,5
 0119 19        	dad	d	; skip past TOD
 011A 220006    	shld	rlr
 011D 219600    	lxi	h,0096h	; osmsegtbl
 0120 19        	dad	d
 0121 220206    	shld	msegtbl
                ; get common size from SYSDAT
 0124 2A0F00    	lhld	sysdat
 0127 2E7C      	mvi	l,124		;common memory base page
 0129 7E        	mov	a,m
                ; Verify that we have banked RAM... A=compag from MP/M
 012A CD0000    	call	?bnkck
 012D 323902    	sta	bnkflg
                 if z180tick
                ; initialize timer interrupts
 0130 210048    	lxi	h,tickrate	; phi/20/tickrate = ticks per sec
                	out0	l,tmdr0l
 0133+ED29CC    	DB	0EDH, L*8+01H, TMDR0L
                	out0	h,tmdr0h
 0136+ED21CD    	DB	0EDH, H*8+01H, TMDR0H
                	out0	l,rldr0l
 0139+ED29CE    	DB	0EDH, L*8+01H, RLDR0L
                	out0	h,rldr0h
 013C+ED21CF    	DB	0EDH, H*8+01H, RLDR0H
                	in0	a,tcr
 013F+ED38D0    	DB	0EDH, A*8+00H, TCR
 0142 F611      	ori	00010001b	; TIE0, TDE0
                	out0	a,tcr		; start the timer
 0144+ED39D0    	DB	0EDH, A*8+01H, TCR
                 endif
                ; Initialize all modules and build tables.
 0147 214902    	lxi	h,thread	;thread our way through the modules,
 014A 5E        iin0:	mov	e,m		;initializing as we go.
 014B 23        	inx	h
 014C 56        	mov	d,m	;next module, or "0000" if we're past the end.
 014D 23        	inx	h
 014E 7A        	mov	a,d
 014F B3        	ora	e
 0150 CA9501    	jz	init$done
 0153 7E        	mov	a,m	;device base number
 0154 23        	inx	h
 0155 23        	inx	h	;thread+4 = init entry (JMP)
 0156 D6C8      	sui	200	;if Char I/O module, build entry(s) in tables.
 0158 DA8D01    	jc	notchr
                	; should only be one...
 015B 22D401    	shld	ciomdl
 015E D5        	push	d	;save NEXT module address
 015F 2B        	dcx	h	;number of devices
 0160 E5        	push	h
 0161 2A0F00    	lhld	sysdat
 0164 23        	inx	h	;nmb$cns
 0165 56        	mov	d,m	;E=nmb$cns
 0166 2EC5      	mvi	l,197
 0168 5E        	mov	e,m	;D=nmb$lst
 0169 E1        	pop	h	;HL=ciomdl.ndev
 016A 7B        	mov	a,e
 016B 82        	add	d	;total ndev needed (never 0)
 016C 3D        	dcr	a
 016D 96        	sub	m	; (nmb$cns+nmb$lst-1) - ciomdl.ndev
                	jrc	iin50	; OK, we have enough
 016E+3811      	DB	38H,IIN50-$-1
 0170 3C        	inr	a	; num devs to drop
 0171 93        	sub	e	; drop printers first
                	jrz	iin3
 0172+2802      	DB	28H,IIN3-$-1
                	jrnc	iin1
 0174+3005      	DB	30H,IIN1-$-1
                iin3:	neg
 0176+ED44      	DB	0EDH,44H
 0178 5F        	mov	e,a	; num$lst remaining
                	jr	iin50
 0179+1806      	DB	18H,IIN50-$-1
 017B 1E00      iin1:	mvi	e,0	; no printers left, must reduce nmb$cns
 017D 92        	sub	d	; must be neg
                	neg
 017E+ED44      	DB	0EDH,44H
 0180 57        	mov	d,a
 0181 7A        iin50:	mov	a,d	; adjusted nmb$cns
 0182 320D01    	sta	maxcon+1
 0185 83        	add	e	; adjusted nmb$lst
 0186 32D601    	sta	cionum	; initialize only what is needed
 0189 E1        	pop	h	; next module
 018A C34A01    	jmp	iin0
                
                notchr: 		;HL point to init entry
 018D D5        	push	d
 018E CD3702    	call	icall	;"call" (HL)
 0191 E1        	pop	h
 0192 C34A01    	jmp	iin0
                
                init$done:	;all Disk I/O modules are initialized.
                		; now initialize the chrio devices
 0195 3AD601    	lda	cionum
 0198 4F        	mov	c,a	; last dev + 1
 0199 0D        iin5:	dcr	c
 019A FAA401    	jm	iin2	; include dev 0
 019D C5        	push	b
 019E CDD701    	call	cinit
 01A1 C1        	pop	b
                	jr	iin5
 01A2+18F5      	DB	18H,IIN5-$-1
                iin2:
 01A4 218C00    	lxi	h,signon
 01A7 CD1E02    	call	msgout
 01AA 3A3902    	lda	bnkflg
 01AD B7        	ora	a	;is enough memory installed?
 01AE CA1602    	jz	ramerr
 01B1 CDC201    	call	segchk	; check memsegtbl (if banked RAM good)
 01B4 B7        	ora	a
 01B5 CA1102    	jz	segerr
 01B8 CDDA01    	call	set$jumps  ;setup system jumps and put in all banks
 01BB CD0000    	call	?itime	; get (starting) TOD from RTC
                
                 if z180tick
                	im2
 01BE+ED5E      	DB	0EDH,5EH
                 endif
 01C0 AF        	xra	a
 01C1 C9        	ret
                
                ; Verify that memsegtbl has no bank >= @nbnk
                segchk:
 01C2 2A0F00    	lhld	sysdat
 01C5 2E0F      	mvi	l,15	; max$mem$seg
 01C7 46        	mov	b,m
 01C8 3A0000    	lda	@nbnk	; num banks
 01CB 3D        	dcr	a	; largest bank num allowed
                sgck0:
 01CC 23        	inx	h
 01CD 23        	inx	h
 01CE 23        	inx	h
 01CF 23        	inx	h	; memsegtbl[x].bank
 01D0 BE        	cmp	m
                	jrc	sgck1
 01D1+3805      	DB	38H,SGCK1-$-1
                	djnz	sgck0
 01D3+10F7      	DB	10H,SGCK0-$-1
 01D5 F6FF      	ori	true
 01D7 C9        	ret
 01D8 AF        sgck1:	xra	a	; error - not enough banks
 01D9 C9        	ret
                
                ; Interrupts disabled, must not enable
                set$jumps:
                	liyd	dbugv
 01DA+FD2A      	DB	0FDH,2AH
 01DC+1500      	DW	DBUGV
 01DE 3EC3      	mvi	a,(JMP)
 01E0 320000    	sta	cpm
                	sty	a,+0      ; set up jumps in page zero
 01E3+FD7700    	DB	0FDH,70H+A,+0
 01E6 2A17002201	lhld	biosjmp ! shld cpm+1	; BIOS warm start entry
 01EC 2A1300    	lhld	dbuga
                	sty	l,+1
 01EF+FD7501    	DB	0FDH,70H+L,+1
                	sty	h,+2	; DEBUGGER entry point
 01F2+FD7402    	DB	0FDH,70H+H,+2
 01F5 3A0000    	lda	@nbnk
 01F8 47        	mov	b,a	;number of banks (also, -1 is dest bank)
 01F9 0E00      	mvi	c,0	;source bank
                sj0:
 01FB 05        	dcr	b
 01FC C8        	rz
 01FD C5        	push	b
                	; must setup DE,HL before ?xmove
 01FE 210000    	lxi	h,0	; page 0 in all banks
 0201 54        	mov	d,h
 0202 5D        	mov	e,l
 0203 CD0000    	call	?xmove
 0206 014000    	lxi	b,64
 0209 AF        	xra	a	; interrupts are disabled
 020A CD0000    	call	?move
 020D C1        	pop	b
                	jr	sj0		;
 020E+18EB      	DB	18H,SJ0-$-1
 0210 C9        	ret
                
 0211 21C300    segerr: lxi	h,bnkerr
                	jr	errx
 0214+1803      	DB	18H,ERRX-$-1
 0216 210000    ramerr: lxi	h,@mmerr
 0219 CD1E02    errx:	call	msgout
 021C F376      	di ! hlt
                
                msgout:
 021E 7E        	mov	a,m
 021F FE24      	cpi	'$'
 0221 C8        	rz
 0222 E5        	push	h
 0223 4E        	mov	c,m
 0224 1600      	mvi	d,0
 0226 CD0702    	call	coo
 0229 E1        	pop	h
 022A 23        	inx	h
                	jr	msgout
 022B+18F1      	DB	18H,MSGOUT-$-1
                
 022D 0000000000@dtbl:	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                
                seldsk:
 024D 79326B00  	mov a,c ! sta @adrv			; save drive select code
 0251 210000    	lxi	h,@lptbl
 0254 060009    	mvi b,0 ! dad b 	      ; create index from drive code
 0257 7E        	mov	a,m
 0258 FEFF      	cpi	255
 025A CADB02    	jz	selerr
 025D 326C00    	sta	@pdrv
 0260 4F        	mov	c,a
 0261 43        	mov	b,e	;save login flag thru "search" routine
 0262 CDBC01    	call	search
 0265 DADB02    	jc	selerr
 0268 326D00    	sta	@rdrv
 026B 226E00    	shld	curmdl
 026E C5        	push	b	;save login bit
 026F 110E00    	lxi	d,14
 0272 19        	dad	d	;point to dphtbl
 0273 5E        	mov	e,m	;DE=dphtbl
 0274 23        	inx	h
 0275 56        	mov	d,m
 0276 23        	inx	h
 0277 4E        	mov	c,m	;BC=modtbl
 0278 23        	inx	h
 0279 46        	mov	b,m
 027A 3A6D00    	lda	@rdrv
 027D 87        	add	a
 027E 87        	add	a
 027F 87        	add	a	;*8
 0280 6F        	mov	l,a
 0281 2600      	mvi	h,0
 0283 09        	dad	b	;select mode bytes
 0284 227000    	shld	@cmode	;set current mode pointer
 0287 C1        	pop	b	;get login bit back.
                	bit	0,b	;test for initial select.
 0288+CB40      	DB	0CBH,0*8+B+40H
                	jrnz	notlgi
 028A+2053      	DB	20H,NOTLGI-$-1
 028C EB        	xchg		;DE=modes
 028D 4F        	mov	c,a
 028E 0600      	mvi	b,0
 0290 09        	dad	b	;+*8
 0291 09        	dad	b	;+*16
 0292 227200    	shld	@dph
 0295 EB        	xchg
 0296 3A6B00    	lda	@adrv
 0299 4F        	mov	c,a
 029A 87        	add	a	;*2
 029B 87        	add	a	;*4
 029C 87        	add	a	;*8
 029D 87        	add	a	;*16
 029E 81        	add	c	;*17
 029F 4F        	mov	c,a	;B still = 0
 02A0 CD1603    	call	setup$dph
                	jrc	selerr
 02A3+3836      	DB	38H,SELERR-$-1
 02A5 AF        	xra	a
 02A6 32ED05    	sta	@rcnfg
 02A9 2A6E00    	lhld	curmdl
                	lxiy	@scrcb
 02AC+FD21      	DB	0FDH,21H
 02AE+2D07      	DW	@SCRCB
 02B0 3A6C00    	lda	@pdrv
                	sty	a,hstdsk
 02B3+FD7707    	DB	0FDH,70H+A,HSTDSK
 02B6 3E03      	mvi	a,3
 02B8 CDDF05    	call	calmod	;call module's "login" routine.
 02BB B7        	ora	a	;see if an error occured.
                	jrnz	selerr
 02BC+201D      	DB	20H,SELERR-$-1
 02BE 3AED05    	lda	@rcnfg
 02C1 B7        	ora	a
 02C2 C41603    	cnz	setup$dph
                	jrc	selerr
 02C5+3814      	DB	38H,SELERR-$-1
 02C7 3A6B00    	lda	@adrv
 02CA 87        	add	a
 02CB 4F        	mov	c,a
 02CC 0600      	mvi	b,0
 02CE 212D02    	lxi	h,@dtbl
 02D1 09        	dad	b
                	lded	@dph
 02D2+ED5B      	DB	0EDH,5BH
 02D4+7200      	DW	@DPH
 02D6 73        	mov	m,e	;set current DPH in @dtbl
 02D7 23        	inx	h
 02D8 72        	mov	m,d
                	jr	selcom	;DE=dph
 02D9+1816      	DB	18H,SELCOM-$-1
                
 02DB 210000    selerr: lxi	h,0
 02DE C9        	ret
                
 02DF 3A6B00    notlgi: lda	@adrv
 02E2 87        	add	a
 02E3 4F        	mov	c,a
 02E4 0600      	mvi	b,0
 02E6 212D02    	lxi	h,@dtbl
 02E9 09        	dad	b
 02EA 5E        	mov	e,m	;get current DPH from @dtbl
 02EB 23        	inx	h
 02EC 56        	mov	d,m	;DE=dph
                	sded	@dph
 02ED+ED53      	DB	0EDH,53H
 02EF+7200      	DW	@DPH
                selcom:
 02F1 210A00    	lxi	h,+10
 02F4 19        	dad	d	;point to DPB entry
 02F5 4E        	mov	c,m
 02F6 23        	inx	h
 02F7 46        	mov	b,m
 02F8 0A        	ldax	b	;SPT (logical)
 02F9 32EC05    	sta	@spt
 02FC 210300    	lxi	h,+3
 02FF 09        	dad	b
 0300 7E        	mov	a,m	;BSM
 0301 32F905    	sta	blkmsk
 0304 210D00    	lxi	h,+13	;point to track offset
 0307 09        	dad	b
 0308 4E        	mov	c,m
 0309 23        	inx	h
 030A 46        	mov	b,m
 030B 23        	inx	h
                	sbcd	offset
 030C+ED43      	DB	0EDH,43H
 030E+EF05      	DW	OFFSET
 0310 7E        	mov	a,m	;psh
 0311 32EE05    	sta	blcode
 0314 EB        	xchg		;put DPH in (HL) for BDOS
 0315 C9        	ret
                
                setup$dph:
 0316 B7        	ora	a	;reset [CY]
 0317 2A7000    	lhld	@cmode	;HL=modes
                	bit	7,m	;check for hard-disk drive (modes not standard)
 031A+CB7E      	DB	0CBH,7*8+M+40H
 031C C0        	rnz
 031D 37        	stc
 031E C9        	ret
                
 031F 010000    home:	lxi b,0 	; same as set track zero
                settrk: sbcd @trk
 0322+ED43      	DB	0EDH,43H
 0324+E705      	DW	@TRK
 0326 C9        	ret
                
                setsec: sbcd @sect
 0327+ED43      	DB	0EDH,43H
 0329+E905      	DW	@SECT
 032B C9        	ret
                
                setdma:
 032C 78        	mov	a,b
 032D A1        	ana	c
 032E FEFF      	cpi	true
 0330 CA7405    	jz	flushall
                	sbcd	@dma
 0333+ED43      	DB	0EDH,43H
 0335+8800      	DW	@DMA
 0337 C9        	ret
                
 0338 6960      sectrn: mov l,c ! mov h,b
 033A 7AB3C8    	mov a,d ! ora e ! rz
 033D EB096E2600	xchg ! dad b ! mov l,m ! mvi h,0
 0342 2B        	dcx	h	;sectors numbered 0 - (n-1)
 0343 C9        	ret
                
                
                read:
 0344 3EFF      	mvi	a,true		; FLAG A READ OPERATION
 0346 32F305    	sta	preread 	; forces FLUSH and Physical READ
 0349 32FA05    	sta	rdflg
 034C 32F405    	sta	defer		; never flush if reading (pointless)
 034F 2F        	cma	; false
 0350 32F505    	sta	unalloc ;terminate any active unallocated-writing
 0353 2AFC05    	LHLD	REQTRK
 0356 3AEF05    	lda	OFFSET
 0359 95        	sub	l	; DIR track must be < 256
 035A B4        	ora	h	; 00=on DIR track
 035B 2AE905    	lhld	@sect
 035E B4        	ora	h	;
 035F B5        	ora	l	; 00=first sector of directory
 0360 D601      	sui	1	; CY = 1st sec of dir
 0362 9F        	sbb	a	; FF = 1st sec of dir, else 00
 0363 32F205    	sta	dir0
                	jr	rwoper
 0366+1852      	DB	18H,RWOPER-$-1
                
                write:
 0368 AF        	xra	a
 0369 32F205    	sta	dir0
 036C 32FA05    	sta	rdflg
 036F 3EFF      	mvi	a,true
 0371 32F305    	STA	preread 	; assume a PRE-READ
 0374 79        	mov	a,c
 0375 E601      	ani	1		; 00 = defered write, else 01
 0377 3D        	dcr	a		; FF = defer, else 00
 0378 32F405    	sta	defer
                	bit	1,c		; write to 1st sector of unallocated block ?
 037B+CB49      	DB	0CBH,1*8+C+40H
                	jrz	CHKUNA
 037D+280D      	DB	28H,CHKUNA-$-1
                	SDED	URECORD 	; SET UNALLOCATED RECORD #
 037F+ED53      	DB	0EDH,53H
 0381+F605      	DW	URECORD
 0383 78        	mov	a,b
 0384 32F805    	sta	urecord+2
 0387 3EFF      	mvi	a,true
 0389 32F505    	STA	UNALLOC 	; FLAG WRITING OF AN UNALLOCATED BLOCK
 038C 3AF505    CHKUNA: LDA	UNALLOC 	; ARE WE WRITING AN UNALLOCATED BLOCK ?
 038F B7        	ORA	A
                	JRZ	rwoper
 0390+2828      	DB	28H,RWOPER-$-1
 0392 2AF605    	LHLD	URECORD 	; IS REQUESTED RECORD SAME AS EXPECTED
                	DSBC	D		;  SAME AS EXPECTED UNALLOCATED RECORD ?
 0395+ED52      	DB	0EDH,D*8+42H
                	JRNZ	ALLOC		; IF NOT, THEN DONE WITH UNALLOCATED BLOCK
 0397+201D      	DB	20H,ALLOC-$-1
 0399 3AF805    	lda	urecord+2
 039C 90        	sub	b
                	jrnz	alloc
 039D+2017      	DB	20H,ALLOC-$-1
 039F AF        	XRA	A		; CLEAR PRE-READ FLAG
 03A0 32F305    	STA	preread
 03A3 210100    	lxi	h,1		; INCREMENT TO NEXT EXPECTED UNALLOCATED RECORD
 03A6 19        	dad	d
 03A7 22F605    	shld	urecord
 03AA 3E00      	mvi	a,0
 03AC 88        	adc	b
 03AD 32F805    	sta	urecord+2
 03B0 3AF905    	LDA	BLKMSK
 03B3 A5        	ana	l		; IS IT THE START OF A NEW BLOCK ?
                	JRNZ	rwoper
 03B4+2004      	DB	20H,RWOPER-$-1
 03B6 AF        ALLOC:	XRA	A		; NO LONGER WRITING AN UNALLOCATED BLOCK
 03B7 32F505    	STA	UNALLOC
                rwoper:
                	; RLR - Ready List Root - points to the current process
 03BA 2A0006    	lhld	rlr
 03BD 4E        	mov	c,m
 03BE 23        	inx	h
 03BF 46        	mov	b,m	;BC=PDAdr, must be preserved throughout.
                ; get a buffer for this disk access...
                 if lrubuf
                	lixd	hsttop
 03C0+DD2A      	DB	0DDH,2AH
 03C2+0406      	DW	HSTTOP
 03C4 210000    	lxi	h,0
 03C7 220806    	shld	previous
 03CA 2A0406    	lhld	hsttop
 03CD 7C        	mov	a,h
 03CE B5        	ora	l
 03CF C2D803    	jnz	sd0
 03D2 2A0606    	lhld	fretop
 03D5 C30504    	jmp	sd1
                sd0:	ldx	e,link
 03D8+DD5E00    	DB	0DDH,E*8+46H,LINK
                	ldx	d,link+1
 03DB+DD5601    	DB	0DDH,D*8+46H,LINK+1
                	ldx	l,hstpda
 03DE+DD6E02    	DB	0DDH,L*8+46H,HSTPDA
                	ldx	h,hstpda+1
 03E1+DD6603    	DB	0DDH,H*8+46H,HSTPDA+1
 03E4 B7        	ora	a
                	dsbc	b	;compare P.D.Adr
 03E5+ED42      	DB	0EDH,B*8+42H
 03E7 CA1004    	jz	sd2
 03EA 7A        	mov	a,d
 03EB B3        	ora	e
 03EC CAF903    	jz	sd3
                	sixd	previous
 03EF+DD22      	DB	0DDH,22H
 03F1+0806      	DW	PREVIOUS
 03F3 D5        	push	d
                	popix
 03F4+DDE1      	DB	0DDH,0E1H
 03F6 C3D803    	jmp	sd0
                sd3:	sixd	last
 03F9+DD22      	DB	0DDH,22H
 03FB+0A06      	DW	LAST
 03FD 2A0606    	lhld	fretop
 0400 7C        	mov	a,h
 0401 B5        	ora	l
 0402 CA2104    	jz	sd4
 0405 5E        sd1:	mov	e,m
 0406 23        	inx	h
 0407 56        	mov	d,m
 0408 2B        	dcx	h
                	sded	fretop
 0409+ED53      	DB	0EDH,53H
 040B+0606      	DW	FRETOP
 040D C33704    	jmp	setbuf
                ; found our buffer, may not be at top of list.
 0410 2A0806    sd2:	lhld	previous	;patch previous bufr to skip this one,
 0413 7C        	mov	a,h		;unless this is already first.
 0414 B5        	ora	l
 0415 CA4D04    	jz	sd5
 0418 73        	mov	m,e
 0419 23        	inx	h
 041A 72        	mov	m,d
                	pushix
 041B+DDE5      	DB	0DDH,0E5H
 041D E1        	pop	h	; move this bufr to top of list (most recently used)
 041E C33F04    	jmp	setbuf1
                ; No existing buffer, no free buffers, must take last on list.
                sd4:	lixd	previous	;no existing in-use bufr, no free bufr.
 0421+DD2A      	DB	0DDH,2AH
 0423+0806      	DW	PREVIOUS
                	mvix	0,link		;remove last buffer in list,
 0425+DD360000  	DB	0DDH,36H,LINK,0
                	mvix	0,link+1	;patching previous to be new end.
 0429+DD360100  	DB	0DDH,36H,LINK+1,0
                	liyd	last	;must flush this buffer, if write pending.
 042D+FD2A      	DB	0FDH,2AH
 042F+0A06      	DW	LAST
 0431 CDC205    	call	flush	; ERROR will return directly to BDOS (pop h, ret)
 0434 2A0A06    	lhld	last	;
                ;	jmp	setbuf
 0437 EB        setbuf: xchg
 0438 210700    	lxi	h,hstdsk
 043B 19        	dad	d
 043C 36FF      	mvi	m,-1	;invalidate buffer.
 043E EB        	xchg
                setbuf1:lded	hsttop	;used to be top of list, now make it 2nd.
 043F+ED5B      	DB	0EDH,5BH
 0441+0406      	DW	HSTTOP
 0443 220406    	shld	hsttop	;put selected bufr at top of list.
 0446 73        	mov	m,e	;set link
 0447 23        	inx	h
 0448 72        	mov	m,d
 0449 23        	inx	h
 044A 71        	mov	m,c	;BC must still = P.D.Adr
 044B 23        	inx	h
 044C 70        	mov	m,b
                sd5:
                 else
                	lxi	h,xxhdr
                	shld	hsttop
                 endif
                	; BC is still PDAdr
                	liyd	hsttop
 044D+FD2A      	DB	0FDH,2AH
 044F+0406      	DW	HSTTOP
 0451 3A6C00    	lda	@pdrv		; Calculate physical sector, etc
 0454 32FB05    	sta	reqdsk
 0457 CD3A02    	call	getusrbnk
 045A 2AE705    	lhld	@trk
 045D 22FC05    	shld	reqtrk
 0460 0E00      	MVI	C,0		; CALCULATE PHYSICAL SECTOR
 0462 3AEE05    	LDA	blcode		; PHYSICAL SECTOR SIZE CODE
 0465 B7        	ORA	A		; TEST FOR ZERO
 0466 47        	MOV	B,A
                	lded	@sect
 0467+ED5B      	DB	0EDH,5BH
 0469+E905      	DW	@SECT
                	JRZ	DBLOK3		; 128 BYTE SECTORS ?
 046B+280D      	DB	28H,DBLOK3-$-1
                DBLOK1: srlr	d		; DIVIDE BY 2
 046D+CB3A      	DB	0CBH, 38H + D
                	rarr	e
 046F+CB1B      	DB	0CBH, 18H + E
                	RARR	C		; SAVE OVERFLOW BITS
 0471+CB19      	DB	0CBH, 18H + C
                	DJNZ	DBLOK1		; AND CONTINUE IF BLOCKING STILL <> 0
 0473+10F8      	DB	10H,DBLOK1-$-1
 0475 47        	mov	b,a
                DBLOK2: RLCR	C		; NOW RESTORE THE OVERFLOW BY
 0476+CB01      	DB	0CBH, 00H + C
                	DJNZ	DBLOK2		; ROTATING IT RIGHT
 0478+10FC      	DB	10H,DBLOK2-$-1
 047A 79        DBLOK3: MOV	A,C
 047B 32F105    	sta	blksec		; STORE IT
                	sded	reqsec
 047E+ED53      	DB	0EDH,53H
 0480+FE05      	DW	REQSEC
                
                chk1:	ldy	e,link		; next buffer, or 0000
 0482+FD5E00    	DB	0FDH,E*8+46H,LINK
                	ldy	d,link+1	;
 0485+FD5601    	DB	0FDH,D*8+46H,LINK+1
 0488 7A        	mov	a,d
 0489 B3        	ora	e
                	jrz	chk2
 048A+2859      	DB	28H,CHK2-$-1
 048C D5        	push	d
                	popiy
 048D+FDE1      	DB	0FDH,0E1H
 048F 210700    	lxi	h,hstdsk
 0492 19        	dad	d
 0493 11FB05    	lxi	d,reqdsk
 0496 0605      	mvi	b,5
 0498 1A        chk0:	ldax	d
 0499 BE        	cmp	m
                	jrnz	chk1
 049A+20E6      	DB	20H,CHK1-$-1
 049C 23        	inx	h
 049D 13        	inx	d
                	djnz	chk0
 049E+10F8      	DB	10H,CHK0-$-1
 04A0 CDC205    	call	flush	;an error bumps us out here.
                	siyd	previous	;save pointer
 04A3+FD22      	DB	0FDH,22H
 04A5+0806      	DW	PREVIOUS
 04A7 3AFA05    	lda	rdflg
 04AA B7        	ora	a
                	jrnz	chk3
 04AB+2004      	DB	20H,CHK3-$-1
                	mviy	-1,hstdsk	;invalidate their buffer if we are writing.
 04AD+FD3607FF  	DB	0FDH,36H,HSTDSK,-1
                chk3:	liyd	hsttop	;restore IY
 04B1+FD2A      	DB	0FDH,2AH
 04B3+0406      	DW	HSTTOP
 04B5 3AF205    	lda	dir0
 04B8 B7        	ora	a
                	jrnz	readit	;don't bother to move data if a read is forced...
 04B9+204B      	DB	20H,READIT-$-1
 04BB CDC205    chk4:	call	flush		; must flush our buffer BEFORE changing data.
                	ldy	l,hstbuf	; destination - our buffer
 04BE+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1	;
 04C1+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
                	ldy	b,hstbnk	;
 04C4+FD460E    	DB	0FDH,B*8+46H,HSTBNK
                	lixd	previous
 04C7+DD2A      	DB	0DDH,2AH
 04C9+0806      	DW	PREVIOUS
                	ldx	e,hstbuf	; source
 04CB+DD5E0C    	DB	0DDH,E*8+46H,HSTBUF
                	ldx	d,hstbuf+1	;
 04CE+DD560D    	DB	0DDH,D*8+46H,HSTBUF+1
                	ldx	c,hstbnk	;
 04D1+DD4E0E    	DB	0DDH,C*8+46H,HSTBNK
 04D4 3E01      	mvi	a,1	; interrupts are enabled
 04D6 CD0000    	call	?xmove		;
 04D9 010002    	lxi	b,secsize	; put requested sector data in our buffer
 04DC CD0000    	call	?move		;
 04DF AF        	xra	a
 04E0 32F305    	sta	preread
                	jr	readit0
 04E3+1824      	DB	18H,READIT0-$-1
                chk2:	liyd	hsttop	;restore IY
 04E5+FD2A      	DB	0FDH,2AH
 04E7+0406      	DW	HSTTOP
 04E9 3AF205    	lda	dir0
 04EC B7        	ora	a
                	jrnz	readit
 04ED+2017      	DB	20H,READIT-$-1
 04EF 2A0406    chkbuf: lhld	hsttop
 04F2 110700    	lxi	d,hstdsk
 04F5 19        	dad	d
 04F6 EB        	xchg
 04F7 21FB05    	lxi	h,reqdsk
 04FA 0605      	mvi	b,5
 04FC 1A        chkbuf1:ldax	d
 04FD BE        	cmp	m
                	jrnz	readit
 04FE+2006      	DB	20H,READIT-$-1
 0500 23        	inx	h
 0501 13        	inx	d
                	djnz	chkbuf1
 0502+10F8      	DB	10H,CHKBUF1-$-1
                	jr	noread		;  THEN NO NEED TO PRE-READ
 0504+182D      	DB	18H,NOREAD-$-1
 0506 CDC205    readit: call	flush
 0509 2A0406    readit0:lhld	hsttop		; SET UP NEW BUFFER PARAMETERS
 050C 110700    	lxi	d,hstdsk
 050F 19        	dad	d
 0510 EB        	xchg
 0511 21FB05    	lxi	h,reqdsk	; set HSTDSK,HSTTRK,HSTSEC
 0514 010500    	lxi	b,5		;
                	ldir			;
 0517+EDB0      	DB	0EDH,0B0H
 0519 2A6E00    	lhld	curmdl
                	sty	l,hstmdl
 051C+FD750F    	DB	0FDH,70H+L,HSTMDL
                	sty	h,hstmdl+1
 051F+FD7410    	DB	0FDH,70H+H,HSTMDL+1
 0522 2A7000    	lhld	@cmode
                	sty	l,hstmod
 0525+FD7504    	DB	0FDH,70H+L,HSTMOD
                	sty	h,hstmod+1
 0528+FD7405    	DB	0FDH,70H+H,HSTMOD+1
 052B 3AF305    	lda	preread
 052E B7        	ora	a
 052F C4D105    	cnz	pread		; READ THE SECTOR
 0532 C0        	rnz		;stop here if error
                noread: ldy	l,hstbuf	; POINT TO START OF SECTOR BUFFER
 0533+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1
 0536+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
 0539 018000    	lxi	b,128
 053C 3AF105    	lda	blksec		; POINT TO LOCATION OF CORRECT LOGICAL SECTOR
 053F 3D        movit1: dcr	a
 0540 FA4605    	jm	movit2
 0543 09        	dad	b
                	jr	movit1
 0544+18F9      	DB	18H,MOVIT1-$-1
                movit2:
                	; TODO: need to handle possible common memory DMA
                	lded	@dma		; POINT TO DMA
 0546+ED5B      	DB	0EDH,5BH
 0548+8800      	DW	@DMA
 054A 3A1900    	lda	@dbnk
 054D EB        	xchg		;DE is source, HL is dest.
 054E 47        	mov	b,a		;B=dest. bank
                	ldy	c,hstbnk	;C=source bank
 054F+FD4E0E    	DB	0FDH,C*8+46H,HSTBNK
 0552 3AFA05    	lda	rdflg		; IS IT A WRITE ?
 0555 B7        	ora	a
                	jrnz	movit3
 0556+2008      	DB	20H,MOVIT3-$-1
 0558 79        	mov	a,c
 0559 48        	mov	c,b
 055A 47        	mov	b,a
 055B EB        	xchg			; SWITCH DIRECTION OF MOVE FOR WRITE
                	mviy	true,pndwrt	; FLAG A PENDING WRITE
 055C+FD3606FF  	DB	0FDH,36H,PNDWRT,TRUE
 0560 CD0000    movit3: call	?xmove
 0563 018000    	lxi	b,128
 0566 3E01      	mvi	a,1	; interrupts are enabled
 0568 CD0000    	call	?move		; MOVE IT
 056B 3AF405    	lda	defer		; CHECK FOR non-defered write
 056E B7        	ora	a
 056F CCC205    	cz	flush		; WRITE THE SECTOR IF IT IS
 0572 AF        	xra	a		; FLAG NO ERROR
 0573 C9        	ret			; RETURN TO BDOS
                
                flushall:
                 if lrubuf
                	lded	hsttop
 0574+ED5B      	DB	0EDH,5BH
 0576+0406      	DW	HSTTOP
 0578 7A        	mov	a,d
 0579 B3        	ora	e
 057A C8        	rz		;no buffers in use.
 057B 210406    	lxi	h,hsttop
 057E 220806    	shld	previous
 0581 2A0006    	lhld	rlr
 0584 4E        	mov	c,m
 0585 23        	inx	h
 0586 46        	mov	b,m	;BC = PDAdr, must be preserved
 0587 210200    fls0:	lxi	h,hstpda
 058A 19        	dad	d
 058B 7E        	mov	a,m
 058C 23        	inx	h
 058D 66        	mov	h,m
 058E 6F        	mov	l,a
 058F B7        	ora	a
                	dsbc	b	;compare P.D. adr
 0590+ED42      	DB	0EDH,B*8+42H
 0592 CAA205    	jz	flush1
 0595 EB        	xchg
 0596 220806    	shld	previous
 0599 5E        	mov	e,m
 059A 23        	inx	h
 059B 56        	mov	d,m
 059C 7A        	mov	a,d
 059D B3        	ora	e
 059E C28705    	jnz	fls0
 05A1 C9        	ret
                
                ; TODO: could there be more than one?
                ; might need to resume flushall...
 05A2 D5        flush1: push	d
                	popiy
 05A3+FDE1      	DB	0FDH,0E1H
 05A5 2A0806    	lhld	previous
                	ldy	a,link
 05A8+FD7E00    	DB	0FDH,A*8+46H,LINK
 05AB 77        	mov	m,a
 05AC 23        	inx	h
                	ldy	a,link+1
 05AD+FD7E01    	DB	0FDH,A*8+46H,LINK+1
 05B0 77        	mov	m,a
 05B1 2A0606    	lhld	fretop
                	sty	l,link
 05B4+FD7500    	DB	0FDH,70H+L,LINK
                	sty	h,link+1
 05B7+FD7401    	DB	0FDH,70H+H,LINK+1
                	siyd	fretop
 05BA+FD22      	DB	0FDH,22H
 05BC+0606      	DW	FRETOP
                 else
                	lxiy	xxhdr
                 endif
 05BE CDC205    	call	flush	; must handle stupid stack tricks
 05C1 C9        	ret
                
                ; Requires 2 ret adrs on stack, returns to imm caller on success,
                ; returns to caller's caller on error.
                flush:	ldy	a,pndwrt
 05C2+FD7E06    	DB	0FDH,A*8+46H,PNDWRT
 05C5 B7        	ora	a
 05C6 C8        	rz
                	mviy	false,pndwrt
 05C7+FD360600  	DB	0FDH,36H,PNDWRT,FALSE
 05CB CDD605    	call	pwrite
 05CE C8        	rz
 05CF E1        	pop	h
 05D0 C9        	ret
                
                ; IY=buffer header
 05D1 1E06      pread:	mvi	e,6	;read entry is +6
 05D3 C3D805    	jmp rw$common			; use common code
                
 05D6 1E09      pwrite: mvi	e,9	;write entry is +9
                
                rw$common:	;do any track/sector/side conversion...
                ;	xra	a
                ;	sta	@side
                ;	; Only "hard disk" supported...
                ;	ldy	l,hstmod
                ;	ldy	h,hstmod+1
                ;	bit	7,m	;floppy or hard-disk?
                ;	jrnz	rw0
                rw0:
 05D8 7B        	mov	a,e	; read(6) or write(9)
                	ldy	l,hstmdl
 05D9+FD6E0F    	DB	0FDH,L*8+46H,HSTMDL
                	ldy	h,hstmdl+1
 05DC+FD6610    	DB	0FDH,H*8+46H,HSTMDL+1
                calmod:
 05DF 85        	add	l
 05E0 6F        	mov	l,a
 05E1 3E00      	mvi	a,0
 05E3 8C        	adc	h
 05E4 67        	mov	h,a
 05E5 E9        	pchl		; leap to driver
                
 05E6           @side:	ds	1		; current side of media (floppy only)
 05E7           @trk:	ds	2		; current track number
 05E9           @sect:	ds	2		; current sector number
 05EB 00        @cnt:	db	0		; record count for multisector transfer
 05EC           @spt:	ds	1
 05ED           @rcnfg: ds	1
                
 05EE           blcode: ds	1	;blocking code, PSH
 05EF           offset: ds	2
 05F1           blksec: ds	1
 05F2           dir0:	ds	1
 05F3           preread:ds	1
 05F4           defer:	ds	1
 05F5           unalloc:ds	1
 05F6           urecord:ds	3
 05F9           blkmsk: ds	1
 05FA           rdflg:	ds	1
                
 05FB           reqdsk: ds	1
 05FC           reqtrk: ds	2
 05FE           reqsec: ds	2
                
 0600 0000      rlr:	dw	0
 0602 0000      msegtbl: dw	0
                
 0604 0000      hsttop:   dw	0
                 if lrubuf
 0606 0C06      fretop:   dw	hsthdr
 0608 0000      previous: dw	0
 060A 0000      last:	  dw	0
                
 0010 =         numbuf	equ	16
 0000 =         @@bnk	equ	0
 0100 #         @@ set 0100h	;start of buffers in bank
                		; (numbuf + 2) * secsize, buffers used,
                		; must not overrun system. At 512b and 16 bufs,
                		; this consumes 0100-2500, MP/M starts about A900.
                hsthdr: rept	numbuf
                	dw	$+hstlen ;Link
                	dw	0	;hstpda - Process Descriptor Address
                	dw	0	;hstmod
                	db	false	;pndwrt
                	db	-1	;hstdsk
                	dw	0	;hsttrk
                	dw	0	;hstsec
                	dw	@@	;hstbuf
                	db	@@bnk	;hstbnk
                	dw	0	;hstmdl
                @@ set @@+secsize
                	endm
 060C+1D06      	DW	$+HSTLEN ;LINK
 060E+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0610+0000      	DW	0	;HSTMOD
 0612+00        	DB	FALSE	;PNDWRT
 0613+FF        	DB	-1	;HSTDSK
 0614+0000      	DW	0	;HSTTRK
 0616+0000      	DW	0	;HSTSEC
 0618+0001      	DW	@@	;HSTBUF
 061A+00        	DB	@@BNK	;HSTBNK
 061B+0000      	DW	0	;HSTMDL
 061D+2E06      	DW	$+HSTLEN ;LINK
 061F+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0621+0000      	DW	0	;HSTMOD
 0623+00        	DB	FALSE	;PNDWRT
 0624+FF        	DB	-1	;HSTDSK
 0625+0000      	DW	0	;HSTTRK
 0627+0000      	DW	0	;HSTSEC
 0629+0003      	DW	@@	;HSTBUF
 062B+00        	DB	@@BNK	;HSTBNK
 062C+0000      	DW	0	;HSTMDL
 062E+3F06      	DW	$+HSTLEN ;LINK
 0630+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0632+0000      	DW	0	;HSTMOD
 0634+00        	DB	FALSE	;PNDWRT
 0635+FF        	DB	-1	;HSTDSK
 0636+0000      	DW	0	;HSTTRK
 0638+0000      	DW	0	;HSTSEC
 063A+0005      	DW	@@	;HSTBUF
 063C+00        	DB	@@BNK	;HSTBNK
 063D+0000      	DW	0	;HSTMDL
 063F+5006      	DW	$+HSTLEN ;LINK
 0641+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0643+0000      	DW	0	;HSTMOD
 0645+00        	DB	FALSE	;PNDWRT
 0646+FF        	DB	-1	;HSTDSK
 0647+0000      	DW	0	;HSTTRK
 0649+0000      	DW	0	;HSTSEC
 064B+0007      	DW	@@	;HSTBUF
 064D+00        	DB	@@BNK	;HSTBNK
 064E+0000      	DW	0	;HSTMDL
 0650+6106      	DW	$+HSTLEN ;LINK
 0652+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0654+0000      	DW	0	;HSTMOD
 0656+00        	DB	FALSE	;PNDWRT
 0657+FF        	DB	-1	;HSTDSK
 0658+0000      	DW	0	;HSTTRK
 065A+0000      	DW	0	;HSTSEC
 065C+0009      	DW	@@	;HSTBUF
 065E+00        	DB	@@BNK	;HSTBNK
 065F+0000      	DW	0	;HSTMDL
 0661+7206      	DW	$+HSTLEN ;LINK
 0663+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0665+0000      	DW	0	;HSTMOD
 0667+00        	DB	FALSE	;PNDWRT
 0668+FF        	DB	-1	;HSTDSK
 0669+0000      	DW	0	;HSTTRK
 066B+0000      	DW	0	;HSTSEC
 066D+000B      	DW	@@	;HSTBUF
 066F+00        	DB	@@BNK	;HSTBNK
 0670+0000      	DW	0	;HSTMDL
 0672+8306      	DW	$+HSTLEN ;LINK
 0674+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0676+0000      	DW	0	;HSTMOD
 0678+00        	DB	FALSE	;PNDWRT
 0679+FF        	DB	-1	;HSTDSK
 067A+0000      	DW	0	;HSTTRK
 067C+0000      	DW	0	;HSTSEC
 067E+000D      	DW	@@	;HSTBUF
 0680+00        	DB	@@BNK	;HSTBNK
 0681+0000      	DW	0	;HSTMDL
 0683+9406      	DW	$+HSTLEN ;LINK
 0685+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0687+0000      	DW	0	;HSTMOD
 0689+00        	DB	FALSE	;PNDWRT
 068A+FF        	DB	-1	;HSTDSK
 068B+0000      	DW	0	;HSTTRK
 068D+0000      	DW	0	;HSTSEC
 068F+000F      	DW	@@	;HSTBUF
 0691+00        	DB	@@BNK	;HSTBNK
 0692+0000      	DW	0	;HSTMDL
 0694+A506      	DW	$+HSTLEN ;LINK
 0696+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0698+0000      	DW	0	;HSTMOD
 069A+00        	DB	FALSE	;PNDWRT
 069B+FF        	DB	-1	;HSTDSK
 069C+0000      	DW	0	;HSTTRK
 069E+0000      	DW	0	;HSTSEC
 06A0+0011      	DW	@@	;HSTBUF
 06A2+00        	DB	@@BNK	;HSTBNK
 06A3+0000      	DW	0	;HSTMDL
 06A5+B606      	DW	$+HSTLEN ;LINK
 06A7+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06A9+0000      	DW	0	;HSTMOD
 06AB+00        	DB	FALSE	;PNDWRT
 06AC+FF        	DB	-1	;HSTDSK
 06AD+0000      	DW	0	;HSTTRK
 06AF+0000      	DW	0	;HSTSEC
 06B1+0013      	DW	@@	;HSTBUF
 06B3+00        	DB	@@BNK	;HSTBNK
 06B4+0000      	DW	0	;HSTMDL
 06B6+C706      	DW	$+HSTLEN ;LINK
 06B8+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06BA+0000      	DW	0	;HSTMOD
 06BC+00        	DB	FALSE	;PNDWRT
 06BD+FF        	DB	-1	;HSTDSK
 06BE+0000      	DW	0	;HSTTRK
 06C0+0000      	DW	0	;HSTSEC
 06C2+0015      	DW	@@	;HSTBUF
 06C4+00        	DB	@@BNK	;HSTBNK
 06C5+0000      	DW	0	;HSTMDL
 06C7+D806      	DW	$+HSTLEN ;LINK
 06C9+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06CB+0000      	DW	0	;HSTMOD
 06CD+00        	DB	FALSE	;PNDWRT
 06CE+FF        	DB	-1	;HSTDSK
 06CF+0000      	DW	0	;HSTTRK
 06D1+0000      	DW	0	;HSTSEC
 06D3+0017      	DW	@@	;HSTBUF
 06D5+00        	DB	@@BNK	;HSTBNK
 06D6+0000      	DW	0	;HSTMDL
 06D8+E906      	DW	$+HSTLEN ;LINK
 06DA+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06DC+0000      	DW	0	;HSTMOD
 06DE+00        	DB	FALSE	;PNDWRT
 06DF+FF        	DB	-1	;HSTDSK
 06E0+0000      	DW	0	;HSTTRK
 06E2+0000      	DW	0	;HSTSEC
 06E4+0019      	DW	@@	;HSTBUF
 06E6+00        	DB	@@BNK	;HSTBNK
 06E7+0000      	DW	0	;HSTMDL
 06E9+FA06      	DW	$+HSTLEN ;LINK
 06EB+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06ED+0000      	DW	0	;HSTMOD
 06EF+00        	DB	FALSE	;PNDWRT
 06F0+FF        	DB	-1	;HSTDSK
 06F1+0000      	DW	0	;HSTTRK
 06F3+0000      	DW	0	;HSTSEC
 06F5+001B      	DW	@@	;HSTBUF
 06F7+00        	DB	@@BNK	;HSTBNK
 06F8+0000      	DW	0	;HSTMDL
 06FA+0B07      	DW	$+HSTLEN ;LINK
 06FC+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06FE+0000      	DW	0	;HSTMOD
 0700+00        	DB	FALSE	;PNDWRT
 0701+FF        	DB	-1	;HSTDSK
 0702+0000      	DW	0	;HSTTRK
 0704+0000      	DW	0	;HSTSEC
 0706+001D      	DW	@@	;HSTBUF
 0708+00        	DB	@@BNK	;HSTBNK
 0709+0000      	DW	0	;HSTMDL
 070B+1C07      	DW	$+HSTLEN ;LINK
 070D+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 070F+0000      	DW	0	;HSTMOD
 0711+00        	DB	FALSE	;PNDWRT
 0712+FF        	DB	-1	;HSTDSK
 0713+0000      	DW	0	;HSTTRK
 0715+0000      	DW	0	;HSTSEC
 0717+001F      	DW	@@	;HSTBUF
 0719+00        	DB	@@BNK	;HSTBNK
 071A+0000      	DW	0	;HSTMDL
                 endif
 071C 0000      xxhdr:	dw	0	;Link - initially last in list.
 071E 0000      	dw	0	;hstpda
 0720 0000      	dw	0	;hstmod
 0722 00        	db	false	;pndwrt
 0723 FF        	db	-1	;hstdsk
 0724 0000      	dw	0	;hsttrk
 0726 0000      	dw	0	;hstsec
 0728 0021      	dw	@@	;hstbuf
 072A 00        	db	@@bnk	;hstbnk
 072B 0000      	dw	0	;hstmdl
 2300 #         @@ set @@+secsize
                
                ; NOTE: this buffer can be used for reading only. (it is never flushed)
 072D 0000      @scrcb: dw	0	;link - not used
 072F 0000      	dw	0	;hstpda - not used
 0731 0000      	dw	0	;hstmod
 0733 00        	db	false	;pndwrt - assumed always false
 0734 FF        	db	-1	;hstdsk
 0735 0000      	dw	0	;hsttrk
 0737 0000      	dw	0	;hstsec
 0739 0023      	dw	@@	;hstbuf
 073B 00        	db	@@bnk	;hstbnk
 073C 0000      	dw	0	;hstmdl
                
 073E           	end
