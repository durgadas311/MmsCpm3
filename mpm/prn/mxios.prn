 6130 =         vers equ '0a' ; Nov 14, 2021  13:49  drm "MXIOS.ASM"
                ;****************************************************************
                ; MP/M main XIOS module for Z180 on the H8/H89			*
                ; Derived from the MMS 77500 server XIOS			*
                ; Copyright (c) 1983 Magnolia Microsystems			*
                ;****************************************************************
                ; All memory segments are ORGed at 0000.
                ; Uses CP/M Plus format DPBs.
                
                	maclib	z180
                	maclib	cfgmpm
                
                	public	@adrv,@pdrv,@rdrv,@side,@trk,@sect
                	public	@dma,@dbnk,@dirbf
                	public	@dstat,@cmode,@dph,@rcnfg,@eops
                	public	@cbnk,@scrcb,@vect,@secnd
                
                	public	xdos,polltb,sysdat
                
                	extrn	@lptbl
                	extrn	?memsl,?bnksl,?bnkck,?xmove,?move	; MMU module
                	extrn	@memstr,@mmerr,@nbnk
                	extrn	?time,?itime,@rtcstr			; RTC module
                
                 if z180
                z180tick	equ	true
                h89tick		equ	false
                 else
                  if h89
 0000 =         z180tick	equ	false
 FFFF =         h89tick		equ	true
 000A =         tick$tick	equ	10	; number of 2mS ticks per MP/M tick
                  else
                ; TODO: what to use for tick?
                z180tick	equ	false
                h89tick		equ	false
                  endif
                 endif
                
 0200 =         secsize		equ	512	; largest sector size supported/used
                
 000D =         cr	equ 13
 000A =         lf	equ 10
 0007 =         bell	equ 7
                
 0000 =         cpm	equ	0
 0005 =         bdos	equ	5
                
 0083 =         poll	equ	131
 0085 =         flagset equ	133
                
                ;relative position of elements in buffer headers:
 0000 =         link	equ	0	;link to next headr, or 0
 0002 =         hstpda	equ	2	;Process Descriptor Adr of owner
 0004 =         hstmod	equ	4	;mode pointer (partition address)
 0006 =         pndwrt	equ	6	;pending write flag
 0007 =         hstdsk	equ	7	;host disk
 0008 =         hsttrk	equ	8	;host track
 000A =         hstsec	equ	10	;host sector
 000C =         hstbuf	equ	12	;host buffer address
 000E =         hstbnk	equ	14	;host bank
 000F =         hstmdl	equ	15	;host module entry
 0011 =         hstlen	equ	17	;length of header
                
                 if z180
                ; Z180 registers
                itc	equ	34h
                rcr	equ	36h
                mmu$cbr	equ	38h
                mmu$bbr	equ	39h
                mmu$cbar equ	3ah
                sar0l	equ	20h
                sar0h	equ	21h
                sar0b	equ	22h
                dar0l	equ	23h
                dar0h	equ	24h
                dar0b	equ	25h
                bcr0l	equ	26h
                bcr0h	equ	27h
                dstat	equ	30h
                dmode	equ	31h
                dcntl	equ	32h
                il	equ	33h
                tmdr0l	equ	0ch
                tmdr0h	equ	0dh
                rldr0l	equ	0eh
                rldr0h	equ	0fh
                tcr	equ	10h
                 endif
                
                ;-------- Start of Code-producing source -----------
                
                	; Because LINK puts dseg after cseg, and 'combas' is
                	; at the beginning of dseg, GENSYS will enforce that
                	; all of dseg falls in common memory.
                	cseg		; Banked memory
 0000 =         BIOS$0	equ	$
 0000 C30000    	jmp combas	; initial entry on cold start, common base
 0003 C39C00    	jmp wboot	; reentry on program exit, warm start
                
 0006 C3D401    	jmp const	; return console input status
 0009 C3E201    	jmp conin	; return console input character
 000C C3BA01    	jmp conout	; send console output character
 000F C3B901    	jmp list	; send list output character
 0012 C3B001    	jmp auxout	; send auxilliary output character	-NULL
 0015 C3AD01    	jmp auxin	; return auxilliary input character	-NULL
                
 0018 C3F502    	jmp home	; set disks to logical home
 001B C32302    	jmp seldsk	; select disk drive, return disk parameter info
 001E C3F802    	jmp settrk	; set disk track
 0021 C3FD02    	jmp setsec	; set disk sector
 0024 C30203    	jmp setdma	; set disk I/O memory address
 0027 C31A03    	jmp read	; read physical block(s)
 002A C33E03    	jmp write	; write physical block(s)
                
 002D C3B401    	jmp listst	; return list device status
 0030 C30E03    	jmp sectrn	; translate logical to physical sector
                
 0033 C30000    	jmp	?memsl
 0036 C3A400    	jmp	poll$dev
 0039 C3D900    	jmp	strtclk
 003C C3DD00    	jmp	stopclk
 003F C3D200    	jmp	exitreg
 0042 C3CF00    	jmp	maxcon
 0045 C3D900    	jmp	boot	;   sysinit
                ;	jmp	idle	;
 0048 000000    	nop ! nop ! nop	; no idle routine
                
 004B BF00      	dw	polltb	;for RSP's (such as NETWRKIF)
                
 004D           	ds	13	;this puts setup/mode info where they expect it
 005A C38D01    	jmp	search
 005D C31302    	jmp	setspd	; change CPU speed - platform dependent
 0060           	ds	3
                
                ; These are only static when accessed via XIOSJMP.TBL
 0063           @dstat: ds	1
 0064           speed:	ds	1	; formerly Port F2 image "@intby"
                
 0065 0000      	dw	@lptbl	;logical/physical drive table
 0067 3702      	dw	thread	;module thread
 0069 0000      	dw	0	;?serdp	;test mode validity, HL=memory address of ?serdp
                
 006B           @adrv:	ds	1		; currently selected disk drive
 006C           @pdrv:	ds	1		; physical drive number (MMS)
 006D           @rdrv:	ds	1		; module relative disk drive number
 006E           curmdl: ds	2		; currently selected Disk I/O module address
 0070           @cmode: ds	2
 0072           @dph:	ds	2
                
 0074 0080      icovec: dw	1000000000000000b
 0076 0080      icivec: dw	1000000000000000b
 0078 0000      iaovec: dw	0000000000000000b
 007A 0000      iaivec: dw	0000000000000000b
 007C 0000      ilovec: dw	0000000000000000b
                
 007E 00FFFFFF  defsrc: db	0,0ffh,0ffh,0ffh
 0082 00        tmpdrv: db	0
 0083 00        srctyp: db	000$00$000b	;only bits 3,4 are used (others ignored)
                
                	; for MODULES.COM... well, not quite since not in common memory...
                	; This will be copied to BIOS JMP PAGE, in common memory,
                	; but these strings must also reside in common memory.
 0084 0000      	dw	@memstr
 0086 0000      	dw	@rtcstr
                
 0088 0000      @dma:	dw	0
 008A 0000      wbtrap: dw	0
                
                	dseg
                ;---------- COMMON MEMORY -----------
                ; WARNING: must be on page boundary ('vect' alignment).
                ; Use LINK 'B' option.
 0000 C39C00    combas: jmp	colds
 0003 C30000    swtusr: jmp	$-$
 0006 C30000    swtsys: jmp	$-$
 0009 C30000    pdisp:	jmp	$-$
 000C C30000    xdos:	jmp	$-$
 000F 0000      sysdat: dw	$-$
                
                ; These locations are fixed, after combas block.
 0011 0000      @vect:	dw	$-$
 0013 0000      dbuga:	dw	$-$
 0015 0000      dbugv:	dw	$-$
 0017 0000      biosjmp:dw	$-$
 0019           @dbnk:	ds	1	; bank for user I/O (user DMA addr)
 001A           @eops:	ds	1
 001B           @intby: ds	1	; Port F2 image
                
 001C           @dirbf: ds	128
                
                 if z180
                	; Z180 internal devices interrupt vector table.
                	; If external devices also generate interrupts,
                	; this must be expanded/realigned to compensate.
                	; need 32-byte aligned address:
                	rept	(32 - (($-combas) AND 1fh)) AND 1fh
                	db	0
                	endm
                vect:	dw	nulint	; 0 - /INT1
                	dw	nulint	; 1 - /INT2
                	dw	tick	; 2 - PRT0 (TMDR0 -> 0)
                	dw	nulint	; 3 - PRT1 (TMDR1 -> 0)
                	dw	nulint	; 4 - DMA0
                	dw	nulint	; 5 - DMA1
                	dw	nulint	; 6 - CSIO
                	dw	nulint	; 7 - ASCI0
                	dw	nulint	; 8 - ASCI1
                	dw	nulint	; 9 - unused by Z180
                	dw	nulint	; 10 - unused by Z180
                	dw	nulint	; 11 - unused by Z180
                	dw	nulint	; 12 - unused by Z180
                	dw	nulint	; 13 - unused by Z180
                	dw	nulint	; 14 - unused by Z180
                	dw	nulint	; 15 - unused by Z180
                 endif
                
                wboot:
                colds:
                 if z180
                	; possible TRAP
                	in0	a,itc
                	tsti	10000000b	; TRAP bit
                	jrnz	trap
                 endif
 009C 0E00      	mvi	c,0
 009E C30C00    	jmp	xdos
                
                 if z180
                ; For now, any TRAP is fatal
                trap:	lxi	h,trpmsg
                	jmp	errx
                
                trpmsg:	db	cr,lf,'*TRAP*',cr,lf,'$'
                 endif
                
 00A1 FB        nulint:	ei
                	reti
 00A2+ED4D      	DB	0EDH,4DH
                
                ; C=device to poll, 0-N char I/O devices (input status)
                poll$dev:
 00A4 79        	mov	a,c
 00A5 FE08      	cpi	8
                	jrnc	pd0	; not char I/O...
 00A7+300A      	DB	30H,PD0-$-1
 00A9 51        	mov	d,c
 00AA D604      	sui	4
 00AC DAD401    	jc	const
 00AF 57        	mov	d,a
 00B0 C3B501    	jmp	conost
 00B3 0600      pd0:	mvi	b,0
 00B5 21BF00    	lxi	h,polltb
 00B8 09        	dad	b
 00B9 09        	dad	b
 00BA 5E        	mov	e,m
 00BB 23        	inx	h
 00BC 56        	mov	d,m
                	; TODO: check DE=NULL?
 00BD EB        	xchg
 00BE E9        	pchl
                
                ; Devices 8..15, starting at +0...
 00BF 0000000000polltb:	dw	$-$,$-$,$-$,$-$,$-$,$-$,$-$,$-$ ; 8..15 unassigned (yet)
                
 00CF 3E00      maxcon: mvi	a,0	;filled in at init from SYSDAT and config
 00D1 C9        	ret
                
                exitreg:
 00D2 3AE300    	lda	preempt
 00D5 B7        	ora	a
 00D6 C0        	rnz
 00D7 FB        	ei
 00D8 C9        	ret
                
 00D9 3EFF      strtclk: mvi	a,true
                	 jr	sc00
 00DB+1802      	DB	18H,SC00-$-1
 00DD 3E00      stopclk: mvi	a,false
 00DF 32E400    sc00:	 sta	clock
 00E2 C9        	 ret
                
 00E3 00        preempt: db	0
 00E4 00        clock:	 db	0
                
 00E5 0000      @secnd: dw	$-$	;used to do timeouts
                
 00E7 00        tps:	db	0	; from system data page on boot
 00E8 00        pcnt:	db	0	; pre-scale for interrupts to MP/M ticks
 00E9 00        tcnt:	db	0	; must immediately follow pcnt...
                
                second:
 00EA 2AE500    	lhld	@secnd
 00ED 7C        	mov	a,h
 00EE B5        	ora	l
 00EF C40002    	cnz	icall
 00F2 1E02      	mvi	e,2
 00F4 0E85      	mvi	c,flagset
 00F6 CD0C00    	call	xdos
                	jr	tk1
 00F9+1836      	DB	18H,TK1-$-1
                
                tick:	sspd	istk
 00FB+ED73      	DB	0EDH,73H
 00FD+8B01      	DW	ISTK
 00FF 318B01    	lxi	sp,intstk
 0102 F5        	push	psw
 0103 E5        	push	h
 0104 D5        	push	d
 0105 C5        	push	b
                 if z180tick
                	in0	a,tmdr0l	; reset INT
                 endif
                 if h89tick
 0106 3A1B00    	lda	@intby
 0109 D3F2      	out	0f2h	; reset INT
 010B 21E800    	lxi	h,pcnt
 010E 35        	dcr	m
                	jrnz	iexit
 010F+2030      	DB	20H,IEXIT-$-1
 0111 360A      	mvi	m,tick$tick
                 endif
 0113 3EFF      	mvi	a,true
 0115 32E300    	sta	preempt
 0118 3AE400    	lda	clock
 011B B7        	ora	a
                	jrz	tk0
 011C+2807      	DB	28H,TK0-$-1
 011E 1E01      	mvi	e,1
 0120 0E85      	mvi	c,flagset
 0122 CD0C00    	call	xdos
                tk0:
 0125 21E900    	lxi	h,tcnt
 0128 35        	dcr	m
                	jrnz	tk1
 0129+2006      	DB	20H,TK1-$-1
 012B 3AE700    	lda	tps
 012E 77        	mov	m,a
                	jr	second
 012F+18B9      	DB	18H,SECOND-$-1
 0131 3E00      tk1:	mvi	a,false
 0133 32E300    	sta	preempt
                 if z180tick
                	lxi	d,nexti
                	push	d
                	reti	; required by Z180?
                nexti:
                 endif
 0136 C1        	pop	b
 0137 D1        	pop	d
 0138 E1        	pop	h
 0139 F1        	pop	psw
                	lspd	istk
 013A+ED7B      	DB	0EDH,07BH
 013C+8B01      	DW	ISTK
 013E C30900    	jmp	pdisp
                
                 if h89tick
                iexit:
 0141 C1        	pop	b
 0142 D1        	pop	d
 0143 E1        	pop	h
 0144 F1        	pop	psw
                	lspd	istk
 0145+ED7B      	DB	0EDH,07BH
 0147+8B01      	DW	ISTK
 0149 FB        	ei
 014A C9        	ret
                 endif
                
 014B           	ds	64	;32 levels of stack
 018B           intstk: ds	0
 018B 0000      istk:	dw	0
                
                ; SEARCH for a module by device #.
                ;   entry:	C = device # (0-249)
                ;   exit:	[CY] = not found
                ;	   else HL=module address ("init" entry)
                ;		A=device number (relative to module's #0)
                ;
 018D 113702    search: lxi	d,thread	;C=device number
 0190 EB        snext:	xchg
 0191 5E        	mov	e,m
 0192 23        	inx	h
 0193 56        	mov	d,m
 0194 23        	inx	h
 0195 7A        	mov	a,d
 0196 B3        	ora	e
 0197 D601      	sui	1	;produce [CY] if DE=0000
 0199 D8        	rc		;return if device not found, DE=0000
 019A 79        	mov	a,c
 019B 96        	sub	m
                	jrc	snext
 019C+38F2      	DB	38H,SNEXT-$-1
 019E 23        	inx	h
 019F BE        	cmp	m
                	jrnc	snext
 01A0+30EE      	DB	30H,SNEXT-$-1
 01A2 23        	inx	h	;point to "init" vector
 01A3 B7        	ora	a	;set [NC] condition
 01A4 C9        	ret
                
 01A5 0000      ciomdl:	dw	0	;character device driver, filled at cold-start.
 01A7 00        cionum:	db	0	;max num cio devices
                
                cinit:	;C=device number (0-11)
 01A8 2AA501    	lhld	ciomdl	; init routine
 01AB 41        	mov	b,c
 01AC E9        	pchl		;jump to modules "init" with B=device #
                
 01AD 3E1A      auxin:	mvi	a,1ah	; EOF
 01AF B7        	ora	a
 01B0 C9        auxout:	ret
                
 01B1 F1        nodev:	pop	psw
 01B2 AF        nost:	xra	a	; never ready
 01B3 C9        	ret
                
                ; D=device number
                listst:
 01B4 14        	inr	d	; LST: #0 = cio device 1
                	; TODO: check overflow/wrap?
                conost:
 01B5 3E09      	mvi	a,9
                	jr	devio
 01B7+181D      	DB	18H,DEVIO-$-1
                
                ; D=device number, C=char
                list:
 01B9 14        	inr	d	; LST: #0 = cio device 1
                	; TODO: check overflow/wrap?
                conout:
 01BA C5        	push	b
 01BB D5        	push	d
 01BC CDB501    	call	conost	; is ready now?
 01BF B7        	ora	a
 01C0 C2CE01    	jnz	co0
 01C3 D1        	pop	d
 01C4 D5        	push	d
 01C5 7A        	mov	a,d
 01C6 C604      	adi	4
 01C8 5F        	mov	e,a
 01C9 0E83      	mvi	c,poll
 01CB CD0C00    	call	xdos	; sleep until ready
 01CE D1        co0:	pop	d
 01CF C1        	pop	b
 01D0 3E0C      coo:	mvi	a,12
                	jr	devio
 01D2+1802      	DB	18H,DEVIO-$-1
                
                ; D=device number
 01D4 3E03      const:	mvi	a,3
                	;jr	devio
                
                ; A=JMP tbl off, D=devnum [C=char]
 01D6 F5        devio:	push	psw
 01D7 3AA701    	lda	cionum	;see if device exists
 01DA 3D        	dcr	a
 01DB BA        	cmp	d
                	jrc	nodev
 01DC+38D3      	DB	38H,NODEV-$-1
 01DE F1        	pop	psw	; driver JMP offset
 01DF 42        	mov	b,d	;device number in B for modules
                	jr	indjmp0
 01E0+1815      	DB	18H,INDJMP0-$-1
                
                ; D=device number
 01E2 D5        conin:	push	d
 01E3 CDD401    	call	const	; is ready now?
 01E6 B7        	ora	a
 01E7 C2F201    	jnz	ci0
 01EA D1        	pop	d
 01EB D5        	push	d
 01EC 5A        	mov	e,d
 01ED 0E83      	mvi	c,poll
 01EF CD0C00    	call	xdos	; sleep until ready
 01F2 D1        ci0:	pop	d
 01F3 3E06      	mvi	a,6
                	jr	devio
 01F5+18DF      	DB	18H,DEVIO-$-1
                
                ; char I/O driver function calls
                ; A=offset (0,3,6,9,...), B=device number (0..N)
                indjmp0:
 01F7 2AA501    	lhld	ciomdl
 01FA 85        	add	l	;a=0,3,6,9,12,...
 01FB 6F        	mov	l,a
 01FC 3E00      	mvi	a,0
 01FE 8C        	adc	h
 01FF 67        	mov	h,a
 0200 E9        icall:	pchl		;indirect call
                
                
 0201 00        @cbnk:	db	0	; bank for processor operations
 0202           bnkflg: ds	1	;flag for enough memory installed.
                
                getusrbnk:	;finds the bank number for calling process
 0203 CD0300    	call	swtusr		; would like better way...
 0206 3A0102    	lda	@cbnk
 0209 321900    	sta	@dbnk
 020C C30600    	jmp	swtsys
                
                 if h89
                ; CPU clock rate selected, ORG0+2mS handled by user
 020F 00100414  cpuspd:	db	00h,10h,04h,14h
                 endif
                
                ; A=0,1,2,3[...] speed index, FF=get current speed
                ; Returns A: FF=error, FE=not supported, 0,1,2,3...=success
                ; Called from user bank, must be in common mem.
                setspd:
                 if h89
 0213 FEFF      	cpi	0ffh
                	jrz	ssx
 0215+281C      	DB	28H,SSX-$-1
 0217 326400    	sta	speed
 021A 5F        	mov	e,a
 021B FE04      	cpi	4
 021D 3EFF      	mvi	a,0ffh
 021F D0        	rnc
 0220 210F02    	lxi	h,cpuspd
 0223 1600      	mvi	d,0
 0225 19        	dad	d
 0226 56        	mov	d,m
 0227 F3        	di
 0228 3A1B00    	lda	@intby
 022B E6EB      	ani	11101011b
 022D B2        	ora	d
 022E 321B00    	sta	@intby
 0231 D3F2      	out	0f2h	; speed changes now
                  if z180tick
                	; there will be a small error until next tick
                	lxi	h,maxclk
                	mov	a,e
                	cpi	3
                	jrz	ss0
                	lxi	h,minclk
                	ora	a
                	jrz	ss0
                ss1:	dad	h
                	dcr	a
                	jrnz	ss1
                ss0:	; HL=timer value for 50Hz tick
                	out0	l,rldr0l	; update timer reload count
                	out0	h,rldr0h	;
                  endif
 0233 3A6400    ssx:	lda	speed	; always return current speed
                 else
                	mvi	a,0feh	; not supported
                 endif
 0236 C9        	ret
                
 0237 =         thread: equ	$	;must be last in dseg (common mem)
                
                	cseg	; rest is in banked memory...
                
 008C 0D0A07    signon: db	cr,lf,bell
                 if h89
 008F 48382D    	db	'H8-'
                 endif
                ; TODO: other platforms...
                 if z180
                	db	'Z180'
                 else
 0092 5A3830    	db	'Z80'
                 endif
 0095 204D502F4D	db	' MP/M-II v3.00'
 00A3 3061      	dw	vers
 00A5 2020286329	db	'  (c) 1984 DRI and MMS',cr,lf,'$'
                
 00BE 0D0A074E6Fbnkerr:	db	cr,lf,bell,'Not enough memory banks$'
                
                ; Interrupts are disabled
                ; HL = BIOS JMP table
                ; DE = debug entry
                ; C = debug RST num
                boot:
                 if h89
                	; This is H89-specific...
 00D9 3E00      	mvi	a,defspd
 00DB 326400    	sta	speed
 00DE 3A0F02    	lda	cpuspd+defspd
 00E1 F620      	ori	00100000b	; ORG0 only, right now
 00E3 321B00    	sta	@intby
 00E6 D3F2      	out	0f2h	; prevent undesirable intrs
                			; Console 8250 should already be off
                 endif
                 if z180
                	; speed things up...
                	mvi	a,z$dcntl
                	out0	a,dcntl	; set WAIT states
                	mvi	a,z$rcr
                	out0	a,rcr	; set RESFRESH cycles
                 endif
                	;
                	sded	dbuga
 00E8+ED53      	DB	0EDH,53H
 00EA+1300      	DW	DBUGA
 00EC 221700    	shld	biosjmp
 00EF 79        	mov	a,c
 00F0 87        	add	a
 00F1 87        	add	a
 00F2 87        	add	a
 00F3 6F        	mov	l,a
 00F4 2600      	mvi	h,0
 00F6 221500    	shld	dbugv
                 if z180tick
                	lxi	h,vect
                	shld	@vect
                	mov	a,h
                	stai
                	out0	l,il
                 endif
                 if h89tick
 00F9 3EC3      	mvi	a,JMP
 00FB 320800    	sta	0008h
 00FE 21FB00    	lxi	h,tick
 0101 220900    	shld	0008h+1
 0104 3A1B00    	lda	@intby
 0107 F602      	ori	02h
 0109 321B00    	sta	@intby
 010C D3F2      	out	0f2h
                 endif
                
 010E 2A0F00    	lhld	sysdat
 0111 2E7A      	mvi	l,122	;ticks/sec
 0113 7E        	mov	a,m
 0114 32E700    	sta	tps
 0117 32E900    	sta	tcnt
 011A 2EFC      	mvi	l,252	;XDOS internal data page
 011C 5E        	mov	e,m
 011D 23        	inx	h
 011E 56        	mov	d,m
 011F 210500    	lxi	h,5
 0122 19        	dad	d	; skip past TOD
 0123 22D605    	shld	rlr
 0126 219600    	lxi	h,0096h	; osmsegtbl
 0129 19        	dad	d
 012A 22D805    	shld	msegtbl
                ; get common size from SYSDAT
 012D 2A0F00    	lhld	sysdat
 0130 2E7C      	mvi	l,124		;common memory base page
 0132 7E        	mov	a,m
                ; Verify that we have banked RAM... A=compag from MP/M
 0133 CD0000    	call	?bnkck
 0136 320202    	sta	bnkflg
                 if z180tick
                ; initialize timer interrupts
                	lxi	h,tickrate	; phi/20/tickrate = ticks per sec
                	out0	l,tmdr0l
                	out0	h,tmdr0h
                	out0	l,rldr0l
                	out0	h,rldr0h
                	in0	a,tcr
                	ori	00010001b	; TIE0, TDE0
                	out0	a,tcr		; start the timer
                 endif
                ; Initialize all modules and build tables.
 0139 213702    	lxi	h,thread	;thread our way through the modules,
 013C 5E        iin0:	mov	e,m		;initializing as we go.
 013D 23        	inx	h
 013E 56        	mov	d,m	;next module, or "0000" if we're past the end.
 013F 23        	inx	h
 0140 7A        	mov	a,d
 0141 B3        	ora	e
 0142 CA6D01    	jz	init$done
 0145 7E        	mov	a,m	;device base number
 0146 23        	inx	h
 0147 23        	inx	h	;thread+4 = init entry (JMP)
 0148 D6C8      	sui	200	;if Char I/O module, build entry(s) in tables.
 014A DA6501    	jc	notchr
                	; should only be one...
 014D 22A501    	shld	ciomdl
 0150 D5        	push	d	;save NEXT module address
 0151 2B        	dcx	h	;number of devices
 0152 7E        	mov	a,m
 0153 2A0F00    	lhld	sysdat
 0156 23        	inx	h
 0157 BE        	cmp	m
                	jrc	iin50	; min(nmbcns,cionum)
 0158+3801      	DB	38H,IIN50-$-1
 015A 7E        	mov	a,m	;number of system consoles (requested)
 015B 32D000    iin50:	sta	maxcon+1
                	; TODO: factor in number of printers: inx h; add m
                	; first need to make printer(s) 0+nmbcns
 015E 32A701    	sta	cionum	; initialize only what is needed
 0161 E1        	pop	h	; next module
 0162 C33C01    	jmp	iin0
                
                notchr: 		;HL point to init entry
 0165 D5        	push	d
 0166 CD0002    	call	icall	;"call" (HL)
 0169 E1        	pop	h
 016A C33C01    	jmp	iin0
                
                init$done:	;all Disk I/O modules are initialized.
                		; now initialize the chrio devices
 016D 3AA701    	lda	cionum
 0170 4F        	mov	c,a	; last dev + 1
 0171 0D        iin5:	dcr	c
 0172 FA7C01    	jm	iin2	; include dev 0
 0175 C5        	push	b
 0176 CDA801    	call	cinit
 0179 C1        	pop	b
                	jr	iin5
 017A+18F5      	DB	18H,IIN5-$-1
                iin2:
 017C 218C00    	lxi	h,signon
 017F CDF401    	call	msgout
 0182 3A0202    	lda	bnkflg
 0185 B7        	ora	a	;is enough memory installed?
 0186 CAEC01    	jz	ramerr
 0189 CD9801    	call	segchk	; check memsegtbl (if banked RAM good)
 018C B7        	ora	a
 018D CAE701    	jz	segerr
 0190 CDB001    	call	set$jumps  ;setup system jumps and put in all banks
 0193 CD0000    	call	?itime	; get (starting) TOD from RTC
                
                 if z180tick
                	im2
                 endif
 0196 AF        	xra	a
 0197 C9        	ret
                
                ; Verify that memsegtbl has no bank >= @nbnk
                segchk:
 0198 2A0F00    	lhld	sysdat
 019B 2E0F      	mvi	l,15	; max$mem$seg
 019D 46        	mov	b,m
 019E 3A0000    	lda	@nbnk	; num banks
 01A1 3D        	dcr	a	; largest bank num allowed
                sgck0:
 01A2 23        	inx	h
 01A3 23        	inx	h
 01A4 23        	inx	h
 01A5 23        	inx	h	; memsegtbl[x].bank
 01A6 BE        	cmp	m
                	jrc	sgck1
 01A7+3805      	DB	38H,SGCK1-$-1
                	djnz	sgck0
 01A9+10F7      	DB	10H,SGCK0-$-1
 01AB F6FF      	ori	true
 01AD C9        	ret
 01AE AF        sgck1:	xra	a	; error - not enough banks
 01AF C9        	ret
                
                ; Interrupts disabled, must not enable
                set$jumps:
                	liyd	dbugv
 01B0+FD2A      	DB	0FDH,2AH
 01B2+1500      	DW	DBUGV
 01B4 3EC3      	mvi	a,(JMP)
 01B6 320000    	sta	cpm
                	sty	a,+0      ; set up jumps in page zero
 01B9+FD7700    	DB	0FDH,70H+A,+0
 01BC 2A17002201	lhld	biosjmp ! shld cpm+1	; BIOS warm start entry
 01C2 2A1300    	lhld	dbuga
                	sty	l,+1
 01C5+FD7501    	DB	0FDH,70H+L,+1
                	sty	h,+2	; DEBUGGER entry point
 01C8+FD7402    	DB	0FDH,70H+H,+2
 01CB 3A0000    	lda	@nbnk
 01CE 47        	mov	b,a	;number of banks (also, -1 is dest bank)
 01CF 0E00      	mvi	c,0	;source bank
                sj0:
 01D1 05        	dcr	b
 01D2 C8        	rz
 01D3 C5        	push	b
                	; must setup DE,HL before ?xmove
 01D4 210000    	lxi	h,0	; page 0 in all banks
 01D7 54        	mov	d,h
 01D8 5D        	mov	e,l
 01D9 CD0000    	call	?xmove
 01DC 014000    	lxi	b,64
 01DF AF        	xra	a	; interrupts are disabled
 01E0 CD0000    	call	?move
 01E3 C1        	pop	b
                	jr	sj0		;
 01E4+18EB      	DB	18H,SJ0-$-1
 01E6 C9        	ret
                
 01E7 21BE00    segerr: lxi	h,bnkerr
                	jr	errx
 01EA+1803      	DB	18H,ERRX-$-1
 01EC 210000    ramerr: lxi	h,@mmerr
 01EF CDF401    errx:	call	msgout
 01F2 F376      	di ! hlt
                
                msgout:
 01F4 7E        	mov	a,m
 01F5 FE24      	cpi	'$'
 01F7 C8        	rz
 01F8 E5        	push	h
 01F9 4E        	mov	c,m
 01FA 1600      	mvi	d,0
 01FC CDD001    	call	coo
 01FF E1        	pop	h
 0200 23        	inx	h
                	jr	msgout
 0201+18F1      	DB	18H,MSGOUT-$-1
                
 0203 0000000000@dtbl:	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                
                seldsk:
 0223 79326B00  	mov a,c ! sta @adrv			; save drive select code
 0227 210000    	lxi	h,@lptbl
 022A 060009    	mvi b,0 ! dad b 	      ; create index from drive code
 022D 7E        	mov	a,m
 022E FEFF      	cpi	255
 0230 CAB102    	jz	selerr
 0233 326C00    	sta	@pdrv
 0236 4F        	mov	c,a
 0237 43        	mov	b,e	;save login flag thru "search" routine
 0238 CD8D01    	call	search
 023B DAB102    	jc	selerr
 023E 326D00    	sta	@rdrv
 0241 226E00    	shld	curmdl
 0244 C5        	push	b	;save login bit
 0245 110E00    	lxi	d,14
 0248 19        	dad	d	;point to dphtbl
 0249 5E        	mov	e,m	;DE=dphtbl
 024A 23        	inx	h
 024B 56        	mov	d,m
 024C 23        	inx	h
 024D 4E        	mov	c,m	;BC=modtbl
 024E 23        	inx	h
 024F 46        	mov	b,m
 0250 3A6D00    	lda	@rdrv
 0253 87        	add	a
 0254 87        	add	a
 0255 87        	add	a	;*8
 0256 6F        	mov	l,a
 0257 2600      	mvi	h,0
 0259 09        	dad	b	;select mode bytes
 025A 227000    	shld	@cmode	;set current mode pointer
 025D C1        	pop	b	;get login bit back.
                	bit	0,b	;test for initial select.
 025E+CB40      	DB	0CBH,0*8+B+40H
                	jrnz	notlgi
 0260+2053      	DB	20H,NOTLGI-$-1
 0262 EB        	xchg		;DE=modes
 0263 4F        	mov	c,a
 0264 0600      	mvi	b,0
 0266 09        	dad	b	;+*8
 0267 09        	dad	b	;+*16
 0268 227200    	shld	@dph
 026B EB        	xchg
 026C 3A6B00    	lda	@adrv
 026F 4F        	mov	c,a
 0270 87        	add	a	;*2
 0271 87        	add	a	;*4
 0272 87        	add	a	;*8
 0273 87        	add	a	;*16
 0274 81        	add	c	;*17
 0275 4F        	mov	c,a	;B still = 0
 0276 CDEC02    	call	setup$dph
                	jrc	selerr
 0279+3836      	DB	38H,SELERR-$-1
 027B AF        	xra	a
 027C 32C305    	sta	@rcnfg
 027F 2A6E00    	lhld	curmdl
                	lxiy	@scrcb
 0282+FD21      	DB	0FDH,21H
 0284+0307      	DW	@SCRCB
 0286 3A6C00    	lda	@pdrv
                	sty	a,hstdsk
 0289+FD7707    	DB	0FDH,70H+A,HSTDSK
 028C 3E03      	mvi	a,3
 028E CDB505    	call	calmod	;call module's "login" routine.
 0291 B7        	ora	a	;see if an error occured.
                	jrnz	selerr
 0292+201D      	DB	20H,SELERR-$-1
 0294 3AC305    	lda	@rcnfg
 0297 B7        	ora	a
 0298 C4EC02    	cnz	setup$dph
                	jrc	selerr
 029B+3814      	DB	38H,SELERR-$-1
 029D 3A6B00    	lda	@adrv
 02A0 87        	add	a
 02A1 4F        	mov	c,a
 02A2 0600      	mvi	b,0
 02A4 210302    	lxi	h,@dtbl
 02A7 09        	dad	b
                	lded	@dph
 02A8+ED5B      	DB	0EDH,5BH
 02AA+7200      	DW	@DPH
 02AC 73        	mov	m,e	;set current DPH in @dtbl
 02AD 23        	inx	h
 02AE 72        	mov	m,d
                	jr	selcom	;DE=dph
 02AF+1816      	DB	18H,SELCOM-$-1
                
 02B1 210000    selerr: lxi	h,0
 02B4 C9        	ret
                
 02B5 3A6B00    notlgi: lda	@adrv
 02B8 87        	add	a
 02B9 4F        	mov	c,a
 02BA 0600      	mvi	b,0
 02BC 210302    	lxi	h,@dtbl
 02BF 09        	dad	b
 02C0 5E        	mov	e,m	;get current DPH from @dtbl
 02C1 23        	inx	h
 02C2 56        	mov	d,m	;DE=dph
                	sded	@dph
 02C3+ED53      	DB	0EDH,53H
 02C5+7200      	DW	@DPH
                selcom:
 02C7 210A00    	lxi	h,+10
 02CA 19        	dad	d	;point to DPB entry
 02CB 4E        	mov	c,m
 02CC 23        	inx	h
 02CD 46        	mov	b,m
 02CE 0A        	ldax	b	;SPT (logical)
 02CF 32C205    	sta	@spt
 02D2 210300    	lxi	h,+3
 02D5 09        	dad	b
 02D6 7E        	mov	a,m	;BSM
 02D7 32CF05    	sta	blkmsk
 02DA 210D00    	lxi	h,+13	;point to track offset
 02DD 09        	dad	b
 02DE 4E        	mov	c,m
 02DF 23        	inx	h
 02E0 46        	mov	b,m
 02E1 23        	inx	h
                	sbcd	offset
 02E2+ED43      	DB	0EDH,43H
 02E4+C505      	DW	OFFSET
 02E6 7E        	mov	a,m	;psh
 02E7 32C405    	sta	blcode
 02EA EB        	xchg		;put DPH in (HL) for BDOS
 02EB C9        	ret
                
                setup$dph:
 02EC B7        	ora	a	;reset [CY]
 02ED 2A7000    	lhld	@cmode	;HL=modes
                	bit	7,m	;check for hard-disk drive (modes not standard)
 02F0+CB7E      	DB	0CBH,7*8+M+40H
 02F2 C0        	rnz
 02F3 37        	stc
 02F4 C9        	ret
                
 02F5 010000    home:	lxi b,0 	; same as set track zero
                settrk: sbcd @trk
 02F8+ED43      	DB	0EDH,43H
 02FA+BD05      	DW	@TRK
 02FC C9        	ret
                
                setsec: sbcd @sect
 02FD+ED43      	DB	0EDH,43H
 02FF+BF05      	DW	@SECT
 0301 C9        	ret
                
                setdma:
 0302 78        	mov	a,b
 0303 A1        	ana	c
 0304 FEFF      	cpi	true
 0306 CA4A05    	jz	flushall
                	sbcd	@dma
 0309+ED43      	DB	0EDH,43H
 030B+8800      	DW	@DMA
 030D C9        	ret
                
 030E 6960      sectrn: mov l,c ! mov h,b
 0310 7AB3C8    	mov a,d ! ora e ! rz
 0313 EB096E2600	xchg ! dad b ! mov l,m ! mvi h,0
 0318 2B        	dcx	h	;sectors numbered 0 - (n-1)
 0319 C9        	ret
                
                
                read:
 031A 3EFF      	mvi	a,true		; FLAG A READ OPERATION
 031C 32C905    	sta	preread 	; forces FLUSH and Physical READ
 031F 32D005    	sta	rdflg
 0322 32CA05    	sta	defer		; never flush if reading (pointless)
 0325 2F        	cma	; false
 0326 32CB05    	sta	unalloc ;terminate any active unallocated-writing
 0329 2AD205    	LHLD	REQTRK
 032C 3AC505    	lda	OFFSET
 032F 95        	sub	l	; DIR track must be < 256
 0330 B4        	ora	h	; 00=on DIR track
 0331 2ABF05    	lhld	@sect
 0334 B4        	ora	h	;
 0335 B5        	ora	l	; 00=first sector of directory
 0336 D601      	sui	1	; CY = 1st sec of dir
 0338 9F        	sbb	a	; FF = 1st sec of dir, else 00
 0339 32C805    	sta	dir0
                	jr	rwoper
 033C+1852      	DB	18H,RWOPER-$-1
                
                write:
 033E AF        	xra	a
 033F 32C805    	sta	dir0
 0342 32D005    	sta	rdflg
 0345 3EFF      	mvi	a,true
 0347 32C905    	STA	preread 	; assume a PRE-READ
 034A 79        	mov	a,c
 034B E601      	ani	1		; 00 = defered write, else 01
 034D 3D        	dcr	a		; FF = defer, else 00
 034E 32CA05    	sta	defer
                	bit	1,c		; write to 1st sector of unallocated block ?
 0351+CB49      	DB	0CBH,1*8+C+40H
                	jrz	CHKUNA
 0353+280D      	DB	28H,CHKUNA-$-1
                	SDED	URECORD 	; SET UNALLOCATED RECORD #
 0355+ED53      	DB	0EDH,53H
 0357+CC05      	DW	URECORD
 0359 78        	mov	a,b
 035A 32CE05    	sta	urecord+2
 035D 3EFF      	mvi	a,true
 035F 32CB05    	STA	UNALLOC 	; FLAG WRITING OF AN UNALLOCATED BLOCK
 0362 3ACB05    CHKUNA: LDA	UNALLOC 	; ARE WE WRITING AN UNALLOCATED BLOCK ?
 0365 B7        	ORA	A
                	JRZ	rwoper
 0366+2828      	DB	28H,RWOPER-$-1
 0368 2ACC05    	LHLD	URECORD 	; IS REQUESTED RECORD SAME AS EXPECTED
                	DSBC	D		;  SAME AS EXPECTED UNALLOCATED RECORD ?
 036B+ED52      	DB	0EDH,D*8+42H
                	JRNZ	ALLOC		; IF NOT, THEN DONE WITH UNALLOCATED BLOCK
 036D+201D      	DB	20H,ALLOC-$-1
 036F 3ACE05    	lda	urecord+2
 0372 90        	sub	b
                	jrnz	alloc
 0373+2017      	DB	20H,ALLOC-$-1
 0375 AF        	XRA	A		; CLEAR PRE-READ FLAG
 0376 32C905    	STA	preread
 0379 210100    	lxi	h,1		; INCREMENT TO NEXT EXPECTED UNALLOCATED RECORD
 037C 19        	dad	d
 037D 22CC05    	shld	urecord
 0380 3E00      	mvi	a,0
 0382 88        	adc	b
 0383 32CE05    	sta	urecord+2
 0386 3ACF05    	LDA	BLKMSK
 0389 A5        	ana	l		; IS IT THE START OF A NEW BLOCK ?
                	JRNZ	rwoper
 038A+2004      	DB	20H,RWOPER-$-1
 038C AF        ALLOC:	XRA	A		; NO LONGER WRITING AN UNALLOCATED BLOCK
 038D 32CB05    	STA	UNALLOC
                rwoper:
                	; RLR - Ready List Root - points to the current process
 0390 2AD605    	lhld	rlr
 0393 4E        	mov	c,m
 0394 23        	inx	h
 0395 46        	mov	b,m	;BC=PDAdr, must be preserved throughout.
                ; get a buffer for this disk access...
                 if lrubuf
                	lixd	hsttop
 0396+DD2A      	DB	0DDH,2AH
 0398+DA05      	DW	HSTTOP
 039A 210000    	lxi	h,0
 039D 22DE05    	shld	previous
 03A0 2ADA05    	lhld	hsttop
 03A3 7C        	mov	a,h
 03A4 B5        	ora	l
 03A5 C2AE03    	jnz	sd0
 03A8 2ADC05    	lhld	fretop
 03AB C3DB03    	jmp	sd1
                sd0:	ldx	e,link
 03AE+DD5E00    	DB	0DDH,E*8+46H,LINK
                	ldx	d,link+1
 03B1+DD5601    	DB	0DDH,D*8+46H,LINK+1
                	ldx	l,hstpda
 03B4+DD6E02    	DB	0DDH,L*8+46H,HSTPDA
                	ldx	h,hstpda+1
 03B7+DD6603    	DB	0DDH,H*8+46H,HSTPDA+1
 03BA B7        	ora	a
                	dsbc	b	;compare P.D.Adr
 03BB+ED42      	DB	0EDH,B*8+42H
 03BD CAE603    	jz	sd2
 03C0 7A        	mov	a,d
 03C1 B3        	ora	e
 03C2 CACF03    	jz	sd3
                	sixd	previous
 03C5+DD22      	DB	0DDH,22H
 03C7+DE05      	DW	PREVIOUS
 03C9 D5        	push	d
                	popix
 03CA+DDE1      	DB	0DDH,0E1H
 03CC C3AE03    	jmp	sd0
                sd3:	sixd	last
 03CF+DD22      	DB	0DDH,22H
 03D1+E005      	DW	LAST
 03D3 2ADC05    	lhld	fretop
 03D6 7C        	mov	a,h
 03D7 B5        	ora	l
 03D8 CAF703    	jz	sd4
 03DB 5E        sd1:	mov	e,m
 03DC 23        	inx	h
 03DD 56        	mov	d,m
 03DE 2B        	dcx	h
                	sded	fretop
 03DF+ED53      	DB	0EDH,53H
 03E1+DC05      	DW	FRETOP
 03E3 C30D04    	jmp	setbuf
                ; found our buffer, may not be at top of list.
 03E6 2ADE05    sd2:	lhld	previous	;patch previous bufr to skip this one,
 03E9 7C        	mov	a,h		;unless this is already first.
 03EA B5        	ora	l
 03EB CA2304    	jz	sd5
 03EE 73        	mov	m,e
 03EF 23        	inx	h
 03F0 72        	mov	m,d
                	pushix
 03F1+DDE5      	DB	0DDH,0E5H
 03F3 E1        	pop	h	; move this bufr to top of list (most recently used)
 03F4 C31504    	jmp	setbuf1
                ; No existing buffer, no free buffers, must take last on list.
                sd4:	lixd	previous	;no existing in-use bufr, no free bufr.
 03F7+DD2A      	DB	0DDH,2AH
 03F9+DE05      	DW	PREVIOUS
                	mvix	0,link		;remove last buffer in list,
 03FB+DD360000  	DB	0DDH,36H,LINK,0
                	mvix	0,link+1	;patching previous to be new end.
 03FF+DD360100  	DB	0DDH,36H,LINK+1,0
                	liyd	last	;must flush this buffer, if write pending.
 0403+FD2A      	DB	0FDH,2AH
 0405+E005      	DW	LAST
 0407 CD9805    	call	flush	; ERROR will return directly to BDOS (pop h, ret)
 040A 2AE005    	lhld	last	;
                ;	jmp	setbuf
 040D EB        setbuf: xchg
 040E 210700    	lxi	h,hstdsk
 0411 19        	dad	d
 0412 36FF      	mvi	m,-1	;invalidate buffer.
 0414 EB        	xchg
                setbuf1:lded	hsttop	;used to be top of list, now make it 2nd.
 0415+ED5B      	DB	0EDH,5BH
 0417+DA05      	DW	HSTTOP
 0419 22DA05    	shld	hsttop	;put selected bufr at top of list.
 041C 73        	mov	m,e	;set link
 041D 23        	inx	h
 041E 72        	mov	m,d
 041F 23        	inx	h
 0420 71        	mov	m,c	;BC must still = P.D.Adr
 0421 23        	inx	h
 0422 70        	mov	m,b
                sd5:
                 else
                	lxi	h,xxhdr
                	shld	hsttop
                 endif
                	; BC is still PDAdr
                	liyd	hsttop
 0423+FD2A      	DB	0FDH,2AH
 0425+DA05      	DW	HSTTOP
 0427 3A6C00    	lda	@pdrv		; Calculate physical sector, etc
 042A 32D105    	sta	reqdsk
 042D CD0302    	call	getusrbnk
 0430 2ABD05    	lhld	@trk
 0433 22D205    	shld	reqtrk
 0436 0E00      	MVI	C,0		; CALCULATE PHYSICAL SECTOR
 0438 3AC405    	LDA	blcode		; PHYSICAL SECTOR SIZE CODE
 043B B7        	ORA	A		; TEST FOR ZERO
 043C 47        	MOV	B,A
                	lded	@sect
 043D+ED5B      	DB	0EDH,5BH
 043F+BF05      	DW	@SECT
                	JRZ	DBLOK3		; 128 BYTE SECTORS ?
 0441+280D      	DB	28H,DBLOK3-$-1
                DBLOK1: srlr	d		; DIVIDE BY 2
 0443+CB3A      	DB	0CBH, 38H + D
                	rarr	e
 0445+CB1B      	DB	0CBH, 18H + E
                	RARR	C		; SAVE OVERFLOW BITS
 0447+CB19      	DB	0CBH, 18H + C
                	DJNZ	DBLOK1		; AND CONTINUE IF BLOCKING STILL <> 0
 0449+10F8      	DB	10H,DBLOK1-$-1
 044B 47        	mov	b,a
                DBLOK2: RLCR	C		; NOW RESTORE THE OVERFLOW BY
 044C+CB01      	DB	0CBH, 00H + C
                	DJNZ	DBLOK2		; ROTATING IT RIGHT
 044E+10FC      	DB	10H,DBLOK2-$-1
 0450 79        DBLOK3: MOV	A,C
 0451 32C705    	sta	blksec		; STORE IT
                	sded	reqsec
 0454+ED53      	DB	0EDH,53H
 0456+D405      	DW	REQSEC
                
                chk1:	ldy	e,link		; next buffer, or 0000
 0458+FD5E00    	DB	0FDH,E*8+46H,LINK
                	ldy	d,link+1	;
 045B+FD5601    	DB	0FDH,D*8+46H,LINK+1
 045E 7A        	mov	a,d
 045F B3        	ora	e
                	jrz	chk2
 0460+2859      	DB	28H,CHK2-$-1
 0462 D5        	push	d
                	popiy
 0463+FDE1      	DB	0FDH,0E1H
 0465 210700    	lxi	h,hstdsk
 0468 19        	dad	d
 0469 11D105    	lxi	d,reqdsk
 046C 0605      	mvi	b,5
 046E 1A        chk0:	ldax	d
 046F BE        	cmp	m
                	jrnz	chk1
 0470+20E6      	DB	20H,CHK1-$-1
 0472 23        	inx	h
 0473 13        	inx	d
                	djnz	chk0
 0474+10F8      	DB	10H,CHK0-$-1
 0476 CD9805    	call	flush	;an error bumps us out here.
                	siyd	previous	;save pointer
 0479+FD22      	DB	0FDH,22H
 047B+DE05      	DW	PREVIOUS
 047D 3AD005    	lda	rdflg
 0480 B7        	ora	a
                	jrnz	chk3
 0481+2004      	DB	20H,CHK3-$-1
                	mviy	-1,hstdsk	;invalidate their buffer if we are writing.
 0483+FD3607FF  	DB	0FDH,36H,HSTDSK,-1
                chk3:	liyd	hsttop	;restore IY
 0487+FD2A      	DB	0FDH,2AH
 0489+DA05      	DW	HSTTOP
 048B 3AC805    	lda	dir0
 048E B7        	ora	a
                	jrnz	readit	;don't bother to move data if a read is forced...
 048F+204B      	DB	20H,READIT-$-1
 0491 CD9805    chk4:	call	flush		; must flush our buffer BEFORE changing data.
                	ldy	l,hstbuf	; destination - our buffer
 0494+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1	;
 0497+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
                	ldy	b,hstbnk	;
 049A+FD460E    	DB	0FDH,B*8+46H,HSTBNK
                	lixd	previous
 049D+DD2A      	DB	0DDH,2AH
 049F+DE05      	DW	PREVIOUS
                	ldx	e,hstbuf	; source
 04A1+DD5E0C    	DB	0DDH,E*8+46H,HSTBUF
                	ldx	d,hstbuf+1	;
 04A4+DD560D    	DB	0DDH,D*8+46H,HSTBUF+1
                	ldx	c,hstbnk	;
 04A7+DD4E0E    	DB	0DDH,C*8+46H,HSTBNK
 04AA 3E01      	mvi	a,1	; interrupts are enabled
 04AC CD0000    	call	?xmove		;
 04AF 010002    	lxi	b,secsize	; put requested sector data in our buffer
 04B2 CD0000    	call	?move		;
 04B5 AF        	xra	a
 04B6 32C905    	sta	preread
                	jr	readit0
 04B9+1824      	DB	18H,READIT0-$-1
                chk2:	liyd	hsttop	;restore IY
 04BB+FD2A      	DB	0FDH,2AH
 04BD+DA05      	DW	HSTTOP
 04BF 3AC805    	lda	dir0
 04C2 B7        	ora	a
                	jrnz	readit
 04C3+2017      	DB	20H,READIT-$-1
 04C5 2ADA05    chkbuf: lhld	hsttop
 04C8 110700    	lxi	d,hstdsk
 04CB 19        	dad	d
 04CC EB        	xchg
 04CD 21D105    	lxi	h,reqdsk
 04D0 0605      	mvi	b,5
 04D2 1A        chkbuf1:ldax	d
 04D3 BE        	cmp	m
                	jrnz	readit
 04D4+2006      	DB	20H,READIT-$-1
 04D6 23        	inx	h
 04D7 13        	inx	d
                	djnz	chkbuf1
 04D8+10F8      	DB	10H,CHKBUF1-$-1
                	jr	noread		;  THEN NO NEED TO PRE-READ
 04DA+182D      	DB	18H,NOREAD-$-1
 04DC CD9805    readit: call	flush
 04DF 2ADA05    readit0:lhld	hsttop		; SET UP NEW BUFFER PARAMETERS
 04E2 110700    	lxi	d,hstdsk
 04E5 19        	dad	d
 04E6 EB        	xchg
 04E7 21D105    	lxi	h,reqdsk	; set HSTDSK,HSTTRK,HSTSEC
 04EA 010500    	lxi	b,5		;
                	ldir			;
 04ED+EDB0      	DB	0EDH,0B0H
 04EF 2A6E00    	lhld	curmdl
                	sty	l,hstmdl
 04F2+FD750F    	DB	0FDH,70H+L,HSTMDL
                	sty	h,hstmdl+1
 04F5+FD7410    	DB	0FDH,70H+H,HSTMDL+1
 04F8 2A7000    	lhld	@cmode
                	sty	l,hstmod
 04FB+FD7504    	DB	0FDH,70H+L,HSTMOD
                	sty	h,hstmod+1
 04FE+FD7405    	DB	0FDH,70H+H,HSTMOD+1
 0501 3AC905    	lda	preread
 0504 B7        	ora	a
 0505 C4A705    	cnz	pread		; READ THE SECTOR
 0508 C0        	rnz		;stop here if error
                noread: ldy	l,hstbuf	; POINT TO START OF SECTOR BUFFER
 0509+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1
 050C+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
 050F 018000    	lxi	b,128
 0512 3AC705    	lda	blksec		; POINT TO LOCATION OF CORRECT LOGICAL SECTOR
 0515 3D        movit1: dcr	a
 0516 FA1C05    	jm	movit2
 0519 09        	dad	b
                	jr	movit1
 051A+18F9      	DB	18H,MOVIT1-$-1
                movit2:
                	; TODO: need to handle possible common memory DMA
                	lded	@dma		; POINT TO DMA
 051C+ED5B      	DB	0EDH,5BH
 051E+8800      	DW	@DMA
 0520 3A1900    	lda	@dbnk
 0523 EB        	xchg		;DE is source, HL is dest.
 0524 47        	mov	b,a		;B=dest. bank
                	ldy	c,hstbnk	;C=source bank
 0525+FD4E0E    	DB	0FDH,C*8+46H,HSTBNK
 0528 3AD005    	lda	rdflg		; IS IT A WRITE ?
 052B B7        	ora	a
                	jrnz	movit3
 052C+2008      	DB	20H,MOVIT3-$-1
 052E 79        	mov	a,c
 052F 48        	mov	c,b
 0530 47        	mov	b,a
 0531 EB        	xchg			; SWITCH DIRECTION OF MOVE FOR WRITE
                	mviy	true,pndwrt	; FLAG A PENDING WRITE
 0532+FD3606FF  	DB	0FDH,36H,PNDWRT,TRUE
 0536 CD0000    movit3: call	?xmove
 0539 018000    	lxi	b,128
 053C 3E01      	mvi	a,1	; interrupts are enabled
 053E CD0000    	call	?move		; MOVE IT
 0541 3ACA05    	lda	defer		; CHECK FOR non-defered write
 0544 B7        	ora	a
 0545 CC9805    	cz	flush		; WRITE THE SECTOR IF IT IS
 0548 AF        	xra	a		; FLAG NO ERROR
 0549 C9        	ret			; RETURN TO BDOS
                
                flushall:
                 if lrubuf
                	lded	hsttop
 054A+ED5B      	DB	0EDH,5BH
 054C+DA05      	DW	HSTTOP
 054E 7A        	mov	a,d
 054F B3        	ora	e
 0550 C8        	rz		;no buffers in use.
 0551 21DA05    	lxi	h,hsttop
 0554 22DE05    	shld	previous
 0557 2AD605    	lhld	rlr
 055A 4E        	mov	c,m
 055B 23        	inx	h
 055C 46        	mov	b,m	;BC = PDAdr, must be preserved
 055D 210200    fls0:	lxi	h,hstpda
 0560 19        	dad	d
 0561 7E        	mov	a,m
 0562 23        	inx	h
 0563 66        	mov	h,m
 0564 6F        	mov	l,a
 0565 B7        	ora	a
                	dsbc	b	;compare P.D. adr
 0566+ED42      	DB	0EDH,B*8+42H
 0568 CA7805    	jz	flush1
 056B EB        	xchg
 056C 22DE05    	shld	previous
 056F 5E        	mov	e,m
 0570 23        	inx	h
 0571 56        	mov	d,m
 0572 7A        	mov	a,d
 0573 B3        	ora	e
 0574 C25D05    	jnz	fls0
 0577 C9        	ret
                
                ; TODO: could there be more than one?
                ; might need to resume flushall...
 0578 D5        flush1: push	d
                	popiy
 0579+FDE1      	DB	0FDH,0E1H
 057B 2ADE05    	lhld	previous
                	ldy	a,link
 057E+FD7E00    	DB	0FDH,A*8+46H,LINK
 0581 77        	mov	m,a
 0582 23        	inx	h
                	ldy	a,link+1
 0583+FD7E01    	DB	0FDH,A*8+46H,LINK+1
 0586 77        	mov	m,a
 0587 2ADC05    	lhld	fretop
                	sty	l,link
 058A+FD7500    	DB	0FDH,70H+L,LINK
                	sty	h,link+1
 058D+FD7401    	DB	0FDH,70H+H,LINK+1
                	siyd	fretop
 0590+FD22      	DB	0FDH,22H
 0592+DC05      	DW	FRETOP
                 else
                	lxiy	xxhdr
                 endif
 0594 CD9805    	call	flush	; must handle stupid stack tricks
 0597 C9        	ret
                
                ; Requires 2 ret adrs on stack, returns to imm caller on success,
                ; returns to caller's caller on error.
                flush:	ldy	a,pndwrt
 0598+FD7E06    	DB	0FDH,A*8+46H,PNDWRT
 059B B7        	ora	a
 059C C8        	rz
                	mviy	false,pndwrt
 059D+FD360600  	DB	0FDH,36H,PNDWRT,FALSE
 05A1 CDAC05    	call	pwrite
 05A4 C8        	rz
 05A5 E1        	pop	h
 05A6 C9        	ret
                
                ; IY=buffer header
 05A7 1E06      pread:	mvi	e,6	;read entry is +6
 05A9 C3AE05    	jmp rw$common			; use common code
                
 05AC 1E09      pwrite: mvi	e,9	;write entry is +9
                
                rw$common:	;do any track/sector/side conversion...
                ;	xra	a
                ;	sta	@side
                ;	; Only "hard disk" supported...
                ;	ldy	l,hstmod
                ;	ldy	h,hstmod+1
                ;	bit	7,m	;floppy or hard-disk?
                ;	jrnz	rw0
                rw0:
 05AE 7B        	mov	a,e	; read(6) or write(9)
                	ldy	l,hstmdl
 05AF+FD6E0F    	DB	0FDH,L*8+46H,HSTMDL
                	ldy	h,hstmdl+1
 05B2+FD6610    	DB	0FDH,H*8+46H,HSTMDL+1
                calmod:
 05B5 85        	add	l
 05B6 6F        	mov	l,a
 05B7 3E00      	mvi	a,0
 05B9 8C        	adc	h
 05BA 67        	mov	h,a
 05BB E9        	pchl		; leap to driver
                
 05BC           @side:	ds	1		; current side of media (floppy only)
 05BD           @trk:	ds	2		; current track number
 05BF           @sect:	ds	2		; current sector number
 05C1 00        @cnt:	db	0		; record count for multisector transfer
 05C2           @spt:	ds	1
 05C3           @rcnfg: ds	1
                
 05C4           blcode: ds	1	;blocking code, PSH
 05C5           offset: ds	2
 05C7           blksec: ds	1
 05C8           dir0:	ds	1
 05C9           preread:ds	1
 05CA           defer:	ds	1
 05CB           unalloc:ds	1
 05CC           urecord:ds	3
 05CF           blkmsk: ds	1
 05D0           rdflg:	ds	1
                
 05D1           reqdsk: ds	1
 05D2           reqtrk: ds	2
 05D4           reqsec: ds	2
                
 05D6 0000      rlr:	dw	0
 05D8 0000      msegtbl: dw	0
                
 05DA 0000      hsttop:   dw	0
                 if lrubuf
 05DC E205      fretop:   dw	hsthdr
 05DE 0000      previous: dw	0
 05E0 0000      last:	  dw	0
                
 0010 =         numbuf	equ	16
 0000 =         @@bnk	equ	0
 0100 #         @@ set 0100h	;start of buffers in bank
                		; (numbuf + 2) * secsize, buffers used,
                		; must not overrun system. At 512b and 16 bufs,
                		; this consumes 0100-2500, MP/M starts about A900.
                hsthdr: rept	numbuf
                	dw	$+hstlen ;Link
                	dw	0	;hstpda - Process Descriptor Address
                	dw	0	;hstmod
                	db	false	;pndwrt
                	db	-1	;hstdsk
                	dw	0	;hsttrk
                	dw	0	;hstsec
                	dw	@@	;hstbuf
                	db	@@bnk	;hstbnk
                	dw	0	;hstmdl
                @@ set @@+secsize
                	endm
 05E2+F305      	DW	$+HSTLEN ;LINK
 05E4+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 05E6+0000      	DW	0	;HSTMOD
 05E8+00        	DB	FALSE	;PNDWRT
 05E9+FF        	DB	-1	;HSTDSK
 05EA+0000      	DW	0	;HSTTRK
 05EC+0000      	DW	0	;HSTSEC
 05EE+0001      	DW	@@	;HSTBUF
 05F0+00        	DB	@@BNK	;HSTBNK
 05F1+0000      	DW	0	;HSTMDL
 05F3+0406      	DW	$+HSTLEN ;LINK
 05F5+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 05F7+0000      	DW	0	;HSTMOD
 05F9+00        	DB	FALSE	;PNDWRT
 05FA+FF        	DB	-1	;HSTDSK
 05FB+0000      	DW	0	;HSTTRK
 05FD+0000      	DW	0	;HSTSEC
 05FF+0003      	DW	@@	;HSTBUF
 0601+00        	DB	@@BNK	;HSTBNK
 0602+0000      	DW	0	;HSTMDL
 0604+1506      	DW	$+HSTLEN ;LINK
 0606+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0608+0000      	DW	0	;HSTMOD
 060A+00        	DB	FALSE	;PNDWRT
 060B+FF        	DB	-1	;HSTDSK
 060C+0000      	DW	0	;HSTTRK
 060E+0000      	DW	0	;HSTSEC
 0610+0005      	DW	@@	;HSTBUF
 0612+00        	DB	@@BNK	;HSTBNK
 0613+0000      	DW	0	;HSTMDL
 0615+2606      	DW	$+HSTLEN ;LINK
 0617+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0619+0000      	DW	0	;HSTMOD
 061B+00        	DB	FALSE	;PNDWRT
 061C+FF        	DB	-1	;HSTDSK
 061D+0000      	DW	0	;HSTTRK
 061F+0000      	DW	0	;HSTSEC
 0621+0007      	DW	@@	;HSTBUF
 0623+00        	DB	@@BNK	;HSTBNK
 0624+0000      	DW	0	;HSTMDL
 0626+3706      	DW	$+HSTLEN ;LINK
 0628+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 062A+0000      	DW	0	;HSTMOD
 062C+00        	DB	FALSE	;PNDWRT
 062D+FF        	DB	-1	;HSTDSK
 062E+0000      	DW	0	;HSTTRK
 0630+0000      	DW	0	;HSTSEC
 0632+0009      	DW	@@	;HSTBUF
 0634+00        	DB	@@BNK	;HSTBNK
 0635+0000      	DW	0	;HSTMDL
 0637+4806      	DW	$+HSTLEN ;LINK
 0639+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 063B+0000      	DW	0	;HSTMOD
 063D+00        	DB	FALSE	;PNDWRT
 063E+FF        	DB	-1	;HSTDSK
 063F+0000      	DW	0	;HSTTRK
 0641+0000      	DW	0	;HSTSEC
 0643+000B      	DW	@@	;HSTBUF
 0645+00        	DB	@@BNK	;HSTBNK
 0646+0000      	DW	0	;HSTMDL
 0648+5906      	DW	$+HSTLEN ;LINK
 064A+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 064C+0000      	DW	0	;HSTMOD
 064E+00        	DB	FALSE	;PNDWRT
 064F+FF        	DB	-1	;HSTDSK
 0650+0000      	DW	0	;HSTTRK
 0652+0000      	DW	0	;HSTSEC
 0654+000D      	DW	@@	;HSTBUF
 0656+00        	DB	@@BNK	;HSTBNK
 0657+0000      	DW	0	;HSTMDL
 0659+6A06      	DW	$+HSTLEN ;LINK
 065B+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 065D+0000      	DW	0	;HSTMOD
 065F+00        	DB	FALSE	;PNDWRT
 0660+FF        	DB	-1	;HSTDSK
 0661+0000      	DW	0	;HSTTRK
 0663+0000      	DW	0	;HSTSEC
 0665+000F      	DW	@@	;HSTBUF
 0667+00        	DB	@@BNK	;HSTBNK
 0668+0000      	DW	0	;HSTMDL
 066A+7B06      	DW	$+HSTLEN ;LINK
 066C+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 066E+0000      	DW	0	;HSTMOD
 0670+00        	DB	FALSE	;PNDWRT
 0671+FF        	DB	-1	;HSTDSK
 0672+0000      	DW	0	;HSTTRK
 0674+0000      	DW	0	;HSTSEC
 0676+0011      	DW	@@	;HSTBUF
 0678+00        	DB	@@BNK	;HSTBNK
 0679+0000      	DW	0	;HSTMDL
 067B+8C06      	DW	$+HSTLEN ;LINK
 067D+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 067F+0000      	DW	0	;HSTMOD
 0681+00        	DB	FALSE	;PNDWRT
 0682+FF        	DB	-1	;HSTDSK
 0683+0000      	DW	0	;HSTTRK
 0685+0000      	DW	0	;HSTSEC
 0687+0013      	DW	@@	;HSTBUF
 0689+00        	DB	@@BNK	;HSTBNK
 068A+0000      	DW	0	;HSTMDL
 068C+9D06      	DW	$+HSTLEN ;LINK
 068E+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0690+0000      	DW	0	;HSTMOD
 0692+00        	DB	FALSE	;PNDWRT
 0693+FF        	DB	-1	;HSTDSK
 0694+0000      	DW	0	;HSTTRK
 0696+0000      	DW	0	;HSTSEC
 0698+0015      	DW	@@	;HSTBUF
 069A+00        	DB	@@BNK	;HSTBNK
 069B+0000      	DW	0	;HSTMDL
 069D+AE06      	DW	$+HSTLEN ;LINK
 069F+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06A1+0000      	DW	0	;HSTMOD
 06A3+00        	DB	FALSE	;PNDWRT
 06A4+FF        	DB	-1	;HSTDSK
 06A5+0000      	DW	0	;HSTTRK
 06A7+0000      	DW	0	;HSTSEC
 06A9+0017      	DW	@@	;HSTBUF
 06AB+00        	DB	@@BNK	;HSTBNK
 06AC+0000      	DW	0	;HSTMDL
 06AE+BF06      	DW	$+HSTLEN ;LINK
 06B0+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06B2+0000      	DW	0	;HSTMOD
 06B4+00        	DB	FALSE	;PNDWRT
 06B5+FF        	DB	-1	;HSTDSK
 06B6+0000      	DW	0	;HSTTRK
 06B8+0000      	DW	0	;HSTSEC
 06BA+0019      	DW	@@	;HSTBUF
 06BC+00        	DB	@@BNK	;HSTBNK
 06BD+0000      	DW	0	;HSTMDL
 06BF+D006      	DW	$+HSTLEN ;LINK
 06C1+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06C3+0000      	DW	0	;HSTMOD
 06C5+00        	DB	FALSE	;PNDWRT
 06C6+FF        	DB	-1	;HSTDSK
 06C7+0000      	DW	0	;HSTTRK
 06C9+0000      	DW	0	;HSTSEC
 06CB+001B      	DW	@@	;HSTBUF
 06CD+00        	DB	@@BNK	;HSTBNK
 06CE+0000      	DW	0	;HSTMDL
 06D0+E106      	DW	$+HSTLEN ;LINK
 06D2+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06D4+0000      	DW	0	;HSTMOD
 06D6+00        	DB	FALSE	;PNDWRT
 06D7+FF        	DB	-1	;HSTDSK
 06D8+0000      	DW	0	;HSTTRK
 06DA+0000      	DW	0	;HSTSEC
 06DC+001D      	DW	@@	;HSTBUF
 06DE+00        	DB	@@BNK	;HSTBNK
 06DF+0000      	DW	0	;HSTMDL
 06E1+F206      	DW	$+HSTLEN ;LINK
 06E3+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06E5+0000      	DW	0	;HSTMOD
 06E7+00        	DB	FALSE	;PNDWRT
 06E8+FF        	DB	-1	;HSTDSK
 06E9+0000      	DW	0	;HSTTRK
 06EB+0000      	DW	0	;HSTSEC
 06ED+001F      	DW	@@	;HSTBUF
 06EF+00        	DB	@@BNK	;HSTBNK
 06F0+0000      	DW	0	;HSTMDL
                 endif
 06F2 0000      xxhdr:	dw	0	;Link - initially last in list.
 06F4 0000      	dw	0	;hstpda
 06F6 0000      	dw	0	;hstmod
 06F8 00        	db	false	;pndwrt
 06F9 FF        	db	-1	;hstdsk
 06FA 0000      	dw	0	;hsttrk
 06FC 0000      	dw	0	;hstsec
 06FE 0021      	dw	@@	;hstbuf
 0700 00        	db	@@bnk	;hstbnk
 0701 0000      	dw	0	;hstmdl
 2300 #         @@ set @@+secsize
                
                ; NOTE: this buffer can be used for reading only. (it is never flushed)
 0703 0000      @scrcb: dw	0	;link - not used
 0705 0000      	dw	0	;hstpda - not used
 0707 0000      	dw	0	;hstmod
 0709 00        	db	false	;pndwrt - assumed always false
 070A FF        	db	-1	;hstdsk
 070B 0000      	dw	0	;hsttrk
 070D 0000      	dw	0	;hstsec
 070F 0023      	dw	@@	;hstbuf
 0711 00        	db	@@bnk	;hstbnk
 0712 0000      	dw	0	;hstmdl
                
 0714           	end
