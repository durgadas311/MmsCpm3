 6130 =         vers equ '0a' ; Nov 14, 2021  13:49  drm "MXIOS.ASM"
                ;****************************************************************
                ; MP/M main XIOS module for Z180 on the H8/H89			*
                ; Derived from the MMS 77500 server XIOS			*
                ; Copyright (c) 1983 Magnolia Microsystems			*
                ;****************************************************************
                ; All memory segments are ORGed at 0000.
                ; Uses CP/M Plus format DPBs.
                
                	maclib z180
                
 0000 =         false	equ	0
 FFFF =         true	equ	not false
                
 FFFF =         lrubuf	equ	true	;
                
                	public	@adrv,@pdrv,@rdrv,@side,@trk,@sect
                	public	@dma,@dbnk,@dirbf
                	public	@dstat,@cmode,@dph,@rcnfg,@eops
                	public	@cbnk,@scrcb,@vect,@secnd
                
                	public	xdos,polltb,sysdat
                
                	extrn	@lptbl
                	extrn	?memsl,?bnksl,?bnkck,?xmove,?move	; MMU module
                	extrn	@memstr,@mmerr,@nbnk
                	extrn	?time,?itime,@rtcstr			; RTC module
                
 0800 =         tickrate	equ	2048	; 50 ticks/second at 2.048MHz
                				; *=2 for each 2x speed bump
 0200 =         secsize		equ	512	; largest sector size supported/used
                
 000D =         cr	equ 13
 000A =         lf	equ 10
 0007 =         bell	equ 7
                
 0000 =         cpm	equ	0
 0005 =         bdos	equ	5
                
 0083 =         poll	equ	131
 0085 =         flagset equ	133
                
                ;relative position of elements in buffer headers:
 0000 =         link	equ	0	;link to next headr, or 0
 0002 =         hstpda	equ	2	;Process Descriptor Adr of owner
 0004 =         hstmod	equ	4	;mode pointer (partition address)
 0006 =         pndwrt	equ	6	;pending write flag
 0007 =         hstdsk	equ	7	;host disk
 0008 =         hsttrk	equ	8	;host track
 000A =         hstsec	equ	10	;host sector
 000C =         hstbuf	equ	12	;host buffer address
 000E =         hstbnk	equ	14	;host bank
 000F =         hstmdl	equ	15	;host module entry
 0011 =         hstlen	equ	17	;length of header
                
                ; Z180 registers
 0034 =         itc	equ	34h
 0036 =         rcr	equ	36h
 0038 =         mmu$cbr	equ	38h
 0039 =         mmu$bbr	equ	39h
 003A =         mmu$cbar equ	3ah
 0020 =         sar0l	equ	20h
 0021 =         sar0h	equ	21h
 0022 =         sar0b	equ	22h
 0023 =         dar0l	equ	23h
 0024 =         dar0h	equ	24h
 0025 =         dar0b	equ	25h
 0026 =         bcr0l	equ	26h
 0027 =         bcr0h	equ	27h
 0030 =         dstat	equ	30h
 0031 =         dmode	equ	31h
 0032 =         dcntl	equ	32h
 0033 =         il	equ	33h
 000C =         tmdr0l	equ	0ch
 000D =         tmdr0h	equ	0dh
 000E =         rldr0l	equ	0eh
 000F =         rldr0h	equ	0fh
 0010 =         tcr	equ	10h
                
                ;-------- Start of Code-producing source -----------
                
                	; Because LINK puts dseg after cseg, and 'combas' is
                	; at the beginning of dseg, GENSYS will enforce that
                	; all of dseg falls in common memory.
                	cseg		; Banked memory
 0000 =         BIOS$0	equ	$
 0000 C30000    	jmp combas	; initial entry on cold start, common base
 0003 C3CA00    	jmp wboot	; reentry on program exit, warm start
                
 0006 C30C02    	jmp const	; return console input status
 0009 C31A02    	jmp conin	; return console input character
 000C C3F201    	jmp conout	; send console output character
 000F C3F101    	jmp list	; send list output character
 0012 C3E801    	jmp auxout	; send auxilliary output character	-NULL
 0015 C3E501    	jmp auxin	; return auxilliary input character	-NULL
                
 0018 C3CA02    	jmp home	; set disks to logical home
 001B C3F801    	jmp seldsk	; select disk drive, return disk parameter info
 001E C3CD02    	jmp settrk	; set disk track
 0021 C3D202    	jmp setsec	; set disk sector
 0024 C3D702    	jmp setdma	; set disk I/O memory address
 0027 C3EF02    	jmp read	; read physical block(s)
 002A C31303    	jmp write	; write physical block(s)
                
 002D C3EC01    	jmp listst	; return list device status
 0030 C3E302    	jmp sectrn	; translate logical to physical sector
                
 0033 C30000    	jmp	?memsl
 0036 C3EB00    	jmp	poll$dev
 0039 C32001    	jmp	strtclk
 003C C32401    	jmp	stopclk
 003F C31901    	jmp	exitreg
 0042 C31601    	jmp	maxcon
 0045 C3BF00    	jmp	boot	;   sysinit
                ;	jmp	idle	;
 0048 000000    	nop ! nop ! nop	; no idle routine
                
 004B 0601      	dw	polltb	;for RSP's (such as NETWRKIF)
                
 004D           	ds	13	;this puts setup/mode info where they expect it
 005A C3C501    	jmp	search
 005D           	ds	6
                
                ; These are only static when accessed via XIOSJMP.TBL
 0063           @dstat: ds	1
 0064           @intby: ds	1	; Port F2 image
                
 0065 0000      	dw	@lptbl	;logical/physical drive table
 0067 4502      	dw	thread	;module thread
 0069 0000      	dw	0	;?serdp	;test mode validity, HL=memory address of ?serdp
                
 006B           @adrv:	ds	1		; currently selected disk drive
 006C           @pdrv:	ds	1		; physical drive number (MMS)
 006D           @rdrv:	ds	1		; module relative disk drive number
 006E           curmdl: ds	2		; currently selected Disk I/O module address
 0070           @cmode: ds	2
 0072           @dph:	ds	2
                
 0074 0080      icovec: dw	1000000000000000b
 0076 0080      icivec: dw	1000000000000000b
 0078 0000      iaovec: dw	0000000000000000b
 007A 0000      iaivec: dw	0000000000000000b
 007C 0000      ilovec: dw	0000000000000000b
                
 007E 00FFFFFF  defsrc: db	0,0ffh,0ffh,0ffh
 0082 00        tmpdrv: db	0
 0083 00        srctyp: db	000$00$000b	;only bits 3,4 are used (others ignored)
                
                	; for MODULES.COM... well, not quite since not in common memory...
                	; This will be copied to BIOS JMP PAGE, in common memory,
                	; but these strings must also reside in common memory.
 0084 0000      	dw	@memstr
 0086 0000      	dw	@rtcstr
                
 0088 0000      @dma:	dw	0
 008A 0000      wbtrap: dw	0
                
                	dseg
                ;---------- COMMON MEMORY -----------
                ; WARNING: must be on page boundary ('vect' alignment).
                ; Use LINK 'B' option.
 0000 C3CA00    combas: jmp	colds
 0003 C30000    swtusr: jmp	$-$
 0006 C30000    swtsys: jmp	$-$
 0009 C30000    pdisp:	jmp	$-$
 000C C30000    xdos:	jmp	$-$
 000F 0000      sysdat: dw	$-$
                
 0011           @dirbf: ds	128
                
                	; Z180 internal devices interrupt vector table.
                	; If external devices also generate interrupts,
                	; this must be expanded/realigned to compensate.
                	; need 32-byte aligned address:
                	rept	(32 - (($-combas) AND 1fh)) AND 1fh
                	db	0
                	endm
 0091+00        	DB	0
 0092+00        	DB	0
 0093+00        	DB	0
 0094+00        	DB	0
 0095+00        	DB	0
 0096+00        	DB	0
 0097+00        	DB	0
 0098+00        	DB	0
 0099+00        	DB	0
 009A+00        	DB	0
 009B+00        	DB	0
 009C+00        	DB	0
 009D+00        	DB	0
 009E+00        	DB	0
 009F+00        	DB	0
 00A0 E800      vect:	dw	nulint	; 0 - /INT1
 00A2 E800      	dw	nulint	; 1 - /INT2
 00A4 4101      	dw	tick	; 2 - PRT0 (TMDR0 -> 0)
 00A6 E800      	dw	nulint	; 3 - PRT1 (TMDR1 -> 0)
 00A8 E800      	dw	nulint	; 4 - DMA0
 00AA E800      	dw	nulint	; 5 - DMA1
 00AC E800      	dw	nulint	; 6 - CSIO
 00AE E800      	dw	nulint	; 7 - ASCI0
 00B0 E800      	dw	nulint	; 8 - ASCI1
 00B2 E800      	dw	nulint	; 9 - unused by Z180
 00B4 E800      	dw	nulint	; 10 - unused by Z180
 00B6 E800      	dw	nulint	; 11 - unused by Z180
 00B8 E800      	dw	nulint	; 12 - unused by Z180
 00BA E800      	dw	nulint	; 13 - unused by Z180
 00BC E800      	dw	nulint	; 14 - unused by Z180
 00BE E800      	dw	nulint	; 15 - unused by Z180
                
 00C0 0000      @vect:	dw	$-$
 00C2 0000      dbuga:	dw	$-$
 00C4 0000      dbugv:	dw	$-$
 00C6 0000      biosjmp:dw	$-$
 00C8           @dbnk:	ds	1	; bank for user I/O (user DMA addr)
 00C9           @eops:	ds	1
                
                wboot:
                colds:	; possible TRAP
                	in0	a,itc
 00CA+ED3834    	DB	0EDH, A*8+00H, ITC
                	tsti	10000000b	; TRAP bit
 00CD+ED6480    	DB	0EDH, 64H, 10000000B
                	jrnz	trap
 00D0+2005      	DB	20H,TRAP-$-1
 00D2 0E00      	mvi	c,0
 00D4 C30C00    	jmp	xdos
                
                ; For now, TRAP is fatal
 00D7 21DD00    trap:	lxi	h,trpmsg
 00DA C3C401    	jmp	errx
                
 00DD 0D0A2A5452trpmsg:	db	CR,LF,'*TRAP*',CR,LF,'$'
                
 00E8 FB        nulint:	ei
                	reti
 00E9+ED4D      	DB	0EDH,4DH
                
                ; C=device to poll, 0-N char I/O devices (input status)
                poll$dev:
 00EB 79        	mov	a,c
 00EC FE08      	cpi	8
                	jrnc	pd0	; not char I/O...
 00EE+300A      	DB	30H,PD0-$-1
 00F0 51        	mov	d,c
 00F1 D604      	sui	4
 00F3 DA0C02    	jc	const
 00F6 57        	mov	d,a
 00F7 C3ED01    	jmp	conost
 00FA 0600      pd0:	mvi	b,0
 00FC 210601    	lxi	h,polltb
 00FF 09        	dad	b
 0100 09        	dad	b
 0101 5E        	mov	e,m
 0102 23        	inx	h
 0103 56        	mov	d,m
                	; TODO: check DE=NULL?
 0104 EB        	xchg
 0105 E9        	pchl
                
                ; Devices 8..15, starting at +0...
 0106 0000000000polltb:	dw	$-$,$-$,$-$,$-$,$-$,$-$,$-$,$-$ ; 8..15 unassigned (yet)
                
 0116 3E00      maxcon: mvi	a,0	;filled in at init from SYSDAT
 0118 C9        	ret
                
                exitreg:
 0119 3A2A01    	lda	preempt
 011C B7        	ora	a
 011D C0        	rnz
 011E FB        	ei
 011F C9        	ret
                
 0120 3EFF      strtclk: mvi	a,true
                	 jr	sc00
 0122+1802      	DB	18H,SC00-$-1
 0124 3E00      stopclk: mvi	a,false
 0126 322B01    sc00:	 sta	clock
 0129 C9        	 ret
                
 012A 00        preempt: db	0
 012B 00        clock:	 db	0
                
 012C 0000      @secnd: dw	$-$	;used to do timeouts
                
 012E 00        tps:	db	0	; from system data page on boot
 012F 00        tcnt:	db	0
                
                second:
 0130 2A2C01    	lhld	@secnd
 0133 7C        	mov	a,h
 0134 B5        	ora	l
 0135 C43602    	cnz	icall
 0138 1E02      	mvi	e,2
 013A 0E85      	mvi	c,flagset
 013C CD0C00    	call	xdos
                	jr	tk1
 013F+182C      	DB	18H,TK1-$-1
                
                tick:	sspd	istk
 0141+ED73      	DB	0EDH,73H
 0143+C301      	DW	ISTK
 0145 31C301    	lxi	sp,intstk
 0148 F5        	push	psw
 0149 E5        	push	h
 014A D5        	push	d
 014B C5        	push	b
                	in0	a,tmdr0l	; reset INT
 014C+ED380C    	DB	0EDH, A*8+00H, TMDR0L
 014F 3EFF      	mvi	a,true
 0151 322A01    	sta	preempt
 0154 3A2B01    	lda	clock
 0157 B7        	ora	a
                	jrz	tk0
 0158+2807      	DB	28H,TK0-$-1
 015A 1E01      	mvi	e,1
 015C 0E85      	mvi	c,flagset
 015E CD0C00    	call	xdos
                tk0:
 0161 212F01    	lxi	h,tcnt
 0164 35        	dcr	m
                	jrnz	tk1
 0165+2006      	DB	20H,TK1-$-1
 0167 3A2E01    	lda	tps
 016A 77        	mov	m,a
                	jr	second
 016B+18C3      	DB	18H,SECOND-$-1
 016D 3E00      tk1:	mvi	a,false
 016F 322A01    	sta	preempt
 0172 117801    	lxi	d,nexti
 0175 D5        	push	d
                	reti
 0176+ED4D      	DB	0EDH,4DH
                nexti:
 0178 C1        	pop	b
 0179 D1        	pop	d
 017A E1        	pop	h
 017B F1        	pop	psw
                	lspd	istk
 017C+ED7B      	DB	0EDH,07BH
 017E+C301      	DW	ISTK
 0180 C30900    	jmp	pdisp
                
 0183           	ds	64	;32 levels of stack
 01C3           intstk: ds	0
 01C3 0000      istk:	dw	0
                
                ; SEARCH for a module by device #.
                ;   entry:	C = device # (0-249)
                ;   exit:	[CY] = not found
                ;	   else HL=module address ("init" entry)
                ;		A=device number (relative to module's #0)
                ;
 01C5 114502    search: lxi	d,thread	;C=device number
 01C8 EB        snext:	xchg
 01C9 5E        	mov	e,m
 01CA 23        	inx	h
 01CB 56        	mov	d,m
 01CC 23        	inx	h
 01CD 7A        	mov	a,d
 01CE B3        	ora	e
 01CF D601      	sui	1	;produce [CY] if DE=0000
 01D1 D8        	rc		;return if device not found, DE=0000
 01D2 79        	mov	a,c
 01D3 96        	sub	m
                	jrc	snext
 01D4+38F2      	DB	38H,SNEXT-$-1
 01D6 23        	inx	h
 01D7 BE        	cmp	m
                	jrnc	snext
 01D8+30EE      	DB	30H,SNEXT-$-1
 01DA 23        	inx	h	;point to "init" vector
 01DB B7        	ora	a	;set [NC] condition
 01DC C9        	ret
                
 01DD 0000      ciomdl:	dw	0	;character device driver, filled at cold-start.
 01DF 00        cionum:	db	0	;max num cio devices
                
                cinit:	;C=device number (0-11)
 01E0 2ADD01    	lhld	ciomdl	; init routine
 01E3 41        	mov	b,c
 01E4 E9        	pchl		;jump to modules "init" with B=device #
                
 01E5 3E1A      auxin:	mvi	a,1ah	; EOF
 01E7 B7        	ora	a
 01E8 C9        auxout:	ret
                
 01E9 F1        nodev:	pop	psw
 01EA AF        nost:	xra	a	; never ready
 01EB C9        	ret
                
                ; D=device number
                listst:
 01EC 14        	inr	d	; LST: #0 = cio device 1
                	; TODO: check overflow/wrap?
                conost:
 01ED 3E09      	mvi	a,9
                	jr	devio
 01EF+181D      	DB	18H,DEVIO-$-1
                
                ; D=device number, C=char
                list:
 01F1 14        	inr	d	; LST: #0 = cio device 1
                	; TODO: check overflow/wrap?
                conout
 01F2 C5        	push	b
 01F3 CDED01    	call	conost	; is ready now?
 01F6 C1        	pop	b
 01F7 B7        	ora	a
 01F8 C20802    	jnz	co0
 01FB D5        	push	d
 01FC C5        	push	b
 01FD 7A        	mov	a,d
 01FE C604      	adi	4
 0200 5F        	mov	e,a
 0201 0E83      	mvi	c,poll
 0203 CD0C00    	call	xdos	; sleep until ready
 0206 C1        	pop	b
 0207 D1        	pop	d
 0208 3E0C      co0:	mvi	a,12
                	jr	devio
 020A+1802      	DB	18H,DEVIO-$-1
                
                ; D=device number
 020C 3E03      const:	mvi	a,3
                	;jr	devio
                
                ; A=JMP tbl off, D=devnum [C=char]
 020E F5        devio:	push	psw
 020F 3ADF01    	lda	cionum	;see if device exists
 0212 3D        	dcr	a
 0213 BA        	cmp	d
                	jrc	nodev
 0214+38D3      	DB	38H,NODEV-$-1
 0216 F1        	pop	psw	; driver JMP offset
 0217 42        	mov	b,d	;device number in B for modules
                	jr	indjmp0
 0218+1813      	DB	18H,INDJMP0-$-1
                
                ; D=device number
 021A CD0C02    conin:	call	const	; is ready now?
 021D B7        	ora	a
 021E C22902    	jnz	ci0
 0221 D5        	push	d
 0222 5A        	mov	e,d
 0223 0E83      	mvi	c,poll
 0225 CD0C00    	call	xdos	; sleep until ready
 0228 D1        	pop	d
 0229 3E06      ci0:	mvi	a,6
                	jr	devio
 022B+18E1      	DB	18H,DEVIO-$-1
                
                ; char I/O driver function calls
                ; A=offset (0,3,6,9,...), B=device number (0..N)
                indjmp0:
 022D 2ADD01    	lhld	ciomdl
 0230 85        	add	l	;a=0,3,6,9,12,...
 0231 6F        	mov	l,a
 0232 3E00      	mvi	a,0
 0234 8C        	adc	h
 0235 67        	mov	h,a
 0236 E9        icall:	pchl		;indirect call
                
                
 0237 00        @cbnk:	db	0	; bank for processor operations
 0238           bnkflg: ds	1	;flag for enough memory installed.
                
                getusrbnk:	;finds the bank number for calling process
 0239 CD0300    	call	swtusr		; would like better way...
 023C 3A3702    	lda	@cbnk
 023F 32C800    	sta	@dbnk
 0242 C30600    	jmp	swtsys
                
 0245 =         thread: equ	$	;must be last in dseg (common mem)
                
                	cseg	; rest is in banked memory...
                
 008C 0D0A074838signon: db	13,10,7,'H8-Z180 MP/M-II v3.00'
 00A4 3061      	dw	vers
 00A6 2020286329	db	'  (c) 1984 DRI and MMS',13,10,'$'
                
                ; Interrupts are disabled
                ; HL = BIOS JMP table
                ; DE = debug entry
                ; C = debug RST num
                boot:
                	; This is H89-specific...
 00BF 3E20      	mvi	a,20h	; ORG0 on, 2mS off, 2.048MHz clock
 00C1 326400    	sta	@intby
 00C4 D3F2      	out	0f2h	; prevent undesirable intrs
                			; Console 8250 should already be off
                	; TODO: make WAIT states configurable...
                	; speed things up...
 00C6 3E00      	mvi	a,00$00$0000b
                	out0	a,dcntl	; no WAIT states
 00C8+ED3932    	DB	0EDH, A*8+01H, DCNTL
 00CB 3E00      	mvi	a,0$0$000000b
                	out0	a,rcr	; no RESFRESH cycles
 00CD+ED3936    	DB	0EDH, A*8+01H, RCR
                	;
                	sded	dbuga
 00D0+ED53      	DB	0EDH,53H
 00D2+C200      	DW	DBUGA
 00D4 22C600    	shld	biosjmp
 00D7 79        	mov	a,c
 00D8 87        	add	a
 00D9 87        	add	a
 00DA 87        	add	a
 00DB 6F        	mov	l,a
 00DC 2600      	mvi	h,0
 00DE 22C400    	shld	dbugv
 00E1 21A000    	lxi	h,vect
 00E4 22C000    	shld	@vect
 00E7 7C        	mov	a,h
                	stai
 00E8+ED47      	DB	0EDH,47H
                	out0	l,il
 00EA+ED2933    	DB	0EDH, L*8+01H, IL
 00ED 2A0F00    	lhld	sysdat
 00F0 2E7A      	mvi	l,122	;ticks/sec
 00F2 7E        	mov	a,m
 00F3 322E01    	sta	tps
 00F6 322F01    	sta	tcnt
 00F9 2EFC      	mvi	l,252	;XDOS internal data page
 00FB 5E        	mov	e,m
 00FC 23        	inx	h
 00FD 56        	mov	d,m
 00FE 210500    	lxi	h,5
 0101 19        	dad	d	; skip past TOD
 0102 22A705    	shld	rlr
 0105 219600    	lxi	h,0096h	; osmsegtbl
 0108 19        	dad	d
 0109 22A905    	shld	msegtbl
                ; get common size from SYSDAT
                	lixd	sysdat
 010C+DD2A      	DB	0DDH,2AH
 010E+0F00      	DW	SYSDAT
                	ldx	a,+1	;number of system consoles
 0110+DD7E01    	DB	0DDH,A*8+46H,+1
 0113 FE02      	cpi	1+1	;we can only support 1
                	jrc	iin50
 0115+3802      	DB	38H,IIN50-$-1
 0117 3E01      	mvi	a,1	;if more than 1, only allow 1.
 0119 321701    iin50:	sta	maxcon+1
                	ldx	a,+124		;common memory base page
 011C+DD7E7C    	DB	0DDH,A*8+46H,+124
                ; Verify that we have banked RAM... A=compag from MP/M
 011F CD0000    	call	?bnkck
 0122 323802    	sta	bnkflg
                ; initialize timer interrupts
 0125 210008    	lxi	h,tickrate	; phi/20/tickrate = ticks per sec
                	out0	l,tmdr0l
 0128+ED290C    	DB	0EDH, L*8+01H, TMDR0L
                	out0	h,tmdr0h
 012B+ED210D    	DB	0EDH, H*8+01H, TMDR0H
                	out0	l,rldr0l
 012E+ED290E    	DB	0EDH, L*8+01H, RLDR0L
                	out0	h,rldr0h
 0131+ED210F    	DB	0EDH, H*8+01H, RLDR0H
                	in0	a,tcr
 0134+ED3810    	DB	0EDH, A*8+00H, TCR
 0137 F611      	ori	00010001b	; TIE0, TDE0
                	out0	a,tcr		; start the timer
 0139+ED3910    	DB	0EDH, A*8+01H, TCR
                ; Initialize all modules and build tables.
 013C 214502    	lxi	h,thread	;thread our way through the modules,
 013F 5E        iin0:	mov	e,m		;initializing as we go.
 0140 23        	inx	h
 0141 56        	mov	d,m	;next module, or "0000" if we're past the end.
 0142 23        	inx	h
 0143 7A        	mov	a,d
 0144 B3        	ora	e
 0145 CA6501    	jz	init$done
 0148 7E        	mov	a,m	;device base number
 0149 23        	inx	h
 014A 23        	inx	h	;thread+4 = init entry (JMP)
 014B D6C8      	sui	200	;if Char I/O module, build entry(s) in tables.
 014D DA5D01    	jc	notchr
                	; should only be one...
 0150 22DD01    	shld	ciomdl
 0153 D5        	push	d	;save NEXT module address
 0154 2B        	dcx	h
 0155 7E        	mov	a,m	;number of devices
 0156 32DF01    	sta	cionum
 0159 E1        	pop	h
 015A C33F01    	jmp	iin0
                
                notchr: 		;HL point to init entry
 015D D5        	push	d
 015E CD3602    	call	icall	;"call" (HL)
 0161 E1        	pop	h
 0162 C33F01    	jmp	iin0
                
                init$done:	;all Disk I/O modules are initialized.
                		; now initialize the chrio devices
 0165 3ADF01    	lda	cionum
 0168 4F        	mov	c,a	; last dev + 1
 0169 0D        iin5:	dcr	c
 016A FA7401    	jm	iin2	; include dev 0
 016D C5        	push	b
 016E CDE001    	call	cinit
 0171 C1        	pop	b
                	jr	iin5
 0172+18F5      	DB	18H,IIN5-$-1
                iin2:
 0174 218C00    	lxi	h,signon
 0177 CDC901    	call	msgout
 017A 3A3802    	lda	bnkflg
 017D B7        	ora	a	;is enough memory installed?
 017E CAC101    	jz	ramerr
 0181 CD8B01    	call	set$jumps  ;setup system jumps and put in all banks
 0184 CD0000    	call	?itime	; get (starting) TOD from RTC
                
                	im2
 0187+ED5E      	DB	0EDH,5EH
 0189 AF        	xra	a
 018A C9        	ret
                
                set$jumps:
                	liyd	dbugv
 018B+FD2A      	DB	0FDH,2AH
 018D+C400      	DW	DBUGV
 018F 3EC3      	mvi	a,(JMP)
 0191 320000    	sta	cpm
                	sty	a,+0      ; set up jumps in page zero
 0194+FD7700    	DB	0FDH,70H+A,+0
 0197 2AC6002201	lhld	biosjmp ! shld cpm+1	; BIOS warm start entry
 019D 2AC200    	lhld	dbuga
                	sty	l,+1
 01A0+FD7501    	DB	0FDH,70H+L,+1
                	sty	h,+2	; DEBUGGER entry point
 01A3+FD7402    	DB	0FDH,70H+H,+2
 01A6 3A0000    	lda	@nbnk
 01A9 47        	mov	b,a	;number of banks (also, -1 is dest bank)
 01AA 0E00      	mvi	c,0	;source bank
                sj0:
 01AC 05        	dcr	b
 01AD C8        	rz
 01AE C5        	push	b
                	; must setup DE,HL before ?xmove
 01AF 210000    	lxi	h,0	; page 0 in all banks
 01B2 54        	mov	d,h
 01B3 5D        	mov	e,l
 01B4 CD0000    	call	?xmove
 01B7 014000    	lxi	b,64
 01BA CD0000    	call	?move
 01BD C1        	pop	b
                	jr	sj0		;
 01BE+18EC      	DB	18H,SJ0-$-1
 01C0 C9        	ret
                
 01C1 210000    ramerr: lxi	h,@mmerr
 01C4 CDC901    errx:	call	msgout
 01C7 F376      	di ! hlt
                
                msgout:
 01C9 7E        	mov	a,m
 01CA FE24      	cpi	'$'
 01CC C8        	rz
 01CD E5        	push	h
 01CE 4E        	mov	c,m
 01CF 1600      	mvi	d,0
 01D1 CD0802    	call	co0
 01D4 E1        	pop	h
 01D5 23        	inx	h
                	jr	msgout
 01D6+18F1      	DB	18H,MSGOUT-$-1
                
 01D8 0000000000@dtbl:	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                
                seldsk:
 01F8 79326B00  	mov a,c ! sta @adrv			; save drive select code
 01FC 210000    	lxi	h,@lptbl
 01FF 060009    	mvi b,0 ! dad b 	      ; create index from drive code
 0202 7E        	mov	a,m
 0203 FEFF      	cpi	255
 0205 CA8602    	jz	selerr
 0208 326C00    	sta	@pdrv
 020B 4F        	mov	c,a
 020C 43        	mov	b,e	;save login flag thru "search" routine
 020D CDC501    	call	search
 0210 DA8602    	jc	selerr
 0213 326D00    	sta	@rdrv
 0216 226E00    	shld	curmdl
 0219 C5        	push	b	;save login bit
 021A 110E00    	lxi	d,14
 021D 19        	dad	d	;point to dphtbl
 021E 5E        	mov	e,m	;DE=dphtbl
 021F 23        	inx	h
 0220 56        	mov	d,m
 0221 23        	inx	h
 0222 4E        	mov	c,m	;BC=modtbl
 0223 23        	inx	h
 0224 46        	mov	b,m
 0225 3A6D00    	lda	@rdrv
 0228 87        	add	a
 0229 87        	add	a
 022A 87        	add	a	;*8
 022B 6F        	mov	l,a
 022C 2600      	mvi	h,0
 022E 09        	dad	b	;select mode bytes
 022F 227000    	shld	@cmode	;set current mode pointer
 0232 C1        	pop	b	;get login bit back.
                	bit	0,b	;test for initial select.
 0233+CB40      	DB	0CBH,0*8+B+40H
                	jrnz	notlgi
 0235+2053      	DB	20H,NOTLGI-$-1
 0237 EB        	xchg		;DE=modes
 0238 4F        	mov	c,a
 0239 0600      	mvi	b,0
 023B 09        	dad	b	;+*8
 023C 09        	dad	b	;+*16
 023D 227200    	shld	@dph
 0240 EB        	xchg
 0241 3A6B00    	lda	@adrv
 0244 4F        	mov	c,a
 0245 87        	add	a	;*2
 0246 87        	add	a	;*4
 0247 87        	add	a	;*8
 0248 87        	add	a	;*16
 0249 81        	add	c	;*17
 024A 4F        	mov	c,a	;B still = 0
 024B CDC102    	call	setup$dph
                	jrc	selerr
 024E+3836      	DB	38H,SELERR-$-1
 0250 AF        	xra	a
 0251 329405    	sta	@rcnfg
 0254 2A6E00    	lhld	curmdl
                	lxiy	@scrcb
 0257+FD21      	DB	0FDH,21H
 0259+D406      	DW	@SCRCB
 025B 3A6C00    	lda	@pdrv
                	sty	a,hstdsk
 025E+FD7707    	DB	0FDH,70H+A,HSTDSK
 0261 3E03      	mvi	a,3
 0263 CD8605    	call	calmod	;call module's "login" routine.
 0266 B7        	ora	a	;see if an error occured.
                	jrnz	selerr
 0267+201D      	DB	20H,SELERR-$-1
 0269 3A9405    	lda	@rcnfg
 026C B7        	ora	a
 026D C4C102    	cnz	setup$dph
                	jrc	selerr
 0270+3814      	DB	38H,SELERR-$-1
 0272 3A6B00    	lda	@adrv
 0275 87        	add	a
 0276 4F        	mov	c,a
 0277 0600      	mvi	b,0
 0279 21D801    	lxi	h,@dtbl
 027C 09        	dad	b
                	lded	@dph
 027D+ED5B      	DB	0EDH,5BH
 027F+7200      	DW	@DPH
 0281 73        	mov	m,e	;set current DPH in @dtbl
 0282 23        	inx	h
 0283 72        	mov	m,d
                	jr	selcom	;DE=dph
 0284+1816      	DB	18H,SELCOM-$-1
                
 0286 210000    selerr: lxi	h,0
 0289 C9        	ret
                
 028A 3A6B00    notlgi: lda	@adrv
 028D 87        	add	a
 028E 4F        	mov	c,a
 028F 0600      	mvi	b,0
 0291 21D801    	lxi	h,@dtbl
 0294 09        	dad	b
 0295 5E        	mov	e,m	;get current DPH from @dtbl
 0296 23        	inx	h
 0297 56        	mov	d,m	;DE=dph
                	sded	@dph
 0298+ED53      	DB	0EDH,53H
 029A+7200      	DW	@DPH
                selcom:
 029C 210A00    	lxi	h,+10
 029F 19        	dad	d	;point to DPB entry
 02A0 4E        	mov	c,m
 02A1 23        	inx	h
 02A2 46        	mov	b,m
 02A3 0A        	ldax	b	;SPT (logical)
 02A4 329305    	sta	@spt
 02A7 210300    	lxi	h,+3
 02AA 09        	dad	b
 02AB 7E        	mov	a,m	;BSM
 02AC 32A005    	sta	blkmsk
 02AF 210D00    	lxi	h,+13	;point to track offset
 02B2 09        	dad	b
 02B3 4E        	mov	c,m
 02B4 23        	inx	h
 02B5 46        	mov	b,m
 02B6 23        	inx	h
                	sbcd	offset
 02B7+ED43      	DB	0EDH,43H
 02B9+9605      	DW	OFFSET
 02BB 7E        	mov	a,m	;psh
 02BC 329505    	sta	blcode
 02BF EB        	xchg		;put DPH in (HL) for BDOS
 02C0 C9        	ret
                
                setup$dph:
 02C1 B7        	ora	a	;reset [CY]
 02C2 2A7000    	lhld	@cmode	;HL=modes
                	bit	7,m	;check for hard-disk drive (modes not standard)
 02C5+CB7E      	DB	0CBH,7*8+M+40H
 02C7 C0        	rnz
 02C8 37        	stc
 02C9 C9        	ret
                
 02CA 010000    home:	lxi b,0 	; same as set track zero
                settrk: sbcd @trk
 02CD+ED43      	DB	0EDH,43H
 02CF+8E05      	DW	@TRK
 02D1 C9        	ret
                
                setsec: sbcd @sect
 02D2+ED43      	DB	0EDH,43H
 02D4+9005      	DW	@SECT
 02D6 C9        	ret
                
                setdma:
 02D7 78        	mov	a,b
 02D8 A1        	ana	c
 02D9 FEFF      	cpi	true
 02DB CA1B05    	jz	flushall
                	sbcd	@dma
 02DE+ED43      	DB	0EDH,43H
 02E0+8800      	DW	@DMA
 02E2 C9        	ret
                
 02E3 6960      sectrn: mov l,c ! mov h,b
 02E5 7AB3C8    	mov a,d ! ora e ! rz
 02E8 EB096E2600	xchg ! dad b ! mov l,m ! mvi h,0
 02ED 2B        	dcx	h	;sectors numbered 0 - (n-1)
 02EE C9        	ret
                
                
                read:
 02EF 3EFF      	mvi	a,true		; FLAG A READ OPERATION
 02F1 329A05    	sta	preread 	; forces FLUSH and Physical READ
 02F4 32A105    	sta	rdflg
 02F7 329B05    	sta	defer		; never flush if reading (pointless)
 02FA 2F        	cma	; false
 02FB 329C05    	sta	unalloc ;terminate any active unallocated-writing
 02FE 2AA305    	LHLD	REQTRK
 0301 3A9605    	lda	OFFSET
 0304 95        	sub	l	; DIR track must be < 256
 0305 B4        	ora	h	; 00=on DIR track
 0306 2A9005    	lhld	@sect
 0309 B4        	ora	h	;
 030A B5        	ora	l	; 00=first sector of directory
 030B D601      	sui	1	; CY = 1st sec of dir
 030D 9F        	sbb	a	; FF = 1st sec of dir, else 00
 030E 329905    	sta	dir0
                	jr	rwoper
 0311+1852      	DB	18H,RWOPER-$-1
                
                write:
 0313 AF        	xra	a
 0314 329905    	sta	dir0
 0317 32A105    	sta	rdflg
 031A 3EFF      	mvi	a,true
 031C 329A05    	STA	preread 	; assume a PRE-READ
 031F 79        	mov	a,c
 0320 E601      	ani	1		; 00 = defered write, else 01
 0322 3D        	dcr	a		; FF = defer, else 00
 0323 329B05    	sta	defer
                	bit	1,c		; write to 1st sector of unallocated block ?
 0326+CB49      	DB	0CBH,1*8+C+40H
                	jrz	CHKUNA
 0328+280D      	DB	28H,CHKUNA-$-1
                	SDED	URECORD 	; SET UNALLOCATED RECORD #
 032A+ED53      	DB	0EDH,53H
 032C+9D05      	DW	URECORD
 032E 78        	mov	a,b
 032F 329F05    	sta	urecord+2
 0332 3EFF      	mvi	a,true
 0334 329C05    	STA	UNALLOC 	; FLAG WRITING OF AN UNALLOCATED BLOCK
 0337 3A9C05    CHKUNA: LDA	UNALLOC 	; ARE WE WRITING AN UNALLOCATED BLOCK ?
 033A B7        	ORA	A
                	JRZ	rwoper
 033B+2828      	DB	28H,RWOPER-$-1
 033D 2A9D05    	LHLD	URECORD 	; IS REQUESTED RECORD SAME AS EXPECTED
                	DSBC	D		;  SAME AS EXPECTED UNALLOCATED RECORD ?
 0340+ED52      	DB	0EDH,D*8+42H
                	JRNZ	ALLOC		; IF NOT, THEN DONE WITH UNALLOCATED BLOCK
 0342+201D      	DB	20H,ALLOC-$-1
 0344 3A9F05    	lda	urecord+2
 0347 90        	sub	b
                	jrnz	alloc
 0348+2017      	DB	20H,ALLOC-$-1
 034A AF        	XRA	A		; CLEAR PRE-READ FLAG
 034B 329A05    	STA	preread
 034E 210100    	lxi	h,1		; INCREMENT TO NEXT EXPECTED UNALLOCATED RECORD
 0351 19        	dad	d
 0352 229D05    	shld	urecord
 0355 3E00      	mvi	a,0
 0357 88        	adc	b
 0358 329F05    	sta	urecord+2
 035B 3AA005    	LDA	BLKMSK
 035E A5        	ana	l		; IS IT THE START OF A NEW BLOCK ?
                	JRNZ	rwoper
 035F+2004      	DB	20H,RWOPER-$-1
 0361 AF        ALLOC:	XRA	A		; NO LONGER WRITING AN UNALLOCATED BLOCK
 0362 329C05    	STA	UNALLOC
                rwoper:
                	; RLR - Ready List Root - points to the current process
 0365 2AA705    	lhld	rlr
 0368 4E        	mov	c,m
 0369 23        	inx	h
 036A 46        	mov	b,m	;BC=PDAdr, must be preserved throughout.
                ; get a buffer for this disk access...
                 if lrubuf
                	lixd	hsttop
 036B+DD2A      	DB	0DDH,2AH
 036D+AB05      	DW	HSTTOP
 036F 210000    	lxi	h,0
 0372 22AF05    	shld	previous
 0375 2AAB05    	lhld	hsttop
 0378 7C        	mov	a,h
 0379 B5        	ora	l
 037A C28303    	jnz	sd0
 037D 2AAD05    	lhld	fretop
 0380 C3B003    	jmp	sd1
                sd0:	ldx	e,link
 0383+DD5E00    	DB	0DDH,E*8+46H,LINK
                	ldx	d,link+1
 0386+DD5601    	DB	0DDH,D*8+46H,LINK+1
                	ldx	l,hstpda
 0389+DD6E02    	DB	0DDH,L*8+46H,HSTPDA
                	ldx	h,hstpda+1
 038C+DD6603    	DB	0DDH,H*8+46H,HSTPDA+1
 038F B7        	ora	a
                	dsbc	b	;compare P.D.Adr
 0390+ED42      	DB	0EDH,B*8+42H
 0392 CABB03    	jz	sd2
 0395 7A        	mov	a,d
 0396 B3        	ora	e
 0397 CAA403    	jz	sd3
                	sixd	previous
 039A+DD22      	DB	0DDH,22H
 039C+AF05      	DW	PREVIOUS
 039E D5        	push	d
                	popix
 039F+DDE1      	DB	0DDH,0E1H
 03A1 C38303    	jmp	sd0
                sd3:	sixd	last
 03A4+DD22      	DB	0DDH,22H
 03A6+B105      	DW	LAST
 03A8 2AAD05    	lhld	fretop
 03AB 7C        	mov	a,h
 03AC B5        	ora	l
 03AD CACC03    	jz	sd4
 03B0 5E        sd1:	mov	e,m
 03B1 23        	inx	h
 03B2 56        	mov	d,m
 03B3 2B        	dcx	h
                	sded	fretop
 03B4+ED53      	DB	0EDH,53H
 03B6+AD05      	DW	FRETOP
 03B8 C3E203    	jmp	setbuf
                ; found our buffer, may not be at top of list.
 03BB 2AAF05    sd2:	lhld	previous	;patch previous bufr to skip this one,
 03BE 7C        	mov	a,h		;unless this is already first.
 03BF B5        	ora	l
 03C0 CAF803    	jz	sd5
 03C3 73        	mov	m,e
 03C4 23        	inx	h
 03C5 72        	mov	m,d
                	pushix
 03C6+DDE5      	DB	0DDH,0E5H
 03C8 E1        	pop	h	; move this bufr to top of list (most recently used)
 03C9 C3EA03    	jmp	setbuf1
                ; No existing buffer, no free buffers, must take last on list.
                sd4:	lixd	previous	;no existing in-use bufr, no free bufr.
 03CC+DD2A      	DB	0DDH,2AH
 03CE+AF05      	DW	PREVIOUS
                	mvix	0,link		;remove last buffer in list,
 03D0+DD360000  	DB	0DDH,36H,LINK,0
                	mvix	0,link+1	;patching previous to be new end.
 03D4+DD360100  	DB	0DDH,36H,LINK+1,0
                	liyd	last	;must flush this buffer, if write pending.
 03D8+FD2A      	DB	0FDH,2AH
 03DA+B105      	DW	LAST
 03DC CD6905    	call	flush	; ERROR will return directly to BDOS (pop h, ret)
 03DF 2AB105    	lhld	last	;
                ;	jmp	setbuf
 03E2 EB        setbuf: xchg
 03E3 210700    	lxi	h,hstdsk
 03E6 19        	dad	d
 03E7 36FF      	mvi	m,-1	;invalidate buffer.
 03E9 EB        	xchg
                setbuf1:lded	hsttop	;used to be top of list, now make it 2nd.
 03EA+ED5B      	DB	0EDH,5BH
 03EC+AB05      	DW	HSTTOP
 03EE 22AB05    	shld	hsttop	;put selected bufr at top of list.
 03F1 73        	mov	m,e	;set link
 03F2 23        	inx	h
 03F3 72        	mov	m,d
 03F4 23        	inx	h
 03F5 71        	mov	m,c	;BC must still = P.D.Adr
 03F6 23        	inx	h
 03F7 70        	mov	m,b
                sd5:
                 else
                	lxi	h,xxhdr
                	shld	hsttop
                 endif
                	; BC is still PDAdr
                	liyd	hsttop
 03F8+FD2A      	DB	0FDH,2AH
 03FA+AB05      	DW	HSTTOP
 03FC 3A6C00    	lda	@pdrv		; Calculate physical sector, etc
 03FF 32A205    	sta	reqdsk
 0402 CD3902    	call	getusrbnk
 0405 2A8E05    	lhld	@trk
 0408 22A305    	shld	reqtrk
 040B 0E00      	MVI	C,0		; CALCULATE PHYSICAL SECTOR
 040D 3A9505    	LDA	BLCODE		; PHYSICAL SECTOR SIZE CODE
 0410 B7        	ORA	A		; TEST FOR ZERO
 0411 47        	MOV	B,A
                	lded	@sect
 0412+ED5B      	DB	0EDH,5BH
 0414+9005      	DW	@SECT
                	JRZ	DBLOK3		; 128 BYTE SECTORS ?
 0416+280D      	DB	28H,DBLOK3-$-1
                DBLOK1: srlr	d		; DIVIDE BY 2
 0418+CB3A      	DB	0CBH, 38H + D
                	rarr	e
 041A+CB1B      	DB	0CBH, 18H + E
                	RARR	C		; SAVE OVERFLOW BITS
 041C+CB19      	DB	0CBH, 18H + C
                	DJNZ	DBLOK1		; AND CONTINUE IF BLOCKING STILL <> 0
 041E+10F8      	DB	10H,DBLOK1-$-1
 0420 47        	mov	b,a
                DBLOK2: RLCR	C		; NOW RESTORE THE OVERFLOW BY
 0421+CB01      	DB	0CBH, 00H + C
                	DJNZ	DBLOK2		; ROTATING IT RIGHT
 0423+10FC      	DB	10H,DBLOK2-$-1
 0425 79        DBLOK3: MOV	A,C
 0426 329805    	STA	BLKSEC		; STORE IT
                	sded	reqsec
 0429+ED53      	DB	0EDH,53H
 042B+A505      	DW	REQSEC
                
                chk1:	ldy	e,link		; next buffer, or 0000
 042D+FD5E00    	DB	0FDH,E*8+46H,LINK
                	ldy	d,link+1	;
 0430+FD5601    	DB	0FDH,D*8+46H,LINK+1
 0433 7A        	mov	a,d
 0434 B3        	ora	e
                	jrz	chk2
 0435+2857      	DB	28H,CHK2-$-1
 0437 D5        	push	d
                	popiy
 0438+FDE1      	DB	0FDH,0E1H
 043A 210700    	lxi	h,hstdsk
 043D 19        	dad	d
 043E 11A205    	lxi	d,reqdsk
 0441 0605      	mvi	b,5
 0443 1A        chk0:	ldax	d
 0444 BE        	cmp	m
                	jrnz	chk1
 0445+20E6      	DB	20H,CHK1-$-1
 0447 23        	inx	h
 0448 13        	inx	d
                	djnz	chk0
 0449+10F8      	DB	10H,CHK0-$-1
 044B CD6905    	call	flush	;an error bumps us out here.
                	siyd	previous	;save pointer
 044E+FD22      	DB	0FDH,22H
 0450+AF05      	DW	PREVIOUS
 0452 3AA105    	lda	rdflg
 0455 B7        	ora	a
                	jrnz	chk3
 0456+2004      	DB	20H,CHK3-$-1
                	mviy	-1,hstdsk	;invalidate their buffer if we are writing.
 0458+FD3607FF  	DB	0FDH,36H,HSTDSK,-1
                chk3:	liyd	hsttop	;restore IY
 045C+FD2A      	DB	0FDH,2AH
 045E+AB05      	DW	HSTTOP
 0460 3A9905    	lda	dir0
 0463 B7        	ora	a
                	jrnz	readit	;don't bother to move data if a read is forced...
 0464+2049      	DB	20H,READIT-$-1
 0466 CD6905    chk4:	call	flush		; must flush our buffer BEFORE changing data.
                	ldy	l,hstbuf	; destination - our buffer
 0469+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1	;
 046C+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
                	ldy	b,hstbnk	;
 046F+FD460E    	DB	0FDH,B*8+46H,HSTBNK
                	lixd	previous
 0472+DD2A      	DB	0DDH,2AH
 0474+AF05      	DW	PREVIOUS
                	ldx	e,hstbuf	; source
 0476+DD5E0C    	DB	0DDH,E*8+46H,HSTBUF
                	ldx	d,hstbuf+1	;
 0479+DD560D    	DB	0DDH,D*8+46H,HSTBUF+1
                	ldx	c,hstbnk	;
 047C+DD4E0E    	DB	0DDH,C*8+46H,HSTBNK
 047F CD0000    	call	?xmove		;
 0482 010002    	lxi	b,secsize	; put requested sector data in our buffer
 0485 CD0000    	call	?move		;
 0488 AF        	xra	a
 0489 329A05    	sta	preread
                	jr	readit0
 048C+1824      	DB	18H,READIT0-$-1
                chk2:	liyd	hsttop	;restore IY
 048E+FD2A      	DB	0FDH,2AH
 0490+AB05      	DW	HSTTOP
 0492 3A9905    	lda	dir0
 0495 B7        	ora	a
                	jrnz	readit
 0496+2017      	DB	20H,READIT-$-1
 0498 2AAB05    chkbuf: lhld	hsttop
 049B 110700    	lxi	d,hstdsk
 049E 19        	dad	d
 049F EB        	xchg
 04A0 21A205    	lxi	h,reqdsk
 04A3 0605      	mvi	b,5
 04A5 1A        chkbuf1:ldax	d
 04A6 BE        	cmp	m
                	jrnz	readit
 04A7+2006      	DB	20H,READIT-$-1
 04A9 23        	inx	h
 04AA 13        	inx	d
                	djnz	chkbuf1
 04AB+10F8      	DB	10H,CHKBUF1-$-1
                	jr	noread		;  THEN NO NEED TO PRE-READ
 04AD+182D      	DB	18H,NOREAD-$-1
 04AF CD6905    readit: call	flush
 04B2 2AAB05    readit0:lhld	hsttop		; SET UP NEW BUFFER PARAMETERS
 04B5 110700    	lxi	d,hstdsk
 04B8 19        	dad	d
 04B9 EB        	xchg
 04BA 21A205    	lxi	h,reqdsk	; set HSTDSK,HSTTRK,HSTSEC
 04BD 010500    	lxi	b,5		;
                	ldir			;
 04C0+EDB0      	DB	0EDH,0B0H
 04C2 2A6E00    	lhld	curmdl
                	sty	l,hstmdl
 04C5+FD750F    	DB	0FDH,70H+L,HSTMDL
                	sty	h,hstmdl+1
 04C8+FD7410    	DB	0FDH,70H+H,HSTMDL+1
 04CB 2A7000    	lhld	@cmode
                	sty	l,hstmod
 04CE+FD7504    	DB	0FDH,70H+L,HSTMOD
                	sty	h,hstmod+1
 04D1+FD7405    	DB	0FDH,70H+H,HSTMOD+1
 04D4 3A9A05    	lda	preread
 04D7 B7        	ora	a
 04D8 C47805    	cnz	pread		; READ THE SECTOR
 04DB C0        	rnz		;stop here if error
                noread: ldy	l,hstbuf	; POINT TO START OF SECTOR BUFFER
 04DC+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1
 04DF+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
 04E2 018000    	lxi	b,128
 04E5 3A9805    	lda	blksec		; POINT TO LOCATION OF CORRECT LOGICAL SECTOR
 04E8 3D        movit1: dcr	a
 04E9 FAEF04    	jm	movit2
 04EC 09        	dad	b
                	jr	movit1
 04ED+18F9      	DB	18H,MOVIT1-$-1
                movit2:
                	; TODO: need to handle possible common memory DMA
                	lded	@dma		; POINT TO DMA
 04EF+ED5B      	DB	0EDH,5BH
 04F1+8800      	DW	@DMA
 04F3 3AC800    	lda	@dbnk
 04F6 EB        	xchg		;DE is source, HL is dest.
 04F7 47        	mov	b,a		;B=dest. bank
                	ldy	c,hstbnk	;C=source bank
 04F8+FD4E0E    	DB	0FDH,C*8+46H,HSTBNK
 04FB 3AA105    	lda	rdflg		; IS IT A WRITE ?
 04FE B7        	ora	a
                	jrnz	movit3
 04FF+2008      	DB	20H,MOVIT3-$-1
 0501 79        	mov	a,c
 0502 48        	mov	c,b
 0503 47        	mov	b,a
 0504 EB        	xchg			; SWITCH DIRECTION OF MOVE FOR WRITE
                	mviy	true,pndwrt	; FLAG A PENDING WRITE
 0505+FD3606FF  	DB	0FDH,36H,PNDWRT,TRUE
 0509 CD0000    movit3: call	?xmove
 050C 018000    	lxi	b,128
 050F CD0000    	call	?move		; MOVE IT
 0512 3A9B05    	lda	defer		; CHECK FOR non-defered write
 0515 B7        	ora	a
 0516 CC6905    	cz	flush		; WRITE THE SECTOR IF IT IS
 0519 AF        	xra	a		; FLAG NO ERROR
 051A C9        	ret			; RETURN TO BDOS
                
                flushall:
                 if lrubuf
                	lded	hsttop
 051B+ED5B      	DB	0EDH,5BH
 051D+AB05      	DW	HSTTOP
 051F 7A        	mov	a,d
 0520 B3        	ora	e
 0521 C8        	rz		;no buffers in use.
 0522 21AB05    	lxi	h,hsttop
 0525 22AF05    	shld	previous
 0528 2AA705    	lhld	rlr
 052B 4E        	mov	c,m
 052C 23        	inx	h
 052D 46        	mov	b,m	;BC = PDAdr, must be preserved
 052E 210200    fls0:	lxi	h,hstpda
 0531 19        	dad	d
 0532 7E        	mov	a,m
 0533 23        	inx	h
 0534 66        	mov	h,m
 0535 6F        	mov	l,a
 0536 B7        	ora	a
                	dsbc	b	;compare P.D. adr
 0537+ED42      	DB	0EDH,B*8+42H
 0539 CA4905    	jz	flush1
 053C EB        	xchg
 053D 22AF05    	shld	previous
 0540 5E        	mov	e,m
 0541 23        	inx	h
 0542 56        	mov	d,m
 0543 7A        	mov	a,d
 0544 B3        	ora	e
 0545 C22E05    	jnz	fls0
 0548 C9        	ret
                
                ; TODO: could there be more than one?
                ; might need to resume flushall...
 0549 D5        flush1: push	d
                	popiy
 054A+FDE1      	DB	0FDH,0E1H
 054C 2AAF05    	lhld	previous
                	ldy	a,link
 054F+FD7E00    	DB	0FDH,A*8+46H,LINK
 0552 77        	mov	m,a
 0553 23        	inx	h
                	ldy	a,link+1
 0554+FD7E01    	DB	0FDH,A*8+46H,LINK+1
 0557 77        	mov	m,a
 0558 2AAD05    	lhld	fretop
                	sty	l,link
 055B+FD7500    	DB	0FDH,70H+L,LINK
                	sty	h,link+1
 055E+FD7401    	DB	0FDH,70H+H,LINK+1
                	siyd	fretop
 0561+FD22      	DB	0FDH,22H
 0563+AD05      	DW	FRETOP
                 else
                	lxiy	xxhdr
                 endif
 0565 CD6905    	call	flush	; must handle stupid stack tricks
 0568 C9        	ret
                
                ; Requires 2 ret adrs on stack, returns to imm caller on success,
                ; returns to caller's caller on error.
                flush:	ldy	a,pndwrt
 0569+FD7E06    	DB	0FDH,A*8+46H,PNDWRT
 056C B7        	ora	a
 056D C8        	rz
                	mviy	false,pndwrt
 056E+FD360600  	DB	0FDH,36H,PNDWRT,FALSE
 0572 CD7D05    	call	pwrite
 0575 C8        	rz
 0576 E1        	pop	h
 0577 C9        	ret
                
                ; IY=buffer header
 0578 1E06      pread:	mvi	e,6	;read entry is +6
 057A C37F05    	jmp rw$common			; use common code
                
 057D 1E09      pwrite: mvi	e,9	;write entry is +9
                
                rw$common:	;do any track/sector/side conversion...
                ;	xra	a
                ;	sta	@side
                ;	; Only "hard disk" supported...
                ;	ldy	l,hstmod
                ;	ldy	h,hstmod+1
                ;	bit	7,m	;floppy or hard-disk?
                ;	jrnz	rw0
                rw0:
 057F 7B        	mov	a,e	; read(6) or write(9)
                	ldy	l,hstmdl
 0580+FD6E0F    	DB	0FDH,L*8+46H,HSTMDL
                	ldy	h,hstmdl+1
 0583+FD6610    	DB	0FDH,H*8+46H,HSTMDL+1
                calmod:
 0586 85        	add	l
 0587 6F        	mov	l,a
 0588 3E00      	mvi	a,0
 058A 8C        	adc	h
 058B 67        	mov	h,a
 058C E9        	pchl		; leap to driver
                
 058D           @side:	ds	1		; current side of media (floppy only)
 058E           @trk:	ds	2		; current track number
 0590           @sect:	ds	2		; current sector number
 0592 00        @cnt:	db	0		; record count for multisector transfer
 0593           @spt:	ds	1
 0594           @rcnfg: ds	1
                
 0595           blcode: ds	1	;blocking code, PSH
 0596           offset: ds	2
 0598           blksec: ds	1
 0599           dir0:	ds	1
 059A           preread:ds	1
 059B           defer:	ds	1
 059C           unalloc:ds	1
 059D           urecord:ds	3
 05A0           blkmsk: ds	1
 05A1           rdflg:	ds	1
                
 05A2           reqdsk: ds	1
 05A3           reqtrk: ds	2
 05A5           reqsec: ds	2
                
 05A7 0000      rlr:	dw	0
 05A9 0000      msegtbl: dw	0
                
 05AB 0000      hsttop:   dw	0
                 if lrubuf
 05AD B305      fretop:   dw	hsthdr
 05AF 0000      previous: dw	0
 05B1 0000      last:	  dw	0
                
 0010 =         numbuf	equ	16
 0000 =         @@bnk	equ	0
 0100 #         @@ set 0100h	;start of buffers in bank
                		; (numbuf + 2) * secsize, buffers used,
                		; must not overrun system. At 512b and 16 bufs,
                		; this consumes 0100-2500, MP/M starts about A900.
                hsthdr: rept	numbuf
                	dw	$+hstlen ;Link
                	dw	0	;hstpda - Process Descriptor Address
                	dw	0	;hstmod
                	db	false	;pndwrt
                	db	-1	;hstdsk
                	dw	0	;hsttrk
                	dw	0	;hstsec
                	dw	@@	;hstbuf
                	db	@@bnk	;hstbnk
                	dw	0	;hstmdl
                @@ set @@+secsize
                	endm
 05B3+C405      	DW	$+HSTLEN ;LINK
 05B5+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 05B7+0000      	DW	0	;HSTMOD
 05B9+00        	DB	FALSE	;PNDWRT
 05BA+FF        	DB	-1	;HSTDSK
 05BB+0000      	DW	0	;HSTTRK
 05BD+0000      	DW	0	;HSTSEC
 05BF+0001      	DW	@@	;HSTBUF
 05C1+00        	DB	@@BNK	;HSTBNK
 05C2+0000      	DW	0	;HSTMDL
 05C4+D505      	DW	$+HSTLEN ;LINK
 05C6+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 05C8+0000      	DW	0	;HSTMOD
 05CA+00        	DB	FALSE	;PNDWRT
 05CB+FF        	DB	-1	;HSTDSK
 05CC+0000      	DW	0	;HSTTRK
 05CE+0000      	DW	0	;HSTSEC
 05D0+0003      	DW	@@	;HSTBUF
 05D2+00        	DB	@@BNK	;HSTBNK
 05D3+0000      	DW	0	;HSTMDL
 05D5+E605      	DW	$+HSTLEN ;LINK
 05D7+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 05D9+0000      	DW	0	;HSTMOD
 05DB+00        	DB	FALSE	;PNDWRT
 05DC+FF        	DB	-1	;HSTDSK
 05DD+0000      	DW	0	;HSTTRK
 05DF+0000      	DW	0	;HSTSEC
 05E1+0005      	DW	@@	;HSTBUF
 05E3+00        	DB	@@BNK	;HSTBNK
 05E4+0000      	DW	0	;HSTMDL
 05E6+F705      	DW	$+HSTLEN ;LINK
 05E8+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 05EA+0000      	DW	0	;HSTMOD
 05EC+00        	DB	FALSE	;PNDWRT
 05ED+FF        	DB	-1	;HSTDSK
 05EE+0000      	DW	0	;HSTTRK
 05F0+0000      	DW	0	;HSTSEC
 05F2+0007      	DW	@@	;HSTBUF
 05F4+00        	DB	@@BNK	;HSTBNK
 05F5+0000      	DW	0	;HSTMDL
 05F7+0806      	DW	$+HSTLEN ;LINK
 05F9+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 05FB+0000      	DW	0	;HSTMOD
 05FD+00        	DB	FALSE	;PNDWRT
 05FE+FF        	DB	-1	;HSTDSK
 05FF+0000      	DW	0	;HSTTRK
 0601+0000      	DW	0	;HSTSEC
 0603+0009      	DW	@@	;HSTBUF
 0605+00        	DB	@@BNK	;HSTBNK
 0606+0000      	DW	0	;HSTMDL
 0608+1906      	DW	$+HSTLEN ;LINK
 060A+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 060C+0000      	DW	0	;HSTMOD
 060E+00        	DB	FALSE	;PNDWRT
 060F+FF        	DB	-1	;HSTDSK
 0610+0000      	DW	0	;HSTTRK
 0612+0000      	DW	0	;HSTSEC
 0614+000B      	DW	@@	;HSTBUF
 0616+00        	DB	@@BNK	;HSTBNK
 0617+0000      	DW	0	;HSTMDL
 0619+2A06      	DW	$+HSTLEN ;LINK
 061B+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 061D+0000      	DW	0	;HSTMOD
 061F+00        	DB	FALSE	;PNDWRT
 0620+FF        	DB	-1	;HSTDSK
 0621+0000      	DW	0	;HSTTRK
 0623+0000      	DW	0	;HSTSEC
 0625+000D      	DW	@@	;HSTBUF
 0627+00        	DB	@@BNK	;HSTBNK
 0628+0000      	DW	0	;HSTMDL
 062A+3B06      	DW	$+HSTLEN ;LINK
 062C+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 062E+0000      	DW	0	;HSTMOD
 0630+00        	DB	FALSE	;PNDWRT
 0631+FF        	DB	-1	;HSTDSK
 0632+0000      	DW	0	;HSTTRK
 0634+0000      	DW	0	;HSTSEC
 0636+000F      	DW	@@	;HSTBUF
 0638+00        	DB	@@BNK	;HSTBNK
 0639+0000      	DW	0	;HSTMDL
 063B+4C06      	DW	$+HSTLEN ;LINK
 063D+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 063F+0000      	DW	0	;HSTMOD
 0641+00        	DB	FALSE	;PNDWRT
 0642+FF        	DB	-1	;HSTDSK
 0643+0000      	DW	0	;HSTTRK
 0645+0000      	DW	0	;HSTSEC
 0647+0011      	DW	@@	;HSTBUF
 0649+00        	DB	@@BNK	;HSTBNK
 064A+0000      	DW	0	;HSTMDL
 064C+5D06      	DW	$+HSTLEN ;LINK
 064E+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0650+0000      	DW	0	;HSTMOD
 0652+00        	DB	FALSE	;PNDWRT
 0653+FF        	DB	-1	;HSTDSK
 0654+0000      	DW	0	;HSTTRK
 0656+0000      	DW	0	;HSTSEC
 0658+0013      	DW	@@	;HSTBUF
 065A+00        	DB	@@BNK	;HSTBNK
 065B+0000      	DW	0	;HSTMDL
 065D+6E06      	DW	$+HSTLEN ;LINK
 065F+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0661+0000      	DW	0	;HSTMOD
 0663+00        	DB	FALSE	;PNDWRT
 0664+FF        	DB	-1	;HSTDSK
 0665+0000      	DW	0	;HSTTRK
 0667+0000      	DW	0	;HSTSEC
 0669+0015      	DW	@@	;HSTBUF
 066B+00        	DB	@@BNK	;HSTBNK
 066C+0000      	DW	0	;HSTMDL
 066E+7F06      	DW	$+HSTLEN ;LINK
 0670+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0672+0000      	DW	0	;HSTMOD
 0674+00        	DB	FALSE	;PNDWRT
 0675+FF        	DB	-1	;HSTDSK
 0676+0000      	DW	0	;HSTTRK
 0678+0000      	DW	0	;HSTSEC
 067A+0017      	DW	@@	;HSTBUF
 067C+00        	DB	@@BNK	;HSTBNK
 067D+0000      	DW	0	;HSTMDL
 067F+9006      	DW	$+HSTLEN ;LINK
 0681+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0683+0000      	DW	0	;HSTMOD
 0685+00        	DB	FALSE	;PNDWRT
 0686+FF        	DB	-1	;HSTDSK
 0687+0000      	DW	0	;HSTTRK
 0689+0000      	DW	0	;HSTSEC
 068B+0019      	DW	@@	;HSTBUF
 068D+00        	DB	@@BNK	;HSTBNK
 068E+0000      	DW	0	;HSTMDL
 0690+A106      	DW	$+HSTLEN ;LINK
 0692+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0694+0000      	DW	0	;HSTMOD
 0696+00        	DB	FALSE	;PNDWRT
 0697+FF        	DB	-1	;HSTDSK
 0698+0000      	DW	0	;HSTTRK
 069A+0000      	DW	0	;HSTSEC
 069C+001B      	DW	@@	;HSTBUF
 069E+00        	DB	@@BNK	;HSTBNK
 069F+0000      	DW	0	;HSTMDL
 06A1+B206      	DW	$+HSTLEN ;LINK
 06A3+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06A5+0000      	DW	0	;HSTMOD
 06A7+00        	DB	FALSE	;PNDWRT
 06A8+FF        	DB	-1	;HSTDSK
 06A9+0000      	DW	0	;HSTTRK
 06AB+0000      	DW	0	;HSTSEC
 06AD+001D      	DW	@@	;HSTBUF
 06AF+00        	DB	@@BNK	;HSTBNK
 06B0+0000      	DW	0	;HSTMDL
 06B2+C306      	DW	$+HSTLEN ;LINK
 06B4+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06B6+0000      	DW	0	;HSTMOD
 06B8+00        	DB	FALSE	;PNDWRT
 06B9+FF        	DB	-1	;HSTDSK
 06BA+0000      	DW	0	;HSTTRK
 06BC+0000      	DW	0	;HSTSEC
 06BE+001F      	DW	@@	;HSTBUF
 06C0+00        	DB	@@BNK	;HSTBNK
 06C1+0000      	DW	0	;HSTMDL
                 endif
 06C3 0000      xxhdr:	dw	0	;Link - initially last in list.
 06C5 0000      	dw	0	;hstpda
 06C7 0000      	dw	0	;hstmod
 06C9 00        	db	false	;pndwrt
 06CA FF        	db	-1	;hstdsk
 06CB 0000      	dw	0	;hsttrk
 06CD 0000      	dw	0	;hstsec
 06CF 0021      	dw	@@	;hstbuf
 06D1 00        	db	@@bnk	;hstbnk
 06D2 0000      	dw	0	;hstmdl
 2300 #         @@ set @@+secsize
                
                ; NOTE: this buffer can be used for reading only. (it is never flushed)
 06D4 0000      @scrcb: dw	0	;link - not used
 06D6 0000      	dw	0	;hstpda - not used
 06D8 0000      	dw	0	;hstmod
 06DA 00        	db	false	;pndwrt - assumed always false
 06DB FF        	db	-1	;hstdsk
 06DC 0000      	dw	0	;hsttrk
 06DE 0000      	dw	0	;hstsec
 06E0 0023      	dw	@@	;hstbuf
 06E2 00        	db	@@bnk	;hstbnk
 06E3 0000      	dw	0	;hstmdl
                
 06E5           	end
