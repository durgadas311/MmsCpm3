 6130 =         vers equ '0a' ; Nov 14, 2021  13:49  drm "MXIOS.ASM"
                ;****************************************************************
                ; MP/M main XIOS module for Z180 on the H8/H89			*
                ; Derived from the MMS 77500 server XIOS			*
                ; Copyright (c) 1983 Magnolia Microsystems			*
                ;****************************************************************
                ; All memory segments are ORGed at 0000.
                ; Uses CP/M Plus format DPBs.
                
                	maclib	z180
                	maclib	cfgsys
                
                	public	@adrv,@pdrv,@rdrv,@side,@trk,@sect
                	public	@dma,@dbnk,@dirbf
                	public	@dstat,@cmode,@dph,@rcnfg,@eops
                	public	@cbnk,@scrcb,@vect,@secnd
                
                	public	xdos,polltb,sysdat
                
                	extrn	@lptbl
                	extrn	?memsl,?bnksl,?bnkck,?xmove,?move	; MMU module
                	extrn	@memstr,@mmerr,@nbnk
                	extrn	?time,?itime,@rtcstr			; RTC module
                
                 if z180
 FFFF =         z180tick	equ	true
 0000 =         h89tick		equ	false
                 else
                  if h89
                z180tick	equ	false
                h89tick		equ	true
                tick$tick	equ	10	; number of 2mS ticks per MP/M tick
                  else
                ; TODO: what to use for tick?
                z180tick	equ	false
                h89tick		equ	false
                  endif
                 endif
                
 0200 =         secsize		equ	512	; largest sector size supported/used
                
 000D =         cr	equ 13
 000A =         lf	equ 10
 0007 =         bell	equ 7
                
 0000 =         cpm	equ	0
 0005 =         bdos	equ	5
                
 0083 =         poll	equ	131
 0085 =         flagset equ	133
                
                ;relative position of elements in buffer headers:
 0000 =         link	equ	0	;link to next headr, or 0
 0002 =         hstpda	equ	2	;Process Descriptor Adr of owner
 0004 =         hstmod	equ	4	;mode pointer (partition address)
 0006 =         pndwrt	equ	6	;pending write flag
 0007 =         hstdsk	equ	7	;host disk
 0008 =         hsttrk	equ	8	;host track
 000A =         hstsec	equ	10	;host sector
 000C =         hstbuf	equ	12	;host buffer address
 000E =         hstbnk	equ	14	;host bank
 000F =         hstmdl	equ	15	;host module entry
 0011 =         hstlen	equ	17	;length of header
                
                 if z180
                ; Z180 registers
 00F4 =         itc	equ	iobase+34h
 00F6 =         rcr	equ	iobase+36h
 00F8 =         mmu$cbr	equ	iobase+38h
 00F9 =         mmu$bbr	equ	iobase+39h
 00FA =         mmu$cbar equ	iobase+3ah
 00E0 =         sar0l	equ	iobase+20h
 00E1 =         sar0h	equ	iobase+21h
 00E2 =         sar0b	equ	iobase+22h
 00E3 =         dar0l	equ	iobase+23h
 00E4 =         dar0h	equ	iobase+24h
 00E5 =         dar0b	equ	iobase+25h
 00E6 =         bcr0l	equ	iobase+26h
 00E7 =         bcr0h	equ	iobase+27h
 00F0 =         dstat	equ	iobase+30h
 00F1 =         dmode	equ	iobase+31h
 00F2 =         dcntl	equ	iobase+32h
 00F3 =         il	equ	iobase+33h
 00CC =         tmdr0l	equ	iobase+0ch
 00CD =         tmdr0h	equ	iobase+0dh
 00CE =         rldr0l	equ	iobase+0eh
 00CF =         rldr0h	equ	iobase+0fh
 00D0 =         tcr	equ	iobase+10h
                 endif
                
                ;-------- Start of Code-producing source -----------
                
                	; Because LINK puts dseg after cseg, and 'combas' is
                	; at the beginning of dseg, GENSYS will enforce that
                	; all of dseg falls in common memory.
                	cseg		; Banked memory
 0000 =         BIOS$0	equ	$
 0000 C30000    	jmp combas	; initial entry on cold start, common base
 0003 C3C000    	jmp wboot	; reentry on program exit, warm start
                
 0006 C32402    	jmp const	; return console input status
 0009 C33202    	jmp conin	; return console input character
 000C C30A02    	jmp conout	; send console output character
 000F C30502    	jmp list	; send list output character
 0012 C3F801    	jmp auxout	; send auxilliary output character	-NULL
 0015 C3F501    	jmp auxin	; return auxilliary input character	-NULL
                
 0018 C30F03    	jmp home	; set disks to logical home
 001B C33D02    	jmp seldsk	; select disk drive, return disk parameter info
 001E C31203    	jmp settrk	; set disk track
 0021 C31703    	jmp setsec	; set disk sector
 0024 C31C03    	jmp setdma	; set disk I/O memory address
 0027 C33403    	jmp read	; read physical block(s)
 002A C35803    	jmp write	; write physical block(s)
                
 002D C3FC01    	jmp listst	; return list device status
 0030 C32803    	jmp sectrn	; translate logical to physical sector
                
 0033 C30000    	jmp	?memsl
 0036 C3F400    	jmp	poll$dev
 0039 C32901    	jmp	strtclk
 003C C32D01    	jmp	stopclk
 003F C32201    	jmp	exitreg
 0042 C31F01    	jmp	maxcon
 0045 C3DE00    	jmp	boot	;   sysinit
                ;	jmp	idle	;
 0048 000000    	nop ! nop ! nop	; no idle routine
                
 004B 0F01      	dw	polltb	;for RSP's (such as NETWRKIF)
                
 004D           	ds	13	;this puts setup/mode info where they expect it
 005A C3D501    	jmp	search
 005D C35F02    	jmp	setspd	; change CPU speed - platform dependent
 0060           	ds	3
                
                ; These are only static when accessed via XIOSJMP.TBL
 0063           @dstat: ds	1
 0064           speed:	ds	1	; formerly Port F2 image "@intby"
                
 0065 0000      	dw	@lptbl	;logical/physical drive table
 0067 6202      	dw	thread	;module thread
 0069 0000      	dw	0	;?serdp	;test mode validity, HL=memory address of ?serdp
                
 006B           @adrv:	ds	1		; currently selected disk drive
 006C           @pdrv:	ds	1		; physical drive number (MMS)
 006D           @rdrv:	ds	1		; module relative disk drive number
 006E           curmdl: ds	2		; currently selected Disk I/O module address
 0070           @cmode: ds	2
 0072           @dph:	ds	2
                
 0074 0080      icovec: dw	1000000000000000b
 0076 0080      icivec: dw	1000000000000000b
 0078 0000      iaovec: dw	0000000000000000b
 007A 0000      iaivec: dw	0000000000000000b
 007C 0000      ilovec: dw	0000000000000000b
                
 007E 00FFFFFF  defsrc: db	0,0ffh,0ffh,0ffh
 0082 00        tmpdrv: db	0
 0083 00        srctyp: db	000$00$000b	;only bits 3,4 are used (others ignored)
                
                	; for MODULES.COM... well, not quite since not in common memory...
                	; This will be copied to BIOS JMP PAGE, in common memory,
                	; but these strings must also reside in common memory.
 0084 0000      	dw	@memstr
 0086 0000      	dw	@rtcstr
                
 0088 0000      @dma:	dw	0
 008A 0000      wbtrap: dw	0
                
                	dseg
                ;---------- COMMON MEMORY -----------
                ; WARNING: must be on page boundary ('vect' alignment).
                ; Use LINK 'B' option.
 0000 C3C000    combas: jmp	colds
 0003 C30000    swtusr: jmp	$-$
 0006 C30000    swtsys: jmp	$-$
 0009 C30000    pdisp:	jmp	$-$
 000C C30000    xdos:	jmp	$-$
 000F 0000      sysdat: dw	$-$
                
                ; These locations are fixed, after combas block.
 0011 0000      @vect:	dw	$-$
 0013 0000      dbuga:	dw	$-$
 0015 0000      dbugv:	dw	$-$
 0017 0000      biosjmp:dw	$-$
 0019           @dbnk:	ds	1	; bank for user I/O (user DMA addr)
 001A           @eops:	ds	1
 001B           @intby: ds	1	; Port F2 image
                
 001C           @dirbf: ds	128
                
                 if z180
                	; Z180 internal devices interrupt vector table.
                	; If external devices also generate interrupts,
                	; this must be expanded/realigned to compensate.
                	; need 32-byte aligned address:
                	rept	(32 - (($-combas) AND 1fh)) AND 1fh
                	db	0
                	endm
 009C+00        	DB	0
 009D+00        	DB	0
 009E+00        	DB	0
 009F+00        	DB	0
 00A0 F100      vect:	dw	nulint	; 0 - /INT1
 00A2 F100      	dw	nulint	; 1 - /INT2
 00A4 4B01      	dw	tick	; 2 - PRT0 (TMDR0 -> 0)
 00A6 F100      	dw	nulint	; 3 - PRT1 (TMDR1 -> 0)
 00A8 F100      	dw	nulint	; 4 - DMA0
 00AA F100      	dw	nulint	; 5 - DMA1
 00AC F100      	dw	nulint	; 6 - CSIO
 00AE F100      	dw	nulint	; 7 - ASCI0
 00B0 F100      	dw	nulint	; 8 - ASCI1
 00B2 F100      	dw	nulint	; 9 - unused by Z180
 00B4 F100      	dw	nulint	; 10 - unused by Z180
 00B6 F100      	dw	nulint	; 11 - unused by Z180
 00B8 F100      	dw	nulint	; 12 - unused by Z180
 00BA F100      	dw	nulint	; 13 - unused by Z180
 00BC F100      	dw	nulint	; 14 - unused by Z180
 00BE F100      	dw	nulint	; 15 - unused by Z180
                 endif
                
                wboot:
                colds:
                 if z180
                	; possible TRAP
                	in0	a,itc
 00C0+ED38F4    	DB	0EDH, A*8+00H, ITC
                	tsti	10000000b	; TRAP bit
 00C3+ED6480    	DB	0EDH, 64H, 10000000B
                	jrnz	trap
 00C6+2019      	DB	20H,TRAP-$-1
                 endif
 00C8 0E00      	mvi	c,0
 00CA C30C00    	jmp	xdos
                
                msgout:
 00CD 7E        	mov	a,m
 00CE FE24      	cpi	'$'
 00D0 C8        	rz
 00D1 E5        	push	h
 00D2 4E        	mov	c,m
 00D3 1600      	mvi	d,0
 00D5 CD2002    	call	coo
 00D8 E1        	pop	h
 00D9 23        	inx	h
                	jr	msgout
 00DA+18F1      	DB	18H,MSGOUT-$-1
                
 00DC CDCD00    errx:	call	msgout
 00DF F376      	di ! hlt
                
                 if z180
                ; For now, any TRAP is fatal
 00E1 21E600    trap:	lxi	h,trpmsg
                	jr	errx
 00E4+18F6      	DB	18H,ERRX-$-1
                
 00E6 0D0A2A5452trpmsg:	db	cr,lf,'*TRAP*',cr,lf,'$'
                 endif
                
 00F1 FB        nulint:	ei
                	reti
 00F2+ED4D      	DB	0EDH,4DH
                
                ; C=device to poll, 0-N char I/O devices (input status)
                poll$dev:
 00F4 79        	mov	a,c
 00F5 FE08      	cpi	8
                	jrnc	pd0	; not char I/O...
 00F7+300A      	DB	30H,PD0-$-1
 00F9 51        	mov	d,c
 00FA D604      	sui	4
 00FC DA2402    	jc	const
 00FF 57        	mov	d,a
 0100 C30102    	jmp	conost
 0103 0600      pd0:	mvi	b,0
 0105 210F01    	lxi	h,polltb
 0108 09        	dad	b
 0109 09        	dad	b
 010A 5E        	mov	e,m
 010B 23        	inx	h
 010C 56        	mov	d,m
                	; TODO: check DE=NULL?
 010D EB        	xchg
 010E E9        	pchl
                
                ; Devices 8..15, starting at +0...
 010F 0000000000polltb:	dw	$-$,$-$,$-$,$-$,$-$,$-$,$-$,$-$ ; 8..15 unassigned (yet)
                
 011F 3E00      maxcon: mvi	a,0	;filled in at init from SYSDAT and config
 0121 C9        	ret
                
                exitreg:
 0122 3A3301    	lda	preempt
 0125 B7        	ora	a
 0126 C0        	rnz
 0127 FB        	ei
 0128 C9        	ret
                
 0129 3EFF      strtclk: mvi	a,true
                	 jr	sc00
 012B+1802      	DB	18H,SC00-$-1
 012D 3E00      stopclk: mvi	a,false
 012F 323401    sc00:	 sta	clock
 0132 C9        	 ret
                
 0133 00        preempt: db	0
 0134 00        clock:	 db	0
                
 0135 0000      @secnd: dw	$-$	;used to do timeouts
                
 0137 00        tps:	db	0	; from system data page on boot
 0138 00        pcnt:	db	0	; pre-scale for interrupts to MP/M ticks
 0139 00        tcnt:	db	0	; must immediately follow pcnt...
                
                second:
 013A 2A3501    	lhld	@secnd
 013D 7C        	mov	a,h
 013E B5        	ora	l
 013F C45002    	cnz	icall
 0142 1E02      	mvi	e,2
 0144 0E85      	mvi	c,flagset
 0146 CD0C00    	call	xdos
                	jr	tk1
 0149+1832      	DB	18H,TK1-$-1
                
                tick:	sspd	istk
 014B+ED73      	DB	0EDH,73H
 014D+D301      	DW	ISTK
 014F 31D301    	lxi	sp,intstk
 0152 F5        	push	psw
 0153 E5        	push	h
 0154 D5        	push	d
 0155 C5        	push	b
                 if z180tick
                	; It appears that ALL of these are required
                	in0	a,tcr		; reset INT
 0156+ED38D0    	DB	0EDH, A*8+00H, TCR
                	in0	a,tmdr0l	; reset INT
 0159+ED38CC    	DB	0EDH, A*8+00H, TMDR0L
                	in0	a,tmdr0h	; reset INT
 015C+ED38CD    	DB	0EDH, A*8+00H, TMDR0H
                 endif
                 if h89tick
                	lda	@intby
                	out	0f2h	; reset INT
                	lxi	h,pcnt
                	dcr	m
                	jrnz	iexit
                	mvi	m,tick$tick
                 endif
 015F 3EFF      	mvi	a,true
 0161 323301    	sta	preempt
 0164 3A3401    	lda	clock
 0167 B7        	ora	a
                	jrz	tk0
 0168+2807      	DB	28H,TK0-$-1
 016A 1E01      	mvi	e,1
 016C 0E85      	mvi	c,flagset
 016E CD0C00    	call	xdos
                tk0:
 0171 213901    	lxi	h,tcnt
 0174 35        	dcr	m
                	jrnz	tk1
 0175+2006      	DB	20H,TK1-$-1
 0177 3A3701    	lda	tps
 017A 77        	mov	m,a
                	jr	second
 017B+18BD      	DB	18H,SECOND-$-1
 017D 3E00      tk1:	mvi	a,false
 017F 323301    	sta	preempt
                 if z180tick
 0182 118801    	lxi	d,nexti
 0185 D5        	push	d
                	reti	; required by Z180?
 0186+ED4D      	DB	0EDH,4DH
                nexti:
                 endif
 0188 C1        	pop	b
 0189 D1        	pop	d
 018A E1        	pop	h
 018B F1        	pop	psw
                	lspd	istk
 018C+ED7B      	DB	0EDH,07BH
 018E+D301      	DW	ISTK
 0190 C30900    	jmp	pdisp
                
                 if h89tick
                iexit:
                	pop	b
                	pop	d
                	pop	h
                	pop	psw
                	lspd	istk
                	ei
                	ret
                 endif
                
 0193           	ds	64	;32 levels of stack
 01D3           intstk: ds	0
 01D3 0000      istk:	dw	0
                
                ; SEARCH for a module by device #.
                ;   entry:	C = device # (0-249)
                ;   exit:	[CY] = not found
                ;	   else HL=module address ("init" entry)
                ;		A=device number (relative to module's #0)
                ;
 01D5 116202    search: lxi	d,thread	;C=device number
 01D8 EB        snext:	xchg
 01D9 5E        	mov	e,m
 01DA 23        	inx	h
 01DB 56        	mov	d,m
 01DC 23        	inx	h
 01DD 7A        	mov	a,d
 01DE B3        	ora	e
 01DF D601      	sui	1	;produce [CY] if DE=0000
 01E1 D8        	rc		;return if device not found, DE=0000
 01E2 79        	mov	a,c
 01E3 96        	sub	m
                	jrc	snext
 01E4+38F2      	DB	38H,SNEXT-$-1
 01E6 23        	inx	h
 01E7 BE        	cmp	m
                	jrnc	snext
 01E8+30EE      	DB	30H,SNEXT-$-1
 01EA 23        	inx	h	;point to "init" vector
 01EB B7        	ora	a	;set [NC] condition
 01EC C9        	ret
                
 01ED 0000      ciomdl:	dw	0	;character device driver, filled at cold-start.
 01EF 00        cionum:	db	0	;max num cio devices (numcon+numlst)
                
                cinit:	;C=device number (0-11)
 01F0 2AED01    	lhld	ciomdl	; init routine
 01F3 41        	mov	b,c
 01F4 E9        	pchl		;jump to modules "init" with B=device #
                
 01F5 3E1A      auxin:	mvi	a,1ah	; EOF
 01F7 B7        	ora	a
 01F8 C9        auxout:	ret
                
 01F9 F1        nodev:	pop	psw
 01FA AF        nost:	xra	a	; never ready
 01FB C9        	ret
                
                ; D=device number
                listst:
 01FC 3A2001    	lda	maxcon+1
 01FF 82        	add	d
 0200 57        	mov	d,a	; LST: #0 = con#N+1
                conost:
 0201 3E09      	mvi	a,9
                	jr	devio
 0203+1821      	DB	18H,DEVIO-$-1
                
                ; D=device number, C=char
                list:
 0205 3A2001    	lda	maxcon+1
 0208 82        	add	d
 0209 57        	mov	d,a	; LST: #0 = con#N+1
                conout:
 020A C5        	push	b
 020B D5        	push	d
 020C CD0102    	call	conost	; is ready now?
 020F B7        	ora	a
 0210 C21E02    	jnz	co0
 0213 D1        	pop	d
 0214 D5        	push	d
 0215 7A        	mov	a,d
 0216 C604      	adi	4
 0218 5F        	mov	e,a
 0219 0E83      	mvi	c,poll
 021B CD0C00    	call	xdos	; sleep until ready
 021E D1        co0:	pop	d
 021F C1        	pop	b
 0220 3E0C      coo:	mvi	a,12
                	jr	devio
 0222+1802      	DB	18H,DEVIO-$-1
                
                ; D=device number
 0224 3E03      const:	mvi	a,3
                	;jr	devio
                
                ; A=JMP tbl off, D=devnum [C=char]
 0226 F5        devio:	push	psw
 0227 3AEF01    	lda	cionum	;see if device exists
 022A 3D        	dcr	a
 022B BA        	cmp	d
                	jrc	nodev
 022C+38CB      	DB	38H,NODEV-$-1
 022E F1        	pop	psw	; driver JMP offset
 022F 42        	mov	b,d	;device number in B for modules
                	jr	indjmp0
 0230+1815      	DB	18H,INDJMP0-$-1
                
                ; D=device number
 0232 D5        conin:	push	d
 0233 CD2402    	call	const	; is ready now?
 0236 B7        	ora	a
 0237 C24202    	jnz	ci0
 023A D1        	pop	d
 023B D5        	push	d
 023C 5A        	mov	e,d
 023D 0E83      	mvi	c,poll
 023F CD0C00    	call	xdos	; sleep until ready
 0242 D1        ci0:	pop	d
 0243 3E06      	mvi	a,6
                	jr	devio
 0245+18DF      	DB	18H,DEVIO-$-1
                
                ; char I/O driver function calls
                ; A=offset (0,3,6,9,...), B=device number (0..N)
                indjmp0:
 0247 2AED01    	lhld	ciomdl
 024A 85        	add	l	;a=0,3,6,9,12,...
 024B 6F        	mov	l,a
 024C 3E00      	mvi	a,0
 024E 8C        	adc	h
 024F 67        	mov	h,a
 0250 E9        icall:	pchl		;indirect call
                
                
 0251 00        @cbnk:	db	0	; bank for processor operations
 0252           bnkflg: ds	1	;flag for enough memory installed.
                
                getusrbnk:	;finds the bank number for calling process
 0253 CD0300    	call	swtusr		; would like better way...
 0256 3A5102    	lda	@cbnk
 0259 321900    	sta	@dbnk
 025C C30600    	jmp	swtsys
                
                 if h89
                ; CPU clock rate selected, ORG0+2mS handled by user
                cpuspd:	db	00h,10h,04h,14h
                 endif
                
                ; A=0,1,2,3[...] speed index, FF=get current speed
                ; Returns A: FF=error, FE=not supported, 0,1,2,3...=success
                ; Called from user bank, must be in common mem.
                setspd:
                 if h89
                	cpi	0ffh
                	jrz	ssx
                	sta	speed
                	mov	e,a
                	cpi	4
                	mvi	a,0ffh
                	rnc
                	lxi	h,cpuspd
                	mvi	d,0
                	dad	d
                	mov	d,m
                	di
                	lda	@intby
                	ani	11101011b
                	ora	d
                	sta	@intby
                	out	0f2h	; speed changes now
                  if z180tick
                	; there will be a small error until next tick
                	lxi	h,maxclk
                	mov	a,e
                	cpi	3
                	jrz	ss0
                	lxi	h,minclk
                	ora	a
                	jrz	ss0
                ss1:	dad	h
                	dcr	a
                	jrnz	ss1
                ss0:	; HL=timer value for 50Hz tick
                	out0	l,rldr0l	; update timer reload count
                	out0	h,rldr0h	;
                  endif
                ssx:	lda	speed	; always return current speed
                 else
 025F 3EFE      	mvi	a,0feh	; not supported
                 endif
 0261 C9        	ret
                
 0262 =         thread: equ	$	;must be last in dseg (common mem)
                
                	cseg	; rest is in banked memory...
                
 008C 0D0A07    signon: db	cr,lf,bell
                 if h89
                	db	'H8-'
                 endif
                 if rc2014
 008F 5243323031	db	'RC2014-'
                 endif
                ; TODO: other platforms...
                 if z180
 0096 5A313830  	db	'Z180'
                 else
                	db	'Z80'
                 endif
 009A 204D502F4D	db	' MP/M-II v3.00'
 00A8 3061      	dw	vers
 00AA 2020286329	db	'  (c) 1984 DRI and MMS',cr,lf,'$'
                
 00C3 0D0A074E6Fbnkerr:	db	cr,lf,bell,'Not enough memory banks$'
                
                ; Interrupts are disabled
                ; HL = BIOS JMP table
                ; DE = debug entry
                ; C = debug RST num
                boot:
                 if h89
                	; This is H89-specific...
                	mvi	a,defspd
                	sta	speed
                	lda	cpuspd+defspd
                	ori	00100000b	; ORG0 only, right now
                	sta	@intby
                	out	0f2h	; prevent undesirable intrs
                			; Console 8250 should already be off
                 endif
                 if z180
                	; speed things up...
 00DE 3E50      	mvi	a,z$dcntl
                	out0	a,dcntl	; set WAIT states
 00E0+ED39F2    	DB	0EDH, A*8+01H, DCNTL
 00E3 3E00      	mvi	a,z$rcr
                	out0	a,rcr	; set RESFRESH cycles
 00E5+ED39F6    	DB	0EDH, A*8+01H, RCR
                 endif
                	;
                	sded	dbuga
 00E8+ED53      	DB	0EDH,53H
 00EA+1300      	DW	DBUGA
 00EC 221700    	shld	biosjmp
 00EF 79        	mov	a,c
 00F0 87        	add	a
 00F1 87        	add	a
 00F2 87        	add	a
 00F3 6F        	mov	l,a
 00F4 2600      	mvi	h,0
 00F6 221500    	shld	dbugv
                 if z180tick
 00F9 21A000    	lxi	h,vect
 00FC 221100    	shld	@vect
 00FF 7C        	mov	a,h
                	stai
 0100+ED47      	DB	0EDH,47H
                	out0	l,il
 0102+ED29F3    	DB	0EDH, L*8+01H, IL
                 endif
                 if h89tick
                	mvi	a,JMP
                	sta	0008h
                	lxi	h,tick
                	shld	0008h+1
                	lda	@intby
                	ori	02h
                	sta	@intby
                	out	0f2h
                 endif
                
 0105 2A0F00    	lhld	sysdat
 0108 2E7A      	mvi	l,122	;ticks/sec
 010A 7E        	mov	a,m
 010B 323701    	sta	tps
 010E 323901    	sta	tcnt
 0111 2EFC      	mvi	l,252	;XDOS internal data page
 0113 5E        	mov	e,m
 0114 23        	inx	h
 0115 56        	mov	d,m
 0116 210500    	lxi	h,5
 0119 19        	dad	d	; skip past TOD
 011A 22F005    	shld	rlr
 011D 219600    	lxi	h,0096h	; osmsegtbl
 0120 19        	dad	d
 0121 22F205    	shld	msegtbl
                ; get common size from SYSDAT
 0124 2A0F00    	lhld	sysdat
 0127 2E7C      	mvi	l,124		;common memory base page
 0129 7E        	mov	a,m
                ; Verify that we have banked RAM... A=compag from MP/M
 012A CD0000    	call	?bnkck
 012D 325202    	sta	bnkflg
                 if z180tick
                ; initialize timer interrupts
 0130 210048    	lxi	h,tickrate	; phi/20/tickrate = ticks per sec
                	out0	l,tmdr0l
 0133+ED29CC    	DB	0EDH, L*8+01H, TMDR0L
                	out0	h,tmdr0h
 0136+ED21CD    	DB	0EDH, H*8+01H, TMDR0H
                	out0	l,rldr0l
 0139+ED29CE    	DB	0EDH, L*8+01H, RLDR0L
                	out0	h,rldr0h
 013C+ED21CF    	DB	0EDH, H*8+01H, RLDR0H
                	in0	a,tcr
 013F+ED38D0    	DB	0EDH, A*8+00H, TCR
 0142 F611      	ori	00010001b	; TIE0, TDE0
                	out0	a,tcr		; start the timer
 0144+ED39D0    	DB	0EDH, A*8+01H, TCR
                 endif
                ; Initialize all modules and build tables.
 0147 216202    	lxi	h,thread	;thread our way through the modules,
 014A 5E        iin0:	mov	e,m		;initializing as we go.
 014B 23        	inx	h
 014C 56        	mov	d,m	;next module, or "0000" if we're past the end.
 014D 23        	inx	h
 014E 7A        	mov	a,d
 014F B3        	ora	e
 0150 CA9501    	jz	init$done
 0153 7E        	mov	a,m	;device base number
 0154 23        	inx	h
 0155 23        	inx	h	;thread+4 = init entry (JMP)
 0156 D6C8      	sui	200	;if Char I/O module, build entry(s) in tables.
 0158 DA8D01    	jc	notchr
                	; should only be one...
 015B 22ED01    	shld	ciomdl
 015E D5        	push	d	;save NEXT module address
 015F 2B        	dcx	h	;number of devices
 0160 E5        	push	h
 0161 2A0F00    	lhld	sysdat
 0164 23        	inx	h	;nmb$cns
 0165 56        	mov	d,m	;E=nmb$cns
 0166 2EC5      	mvi	l,197
 0168 5E        	mov	e,m	;D=nmb$lst
 0169 E1        	pop	h	;HL=ciomdl.ndev
 016A 7B        	mov	a,e
 016B 82        	add	d	;total ndev needed (never 0)
 016C 3D        	dcr	a
 016D 96        	sub	m	; (nmb$cns+nmb$lst-1) - ciomdl.ndev
                	jrc	iin50	; OK, we have enough
 016E+3811      	DB	38H,IIN50-$-1
 0170 3C        	inr	a	; num devs to drop
 0171 93        	sub	e	; drop printers first
                	jrz	iin3
 0172+2802      	DB	28H,IIN3-$-1
                	jrnc	iin1
 0174+3005      	DB	30H,IIN1-$-1
                iin3:	neg
 0176+ED44      	DB	0EDH,44H
 0178 5F        	mov	e,a	; num$lst remaining
                	jr	iin50
 0179+1806      	DB	18H,IIN50-$-1
 017B 1E00      iin1:	mvi	e,0	; no printers left, must reduce nmb$cns
 017D 92        	sub	d	; must be neg
                	neg
 017E+ED44      	DB	0EDH,44H
 0180 57        	mov	d,a
 0181 7A        iin50:	mov	a,d	; adjusted nmb$cns
 0182 322001    	sta	maxcon+1
 0185 83        	add	e	; adjusted nmb$lst
 0186 32EF01    	sta	cionum	; initialize only what is needed
 0189 E1        	pop	h	; next module
 018A C34A01    	jmp	iin0
                
                notchr: 		;HL point to init entry
 018D D5        	push	d
 018E CD5002    	call	icall	;"call" (HL)
 0191 E1        	pop	h
 0192 C34A01    	jmp	iin0
                
                init$done:	;all Disk I/O modules are initialized.
                		; now initialize the chrio devices
 0195 3AEF01    	lda	cionum
 0198 4F        	mov	c,a	; last dev + 1
 0199 0D        iin5:	dcr	c
 019A FAA401    	jm	iin2	; include dev 0
 019D C5        	push	b
 019E CDF001    	call	cinit
 01A1 C1        	pop	b
                	jr	iin5
 01A2+18F5      	DB	18H,IIN5-$-1
                iin2:
 01A4 218C00    	lxi	h,signon
 01A7 CDCD00    	call	msgout
 01AA 3A5202    	lda	bnkflg
 01AD B7        	ora	a	;is enough memory installed?
 01AE CA1702    	jz	ramerr
 01B1 CDC201    	call	segchk	; check memsegtbl (if banked RAM good)
 01B4 B7        	ora	a
 01B5 CA1102    	jz	segerr
 01B8 CDDA01    	call	set$jumps  ;setup system jumps and put in all banks
 01BB CD0000    	call	?itime	; get (starting) TOD from RTC
                
                 if z180tick
                	im2
 01BE+ED5E      	DB	0EDH,5EH
                 endif
 01C0 AF        	xra	a
 01C1 C9        	ret
                
                ; Verify that memsegtbl has no bank >= @nbnk
                segchk:
 01C2 2A0F00    	lhld	sysdat
 01C5 2E0F      	mvi	l,15	; max$mem$seg
 01C7 46        	mov	b,m
 01C8 3A0000    	lda	@nbnk	; num banks
 01CB 3D        	dcr	a	; largest bank num allowed
                sgck0:
 01CC 23        	inx	h
 01CD 23        	inx	h
 01CE 23        	inx	h
 01CF 23        	inx	h	; memsegtbl[x].bank
 01D0 BE        	cmp	m
                	jrc	sgck1
 01D1+3805      	DB	38H,SGCK1-$-1
                	djnz	sgck0
 01D3+10F7      	DB	10H,SGCK0-$-1
 01D5 F6FF      	ori	true
 01D7 C9        	ret
 01D8 AF        sgck1:	xra	a	; error - not enough banks
 01D9 C9        	ret
                
                ; Interrupts disabled, must not enable
                set$jumps:
                	liyd	dbugv
 01DA+FD2A      	DB	0FDH,2AH
 01DC+1500      	DW	DBUGV
 01DE 3EC3      	mvi	a,(JMP)
 01E0 320000    	sta	cpm
                	sty	a,+0      ; set up jumps in page zero
 01E3+FD7700    	DB	0FDH,70H+A,+0
 01E6 2A17002201	lhld	biosjmp ! shld cpm+1	; BIOS warm start entry
 01EC 2A1300    	lhld	dbuga
                	sty	l,+1
 01EF+FD7501    	DB	0FDH,70H+L,+1
                	sty	h,+2	; DEBUGGER entry point
 01F2+FD7402    	DB	0FDH,70H+H,+2
 01F5 3A0000    	lda	@nbnk
 01F8 47        	mov	b,a	;number of banks (also, -1 is dest bank)
 01F9 0E00      	mvi	c,0	;source bank
                sj0:
 01FB 05        	dcr	b
 01FC C8        	rz
 01FD C5        	push	b
                	; must setup DE,HL before ?xmove
 01FE 210000    	lxi	h,0	; page 0 in all banks
 0201 54        	mov	d,h
 0202 5D        	mov	e,l
 0203 CD0000    	call	?xmove
 0206 014000    	lxi	b,64
 0209 AF        	xra	a	; interrupts are disabled
 020A CD0000    	call	?move
 020D C1        	pop	b
                	jr	sj0		;
 020E+18EB      	DB	18H,SJ0-$-1
 0210 C9        	ret
                
 0211 21C300    segerr: lxi	h,bnkerr
 0214 C3DC00    	jmp	errx
 0217 210000    ramerr: lxi	h,@mmerr
 021A C3DC00    	jmp	errx
                
 021D 0000000000@dtbl:	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                
                seldsk:
 023D 79326B00  	mov a,c ! sta @adrv			; save drive select code
 0241 210000    	lxi	h,@lptbl
 0244 060009    	mvi b,0 ! dad b 	      ; create index from drive code
 0247 7E        	mov	a,m
 0248 FEFF      	cpi	255
 024A CACB02    	jz	selerr
 024D 326C00    	sta	@pdrv
 0250 4F        	mov	c,a
 0251 43        	mov	b,e	;save login flag thru "search" routine
 0252 CDD501    	call	search
 0255 DACB02    	jc	selerr
 0258 326D00    	sta	@rdrv
 025B 226E00    	shld	curmdl
 025E C5        	push	b	;save login bit
 025F 110E00    	lxi	d,14
 0262 19        	dad	d	;point to dphtbl
 0263 5E        	mov	e,m	;DE=dphtbl
 0264 23        	inx	h
 0265 56        	mov	d,m
 0266 23        	inx	h
 0267 4E        	mov	c,m	;BC=modtbl
 0268 23        	inx	h
 0269 46        	mov	b,m
 026A 3A6D00    	lda	@rdrv
 026D 87        	add	a
 026E 87        	add	a
 026F 87        	add	a	;*8
 0270 6F        	mov	l,a
 0271 2600      	mvi	h,0
 0273 09        	dad	b	;select mode bytes
 0274 227000    	shld	@cmode	;set current mode pointer
 0277 C1        	pop	b	;get login bit back.
                	bit	0,b	;test for initial select.
 0278+CB40      	DB	0CBH,0*8+B+40H
                	jrnz	notlgi
 027A+2053      	DB	20H,NOTLGI-$-1
 027C EB        	xchg		;DE=modes
 027D 4F        	mov	c,a
 027E 0600      	mvi	b,0
 0280 09        	dad	b	;+*8
 0281 09        	dad	b	;+*16
 0282 227200    	shld	@dph
 0285 EB        	xchg
 0286 3A6B00    	lda	@adrv
 0289 4F        	mov	c,a
 028A 87        	add	a	;*2
 028B 87        	add	a	;*4
 028C 87        	add	a	;*8
 028D 87        	add	a	;*16
 028E 81        	add	c	;*17
 028F 4F        	mov	c,a	;B still = 0
 0290 CD0603    	call	setup$dph
                	jrc	selerr
 0293+3836      	DB	38H,SELERR-$-1
 0295 AF        	xra	a
 0296 32DD05    	sta	@rcnfg
 0299 2A6E00    	lhld	curmdl
                	lxiy	@scrcb
 029C+FD21      	DB	0FDH,21H
 029E+1D07      	DW	@SCRCB
 02A0 3A6C00    	lda	@pdrv
                	sty	a,hstdsk
 02A3+FD7707    	DB	0FDH,70H+A,HSTDSK
 02A6 3E03      	mvi	a,3
 02A8 CDCF05    	call	calmod	;call module's "login" routine.
 02AB B7        	ora	a	;see if an error occured.
                	jrnz	selerr
 02AC+201D      	DB	20H,SELERR-$-1
 02AE 3ADD05    	lda	@rcnfg
 02B1 B7        	ora	a
 02B2 C40603    	cnz	setup$dph
                	jrc	selerr
 02B5+3814      	DB	38H,SELERR-$-1
 02B7 3A6B00    	lda	@adrv
 02BA 87        	add	a
 02BB 4F        	mov	c,a
 02BC 0600      	mvi	b,0
 02BE 211D02    	lxi	h,@dtbl
 02C1 09        	dad	b
                	lded	@dph
 02C2+ED5B      	DB	0EDH,5BH
 02C4+7200      	DW	@DPH
 02C6 73        	mov	m,e	;set current DPH in @dtbl
 02C7 23        	inx	h
 02C8 72        	mov	m,d
                	jr	selcom	;DE=dph
 02C9+1816      	DB	18H,SELCOM-$-1
                
 02CB 210000    selerr: lxi	h,0
 02CE C9        	ret
                
 02CF 3A6B00    notlgi: lda	@adrv
 02D2 87        	add	a
 02D3 4F        	mov	c,a
 02D4 0600      	mvi	b,0
 02D6 211D02    	lxi	h,@dtbl
 02D9 09        	dad	b
 02DA 5E        	mov	e,m	;get current DPH from @dtbl
 02DB 23        	inx	h
 02DC 56        	mov	d,m	;DE=dph
                	sded	@dph
 02DD+ED53      	DB	0EDH,53H
 02DF+7200      	DW	@DPH
                selcom:
 02E1 210A00    	lxi	h,+10
 02E4 19        	dad	d	;point to DPB entry
 02E5 4E        	mov	c,m
 02E6 23        	inx	h
 02E7 46        	mov	b,m
 02E8 0A        	ldax	b	;SPT (logical)
 02E9 32DC05    	sta	@spt
 02EC 210300    	lxi	h,+3
 02EF 09        	dad	b
 02F0 7E        	mov	a,m	;BSM
 02F1 32E905    	sta	blkmsk
 02F4 210D00    	lxi	h,+13	;point to track offset
 02F7 09        	dad	b
 02F8 4E        	mov	c,m
 02F9 23        	inx	h
 02FA 46        	mov	b,m
 02FB 23        	inx	h
                	sbcd	offset
 02FC+ED43      	DB	0EDH,43H
 02FE+DF05      	DW	OFFSET
 0300 7E        	mov	a,m	;psh
 0301 32DE05    	sta	blcode
 0304 EB        	xchg		;put DPH in (HL) for BDOS
 0305 C9        	ret
                
                setup$dph:
 0306 B7        	ora	a	;reset [CY]
 0307 2A7000    	lhld	@cmode	;HL=modes
                	bit	7,m	;check for hard-disk drive (modes not standard)
 030A+CB7E      	DB	0CBH,7*8+M+40H
 030C C0        	rnz
 030D 37        	stc
 030E C9        	ret
                
 030F 010000    home:	lxi b,0 	; same as set track zero
                settrk: sbcd @trk
 0312+ED43      	DB	0EDH,43H
 0314+D705      	DW	@TRK
 0316 C9        	ret
                
                setsec: sbcd @sect
 0317+ED43      	DB	0EDH,43H
 0319+D905      	DW	@SECT
 031B C9        	ret
                
                setdma:
 031C 78        	mov	a,b
 031D A1        	ana	c
 031E FEFF      	cpi	true
 0320 CA6405    	jz	flushall
                	sbcd	@dma
 0323+ED43      	DB	0EDH,43H
 0325+8800      	DW	@DMA
 0327 C9        	ret
                
 0328 6960      sectrn: mov l,c ! mov h,b
 032A 7AB3C8    	mov a,d ! ora e ! rz
 032D EB096E2600	xchg ! dad b ! mov l,m ! mvi h,0
 0332 2B        	dcx	h	;sectors numbered 0 - (n-1)
 0333 C9        	ret
                
                
                read:
 0334 3EFF      	mvi	a,true		; FLAG A READ OPERATION
 0336 32E305    	sta	preread 	; forces FLUSH and Physical READ
 0339 32EA05    	sta	rdflg
 033C 32E405    	sta	defer		; never flush if reading (pointless)
 033F 2F        	cma	; false
 0340 32E505    	sta	unalloc ;terminate any active unallocated-writing
 0343 2AEC05    	LHLD	REQTRK
 0346 3ADF05    	lda	OFFSET
 0349 95        	sub	l	; DIR track must be < 256
 034A B4        	ora	h	; 00=on DIR track
 034B 2AD905    	lhld	@sect
 034E B4        	ora	h	;
 034F B5        	ora	l	; 00=first sector of directory
 0350 D601      	sui	1	; CY = 1st sec of dir
 0352 9F        	sbb	a	; FF = 1st sec of dir, else 00
 0353 32E205    	sta	dir0
                	jr	rwoper
 0356+1852      	DB	18H,RWOPER-$-1
                
                write:
 0358 AF        	xra	a
 0359 32E205    	sta	dir0
 035C 32EA05    	sta	rdflg
 035F 3EFF      	mvi	a,true
 0361 32E305    	STA	preread 	; assume a PRE-READ
 0364 79        	mov	a,c
 0365 E601      	ani	1		; 00 = defered write, else 01
 0367 3D        	dcr	a		; FF = defer, else 00
 0368 32E405    	sta	defer
                	bit	1,c		; write to 1st sector of unallocated block ?
 036B+CB49      	DB	0CBH,1*8+C+40H
                	jrz	CHKUNA
 036D+280D      	DB	28H,CHKUNA-$-1
                	SDED	URECORD 	; SET UNALLOCATED RECORD #
 036F+ED53      	DB	0EDH,53H
 0371+E605      	DW	URECORD
 0373 78        	mov	a,b
 0374 32E805    	sta	urecord+2
 0377 3EFF      	mvi	a,true
 0379 32E505    	STA	UNALLOC 	; FLAG WRITING OF AN UNALLOCATED BLOCK
 037C 3AE505    CHKUNA: LDA	UNALLOC 	; ARE WE WRITING AN UNALLOCATED BLOCK ?
 037F B7        	ORA	A
                	JRZ	rwoper
 0380+2828      	DB	28H,RWOPER-$-1
 0382 2AE605    	LHLD	URECORD 	; IS REQUESTED RECORD SAME AS EXPECTED
                	DSBC	D		;  SAME AS EXPECTED UNALLOCATED RECORD ?
 0385+ED52      	DB	0EDH,D*8+42H
                	JRNZ	ALLOC		; IF NOT, THEN DONE WITH UNALLOCATED BLOCK
 0387+201D      	DB	20H,ALLOC-$-1
 0389 3AE805    	lda	urecord+2
 038C 90        	sub	b
                	jrnz	alloc
 038D+2017      	DB	20H,ALLOC-$-1
 038F AF        	XRA	A		; CLEAR PRE-READ FLAG
 0390 32E305    	STA	preread
 0393 210100    	lxi	h,1		; INCREMENT TO NEXT EXPECTED UNALLOCATED RECORD
 0396 19        	dad	d
 0397 22E605    	shld	urecord
 039A 3E00      	mvi	a,0
 039C 88        	adc	b
 039D 32E805    	sta	urecord+2
 03A0 3AE905    	LDA	BLKMSK
 03A3 A5        	ana	l		; IS IT THE START OF A NEW BLOCK ?
                	JRNZ	rwoper
 03A4+2004      	DB	20H,RWOPER-$-1
 03A6 AF        ALLOC:	XRA	A		; NO LONGER WRITING AN UNALLOCATED BLOCK
 03A7 32E505    	STA	UNALLOC
                rwoper:
                	; RLR - Ready List Root - points to the current process
 03AA 2AF005    	lhld	rlr
 03AD 4E        	mov	c,m
 03AE 23        	inx	h
 03AF 46        	mov	b,m	;BC=PDAdr, must be preserved throughout.
                ; get a buffer for this disk access...
                 if lrubuf
                	lixd	hsttop
 03B0+DD2A      	DB	0DDH,2AH
 03B2+F405      	DW	HSTTOP
 03B4 210000    	lxi	h,0
 03B7 22F805    	shld	previous
 03BA 2AF405    	lhld	hsttop
 03BD 7C        	mov	a,h
 03BE B5        	ora	l
 03BF C2C803    	jnz	sd0
 03C2 2AF605    	lhld	fretop
 03C5 C3F503    	jmp	sd1
                sd0:	ldx	e,link
 03C8+DD5E00    	DB	0DDH,E*8+46H,LINK
                	ldx	d,link+1
 03CB+DD5601    	DB	0DDH,D*8+46H,LINK+1
                	ldx	l,hstpda
 03CE+DD6E02    	DB	0DDH,L*8+46H,HSTPDA
                	ldx	h,hstpda+1
 03D1+DD6603    	DB	0DDH,H*8+46H,HSTPDA+1
 03D4 B7        	ora	a
                	dsbc	b	;compare P.D.Adr
 03D5+ED42      	DB	0EDH,B*8+42H
 03D7 CA0004    	jz	sd2
 03DA 7A        	mov	a,d
 03DB B3        	ora	e
 03DC CAE903    	jz	sd3
                	sixd	previous
 03DF+DD22      	DB	0DDH,22H
 03E1+F805      	DW	PREVIOUS
 03E3 D5        	push	d
                	popix
 03E4+DDE1      	DB	0DDH,0E1H
 03E6 C3C803    	jmp	sd0
                sd3:	sixd	last
 03E9+DD22      	DB	0DDH,22H
 03EB+FA05      	DW	LAST
 03ED 2AF605    	lhld	fretop
 03F0 7C        	mov	a,h
 03F1 B5        	ora	l
 03F2 CA1104    	jz	sd4
 03F5 5E        sd1:	mov	e,m
 03F6 23        	inx	h
 03F7 56        	mov	d,m
 03F8 2B        	dcx	h
                	sded	fretop
 03F9+ED53      	DB	0EDH,53H
 03FB+F605      	DW	FRETOP
 03FD C32704    	jmp	setbuf
                ; found our buffer, may not be at top of list.
 0400 2AF805    sd2:	lhld	previous	;patch previous bufr to skip this one,
 0403 7C        	mov	a,h		;unless this is already first.
 0404 B5        	ora	l
 0405 CA3D04    	jz	sd5
 0408 73        	mov	m,e
 0409 23        	inx	h
 040A 72        	mov	m,d
                	pushix
 040B+DDE5      	DB	0DDH,0E5H
 040D E1        	pop	h	; move this bufr to top of list (most recently used)
 040E C32F04    	jmp	setbuf1
                ; No existing buffer, no free buffers, must take last on list.
                sd4:	lixd	previous	;no existing in-use bufr, no free bufr.
 0411+DD2A      	DB	0DDH,2AH
 0413+F805      	DW	PREVIOUS
                	mvix	0,link		;remove last buffer in list,
 0415+DD360000  	DB	0DDH,36H,LINK,0
                	mvix	0,link+1	;patching previous to be new end.
 0419+DD360100  	DB	0DDH,36H,LINK+1,0
                	liyd	last	;must flush this buffer, if write pending.
 041D+FD2A      	DB	0FDH,2AH
 041F+FA05      	DW	LAST
 0421 CDB205    	call	flush	; ERROR will return directly to BDOS (pop h, ret)
 0424 2AFA05    	lhld	last	;
                ;	jmp	setbuf
 0427 EB        setbuf: xchg
 0428 210700    	lxi	h,hstdsk
 042B 19        	dad	d
 042C 36FF      	mvi	m,-1	;invalidate buffer.
 042E EB        	xchg
                setbuf1:lded	hsttop	;used to be top of list, now make it 2nd.
 042F+ED5B      	DB	0EDH,5BH
 0431+F405      	DW	HSTTOP
 0433 22F405    	shld	hsttop	;put selected bufr at top of list.
 0436 73        	mov	m,e	;set link
 0437 23        	inx	h
 0438 72        	mov	m,d
 0439 23        	inx	h
 043A 71        	mov	m,c	;BC must still = P.D.Adr
 043B 23        	inx	h
 043C 70        	mov	m,b
                sd5:
                 else
                	lxi	h,xxhdr
                	shld	hsttop
                 endif
                	; BC is still PDAdr
                	liyd	hsttop
 043D+FD2A      	DB	0FDH,2AH
 043F+F405      	DW	HSTTOP
 0441 3A6C00    	lda	@pdrv		; Calculate physical sector, etc
 0444 32EB05    	sta	reqdsk
 0447 CD5302    	call	getusrbnk
 044A 2AD705    	lhld	@trk
 044D 22EC05    	shld	reqtrk
 0450 0E00      	MVI	C,0		; CALCULATE PHYSICAL SECTOR
 0452 3ADE05    	LDA	blcode		; PHYSICAL SECTOR SIZE CODE
 0455 B7        	ORA	A		; TEST FOR ZERO
 0456 47        	MOV	B,A
                	lded	@sect
 0457+ED5B      	DB	0EDH,5BH
 0459+D905      	DW	@SECT
                	JRZ	DBLOK3		; 128 BYTE SECTORS ?
 045B+280D      	DB	28H,DBLOK3-$-1
                DBLOK1: srlr	d		; DIVIDE BY 2
 045D+CB3A      	DB	0CBH, 38H + D
                	rarr	e
 045F+CB1B      	DB	0CBH, 18H + E
                	RARR	C		; SAVE OVERFLOW BITS
 0461+CB19      	DB	0CBH, 18H + C
                	DJNZ	DBLOK1		; AND CONTINUE IF BLOCKING STILL <> 0
 0463+10F8      	DB	10H,DBLOK1-$-1
 0465 47        	mov	b,a
                DBLOK2: RLCR	C		; NOW RESTORE THE OVERFLOW BY
 0466+CB01      	DB	0CBH, 00H + C
                	DJNZ	DBLOK2		; ROTATING IT RIGHT
 0468+10FC      	DB	10H,DBLOK2-$-1
 046A 79        DBLOK3: MOV	A,C
 046B 32E105    	sta	blksec		; STORE IT
                	sded	reqsec
 046E+ED53      	DB	0EDH,53H
 0470+EE05      	DW	REQSEC
                
                chk1:	ldy	e,link		; next buffer, or 0000
 0472+FD5E00    	DB	0FDH,E*8+46H,LINK
                	ldy	d,link+1	;
 0475+FD5601    	DB	0FDH,D*8+46H,LINK+1
 0478 7A        	mov	a,d
 0479 B3        	ora	e
                	jrz	chk2
 047A+2859      	DB	28H,CHK2-$-1
 047C D5        	push	d
                	popiy
 047D+FDE1      	DB	0FDH,0E1H
 047F 210700    	lxi	h,hstdsk
 0482 19        	dad	d
 0483 11EB05    	lxi	d,reqdsk
 0486 0605      	mvi	b,5
 0488 1A        chk0:	ldax	d
 0489 BE        	cmp	m
                	jrnz	chk1
 048A+20E6      	DB	20H,CHK1-$-1
 048C 23        	inx	h
 048D 13        	inx	d
                	djnz	chk0
 048E+10F8      	DB	10H,CHK0-$-1
 0490 CDB205    	call	flush	;an error bumps us out here.
                	siyd	previous	;save pointer
 0493+FD22      	DB	0FDH,22H
 0495+F805      	DW	PREVIOUS
 0497 3AEA05    	lda	rdflg
 049A B7        	ora	a
                	jrnz	chk3
 049B+2004      	DB	20H,CHK3-$-1
                	mviy	-1,hstdsk	;invalidate their buffer if we are writing.
 049D+FD3607FF  	DB	0FDH,36H,HSTDSK,-1
                chk3:	liyd	hsttop	;restore IY
 04A1+FD2A      	DB	0FDH,2AH
 04A3+F405      	DW	HSTTOP
 04A5 3AE205    	lda	dir0
 04A8 B7        	ora	a
                	jrnz	readit	;don't bother to move data if a read is forced...
 04A9+204B      	DB	20H,READIT-$-1
 04AB CDB205    chk4:	call	flush		; must flush our buffer BEFORE changing data.
                	ldy	l,hstbuf	; destination - our buffer
 04AE+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1	;
 04B1+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
                	ldy	b,hstbnk	;
 04B4+FD460E    	DB	0FDH,B*8+46H,HSTBNK
                	lixd	previous
 04B7+DD2A      	DB	0DDH,2AH
 04B9+F805      	DW	PREVIOUS
                	ldx	e,hstbuf	; source
 04BB+DD5E0C    	DB	0DDH,E*8+46H,HSTBUF
                	ldx	d,hstbuf+1	;
 04BE+DD560D    	DB	0DDH,D*8+46H,HSTBUF+1
                	ldx	c,hstbnk	;
 04C1+DD4E0E    	DB	0DDH,C*8+46H,HSTBNK
 04C4 3E01      	mvi	a,1	; interrupts are enabled
 04C6 CD0000    	call	?xmove		;
 04C9 010002    	lxi	b,secsize	; put requested sector data in our buffer
 04CC CD0000    	call	?move		;
 04CF AF        	xra	a
 04D0 32E305    	sta	preread
                	jr	readit0
 04D3+1824      	DB	18H,READIT0-$-1
                chk2:	liyd	hsttop	;restore IY
 04D5+FD2A      	DB	0FDH,2AH
 04D7+F405      	DW	HSTTOP
 04D9 3AE205    	lda	dir0
 04DC B7        	ora	a
                	jrnz	readit
 04DD+2017      	DB	20H,READIT-$-1
 04DF 2AF405    chkbuf: lhld	hsttop
 04E2 110700    	lxi	d,hstdsk
 04E5 19        	dad	d
 04E6 EB        	xchg
 04E7 21EB05    	lxi	h,reqdsk
 04EA 0605      	mvi	b,5
 04EC 1A        chkbuf1:ldax	d
 04ED BE        	cmp	m
                	jrnz	readit
 04EE+2006      	DB	20H,READIT-$-1
 04F0 23        	inx	h
 04F1 13        	inx	d
                	djnz	chkbuf1
 04F2+10F8      	DB	10H,CHKBUF1-$-1
                	jr	noread		;  THEN NO NEED TO PRE-READ
 04F4+182D      	DB	18H,NOREAD-$-1
 04F6 CDB205    readit: call	flush
 04F9 2AF405    readit0:lhld	hsttop		; SET UP NEW BUFFER PARAMETERS
 04FC 110700    	lxi	d,hstdsk
 04FF 19        	dad	d
 0500 EB        	xchg
 0501 21EB05    	lxi	h,reqdsk	; set HSTDSK,HSTTRK,HSTSEC
 0504 010500    	lxi	b,5		;
                	ldir			;
 0507+EDB0      	DB	0EDH,0B0H
 0509 2A6E00    	lhld	curmdl
                	sty	l,hstmdl
 050C+FD750F    	DB	0FDH,70H+L,HSTMDL
                	sty	h,hstmdl+1
 050F+FD7410    	DB	0FDH,70H+H,HSTMDL+1
 0512 2A7000    	lhld	@cmode
                	sty	l,hstmod
 0515+FD7504    	DB	0FDH,70H+L,HSTMOD
                	sty	h,hstmod+1
 0518+FD7405    	DB	0FDH,70H+H,HSTMOD+1
 051B 3AE305    	lda	preread
 051E B7        	ora	a
 051F C4C105    	cnz	pread		; READ THE SECTOR
 0522 C0        	rnz		;stop here if error
                noread: ldy	l,hstbuf	; POINT TO START OF SECTOR BUFFER
 0523+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1
 0526+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
 0529 018000    	lxi	b,128
 052C 3AE105    	lda	blksec		; POINT TO LOCATION OF CORRECT LOGICAL SECTOR
 052F 3D        movit1: dcr	a
 0530 FA3605    	jm	movit2
 0533 09        	dad	b
                	jr	movit1
 0534+18F9      	DB	18H,MOVIT1-$-1
                movit2:
                	; TODO: need to handle possible common memory DMA
                	lded	@dma		; POINT TO DMA
 0536+ED5B      	DB	0EDH,5BH
 0538+8800      	DW	@DMA
 053A 3A1900    	lda	@dbnk
 053D EB        	xchg		;DE is source, HL is dest.
 053E 47        	mov	b,a		;B=dest. bank
                	ldy	c,hstbnk	;C=source bank
 053F+FD4E0E    	DB	0FDH,C*8+46H,HSTBNK
 0542 3AEA05    	lda	rdflg		; IS IT A WRITE ?
 0545 B7        	ora	a
                	jrnz	movit3
 0546+2008      	DB	20H,MOVIT3-$-1
 0548 79        	mov	a,c
 0549 48        	mov	c,b
 054A 47        	mov	b,a
 054B EB        	xchg			; SWITCH DIRECTION OF MOVE FOR WRITE
                	mviy	true,pndwrt	; FLAG A PENDING WRITE
 054C+FD3606FF  	DB	0FDH,36H,PNDWRT,TRUE
 0550 CD0000    movit3: call	?xmove
 0553 018000    	lxi	b,128
 0556 3E01      	mvi	a,1	; interrupts are enabled
 0558 CD0000    	call	?move		; MOVE IT
 055B 3AE405    	lda	defer		; CHECK FOR non-defered write
 055E B7        	ora	a
 055F CCB205    	cz	flush		; WRITE THE SECTOR IF IT IS
 0562 AF        	xra	a		; FLAG NO ERROR
 0563 C9        	ret			; RETURN TO BDOS
                
                flushall:
                 if lrubuf
                	lded	hsttop
 0564+ED5B      	DB	0EDH,5BH
 0566+F405      	DW	HSTTOP
 0568 7A        	mov	a,d
 0569 B3        	ora	e
 056A C8        	rz		;no buffers in use.
 056B 21F405    	lxi	h,hsttop
 056E 22F805    	shld	previous
 0571 2AF005    	lhld	rlr
 0574 4E        	mov	c,m
 0575 23        	inx	h
 0576 46        	mov	b,m	;BC = PDAdr, must be preserved
 0577 210200    fls0:	lxi	h,hstpda
 057A 19        	dad	d
 057B 7E        	mov	a,m
 057C 23        	inx	h
 057D 66        	mov	h,m
 057E 6F        	mov	l,a
 057F B7        	ora	a
                	dsbc	b	;compare P.D. adr
 0580+ED42      	DB	0EDH,B*8+42H
 0582 CA9205    	jz	flush1
 0585 EB        	xchg
 0586 22F805    	shld	previous
 0589 5E        	mov	e,m
 058A 23        	inx	h
 058B 56        	mov	d,m
 058C 7A        	mov	a,d
 058D B3        	ora	e
 058E C27705    	jnz	fls0
 0591 C9        	ret
                
                ; TODO: could there be more than one?
                ; might need to resume flushall...
 0592 D5        flush1: push	d
                	popiy
 0593+FDE1      	DB	0FDH,0E1H
 0595 2AF805    	lhld	previous
                	ldy	a,link
 0598+FD7E00    	DB	0FDH,A*8+46H,LINK
 059B 77        	mov	m,a
 059C 23        	inx	h
                	ldy	a,link+1
 059D+FD7E01    	DB	0FDH,A*8+46H,LINK+1
 05A0 77        	mov	m,a
 05A1 2AF605    	lhld	fretop
                	sty	l,link
 05A4+FD7500    	DB	0FDH,70H+L,LINK
                	sty	h,link+1
 05A7+FD7401    	DB	0FDH,70H+H,LINK+1
                	siyd	fretop
 05AA+FD22      	DB	0FDH,22H
 05AC+F605      	DW	FRETOP
                 else
                	lxiy	xxhdr
                 endif
 05AE CDB205    	call	flush	; must handle stupid stack tricks
 05B1 C9        	ret
                
                ; Requires 2 ret adrs on stack, returns to imm caller on success,
                ; returns to caller's caller on error.
                flush:	ldy	a,pndwrt
 05B2+FD7E06    	DB	0FDH,A*8+46H,PNDWRT
 05B5 B7        	ora	a
 05B6 C8        	rz
                	mviy	false,pndwrt
 05B7+FD360600  	DB	0FDH,36H,PNDWRT,FALSE
 05BB CDC605    	call	pwrite
 05BE C8        	rz
 05BF E1        	pop	h
 05C0 C9        	ret
                
                ; IY=buffer header
 05C1 1E06      pread:	mvi	e,6	;read entry is +6
 05C3 C3C805    	jmp rw$common			; use common code
                
 05C6 1E09      pwrite: mvi	e,9	;write entry is +9
                
                rw$common:	;do any track/sector/side conversion...
                ;	xra	a
                ;	sta	@side
                ;	; Only "hard disk" supported...
                ;	ldy	l,hstmod
                ;	ldy	h,hstmod+1
                ;	bit	7,m	;floppy or hard-disk?
                ;	jrnz	rw0
                rw0:
 05C8 7B        	mov	a,e	; read(6) or write(9)
                	ldy	l,hstmdl
 05C9+FD6E0F    	DB	0FDH,L*8+46H,HSTMDL
                	ldy	h,hstmdl+1
 05CC+FD6610    	DB	0FDH,H*8+46H,HSTMDL+1
                calmod:
 05CF 85        	add	l
 05D0 6F        	mov	l,a
 05D1 3E00      	mvi	a,0
 05D3 8C        	adc	h
 05D4 67        	mov	h,a
 05D5 E9        	pchl		; leap to driver
                
 05D6           @side:	ds	1		; current side of media (floppy only)
 05D7           @trk:	ds	2		; current track number
 05D9           @sect:	ds	2		; current sector number
 05DB 00        @cnt:	db	0		; record count for multisector transfer
 05DC           @spt:	ds	1
 05DD           @rcnfg: ds	1
                
 05DE           blcode: ds	1	;blocking code, PSH
 05DF           offset: ds	2
 05E1           blksec: ds	1
 05E2           dir0:	ds	1
 05E3           preread:ds	1
 05E4           defer:	ds	1
 05E5           unalloc:ds	1
 05E6           urecord:ds	3
 05E9           blkmsk: ds	1
 05EA           rdflg:	ds	1
                
 05EB           reqdsk: ds	1
 05EC           reqtrk: ds	2
 05EE           reqsec: ds	2
                
 05F0 0000      rlr:	dw	0
 05F2 0000      msegtbl: dw	0
                
 05F4 0000      hsttop:   dw	0
                 if lrubuf
 05F6 FC05      fretop:   dw	hsthdr
 05F8 0000      previous: dw	0
 05FA 0000      last:	  dw	0
                
 0010 =         numbuf	equ	16
 0000 =         @@bnk	equ	0
 0100 #         @@ set 0100h	;start of buffers in bank
                		; (numbuf + 2) * secsize, buffers used,
                		; must not overrun system. At 512b and 16 bufs,
                		; this consumes 0100-2500, MP/M starts about A900.
                hsthdr: rept	numbuf
                	dw	$+hstlen ;Link
                	dw	0	;hstpda - Process Descriptor Address
                	dw	0	;hstmod
                	db	false	;pndwrt
                	db	-1	;hstdsk
                	dw	0	;hsttrk
                	dw	0	;hstsec
                	dw	@@	;hstbuf
                	db	@@bnk	;hstbnk
                	dw	0	;hstmdl
                @@ set @@+secsize
                	endm
 05FC+0D06      	DW	$+HSTLEN ;LINK
 05FE+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0600+0000      	DW	0	;HSTMOD
 0602+00        	DB	FALSE	;PNDWRT
 0603+FF        	DB	-1	;HSTDSK
 0604+0000      	DW	0	;HSTTRK
 0606+0000      	DW	0	;HSTSEC
 0608+0001      	DW	@@	;HSTBUF
 060A+00        	DB	@@BNK	;HSTBNK
 060B+0000      	DW	0	;HSTMDL
 060D+1E06      	DW	$+HSTLEN ;LINK
 060F+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0611+0000      	DW	0	;HSTMOD
 0613+00        	DB	FALSE	;PNDWRT
 0614+FF        	DB	-1	;HSTDSK
 0615+0000      	DW	0	;HSTTRK
 0617+0000      	DW	0	;HSTSEC
 0619+0003      	DW	@@	;HSTBUF
 061B+00        	DB	@@BNK	;HSTBNK
 061C+0000      	DW	0	;HSTMDL
 061E+2F06      	DW	$+HSTLEN ;LINK
 0620+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0622+0000      	DW	0	;HSTMOD
 0624+00        	DB	FALSE	;PNDWRT
 0625+FF        	DB	-1	;HSTDSK
 0626+0000      	DW	0	;HSTTRK
 0628+0000      	DW	0	;HSTSEC
 062A+0005      	DW	@@	;HSTBUF
 062C+00        	DB	@@BNK	;HSTBNK
 062D+0000      	DW	0	;HSTMDL
 062F+4006      	DW	$+HSTLEN ;LINK
 0631+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0633+0000      	DW	0	;HSTMOD
 0635+00        	DB	FALSE	;PNDWRT
 0636+FF        	DB	-1	;HSTDSK
 0637+0000      	DW	0	;HSTTRK
 0639+0000      	DW	0	;HSTSEC
 063B+0007      	DW	@@	;HSTBUF
 063D+00        	DB	@@BNK	;HSTBNK
 063E+0000      	DW	0	;HSTMDL
 0640+5106      	DW	$+HSTLEN ;LINK
 0642+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0644+0000      	DW	0	;HSTMOD
 0646+00        	DB	FALSE	;PNDWRT
 0647+FF        	DB	-1	;HSTDSK
 0648+0000      	DW	0	;HSTTRK
 064A+0000      	DW	0	;HSTSEC
 064C+0009      	DW	@@	;HSTBUF
 064E+00        	DB	@@BNK	;HSTBNK
 064F+0000      	DW	0	;HSTMDL
 0651+6206      	DW	$+HSTLEN ;LINK
 0653+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0655+0000      	DW	0	;HSTMOD
 0657+00        	DB	FALSE	;PNDWRT
 0658+FF        	DB	-1	;HSTDSK
 0659+0000      	DW	0	;HSTTRK
 065B+0000      	DW	0	;HSTSEC
 065D+000B      	DW	@@	;HSTBUF
 065F+00        	DB	@@BNK	;HSTBNK
 0660+0000      	DW	0	;HSTMDL
 0662+7306      	DW	$+HSTLEN ;LINK
 0664+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0666+0000      	DW	0	;HSTMOD
 0668+00        	DB	FALSE	;PNDWRT
 0669+FF        	DB	-1	;HSTDSK
 066A+0000      	DW	0	;HSTTRK
 066C+0000      	DW	0	;HSTSEC
 066E+000D      	DW	@@	;HSTBUF
 0670+00        	DB	@@BNK	;HSTBNK
 0671+0000      	DW	0	;HSTMDL
 0673+8406      	DW	$+HSTLEN ;LINK
 0675+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0677+0000      	DW	0	;HSTMOD
 0679+00        	DB	FALSE	;PNDWRT
 067A+FF        	DB	-1	;HSTDSK
 067B+0000      	DW	0	;HSTTRK
 067D+0000      	DW	0	;HSTSEC
 067F+000F      	DW	@@	;HSTBUF
 0681+00        	DB	@@BNK	;HSTBNK
 0682+0000      	DW	0	;HSTMDL
 0684+9506      	DW	$+HSTLEN ;LINK
 0686+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0688+0000      	DW	0	;HSTMOD
 068A+00        	DB	FALSE	;PNDWRT
 068B+FF        	DB	-1	;HSTDSK
 068C+0000      	DW	0	;HSTTRK
 068E+0000      	DW	0	;HSTSEC
 0690+0011      	DW	@@	;HSTBUF
 0692+00        	DB	@@BNK	;HSTBNK
 0693+0000      	DW	0	;HSTMDL
 0695+A606      	DW	$+HSTLEN ;LINK
 0697+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0699+0000      	DW	0	;HSTMOD
 069B+00        	DB	FALSE	;PNDWRT
 069C+FF        	DB	-1	;HSTDSK
 069D+0000      	DW	0	;HSTTRK
 069F+0000      	DW	0	;HSTSEC
 06A1+0013      	DW	@@	;HSTBUF
 06A3+00        	DB	@@BNK	;HSTBNK
 06A4+0000      	DW	0	;HSTMDL
 06A6+B706      	DW	$+HSTLEN ;LINK
 06A8+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06AA+0000      	DW	0	;HSTMOD
 06AC+00        	DB	FALSE	;PNDWRT
 06AD+FF        	DB	-1	;HSTDSK
 06AE+0000      	DW	0	;HSTTRK
 06B0+0000      	DW	0	;HSTSEC
 06B2+0015      	DW	@@	;HSTBUF
 06B4+00        	DB	@@BNK	;HSTBNK
 06B5+0000      	DW	0	;HSTMDL
 06B7+C806      	DW	$+HSTLEN ;LINK
 06B9+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06BB+0000      	DW	0	;HSTMOD
 06BD+00        	DB	FALSE	;PNDWRT
 06BE+FF        	DB	-1	;HSTDSK
 06BF+0000      	DW	0	;HSTTRK
 06C1+0000      	DW	0	;HSTSEC
 06C3+0017      	DW	@@	;HSTBUF
 06C5+00        	DB	@@BNK	;HSTBNK
 06C6+0000      	DW	0	;HSTMDL
 06C8+D906      	DW	$+HSTLEN ;LINK
 06CA+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06CC+0000      	DW	0	;HSTMOD
 06CE+00        	DB	FALSE	;PNDWRT
 06CF+FF        	DB	-1	;HSTDSK
 06D0+0000      	DW	0	;HSTTRK
 06D2+0000      	DW	0	;HSTSEC
 06D4+0019      	DW	@@	;HSTBUF
 06D6+00        	DB	@@BNK	;HSTBNK
 06D7+0000      	DW	0	;HSTMDL
 06D9+EA06      	DW	$+HSTLEN ;LINK
 06DB+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06DD+0000      	DW	0	;HSTMOD
 06DF+00        	DB	FALSE	;PNDWRT
 06E0+FF        	DB	-1	;HSTDSK
 06E1+0000      	DW	0	;HSTTRK
 06E3+0000      	DW	0	;HSTSEC
 06E5+001B      	DW	@@	;HSTBUF
 06E7+00        	DB	@@BNK	;HSTBNK
 06E8+0000      	DW	0	;HSTMDL
 06EA+FB06      	DW	$+HSTLEN ;LINK
 06EC+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06EE+0000      	DW	0	;HSTMOD
 06F0+00        	DB	FALSE	;PNDWRT
 06F1+FF        	DB	-1	;HSTDSK
 06F2+0000      	DW	0	;HSTTRK
 06F4+0000      	DW	0	;HSTSEC
 06F6+001D      	DW	@@	;HSTBUF
 06F8+00        	DB	@@BNK	;HSTBNK
 06F9+0000      	DW	0	;HSTMDL
 06FB+0C07      	DW	$+HSTLEN ;LINK
 06FD+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06FF+0000      	DW	0	;HSTMOD
 0701+00        	DB	FALSE	;PNDWRT
 0702+FF        	DB	-1	;HSTDSK
 0703+0000      	DW	0	;HSTTRK
 0705+0000      	DW	0	;HSTSEC
 0707+001F      	DW	@@	;HSTBUF
 0709+00        	DB	@@BNK	;HSTBNK
 070A+0000      	DW	0	;HSTMDL
                 endif
 070C 0000      xxhdr:	dw	0	;Link - initially last in list.
 070E 0000      	dw	0	;hstpda
 0710 0000      	dw	0	;hstmod
 0712 00        	db	false	;pndwrt
 0713 FF        	db	-1	;hstdsk
 0714 0000      	dw	0	;hsttrk
 0716 0000      	dw	0	;hstsec
 0718 0021      	dw	@@	;hstbuf
 071A 00        	db	@@bnk	;hstbnk
 071B 0000      	dw	0	;hstmdl
 2300 #         @@ set @@+secsize
                
                ; NOTE: this buffer can be used for reading only. (it is never flushed)
 071D 0000      @scrcb: dw	0	;link - not used
 071F 0000      	dw	0	;hstpda - not used
 0721 0000      	dw	0	;hstmod
 0723 00        	db	false	;pndwrt - assumed always false
 0724 FF        	db	-1	;hstdsk
 0725 0000      	dw	0	;hsttrk
 0727 0000      	dw	0	;hstsec
 0729 0023      	dw	@@	;hstbuf
 072B 00        	db	@@bnk	;hstbnk
 072C 0000      	dw	0	;hstmdl
                
 072E           	end
