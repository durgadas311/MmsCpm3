 6130 =         vers equ '0a' ; Nov 14, 2021  13:49  drm "MXIOS.ASM"
                ;****************************************************************
                ; MP/M main XIOS module for Z180 on the H8/H89			*
                ; Derived from the MMS 77500 server XIOS			*
                ; Copyright (c) 1983 Magnolia Microsystems			*
                ;****************************************************************
                ; All memory segments are ORGed at 0000.
                ; Uses CP/M Plus format DPBs.
                
                	maclib	z180
                	maclib	cfgsys
                
                	public	@adrv,@pdrv,@rdrv,@side,@trk,@sect
                	public	@dma,@dbnk,@dirbf
                	public	@dstat,@cmode,@dph,@rcnfg,@eops
                	public	@cbnk,@scrcb,@vect,@secnd
                
                	public	xdos,polltb,sysdat
                
                	extrn	@lptbl
                	extrn	?memsl,?bnksl,?bnkck,?xmove,?move	; MMU module
                	extrn	@memstr,@mmerr,@nbnk
                	extrn	?time,?itime,@rtcstr			; RTC module
                
                 if z180
                z180tick	equ	true
                h89tick		equ	false
                 else
                  if h89
 0000 =         z180tick	equ	false
 FFFF =         h89tick		equ	true
 000A =         tick$tick	equ	10	; number of 2mS ticks per MP/M tick
                  else
                ; TODO: what to use for tick?
                z180tick	equ	false
                h89tick		equ	false
                  endif
                 endif
                
 0200 =         secsize		equ	512	; largest sector size supported/used
                
 000D =         cr	equ 13
 000A =         lf	equ 10
 0007 =         bell	equ 7
                
 0000 =         cpm	equ	0
 0005 =         bdos	equ	5
                
 0083 =         poll	equ	131
 0085 =         flagset equ	133
                
                ;relative position of elements in buffer headers:
 0000 =         link	equ	0	;link to next headr, or 0
 0002 =         hstpda	equ	2	;Process Descriptor Adr of owner
 0004 =         hstmod	equ	4	;mode pointer (partition address)
 0006 =         pndwrt	equ	6	;pending write flag
 0007 =         hstdsk	equ	7	;host disk
 0008 =         hsttrk	equ	8	;host track
 000A =         hstsec	equ	10	;host sector
 000C =         hstbuf	equ	12	;host buffer address
 000E =         hstbnk	equ	14	;host bank
 000F =         hstmdl	equ	15	;host module entry
 0011 =         hstlen	equ	17	;length of header
                
                 if z180
                ; Z180 registers
                itc	equ	iobase+34h
                rcr	equ	iobase+36h
                mmu$cbr	equ	iobase+38h
                mmu$bbr	equ	iobase+39h
                mmu$cbar equ	iobase+3ah
                sar0l	equ	iobase+20h
                sar0h	equ	iobase+21h
                sar0b	equ	iobase+22h
                dar0l	equ	iobase+23h
                dar0h	equ	iobase+24h
                dar0b	equ	iobase+25h
                bcr0l	equ	iobase+26h
                bcr0h	equ	iobase+27h
                dstat	equ	iobase+30h
                dmode	equ	iobase+31h
                dcntl	equ	iobase+32h
                il	equ	iobase+33h
                tmdr0l	equ	iobase+0ch
                tmdr0h	equ	iobase+0dh
                rldr0l	equ	iobase+0eh
                rldr0h	equ	iobase+0fh
                tcr	equ	iobase+10h
                 endif
                
                ;-------- Start of Code-producing source -----------
                
                	; Because LINK puts dseg after cseg, and 'combas' is
                	; at the beginning of dseg, GENSYS will enforce that
                	; all of dseg falls in common memory.
                	cseg		; Banked memory
 0000 =         BIOS$0	equ	$
 0000 C30000    	jmp combas	; initial entry on cold start, common base
 0003 C39C00    	jmp wboot	; reentry on program exit, warm start
                
 0006 C3F001    	jmp const	; return console input status
 0009 C3FE01    	jmp conin	; return console input character
 000C C3D601    	jmp conout	; send console output character
 000F C3D101    	jmp list	; send list output character
 0012 C3C401    	jmp auxout	; send auxilliary output character	-NULL
 0015 C3C101    	jmp auxin	; return auxilliary input character	-NULL
                
 0018 C3FF02    	jmp home	; set disks to logical home
 001B C32D02    	jmp seldsk	; select disk drive, return disk parameter info
 001E C30203    	jmp settrk	; set disk track
 0021 C30703    	jmp setsec	; set disk sector
 0024 C30C03    	jmp setdma	; set disk I/O memory address
 0027 C32403    	jmp read	; read physical block(s)
 002A C34803    	jmp write	; write physical block(s)
                
 002D C3C801    	jmp listst	; return list device status
 0030 C31803    	jmp sectrn	; translate logical to physical sector
                
 0033 C30000    	jmp	?memsl
 0036 C3B800    	jmp	poll$dev
 0039 C3ED00    	jmp	strtclk
 003C C3F100    	jmp	stopclk
 003F C3E600    	jmp	exitreg
 0042 C3E300    	jmp	maxcon
 0045 C3D900    	jmp	boot	;   sysinit
                ;	jmp	idle	;
 0048 000000    	nop ! nop ! nop	; no idle routine
                
 004B D300      	dw	polltb	;for RSP's (such as NETWRKIF)
                
 004D           	ds	13	;this puts setup/mode info where they expect it
 005A C3A101    	jmp	search
 005D C32F02    	jmp	setspd	; change CPU speed - platform dependent
 0060           	ds	3
                
                ; These are only static when accessed via XIOSJMP.TBL
 0063           @dstat: ds	1
 0064           speed:	ds	1	; formerly Port F2 image "@intby"
                
 0065 0000      	dw	@lptbl	;logical/physical drive table
 0067 5302      	dw	thread	;module thread
 0069 0000      	dw	0	;?serdp	;test mode validity, HL=memory address of ?serdp
                
 006B           @adrv:	ds	1		; currently selected disk drive
 006C           @pdrv:	ds	1		; physical drive number (MMS)
 006D           @rdrv:	ds	1		; module relative disk drive number
 006E           curmdl: ds	2		; currently selected Disk I/O module address
 0070           @cmode: ds	2
 0072           @dph:	ds	2
                
 0074 0080      icovec: dw	1000000000000000b
 0076 0080      icivec: dw	1000000000000000b
 0078 0000      iaovec: dw	0000000000000000b
 007A 0000      iaivec: dw	0000000000000000b
 007C 0000      ilovec: dw	0000000000000000b
                
 007E 00FFFFFF  defsrc: db	0,0ffh,0ffh,0ffh
 0082 00        tmpdrv: db	0
 0083 00        srctyp: db	000$00$000b	;only bits 3,4 are used (others ignored)
                
                	; for MODULES.COM... well, not quite since not in common memory...
                	; This will be copied to BIOS JMP PAGE, in common memory,
                	; but these strings must also reside in common memory.
 0084 0000      	dw	@memstr
 0086 0000      	dw	@rtcstr
                
 0088 0000      @dma:	dw	0
 008A 0000      wbtrap: dw	0
                
                	dseg
                ;---------- COMMON MEMORY -----------
                ; WARNING: must be on page boundary ('vect' alignment).
                ; Use LINK 'B' option.
 0000 C39C00    combas: jmp	colds
 0003 C30000    swtusr: jmp	$-$
 0006 C30000    swtsys: jmp	$-$
 0009 C30000    pdisp:	jmp	$-$
 000C C30000    xdos:	jmp	$-$
 000F 0000      sysdat: dw	$-$
                
                ; These locations are fixed, after combas block.
 0011 0000      @vect:	dw	$-$
 0013 0000      dbuga:	dw	$-$
 0015 0000      dbugv:	dw	$-$
 0017 0000      biosjmp:dw	$-$
 0019           @dbnk:	ds	1	; bank for user I/O (user DMA addr)
 001A           @eops:	ds	1
 001B           @intby: ds	1	; Port F2 image
                
 001C           @dirbf: ds	128
                
                 if z180
                	; Z180 internal devices interrupt vector table.
                	; If external devices also generate interrupts,
                	; this must be expanded/realigned to compensate.
                	; need 32-byte aligned address:
                	rept	(32 - (($-combas) AND 1fh)) AND 1fh
                	db	0
                	endm
                vect:	dw	nulint	; 0 - /INT1
                	dw	nulint	; 1 - /INT2
                	dw	tick	; 2 - PRT0 (TMDR0 -> 0)
                	dw	nulint	; 3 - PRT1 (TMDR1 -> 0)
                	dw	nulint	; 4 - DMA0
                	dw	nulint	; 5 - DMA1
                	dw	nulint	; 6 - CSIO
                	dw	nulint	; 7 - ASCI0
                	dw	nulint	; 8 - ASCI1
                	dw	nulint	; 9 - unused by Z180
                	dw	nulint	; 10 - unused by Z180
                	dw	nulint	; 11 - unused by Z180
                	dw	nulint	; 12 - unused by Z180
                	dw	nulint	; 13 - unused by Z180
                	dw	nulint	; 14 - unused by Z180
                	dw	nulint	; 15 - unused by Z180
                 endif
                
                wboot:
                colds:
                 if z180
                	; possible TRAP
                	in0	a,itc
                	tsti	10000000b	; TRAP bit
                	jrnz	trap
                 endif
 009C 0E00      	mvi	c,0
 009E C30C00    	jmp	xdos
                
                msgout:
 00A1 7E        	mov	a,m
 00A2 FE24      	cpi	'$'
 00A4 C8        	rz
 00A5 E5        	push	h
 00A6 4E        	mov	c,m
 00A7 1600      	mvi	d,0
 00A9 CDEC01    	call	coo
 00AC E1        	pop	h
 00AD 23        	inx	h
                	jr	msgout
 00AE+18F1      	DB	18H,MSGOUT-$-1
                
 00B0 CDA100    errx:	call	msgout
 00B3 F376      	di ! hlt
                
                 if z180
                ; For now, any TRAP is fatal
                trap:	lxi	h,trpmsg
                	jr	errx
                
                trpmsg:	db	cr,lf,'*TRAP*',cr,lf,'$'
                 endif
                
 00B5 FB        nulint:	ei
                	reti
 00B6+ED4D      	DB	0EDH,4DH
                
                ; C=device to poll, 0-N char I/O devices (input status)
                poll$dev:
 00B8 79        	mov	a,c
 00B9 FE08      	cpi	8
                	jrnc	pd0	; not char I/O...
 00BB+300A      	DB	30H,PD0-$-1
 00BD 51        	mov	d,c
 00BE D604      	sui	4
 00C0 DAF001    	jc	const
 00C3 57        	mov	d,a
 00C4 C3CD01    	jmp	conost
 00C7 0600      pd0:	mvi	b,0
 00C9 21D300    	lxi	h,polltb
 00CC 09        	dad	b
 00CD 09        	dad	b
 00CE 5E        	mov	e,m
 00CF 23        	inx	h
 00D0 56        	mov	d,m
                	; TODO: check DE=NULL?
 00D1 EB        	xchg
 00D2 E9        	pchl
                
                ; Devices 8..15, starting at +0...
 00D3 0000000000polltb:	dw	$-$,$-$,$-$,$-$,$-$,$-$,$-$,$-$ ; 8..15 unassigned (yet)
                
 00E3 3E00      maxcon: mvi	a,0	;filled in at init from SYSDAT and config
 00E5 C9        	ret
                
                exitreg:
 00E6 3AF700    	lda	preempt
 00E9 B7        	ora	a
 00EA C0        	rnz
 00EB FB        	ei
 00EC C9        	ret
                
 00ED 3EFF      strtclk: mvi	a,true
                	 jr	sc00
 00EF+1802      	DB	18H,SC00-$-1
 00F1 3E00      stopclk: mvi	a,false
 00F3 32F800    sc00:	 sta	clock
 00F6 C9        	 ret
                
 00F7 00        preempt: db	0
 00F8 00        clock:	 db	0
                
 00F9 0000      @secnd: dw	$-$	;used to do timeouts
                
 00FB 00        tps:	db	0	; from system data page on boot
 00FC 00        pcnt:	db	0	; pre-scale for interrupts to MP/M ticks
 00FD 00        tcnt:	db	0	; must immediately follow pcnt...
                
                second:
 00FE 2AF900    	lhld	@secnd
 0101 7C        	mov	a,h
 0102 B5        	ora	l
 0103 C41C02    	cnz	icall
 0106 1E02      	mvi	e,2
 0108 0E85      	mvi	c,flagset
 010A CD0C00    	call	xdos
                	jr	tk1
 010D+1836      	DB	18H,TK1-$-1
                
                tick:	sspd	istk
 010F+ED73      	DB	0EDH,73H
 0111+9F01      	DW	ISTK
 0113 319F01    	lxi	sp,intstk
 0116 F5        	push	psw
 0117 E5        	push	h
 0118 D5        	push	d
 0119 C5        	push	b
                 if z180tick
                	; It appears that ALL of these are required
                	in0	a,tcr		; reset INT
                	in0	a,tmdr0l	; reset INT
                	in0	a,tmdr0h	; reset INT
                 endif
                 if h89tick
 011A 3A1B00    	lda	@intby
 011D D3F2      	out	0f2h	; reset INT
 011F 21FC00    	lxi	h,pcnt
 0122 35        	dcr	m
                	jrnz	iexit
 0123+2030      	DB	20H,IEXIT-$-1
 0125 360A      	mvi	m,tick$tick
                 endif
 0127 3EFF      	mvi	a,true
 0129 32F700    	sta	preempt
 012C 3AF800    	lda	clock
 012F B7        	ora	a
                	jrz	tk0
 0130+2807      	DB	28H,TK0-$-1
 0132 1E01      	mvi	e,1
 0134 0E85      	mvi	c,flagset
 0136 CD0C00    	call	xdos
                tk0:
 0139 21FD00    	lxi	h,tcnt
 013C 35        	dcr	m
                	jrnz	tk1
 013D+2006      	DB	20H,TK1-$-1
 013F 3AFB00    	lda	tps
 0142 77        	mov	m,a
                	jr	second
 0143+18B9      	DB	18H,SECOND-$-1
 0145 3E00      tk1:	mvi	a,false
 0147 32F700    	sta	preempt
                 if z180tick
                	lxi	d,nexti
                	push	d
                	reti	; required by Z180?
                nexti:
                 endif
 014A C1        	pop	b
 014B D1        	pop	d
 014C E1        	pop	h
 014D F1        	pop	psw
                	lspd	istk
 014E+ED7B      	DB	0EDH,07BH
 0150+9F01      	DW	ISTK
 0152 C30900    	jmp	pdisp
                
                 if h89tick
                iexit:
 0155 C1        	pop	b
 0156 D1        	pop	d
 0157 E1        	pop	h
 0158 F1        	pop	psw
                	lspd	istk
 0159+ED7B      	DB	0EDH,07BH
 015B+9F01      	DW	ISTK
 015D FB        	ei
 015E C9        	ret
                 endif
                
 015F           	ds	64	;32 levels of stack
 019F           intstk: ds	0
 019F 0000      istk:	dw	0
                
                ; SEARCH for a module by device #.
                ;   entry:	C = device # (0-249)
                ;   exit:	[CY] = not found
                ;	   else HL=module address ("init" entry)
                ;		A=device number (relative to module's #0)
                ;
 01A1 115302    search: lxi	d,thread	;C=device number
 01A4 EB        snext:	xchg
 01A5 5E        	mov	e,m
 01A6 23        	inx	h
 01A7 56        	mov	d,m
 01A8 23        	inx	h
 01A9 7A        	mov	a,d
 01AA B3        	ora	e
 01AB D601      	sui	1	;produce [CY] if DE=0000
 01AD D8        	rc		;return if device not found, DE=0000
 01AE 79        	mov	a,c
 01AF 96        	sub	m
                	jrc	snext
 01B0+38F2      	DB	38H,SNEXT-$-1
 01B2 23        	inx	h
 01B3 BE        	cmp	m
                	jrnc	snext
 01B4+30EE      	DB	30H,SNEXT-$-1
 01B6 23        	inx	h	;point to "init" vector
 01B7 B7        	ora	a	;set [NC] condition
 01B8 C9        	ret
                
 01B9 0000      ciomdl:	dw	0	;character device driver, filled at cold-start.
 01BB 00        cionum:	db	0	;max num cio devices (numcon+numlst)
                
                cinit:	;C=device number (0-11)
 01BC 2AB901    	lhld	ciomdl	; init routine
 01BF 41        	mov	b,c
 01C0 E9        	pchl		;jump to modules "init" with B=device #
                
 01C1 3E1A      auxin:	mvi	a,1ah	; EOF
 01C3 B7        	ora	a
 01C4 C9        auxout:	ret
                
 01C5 F1        nodev:	pop	psw
 01C6 AF        nost:	xra	a	; never ready
 01C7 C9        	ret
                
                ; D=device number
                listst:
 01C8 3AE400    	lda	maxcon+1
 01CB 82        	add	d
 01CC 57        	mov	d,a	; LST: #0 = con#N+1
                conost:
 01CD 3E09      	mvi	a,9
                	jr	devio
 01CF+1821      	DB	18H,DEVIO-$-1
                
                ; D=device number, C=char
                list:
 01D1 3AE400    	lda	maxcon+1
 01D4 82        	add	d
 01D5 57        	mov	d,a	; LST: #0 = con#N+1
                conout:
 01D6 C5        	push	b
 01D7 D5        	push	d
 01D8 CDCD01    	call	conost	; is ready now?
 01DB B7        	ora	a
 01DC C2EA01    	jnz	co0
 01DF D1        	pop	d
 01E0 D5        	push	d
 01E1 7A        	mov	a,d
 01E2 C604      	adi	4
 01E4 5F        	mov	e,a
 01E5 0E83      	mvi	c,poll
 01E7 CD0C00    	call	xdos	; sleep until ready
 01EA D1        co0:	pop	d
 01EB C1        	pop	b
 01EC 3E0C      coo:	mvi	a,12
                	jr	devio
 01EE+1802      	DB	18H,DEVIO-$-1
                
                ; D=device number
 01F0 3E03      const:	mvi	a,3
                	;jr	devio
                
                ; A=JMP tbl off, D=devnum [C=char]
 01F2 F5        devio:	push	psw
 01F3 3ABB01    	lda	cionum	;see if device exists
 01F6 3D        	dcr	a
 01F7 BA        	cmp	d
                	jrc	nodev
 01F8+38CB      	DB	38H,NODEV-$-1
 01FA F1        	pop	psw	; driver JMP offset
 01FB 42        	mov	b,d	;device number in B for modules
                	jr	indjmp0
 01FC+1815      	DB	18H,INDJMP0-$-1
                
                ; D=device number
 01FE D5        conin:	push	d
 01FF CDF001    	call	const	; is ready now?
 0202 B7        	ora	a
 0203 C20E02    	jnz	ci0
 0206 D1        	pop	d
 0207 D5        	push	d
 0208 5A        	mov	e,d
 0209 0E83      	mvi	c,poll
 020B CD0C00    	call	xdos	; sleep until ready
 020E D1        ci0:	pop	d
 020F 3E06      	mvi	a,6
                	jr	devio
 0211+18DF      	DB	18H,DEVIO-$-1
                
                ; char I/O driver function calls
                ; A=offset (0,3,6,9,...), B=device number (0..N)
                indjmp0:
 0213 2AB901    	lhld	ciomdl
 0216 85        	add	l	;a=0,3,6,9,12,...
 0217 6F        	mov	l,a
 0218 3E00      	mvi	a,0
 021A 8C        	adc	h
 021B 67        	mov	h,a
 021C E9        icall:	pchl		;indirect call
                
                
 021D 00        @cbnk:	db	0	; bank for processor operations
 021E           bnkflg: ds	1	;flag for enough memory installed.
                
                getusrbnk:	;finds the bank number for calling process
 021F CD0300    	call	swtusr		; would like better way...
 0222 3A1D02    	lda	@cbnk
 0225 321900    	sta	@dbnk
 0228 C30600    	jmp	swtsys
                
                 if h89
                ; CPU clock rate selected, ORG0+2mS handled by user
 022B 00100414  cpuspd:	db	00h,10h,04h,14h
                 endif
                
                ; A=0,1,2,3[...] speed index, FF=get current speed
                ; Returns A: FF=error, FE=not supported, 0,1,2,3...=success
                ; Called from user bank, must be in common mem.
                setspd:
                 if h89
 022F FEFF      	cpi	0ffh
                	jrz	ssx
 0231+281C      	DB	28H,SSX-$-1
 0233 326400    	sta	speed
 0236 5F        	mov	e,a
 0237 FE04      	cpi	4
 0239 3EFF      	mvi	a,0ffh
 023B D0        	rnc
 023C 212B02    	lxi	h,cpuspd
 023F 1600      	mvi	d,0
 0241 19        	dad	d
 0242 56        	mov	d,m
 0243 F3        	di
 0244 3A1B00    	lda	@intby
 0247 E6EB      	ani	11101011b
 0249 B2        	ora	d
 024A 321B00    	sta	@intby
 024D D3F2      	out	0f2h	; speed changes now
                  if z180tick
                	; there will be a small error until next tick
                	lxi	h,maxclk
                	mov	a,e
                	cpi	3
                	jrz	ss0
                	lxi	h,minclk
                	ora	a
                	jrz	ss0
                ss1:	dad	h
                	dcr	a
                	jrnz	ss1
                ss0:	; HL=timer value for 50Hz tick
                	out0	l,rldr0l	; update timer reload count
                	out0	h,rldr0h	;
                  endif
 024F 3A6400    ssx:	lda	speed	; always return current speed
                 else
                	mvi	a,0feh	; not supported
                 endif
 0252 C9        	ret
                
 0253 =         thread: equ	$	;must be last in dseg (common mem)
                
                	cseg	; rest is in banked memory...
                
 008C 0D0A07    signon: db	cr,lf,bell
                 if h89
 008F 48382D    	db	'H8-'
                 endif
                 if rc2014
                	db	'RC2014-'
                 endif
                ; TODO: other platforms...
                 if z180
                	db	'Z180'
                 else
 0092 5A3830    	db	'Z80'
                 endif
 0095 204D502F4D	db	' MP/M-II v3.00'
 00A3 3061      	dw	vers
 00A5 2020286329	db	'  (c) 1984 DRI and MMS',cr,lf,'$'
                
 00BE 0D0A074E6Fbnkerr:	db	cr,lf,bell,'Not enough memory banks$'
                
                ; Interrupts are disabled
                ; HL = BIOS JMP table
                ; DE = debug entry
                ; C = debug RST num
                boot:
                 if h89
                	; This is H89-specific...
 00D9 3E00      	mvi	a,defspd
 00DB 326400    	sta	speed
 00DE 3A2B02    	lda	cpuspd+defspd
 00E1 F620      	ori	00100000b	; ORG0 only, right now
 00E3 321B00    	sta	@intby
 00E6 D3F2      	out	0f2h	; prevent undesirable intrs
                			; Console 8250 should already be off
                 endif
                 if z180
                	; speed things up...
                	mvi	a,z$dcntl
                	out0	a,dcntl	; set WAIT states
                	mvi	a,z$rcr
                	out0	a,rcr	; set RESFRESH cycles
                 endif
                	;
                	sded	dbuga
 00E8+ED53      	DB	0EDH,53H
 00EA+1300      	DW	DBUGA
 00EC 221700    	shld	biosjmp
 00EF 79        	mov	a,c
 00F0 87        	add	a
 00F1 87        	add	a
 00F2 87        	add	a
 00F3 6F        	mov	l,a
 00F4 2600      	mvi	h,0
 00F6 221500    	shld	dbugv
                 if z180tick
                	lxi	h,vect
                	shld	@vect
                	mov	a,h
                	stai
                	out0	l,il
                 endif
                 if h89tick
 00F9 3EC3      	mvi	a,JMP
 00FB 320800    	sta	0008h
 00FE 210F01    	lxi	h,tick
 0101 220900    	shld	0008h+1
 0104 3A1B00    	lda	@intby
 0107 F602      	ori	02h
 0109 321B00    	sta	@intby
 010C D3F2      	out	0f2h
                 endif
                
 010E 2A0F00    	lhld	sysdat
 0111 2E7A      	mvi	l,122	;ticks/sec
 0113 7E        	mov	a,m
 0114 32FB00    	sta	tps
 0117 32FD00    	sta	tcnt
 011A 2EFC      	mvi	l,252	;XDOS internal data page
 011C 5E        	mov	e,m
 011D 23        	inx	h
 011E 56        	mov	d,m
 011F 210500    	lxi	h,5
 0122 19        	dad	d	; skip past TOD
 0123 22E005    	shld	rlr
 0126 219600    	lxi	h,0096h	; osmsegtbl
 0129 19        	dad	d
 012A 22E205    	shld	msegtbl
                ; get common size from SYSDAT
 012D 2A0F00    	lhld	sysdat
 0130 2E7C      	mvi	l,124		;common memory base page
 0132 7E        	mov	a,m
                ; Verify that we have banked RAM... A=compag from MP/M
 0133 CD0000    	call	?bnkck
 0136 321E02    	sta	bnkflg
                 if z180tick
                ; initialize timer interrupts
                	lxi	h,tickrate	; phi/20/tickrate = ticks per sec
                	out0	l,tmdr0l
                	out0	h,tmdr0h
                	out0	l,rldr0l
                	out0	h,rldr0h
                	in0	a,tcr
                	ori	00010001b	; TIE0, TDE0
                	out0	a,tcr		; start the timer
                 endif
                ; Initialize all modules and build tables.
 0139 215302    	lxi	h,thread	;thread our way through the modules,
 013C 5E        iin0:	mov	e,m		;initializing as we go.
 013D 23        	inx	h
 013E 56        	mov	d,m	;next module, or "0000" if we're past the end.
 013F 23        	inx	h
 0140 7A        	mov	a,d
 0141 B3        	ora	e
 0142 CA8701    	jz	init$done
 0145 7E        	mov	a,m	;device base number
 0146 23        	inx	h
 0147 23        	inx	h	;thread+4 = init entry (JMP)
 0148 D6C8      	sui	200	;if Char I/O module, build entry(s) in tables.
 014A DA7F01    	jc	notchr
                	; should only be one...
 014D 22B901    	shld	ciomdl
 0150 D5        	push	d	;save NEXT module address
 0151 2B        	dcx	h	;number of devices
 0152 E5        	push	h
 0153 2A0F00    	lhld	sysdat
 0156 23        	inx	h	;nmb$cns
 0157 56        	mov	d,m	;E=nmb$cns
 0158 2EC5      	mvi	l,197
 015A 5E        	mov	e,m	;D=nmb$lst
 015B E1        	pop	h	;HL=ciomdl.ndev
 015C 7B        	mov	a,e
 015D 82        	add	d	;total ndev needed (never 0)
 015E 3D        	dcr	a
 015F 96        	sub	m	; (nmb$cns+nmb$lst-1) - ciomdl.ndev
                	jrc	iin50	; OK, we have enough
 0160+3811      	DB	38H,IIN50-$-1
 0162 3C        	inr	a	; num devs to drop
 0163 93        	sub	e	; drop printers first
                	jrz	iin3
 0164+2802      	DB	28H,IIN3-$-1
                	jrnc	iin1
 0166+3005      	DB	30H,IIN1-$-1
                iin3:	neg
 0168+ED44      	DB	0EDH,44H
 016A 5F        	mov	e,a	; num$lst remaining
                	jr	iin50
 016B+1806      	DB	18H,IIN50-$-1
 016D 1E00      iin1:	mvi	e,0	; no printers left, must reduce nmb$cns
 016F 92        	sub	d	; must be neg
                	neg
 0170+ED44      	DB	0EDH,44H
 0172 57        	mov	d,a
 0173 7A        iin50:	mov	a,d	; adjusted nmb$cns
 0174 32E400    	sta	maxcon+1
 0177 83        	add	e	; adjusted nmb$lst
 0178 32BB01    	sta	cionum	; initialize only what is needed
 017B E1        	pop	h	; next module
 017C C33C01    	jmp	iin0
                
                notchr: 		;HL point to init entry
 017F D5        	push	d
 0180 CD1C02    	call	icall	;"call" (HL)
 0183 E1        	pop	h
 0184 C33C01    	jmp	iin0
                
                init$done:	;all Disk I/O modules are initialized.
                		; now initialize the chrio devices
 0187 3ABB01    	lda	cionum
 018A 4F        	mov	c,a	; last dev + 1
 018B 0D        iin5:	dcr	c
 018C FA9601    	jm	iin2	; include dev 0
 018F C5        	push	b
 0190 CDBC01    	call	cinit
 0193 C1        	pop	b
                	jr	iin5
 0194+18F5      	DB	18H,IIN5-$-1
                iin2:
 0196 218C00    	lxi	h,signon
 0199 CDA100    	call	msgout
 019C 3A1E02    	lda	bnkflg
 019F B7        	ora	a	;is enough memory installed?
 01A0 CA0702    	jz	ramerr
 01A3 CDB201    	call	segchk	; check memsegtbl (if banked RAM good)
 01A6 B7        	ora	a
 01A7 CA0102    	jz	segerr
 01AA CDCA01    	call	set$jumps  ;setup system jumps and put in all banks
 01AD CD0000    	call	?itime	; get (starting) TOD from RTC
                
                 if z180tick
                	im2
                 endif
 01B0 AF        	xra	a
 01B1 C9        	ret
                
                ; Verify that memsegtbl has no bank >= @nbnk
                segchk:
 01B2 2A0F00    	lhld	sysdat
 01B5 2E0F      	mvi	l,15	; max$mem$seg
 01B7 46        	mov	b,m
 01B8 3A0000    	lda	@nbnk	; num banks
 01BB 3D        	dcr	a	; largest bank num allowed
                sgck0:
 01BC 23        	inx	h
 01BD 23        	inx	h
 01BE 23        	inx	h
 01BF 23        	inx	h	; memsegtbl[x].bank
 01C0 BE        	cmp	m
                	jrc	sgck1
 01C1+3805      	DB	38H,SGCK1-$-1
                	djnz	sgck0
 01C3+10F7      	DB	10H,SGCK0-$-1
 01C5 F6FF      	ori	true
 01C7 C9        	ret
 01C8 AF        sgck1:	xra	a	; error - not enough banks
 01C9 C9        	ret
                
                ; Interrupts disabled, must not enable
                set$jumps:
                	liyd	dbugv
 01CA+FD2A      	DB	0FDH,2AH
 01CC+1500      	DW	DBUGV
 01CE 3EC3      	mvi	a,(JMP)
 01D0 320000    	sta	cpm
                	sty	a,+0      ; set up jumps in page zero
 01D3+FD7700    	DB	0FDH,70H+A,+0
 01D6 2A17002201	lhld	biosjmp ! shld cpm+1	; BIOS warm start entry
 01DC 2A1300    	lhld	dbuga
                	sty	l,+1
 01DF+FD7501    	DB	0FDH,70H+L,+1
                	sty	h,+2	; DEBUGGER entry point
 01E2+FD7402    	DB	0FDH,70H+H,+2
 01E5 3A0000    	lda	@nbnk
 01E8 47        	mov	b,a	;number of banks (also, -1 is dest bank)
 01E9 0E00      	mvi	c,0	;source bank
                sj0:
 01EB 05        	dcr	b
 01EC C8        	rz
 01ED C5        	push	b
                	; must setup DE,HL before ?xmove
 01EE 210000    	lxi	h,0	; page 0 in all banks
 01F1 54        	mov	d,h
 01F2 5D        	mov	e,l
 01F3 CD0000    	call	?xmove
 01F6 014000    	lxi	b,64
 01F9 AF        	xra	a	; interrupts are disabled
 01FA CD0000    	call	?move
 01FD C1        	pop	b
                	jr	sj0		;
 01FE+18EB      	DB	18H,SJ0-$-1
 0200 C9        	ret
                
 0201 21BE00    segerr: lxi	h,bnkerr
 0204 C3B000    	jmp	errx
 0207 210000    ramerr: lxi	h,@mmerr
 020A C3B000    	jmp	errx
                
 020D 0000000000@dtbl:	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                
                seldsk:
 022D 79326B00  	mov a,c ! sta @adrv			; save drive select code
 0231 210000    	lxi	h,@lptbl
 0234 060009    	mvi b,0 ! dad b 	      ; create index from drive code
 0237 7E        	mov	a,m
 0238 FEFF      	cpi	255
 023A CABB02    	jz	selerr
 023D 326C00    	sta	@pdrv
 0240 4F        	mov	c,a
 0241 43        	mov	b,e	;save login flag thru "search" routine
 0242 CDA101    	call	search
 0245 DABB02    	jc	selerr
 0248 326D00    	sta	@rdrv
 024B 226E00    	shld	curmdl
 024E C5        	push	b	;save login bit
 024F 110E00    	lxi	d,14
 0252 19        	dad	d	;point to dphtbl
 0253 5E        	mov	e,m	;DE=dphtbl
 0254 23        	inx	h
 0255 56        	mov	d,m
 0256 23        	inx	h
 0257 4E        	mov	c,m	;BC=modtbl
 0258 23        	inx	h
 0259 46        	mov	b,m
 025A 3A6D00    	lda	@rdrv
 025D 87        	add	a
 025E 87        	add	a
 025F 87        	add	a	;*8
 0260 6F        	mov	l,a
 0261 2600      	mvi	h,0
 0263 09        	dad	b	;select mode bytes
 0264 227000    	shld	@cmode	;set current mode pointer
 0267 C1        	pop	b	;get login bit back.
                	bit	0,b	;test for initial select.
 0268+CB40      	DB	0CBH,0*8+B+40H
                	jrnz	notlgi
 026A+2053      	DB	20H,NOTLGI-$-1
 026C EB        	xchg		;DE=modes
 026D 4F        	mov	c,a
 026E 0600      	mvi	b,0
 0270 09        	dad	b	;+*8
 0271 09        	dad	b	;+*16
 0272 227200    	shld	@dph
 0275 EB        	xchg
 0276 3A6B00    	lda	@adrv
 0279 4F        	mov	c,a
 027A 87        	add	a	;*2
 027B 87        	add	a	;*4
 027C 87        	add	a	;*8
 027D 87        	add	a	;*16
 027E 81        	add	c	;*17
 027F 4F        	mov	c,a	;B still = 0
 0280 CDF602    	call	setup$dph
                	jrc	selerr
 0283+3836      	DB	38H,SELERR-$-1
 0285 AF        	xra	a
 0286 32CD05    	sta	@rcnfg
 0289 2A6E00    	lhld	curmdl
                	lxiy	@scrcb
 028C+FD21      	DB	0FDH,21H
 028E+0D07      	DW	@SCRCB
 0290 3A6C00    	lda	@pdrv
                	sty	a,hstdsk
 0293+FD7707    	DB	0FDH,70H+A,HSTDSK
 0296 3E03      	mvi	a,3
 0298 CDBF05    	call	calmod	;call module's "login" routine.
 029B B7        	ora	a	;see if an error occured.
                	jrnz	selerr
 029C+201D      	DB	20H,SELERR-$-1
 029E 3ACD05    	lda	@rcnfg
 02A1 B7        	ora	a
 02A2 C4F602    	cnz	setup$dph
                	jrc	selerr
 02A5+3814      	DB	38H,SELERR-$-1
 02A7 3A6B00    	lda	@adrv
 02AA 87        	add	a
 02AB 4F        	mov	c,a
 02AC 0600      	mvi	b,0
 02AE 210D02    	lxi	h,@dtbl
 02B1 09        	dad	b
                	lded	@dph
 02B2+ED5B      	DB	0EDH,5BH
 02B4+7200      	DW	@DPH
 02B6 73        	mov	m,e	;set current DPH in @dtbl
 02B7 23        	inx	h
 02B8 72        	mov	m,d
                	jr	selcom	;DE=dph
 02B9+1816      	DB	18H,SELCOM-$-1
                
 02BB 210000    selerr: lxi	h,0
 02BE C9        	ret
                
 02BF 3A6B00    notlgi: lda	@adrv
 02C2 87        	add	a
 02C3 4F        	mov	c,a
 02C4 0600      	mvi	b,0
 02C6 210D02    	lxi	h,@dtbl
 02C9 09        	dad	b
 02CA 5E        	mov	e,m	;get current DPH from @dtbl
 02CB 23        	inx	h
 02CC 56        	mov	d,m	;DE=dph
                	sded	@dph
 02CD+ED53      	DB	0EDH,53H
 02CF+7200      	DW	@DPH
                selcom:
 02D1 210A00    	lxi	h,+10
 02D4 19        	dad	d	;point to DPB entry
 02D5 4E        	mov	c,m
 02D6 23        	inx	h
 02D7 46        	mov	b,m
 02D8 0A        	ldax	b	;SPT (logical)
 02D9 32CC05    	sta	@spt
 02DC 210300    	lxi	h,+3
 02DF 09        	dad	b
 02E0 7E        	mov	a,m	;BSM
 02E1 32D905    	sta	blkmsk
 02E4 210D00    	lxi	h,+13	;point to track offset
 02E7 09        	dad	b
 02E8 4E        	mov	c,m
 02E9 23        	inx	h
 02EA 46        	mov	b,m
 02EB 23        	inx	h
                	sbcd	offset
 02EC+ED43      	DB	0EDH,43H
 02EE+CF05      	DW	OFFSET
 02F0 7E        	mov	a,m	;psh
 02F1 32CE05    	sta	blcode
 02F4 EB        	xchg		;put DPH in (HL) for BDOS
 02F5 C9        	ret
                
                setup$dph:
 02F6 B7        	ora	a	;reset [CY]
 02F7 2A7000    	lhld	@cmode	;HL=modes
                	bit	7,m	;check for hard-disk drive (modes not standard)
 02FA+CB7E      	DB	0CBH,7*8+M+40H
 02FC C0        	rnz
 02FD 37        	stc
 02FE C9        	ret
                
 02FF 010000    home:	lxi b,0 	; same as set track zero
                settrk: sbcd @trk
 0302+ED43      	DB	0EDH,43H
 0304+C705      	DW	@TRK
 0306 C9        	ret
                
                setsec: sbcd @sect
 0307+ED43      	DB	0EDH,43H
 0309+C905      	DW	@SECT
 030B C9        	ret
                
                setdma:
 030C 78        	mov	a,b
 030D A1        	ana	c
 030E FEFF      	cpi	true
 0310 CA5405    	jz	flushall
                	sbcd	@dma
 0313+ED43      	DB	0EDH,43H
 0315+8800      	DW	@DMA
 0317 C9        	ret
                
 0318 6960      sectrn: mov l,c ! mov h,b
 031A 7AB3C8    	mov a,d ! ora e ! rz
 031D EB096E2600	xchg ! dad b ! mov l,m ! mvi h,0
 0322 2B        	dcx	h	;sectors numbered 0 - (n-1)
 0323 C9        	ret
                
                
                read:
 0324 3EFF      	mvi	a,true		; FLAG A READ OPERATION
 0326 32D305    	sta	preread 	; forces FLUSH and Physical READ
 0329 32DA05    	sta	rdflg
 032C 32D405    	sta	defer		; never flush if reading (pointless)
 032F 2F        	cma	; false
 0330 32D505    	sta	unalloc ;terminate any active unallocated-writing
 0333 2ADC05    	LHLD	REQTRK
 0336 3ACF05    	lda	OFFSET
 0339 95        	sub	l	; DIR track must be < 256
 033A B4        	ora	h	; 00=on DIR track
 033B 2AC905    	lhld	@sect
 033E B4        	ora	h	;
 033F B5        	ora	l	; 00=first sector of directory
 0340 D601      	sui	1	; CY = 1st sec of dir
 0342 9F        	sbb	a	; FF = 1st sec of dir, else 00
 0343 32D205    	sta	dir0
                	jr	rwoper
 0346+1852      	DB	18H,RWOPER-$-1
                
                write:
 0348 AF        	xra	a
 0349 32D205    	sta	dir0
 034C 32DA05    	sta	rdflg
 034F 3EFF      	mvi	a,true
 0351 32D305    	STA	preread 	; assume a PRE-READ
 0354 79        	mov	a,c
 0355 E601      	ani	1		; 00 = defered write, else 01
 0357 3D        	dcr	a		; FF = defer, else 00
 0358 32D405    	sta	defer
                	bit	1,c		; write to 1st sector of unallocated block ?
 035B+CB49      	DB	0CBH,1*8+C+40H
                	jrz	CHKUNA
 035D+280D      	DB	28H,CHKUNA-$-1
                	SDED	URECORD 	; SET UNALLOCATED RECORD #
 035F+ED53      	DB	0EDH,53H
 0361+D605      	DW	URECORD
 0363 78        	mov	a,b
 0364 32D805    	sta	urecord+2
 0367 3EFF      	mvi	a,true
 0369 32D505    	STA	UNALLOC 	; FLAG WRITING OF AN UNALLOCATED BLOCK
 036C 3AD505    CHKUNA: LDA	UNALLOC 	; ARE WE WRITING AN UNALLOCATED BLOCK ?
 036F B7        	ORA	A
                	JRZ	rwoper
 0370+2828      	DB	28H,RWOPER-$-1
 0372 2AD605    	LHLD	URECORD 	; IS REQUESTED RECORD SAME AS EXPECTED
                	DSBC	D		;  SAME AS EXPECTED UNALLOCATED RECORD ?
 0375+ED52      	DB	0EDH,D*8+42H
                	JRNZ	ALLOC		; IF NOT, THEN DONE WITH UNALLOCATED BLOCK
 0377+201D      	DB	20H,ALLOC-$-1
 0379 3AD805    	lda	urecord+2
 037C 90        	sub	b
                	jrnz	alloc
 037D+2017      	DB	20H,ALLOC-$-1
 037F AF        	XRA	A		; CLEAR PRE-READ FLAG
 0380 32D305    	STA	preread
 0383 210100    	lxi	h,1		; INCREMENT TO NEXT EXPECTED UNALLOCATED RECORD
 0386 19        	dad	d
 0387 22D605    	shld	urecord
 038A 3E00      	mvi	a,0
 038C 88        	adc	b
 038D 32D805    	sta	urecord+2
 0390 3AD905    	LDA	BLKMSK
 0393 A5        	ana	l		; IS IT THE START OF A NEW BLOCK ?
                	JRNZ	rwoper
 0394+2004      	DB	20H,RWOPER-$-1
 0396 AF        ALLOC:	XRA	A		; NO LONGER WRITING AN UNALLOCATED BLOCK
 0397 32D505    	STA	UNALLOC
                rwoper:
                	; RLR - Ready List Root - points to the current process
 039A 2AE005    	lhld	rlr
 039D 4E        	mov	c,m
 039E 23        	inx	h
 039F 46        	mov	b,m	;BC=PDAdr, must be preserved throughout.
                ; get a buffer for this disk access...
                 if lrubuf
                	lixd	hsttop
 03A0+DD2A      	DB	0DDH,2AH
 03A2+E405      	DW	HSTTOP
 03A4 210000    	lxi	h,0
 03A7 22E805    	shld	previous
 03AA 2AE405    	lhld	hsttop
 03AD 7C        	mov	a,h
 03AE B5        	ora	l
 03AF C2B803    	jnz	sd0
 03B2 2AE605    	lhld	fretop
 03B5 C3E503    	jmp	sd1
                sd0:	ldx	e,link
 03B8+DD5E00    	DB	0DDH,E*8+46H,LINK
                	ldx	d,link+1
 03BB+DD5601    	DB	0DDH,D*8+46H,LINK+1
                	ldx	l,hstpda
 03BE+DD6E02    	DB	0DDH,L*8+46H,HSTPDA
                	ldx	h,hstpda+1
 03C1+DD6603    	DB	0DDH,H*8+46H,HSTPDA+1
 03C4 B7        	ora	a
                	dsbc	b	;compare P.D.Adr
 03C5+ED42      	DB	0EDH,B*8+42H
 03C7 CAF003    	jz	sd2
 03CA 7A        	mov	a,d
 03CB B3        	ora	e
 03CC CAD903    	jz	sd3
                	sixd	previous
 03CF+DD22      	DB	0DDH,22H
 03D1+E805      	DW	PREVIOUS
 03D3 D5        	push	d
                	popix
 03D4+DDE1      	DB	0DDH,0E1H
 03D6 C3B803    	jmp	sd0
                sd3:	sixd	last
 03D9+DD22      	DB	0DDH,22H
 03DB+EA05      	DW	LAST
 03DD 2AE605    	lhld	fretop
 03E0 7C        	mov	a,h
 03E1 B5        	ora	l
 03E2 CA0104    	jz	sd4
 03E5 5E        sd1:	mov	e,m
 03E6 23        	inx	h
 03E7 56        	mov	d,m
 03E8 2B        	dcx	h
                	sded	fretop
 03E9+ED53      	DB	0EDH,53H
 03EB+E605      	DW	FRETOP
 03ED C31704    	jmp	setbuf
                ; found our buffer, may not be at top of list.
 03F0 2AE805    sd2:	lhld	previous	;patch previous bufr to skip this one,
 03F3 7C        	mov	a,h		;unless this is already first.
 03F4 B5        	ora	l
 03F5 CA2D04    	jz	sd5
 03F8 73        	mov	m,e
 03F9 23        	inx	h
 03FA 72        	mov	m,d
                	pushix
 03FB+DDE5      	DB	0DDH,0E5H
 03FD E1        	pop	h	; move this bufr to top of list (most recently used)
 03FE C31F04    	jmp	setbuf1
                ; No existing buffer, no free buffers, must take last on list.
                sd4:	lixd	previous	;no existing in-use bufr, no free bufr.
 0401+DD2A      	DB	0DDH,2AH
 0403+E805      	DW	PREVIOUS
                	mvix	0,link		;remove last buffer in list,
 0405+DD360000  	DB	0DDH,36H,LINK,0
                	mvix	0,link+1	;patching previous to be new end.
 0409+DD360100  	DB	0DDH,36H,LINK+1,0
                	liyd	last	;must flush this buffer, if write pending.
 040D+FD2A      	DB	0FDH,2AH
 040F+EA05      	DW	LAST
 0411 CDA205    	call	flush	; ERROR will return directly to BDOS (pop h, ret)
 0414 2AEA05    	lhld	last	;
                ;	jmp	setbuf
 0417 EB        setbuf: xchg
 0418 210700    	lxi	h,hstdsk
 041B 19        	dad	d
 041C 36FF      	mvi	m,-1	;invalidate buffer.
 041E EB        	xchg
                setbuf1:lded	hsttop	;used to be top of list, now make it 2nd.
 041F+ED5B      	DB	0EDH,5BH
 0421+E405      	DW	HSTTOP
 0423 22E405    	shld	hsttop	;put selected bufr at top of list.
 0426 73        	mov	m,e	;set link
 0427 23        	inx	h
 0428 72        	mov	m,d
 0429 23        	inx	h
 042A 71        	mov	m,c	;BC must still = P.D.Adr
 042B 23        	inx	h
 042C 70        	mov	m,b
                sd5:
                 else
                	lxi	h,xxhdr
                	shld	hsttop
                 endif
                	; BC is still PDAdr
                	liyd	hsttop
 042D+FD2A      	DB	0FDH,2AH
 042F+E405      	DW	HSTTOP
 0431 3A6C00    	lda	@pdrv		; Calculate physical sector, etc
 0434 32DB05    	sta	reqdsk
 0437 CD1F02    	call	getusrbnk
 043A 2AC705    	lhld	@trk
 043D 22DC05    	shld	reqtrk
 0440 0E00      	MVI	C,0		; CALCULATE PHYSICAL SECTOR
 0442 3ACE05    	LDA	blcode		; PHYSICAL SECTOR SIZE CODE
 0445 B7        	ORA	A		; TEST FOR ZERO
 0446 47        	MOV	B,A
                	lded	@sect
 0447+ED5B      	DB	0EDH,5BH
 0449+C905      	DW	@SECT
                	JRZ	DBLOK3		; 128 BYTE SECTORS ?
 044B+280D      	DB	28H,DBLOK3-$-1
                DBLOK1: srlr	d		; DIVIDE BY 2
 044D+CB3A      	DB	0CBH, 38H + D
                	rarr	e
 044F+CB1B      	DB	0CBH, 18H + E
                	RARR	C		; SAVE OVERFLOW BITS
 0451+CB19      	DB	0CBH, 18H + C
                	DJNZ	DBLOK1		; AND CONTINUE IF BLOCKING STILL <> 0
 0453+10F8      	DB	10H,DBLOK1-$-1
 0455 47        	mov	b,a
                DBLOK2: RLCR	C		; NOW RESTORE THE OVERFLOW BY
 0456+CB01      	DB	0CBH, 00H + C
                	DJNZ	DBLOK2		; ROTATING IT RIGHT
 0458+10FC      	DB	10H,DBLOK2-$-1
 045A 79        DBLOK3: MOV	A,C
 045B 32D105    	sta	blksec		; STORE IT
                	sded	reqsec
 045E+ED53      	DB	0EDH,53H
 0460+DE05      	DW	REQSEC
                
                chk1:	ldy	e,link		; next buffer, or 0000
 0462+FD5E00    	DB	0FDH,E*8+46H,LINK
                	ldy	d,link+1	;
 0465+FD5601    	DB	0FDH,D*8+46H,LINK+1
 0468 7A        	mov	a,d
 0469 B3        	ora	e
                	jrz	chk2
 046A+2859      	DB	28H,CHK2-$-1
 046C D5        	push	d
                	popiy
 046D+FDE1      	DB	0FDH,0E1H
 046F 210700    	lxi	h,hstdsk
 0472 19        	dad	d
 0473 11DB05    	lxi	d,reqdsk
 0476 0605      	mvi	b,5
 0478 1A        chk0:	ldax	d
 0479 BE        	cmp	m
                	jrnz	chk1
 047A+20E6      	DB	20H,CHK1-$-1
 047C 23        	inx	h
 047D 13        	inx	d
                	djnz	chk0
 047E+10F8      	DB	10H,CHK0-$-1
 0480 CDA205    	call	flush	;an error bumps us out here.
                	siyd	previous	;save pointer
 0483+FD22      	DB	0FDH,22H
 0485+E805      	DW	PREVIOUS
 0487 3ADA05    	lda	rdflg
 048A B7        	ora	a
                	jrnz	chk3
 048B+2004      	DB	20H,CHK3-$-1
                	mviy	-1,hstdsk	;invalidate their buffer if we are writing.
 048D+FD3607FF  	DB	0FDH,36H,HSTDSK,-1
                chk3:	liyd	hsttop	;restore IY
 0491+FD2A      	DB	0FDH,2AH
 0493+E405      	DW	HSTTOP
 0495 3AD205    	lda	dir0
 0498 B7        	ora	a
                	jrnz	readit	;don't bother to move data if a read is forced...
 0499+204B      	DB	20H,READIT-$-1
 049B CDA205    chk4:	call	flush		; must flush our buffer BEFORE changing data.
                	ldy	l,hstbuf	; destination - our buffer
 049E+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1	;
 04A1+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
                	ldy	b,hstbnk	;
 04A4+FD460E    	DB	0FDH,B*8+46H,HSTBNK
                	lixd	previous
 04A7+DD2A      	DB	0DDH,2AH
 04A9+E805      	DW	PREVIOUS
                	ldx	e,hstbuf	; source
 04AB+DD5E0C    	DB	0DDH,E*8+46H,HSTBUF
                	ldx	d,hstbuf+1	;
 04AE+DD560D    	DB	0DDH,D*8+46H,HSTBUF+1
                	ldx	c,hstbnk	;
 04B1+DD4E0E    	DB	0DDH,C*8+46H,HSTBNK
 04B4 3E01      	mvi	a,1	; interrupts are enabled
 04B6 CD0000    	call	?xmove		;
 04B9 010002    	lxi	b,secsize	; put requested sector data in our buffer
 04BC CD0000    	call	?move		;
 04BF AF        	xra	a
 04C0 32D305    	sta	preread
                	jr	readit0
 04C3+1824      	DB	18H,READIT0-$-1
                chk2:	liyd	hsttop	;restore IY
 04C5+FD2A      	DB	0FDH,2AH
 04C7+E405      	DW	HSTTOP
 04C9 3AD205    	lda	dir0
 04CC B7        	ora	a
                	jrnz	readit
 04CD+2017      	DB	20H,READIT-$-1
 04CF 2AE405    chkbuf: lhld	hsttop
 04D2 110700    	lxi	d,hstdsk
 04D5 19        	dad	d
 04D6 EB        	xchg
 04D7 21DB05    	lxi	h,reqdsk
 04DA 0605      	mvi	b,5
 04DC 1A        chkbuf1:ldax	d
 04DD BE        	cmp	m
                	jrnz	readit
 04DE+2006      	DB	20H,READIT-$-1
 04E0 23        	inx	h
 04E1 13        	inx	d
                	djnz	chkbuf1
 04E2+10F8      	DB	10H,CHKBUF1-$-1
                	jr	noread		;  THEN NO NEED TO PRE-READ
 04E4+182D      	DB	18H,NOREAD-$-1
 04E6 CDA205    readit: call	flush
 04E9 2AE405    readit0:lhld	hsttop		; SET UP NEW BUFFER PARAMETERS
 04EC 110700    	lxi	d,hstdsk
 04EF 19        	dad	d
 04F0 EB        	xchg
 04F1 21DB05    	lxi	h,reqdsk	; set HSTDSK,HSTTRK,HSTSEC
 04F4 010500    	lxi	b,5		;
                	ldir			;
 04F7+EDB0      	DB	0EDH,0B0H
 04F9 2A6E00    	lhld	curmdl
                	sty	l,hstmdl
 04FC+FD750F    	DB	0FDH,70H+L,HSTMDL
                	sty	h,hstmdl+1
 04FF+FD7410    	DB	0FDH,70H+H,HSTMDL+1
 0502 2A7000    	lhld	@cmode
                	sty	l,hstmod
 0505+FD7504    	DB	0FDH,70H+L,HSTMOD
                	sty	h,hstmod+1
 0508+FD7405    	DB	0FDH,70H+H,HSTMOD+1
 050B 3AD305    	lda	preread
 050E B7        	ora	a
 050F C4B105    	cnz	pread		; READ THE SECTOR
 0512 C0        	rnz		;stop here if error
                noread: ldy	l,hstbuf	; POINT TO START OF SECTOR BUFFER
 0513+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1
 0516+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
 0519 018000    	lxi	b,128
 051C 3AD105    	lda	blksec		; POINT TO LOCATION OF CORRECT LOGICAL SECTOR
 051F 3D        movit1: dcr	a
 0520 FA2605    	jm	movit2
 0523 09        	dad	b
                	jr	movit1
 0524+18F9      	DB	18H,MOVIT1-$-1
                movit2:
                	; TODO: need to handle possible common memory DMA
                	lded	@dma		; POINT TO DMA
 0526+ED5B      	DB	0EDH,5BH
 0528+8800      	DW	@DMA
 052A 3A1900    	lda	@dbnk
 052D EB        	xchg		;DE is source, HL is dest.
 052E 47        	mov	b,a		;B=dest. bank
                	ldy	c,hstbnk	;C=source bank
 052F+FD4E0E    	DB	0FDH,C*8+46H,HSTBNK
 0532 3ADA05    	lda	rdflg		; IS IT A WRITE ?
 0535 B7        	ora	a
                	jrnz	movit3
 0536+2008      	DB	20H,MOVIT3-$-1
 0538 79        	mov	a,c
 0539 48        	mov	c,b
 053A 47        	mov	b,a
 053B EB        	xchg			; SWITCH DIRECTION OF MOVE FOR WRITE
                	mviy	true,pndwrt	; FLAG A PENDING WRITE
 053C+FD3606FF  	DB	0FDH,36H,PNDWRT,TRUE
 0540 CD0000    movit3: call	?xmove
 0543 018000    	lxi	b,128
 0546 3E01      	mvi	a,1	; interrupts are enabled
 0548 CD0000    	call	?move		; MOVE IT
 054B 3AD405    	lda	defer		; CHECK FOR non-defered write
 054E B7        	ora	a
 054F CCA205    	cz	flush		; WRITE THE SECTOR IF IT IS
 0552 AF        	xra	a		; FLAG NO ERROR
 0553 C9        	ret			; RETURN TO BDOS
                
                flushall:
                 if lrubuf
                	lded	hsttop
 0554+ED5B      	DB	0EDH,5BH
 0556+E405      	DW	HSTTOP
 0558 7A        	mov	a,d
 0559 B3        	ora	e
 055A C8        	rz		;no buffers in use.
 055B 21E405    	lxi	h,hsttop
 055E 22E805    	shld	previous
 0561 2AE005    	lhld	rlr
 0564 4E        	mov	c,m
 0565 23        	inx	h
 0566 46        	mov	b,m	;BC = PDAdr, must be preserved
 0567 210200    fls0:	lxi	h,hstpda
 056A 19        	dad	d
 056B 7E        	mov	a,m
 056C 23        	inx	h
 056D 66        	mov	h,m
 056E 6F        	mov	l,a
 056F B7        	ora	a
                	dsbc	b	;compare P.D. adr
 0570+ED42      	DB	0EDH,B*8+42H
 0572 CA8205    	jz	flush1
 0575 EB        	xchg
 0576 22E805    	shld	previous
 0579 5E        	mov	e,m
 057A 23        	inx	h
 057B 56        	mov	d,m
 057C 7A        	mov	a,d
 057D B3        	ora	e
 057E C26705    	jnz	fls0
 0581 C9        	ret
                
                ; TODO: could there be more than one?
                ; might need to resume flushall...
 0582 D5        flush1: push	d
                	popiy
 0583+FDE1      	DB	0FDH,0E1H
 0585 2AE805    	lhld	previous
                	ldy	a,link
 0588+FD7E00    	DB	0FDH,A*8+46H,LINK
 058B 77        	mov	m,a
 058C 23        	inx	h
                	ldy	a,link+1
 058D+FD7E01    	DB	0FDH,A*8+46H,LINK+1
 0590 77        	mov	m,a
 0591 2AE605    	lhld	fretop
                	sty	l,link
 0594+FD7500    	DB	0FDH,70H+L,LINK
                	sty	h,link+1
 0597+FD7401    	DB	0FDH,70H+H,LINK+1
                	siyd	fretop
 059A+FD22      	DB	0FDH,22H
 059C+E605      	DW	FRETOP
                 else
                	lxiy	xxhdr
                 endif
 059E CDA205    	call	flush	; must handle stupid stack tricks
 05A1 C9        	ret
                
                ; Requires 2 ret adrs on stack, returns to imm caller on success,
                ; returns to caller's caller on error.
                flush:	ldy	a,pndwrt
 05A2+FD7E06    	DB	0FDH,A*8+46H,PNDWRT
 05A5 B7        	ora	a
 05A6 C8        	rz
                	mviy	false,pndwrt
 05A7+FD360600  	DB	0FDH,36H,PNDWRT,FALSE
 05AB CDB605    	call	pwrite
 05AE C8        	rz
 05AF E1        	pop	h
 05B0 C9        	ret
                
                ; IY=buffer header
 05B1 1E06      pread:	mvi	e,6	;read entry is +6
 05B3 C3B805    	jmp rw$common			; use common code
                
 05B6 1E09      pwrite: mvi	e,9	;write entry is +9
                
                rw$common:	;do any track/sector/side conversion...
                ;	xra	a
                ;	sta	@side
                ;	; Only "hard disk" supported...
                ;	ldy	l,hstmod
                ;	ldy	h,hstmod+1
                ;	bit	7,m	;floppy or hard-disk?
                ;	jrnz	rw0
                rw0:
 05B8 7B        	mov	a,e	; read(6) or write(9)
                	ldy	l,hstmdl
 05B9+FD6E0F    	DB	0FDH,L*8+46H,HSTMDL
                	ldy	h,hstmdl+1
 05BC+FD6610    	DB	0FDH,H*8+46H,HSTMDL+1
                calmod:
 05BF 85        	add	l
 05C0 6F        	mov	l,a
 05C1 3E00      	mvi	a,0
 05C3 8C        	adc	h
 05C4 67        	mov	h,a
 05C5 E9        	pchl		; leap to driver
                
 05C6           @side:	ds	1		; current side of media (floppy only)
 05C7           @trk:	ds	2		; current track number
 05C9           @sect:	ds	2		; current sector number
 05CB 00        @cnt:	db	0		; record count for multisector transfer
 05CC           @spt:	ds	1
 05CD           @rcnfg: ds	1
                
 05CE           blcode: ds	1	;blocking code, PSH
 05CF           offset: ds	2
 05D1           blksec: ds	1
 05D2           dir0:	ds	1
 05D3           preread:ds	1
 05D4           defer:	ds	1
 05D5           unalloc:ds	1
 05D6           urecord:ds	3
 05D9           blkmsk: ds	1
 05DA           rdflg:	ds	1
                
 05DB           reqdsk: ds	1
 05DC           reqtrk: ds	2
 05DE           reqsec: ds	2
                
 05E0 0000      rlr:	dw	0
 05E2 0000      msegtbl: dw	0
                
 05E4 0000      hsttop:   dw	0
                 if lrubuf
 05E6 EC05      fretop:   dw	hsthdr
 05E8 0000      previous: dw	0
 05EA 0000      last:	  dw	0
                
 0010 =         numbuf	equ	16
 0000 =         @@bnk	equ	0
 0100 #         @@ set 0100h	;start of buffers in bank
                		; (numbuf + 2) * secsize, buffers used,
                		; must not overrun system. At 512b and 16 bufs,
                		; this consumes 0100-2500, MP/M starts about A900.
                hsthdr: rept	numbuf
                	dw	$+hstlen ;Link
                	dw	0	;hstpda - Process Descriptor Address
                	dw	0	;hstmod
                	db	false	;pndwrt
                	db	-1	;hstdsk
                	dw	0	;hsttrk
                	dw	0	;hstsec
                	dw	@@	;hstbuf
                	db	@@bnk	;hstbnk
                	dw	0	;hstmdl
                @@ set @@+secsize
                	endm
 05EC+FD05      	DW	$+HSTLEN ;LINK
 05EE+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 05F0+0000      	DW	0	;HSTMOD
 05F2+00        	DB	FALSE	;PNDWRT
 05F3+FF        	DB	-1	;HSTDSK
 05F4+0000      	DW	0	;HSTTRK
 05F6+0000      	DW	0	;HSTSEC
 05F8+0001      	DW	@@	;HSTBUF
 05FA+00        	DB	@@BNK	;HSTBNK
 05FB+0000      	DW	0	;HSTMDL
 05FD+0E06      	DW	$+HSTLEN ;LINK
 05FF+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0601+0000      	DW	0	;HSTMOD
 0603+00        	DB	FALSE	;PNDWRT
 0604+FF        	DB	-1	;HSTDSK
 0605+0000      	DW	0	;HSTTRK
 0607+0000      	DW	0	;HSTSEC
 0609+0003      	DW	@@	;HSTBUF
 060B+00        	DB	@@BNK	;HSTBNK
 060C+0000      	DW	0	;HSTMDL
 060E+1F06      	DW	$+HSTLEN ;LINK
 0610+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0612+0000      	DW	0	;HSTMOD
 0614+00        	DB	FALSE	;PNDWRT
 0615+FF        	DB	-1	;HSTDSK
 0616+0000      	DW	0	;HSTTRK
 0618+0000      	DW	0	;HSTSEC
 061A+0005      	DW	@@	;HSTBUF
 061C+00        	DB	@@BNK	;HSTBNK
 061D+0000      	DW	0	;HSTMDL
 061F+3006      	DW	$+HSTLEN ;LINK
 0621+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0623+0000      	DW	0	;HSTMOD
 0625+00        	DB	FALSE	;PNDWRT
 0626+FF        	DB	-1	;HSTDSK
 0627+0000      	DW	0	;HSTTRK
 0629+0000      	DW	0	;HSTSEC
 062B+0007      	DW	@@	;HSTBUF
 062D+00        	DB	@@BNK	;HSTBNK
 062E+0000      	DW	0	;HSTMDL
 0630+4106      	DW	$+HSTLEN ;LINK
 0632+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0634+0000      	DW	0	;HSTMOD
 0636+00        	DB	FALSE	;PNDWRT
 0637+FF        	DB	-1	;HSTDSK
 0638+0000      	DW	0	;HSTTRK
 063A+0000      	DW	0	;HSTSEC
 063C+0009      	DW	@@	;HSTBUF
 063E+00        	DB	@@BNK	;HSTBNK
 063F+0000      	DW	0	;HSTMDL
 0641+5206      	DW	$+HSTLEN ;LINK
 0643+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0645+0000      	DW	0	;HSTMOD
 0647+00        	DB	FALSE	;PNDWRT
 0648+FF        	DB	-1	;HSTDSK
 0649+0000      	DW	0	;HSTTRK
 064B+0000      	DW	0	;HSTSEC
 064D+000B      	DW	@@	;HSTBUF
 064F+00        	DB	@@BNK	;HSTBNK
 0650+0000      	DW	0	;HSTMDL
 0652+6306      	DW	$+HSTLEN ;LINK
 0654+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0656+0000      	DW	0	;HSTMOD
 0658+00        	DB	FALSE	;PNDWRT
 0659+FF        	DB	-1	;HSTDSK
 065A+0000      	DW	0	;HSTTRK
 065C+0000      	DW	0	;HSTSEC
 065E+000D      	DW	@@	;HSTBUF
 0660+00        	DB	@@BNK	;HSTBNK
 0661+0000      	DW	0	;HSTMDL
 0663+7406      	DW	$+HSTLEN ;LINK
 0665+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0667+0000      	DW	0	;HSTMOD
 0669+00        	DB	FALSE	;PNDWRT
 066A+FF        	DB	-1	;HSTDSK
 066B+0000      	DW	0	;HSTTRK
 066D+0000      	DW	0	;HSTSEC
 066F+000F      	DW	@@	;HSTBUF
 0671+00        	DB	@@BNK	;HSTBNK
 0672+0000      	DW	0	;HSTMDL
 0674+8506      	DW	$+HSTLEN ;LINK
 0676+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0678+0000      	DW	0	;HSTMOD
 067A+00        	DB	FALSE	;PNDWRT
 067B+FF        	DB	-1	;HSTDSK
 067C+0000      	DW	0	;HSTTRK
 067E+0000      	DW	0	;HSTSEC
 0680+0011      	DW	@@	;HSTBUF
 0682+00        	DB	@@BNK	;HSTBNK
 0683+0000      	DW	0	;HSTMDL
 0685+9606      	DW	$+HSTLEN ;LINK
 0687+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0689+0000      	DW	0	;HSTMOD
 068B+00        	DB	FALSE	;PNDWRT
 068C+FF        	DB	-1	;HSTDSK
 068D+0000      	DW	0	;HSTTRK
 068F+0000      	DW	0	;HSTSEC
 0691+0013      	DW	@@	;HSTBUF
 0693+00        	DB	@@BNK	;HSTBNK
 0694+0000      	DW	0	;HSTMDL
 0696+A706      	DW	$+HSTLEN ;LINK
 0698+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 069A+0000      	DW	0	;HSTMOD
 069C+00        	DB	FALSE	;PNDWRT
 069D+FF        	DB	-1	;HSTDSK
 069E+0000      	DW	0	;HSTTRK
 06A0+0000      	DW	0	;HSTSEC
 06A2+0015      	DW	@@	;HSTBUF
 06A4+00        	DB	@@BNK	;HSTBNK
 06A5+0000      	DW	0	;HSTMDL
 06A7+B806      	DW	$+HSTLEN ;LINK
 06A9+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06AB+0000      	DW	0	;HSTMOD
 06AD+00        	DB	FALSE	;PNDWRT
 06AE+FF        	DB	-1	;HSTDSK
 06AF+0000      	DW	0	;HSTTRK
 06B1+0000      	DW	0	;HSTSEC
 06B3+0017      	DW	@@	;HSTBUF
 06B5+00        	DB	@@BNK	;HSTBNK
 06B6+0000      	DW	0	;HSTMDL
 06B8+C906      	DW	$+HSTLEN ;LINK
 06BA+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06BC+0000      	DW	0	;HSTMOD
 06BE+00        	DB	FALSE	;PNDWRT
 06BF+FF        	DB	-1	;HSTDSK
 06C0+0000      	DW	0	;HSTTRK
 06C2+0000      	DW	0	;HSTSEC
 06C4+0019      	DW	@@	;HSTBUF
 06C6+00        	DB	@@BNK	;HSTBNK
 06C7+0000      	DW	0	;HSTMDL
 06C9+DA06      	DW	$+HSTLEN ;LINK
 06CB+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06CD+0000      	DW	0	;HSTMOD
 06CF+00        	DB	FALSE	;PNDWRT
 06D0+FF        	DB	-1	;HSTDSK
 06D1+0000      	DW	0	;HSTTRK
 06D3+0000      	DW	0	;HSTSEC
 06D5+001B      	DW	@@	;HSTBUF
 06D7+00        	DB	@@BNK	;HSTBNK
 06D8+0000      	DW	0	;HSTMDL
 06DA+EB06      	DW	$+HSTLEN ;LINK
 06DC+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06DE+0000      	DW	0	;HSTMOD
 06E0+00        	DB	FALSE	;PNDWRT
 06E1+FF        	DB	-1	;HSTDSK
 06E2+0000      	DW	0	;HSTTRK
 06E4+0000      	DW	0	;HSTSEC
 06E6+001D      	DW	@@	;HSTBUF
 06E8+00        	DB	@@BNK	;HSTBNK
 06E9+0000      	DW	0	;HSTMDL
 06EB+FC06      	DW	$+HSTLEN ;LINK
 06ED+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06EF+0000      	DW	0	;HSTMOD
 06F1+00        	DB	FALSE	;PNDWRT
 06F2+FF        	DB	-1	;HSTDSK
 06F3+0000      	DW	0	;HSTTRK
 06F5+0000      	DW	0	;HSTSEC
 06F7+001F      	DW	@@	;HSTBUF
 06F9+00        	DB	@@BNK	;HSTBNK
 06FA+0000      	DW	0	;HSTMDL
                 endif
 06FC 0000      xxhdr:	dw	0	;Link - initially last in list.
 06FE 0000      	dw	0	;hstpda
 0700 0000      	dw	0	;hstmod
 0702 00        	db	false	;pndwrt
 0703 FF        	db	-1	;hstdsk
 0704 0000      	dw	0	;hsttrk
 0706 0000      	dw	0	;hstsec
 0708 0021      	dw	@@	;hstbuf
 070A 00        	db	@@bnk	;hstbnk
 070B 0000      	dw	0	;hstmdl
 2300 #         @@ set @@+secsize
                
                ; NOTE: this buffer can be used for reading only. (it is never flushed)
 070D 0000      @scrcb: dw	0	;link - not used
 070F 0000      	dw	0	;hstpda - not used
 0711 0000      	dw	0	;hstmod
 0713 00        	db	false	;pndwrt - assumed always false
 0714 FF        	db	-1	;hstdsk
 0715 0000      	dw	0	;hsttrk
 0717 0000      	dw	0	;hstsec
 0719 0023      	dw	@@	;hstbuf
 071B 00        	db	@@bnk	;hstbnk
 071C 0000      	dw	0	;hstmdl
                
 071E           	end
