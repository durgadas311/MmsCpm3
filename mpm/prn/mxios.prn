 6130 =         vers equ '0a' ; Nov 14, 2021  13:49  drm "MXIOS.ASM"
                ;****************************************************************
                ; MP/M main XIOS module for Z180 on the H8/H89			*
                ; Derived from the MMS 77500 server XIOS			*
                ; Copyright (c) 1983 Magnolia Microsystems			*
                ;****************************************************************
                ; All memory segments are ORGed at 0000.
                ; Uses CP/M Plus format DPBs.
                
                	maclib	z180
                	maclib	cfgmpm
                
                	public	@adrv,@pdrv,@rdrv,@side,@trk,@sect
                	public	@dma,@dbnk,@dirbf
                	public	@dstat,@cmode,@dph,@rcnfg,@eops
                	public	@cbnk,@scrcb,@vect,@secnd
                
                	public	xdos,polltb,sysdat
                
                	extrn	@lptbl
                	extrn	?memsl,?bnksl,?bnkck,?xmove,?move	; MMU module
                	extrn	@memstr,@mmerr,@nbnk
                	extrn	?time,?itime,@rtcstr			; RTC module
                
                 if z180
                z180tick	equ	true
                h89tick		equ	false
                 else
                  if h89
 0000 =         z180tick	equ	false
 FFFF =         h89tick		equ	true
 000A =         tick$tick	equ	10	; number of 2mS ticks per MP/M tick
                  else
                ; TODO: what to use for tick?
                z180tick	equ	false
                h89tick		equ	false
                  endif
                 endif
                
 FFFF =         only$prot$A	equ	true	; Only worry about R/O A:
 0200 =         secsize		equ	512	; largest sector size supported/used
                
 000D =         cr	equ 13
 000A =         lf	equ 10
 0007 =         bell	equ 7
                
 0000 =         cpm	equ	0
 0005 =         bdos	equ	5
                
 0083 =         poll	equ	131
 0085 =         flagset equ	133
                
                ;relative position of elements in buffer headers:
 0000 =         link	equ	0	;link to next headr, or 0
 0002 =         hstpda	equ	2	;Process Descriptor Adr of owner
 0004 =         hstmod	equ	4	;mode pointer (partition address)
 0006 =         pndwrt	equ	6	;pending write flag
 0007 =         hstdsk	equ	7	;host disk
 0008 =         hsttrk	equ	8	;host track
 000A =         hstsec	equ	10	;host sector
 000C =         hstbuf	equ	12	;host buffer address
 000E =         hstbnk	equ	14	;host bank
 000F =         hstmdl	equ	15	;host module entry
 0011 =         hstlen	equ	17	;length of header
                
                 if z180
                ; Z180 registers
                itc	equ	34h
                rcr	equ	36h
                mmu$cbr	equ	38h
                mmu$bbr	equ	39h
                mmu$cbar equ	3ah
                sar0l	equ	20h
                sar0h	equ	21h
                sar0b	equ	22h
                dar0l	equ	23h
                dar0h	equ	24h
                dar0b	equ	25h
                bcr0l	equ	26h
                bcr0h	equ	27h
                dstat	equ	30h
                dmode	equ	31h
                dcntl	equ	32h
                il	equ	33h
                tmdr0l	equ	0ch
                tmdr0h	equ	0dh
                rldr0l	equ	0eh
                rldr0h	equ	0fh
                tcr	equ	10h
                 endif
                
                ;-------- Start of Code-producing source -----------
                
                	; Because LINK puts dseg after cseg, and 'combas' is
                	; at the beginning of dseg, GENSYS will enforce that
                	; all of dseg falls in common memory.
                	cseg		; Banked memory
 0000 =         BIOS$0	equ	$
 0000 C30000    	jmp combas	; initial entry on cold start, common base
 0003 C39C00    	jmp wboot	; reentry on program exit, warm start
                
 0006 C3DC01    	jmp const	; return console input status
 0009 C3EA01    	jmp conin	; return console input character
 000C C3C201    	jmp conout	; send console output character
 000F C3BD01    	jmp list	; send list output character
 0012 C3B001    	jmp auxout	; send auxilliary output character	-NULL
 0015 C3AD01    	jmp auxin	; return auxilliary input character	-NULL
                
 0018 C30F03    	jmp home	; set disks to logical home
 001B C33D02    	jmp seldsk	; select disk drive, return disk parameter info
 001E C31203    	jmp settrk	; set disk track
 0021 C31703    	jmp setsec	; set disk sector
 0024 C31C03    	jmp setdma	; set disk I/O memory address
 0027 C33403    	jmp read	; read physical block(s)
 002A C35803    	jmp write	; write physical block(s)
                
 002D C3B401    	jmp listst	; return list device status
 0030 C32803    	jmp sectrn	; translate logical to physical sector
                
 0033 C30000    	jmp	?memsl
 0036 C3A400    	jmp	poll$dev
 0039 C3D900    	jmp	strtclk
 003C C3DD00    	jmp	stopclk
 003F C3D200    	jmp	exitreg
 0042 C3CF00    	jmp	maxcon
 0045 C3D900    	jmp	boot	;   sysinit
                ;	jmp	idle	;
 0048 000000    	nop ! nop ! nop	; no idle routine
                
 004B BF00      	dw	polltb	;for RSP's (such as NETWRKIF)
                
 004D           	ds	13	;this puts setup/mode info where they expect it
 005A C38D01    	jmp	search
 005D C31B02    	jmp	setspd	; change CPU speed - platform dependent
 0060           	ds	3
                
                ; These are only static when accessed via XIOSJMP.TBL
 0063           @dstat: ds	1
 0064           speed:	ds	1	; formerly Port F2 image "@intby"
                
 0065 0000      	dw	@lptbl	;logical/physical drive table
 0067 3F02      	dw	thread	;module thread
 0069 0000      	dw	0	;?serdp	;test mode validity, HL=memory address of ?serdp
                
 006B           @adrv:	ds	1		; currently selected disk drive
 006C           @pdrv:	ds	1		; physical drive number (MMS)
 006D           @rdrv:	ds	1		; module relative disk drive number
 006E           curmdl: ds	2		; currently selected Disk I/O module address
 0070           @cmode: ds	2
 0072           @dph:	ds	2
                
 0074 0080      icovec: dw	1000000000000000b
 0076 0080      icivec: dw	1000000000000000b
 0078 0000      iaovec: dw	0000000000000000b
 007A 0000      iaivec: dw	0000000000000000b
 007C 0000      ilovec: dw	0000000000000000b
                
 007E 00FFFFFF  defsrc: db	0,0ffh,0ffh,0ffh
 0082 00        tmpdrv: db	0
 0083 00        srctyp: db	000$00$000b	;only bits 3,4 are used (others ignored)
                
                	; for MODULES.COM... well, not quite since not in common memory...
                	; This will be copied to BIOS JMP PAGE, in common memory,
                	; but these strings must also reside in common memory.
 0084 0000      	dw	@memstr
 0086 0000      	dw	@rtcstr
                
 0088 0000      @dma:	dw	0
 008A 0000      wbtrap: dw	0
                
                	dseg
                ;---------- COMMON MEMORY -----------
                ; WARNING: must be on page boundary ('vect' alignment).
                ; Use LINK 'B' option.
 0000 C39C00    combas: jmp	colds
 0003 C30000    swtusr: jmp	$-$
 0006 C30000    swtsys: jmp	$-$
 0009 C30000    pdisp:	jmp	$-$
 000C C30000    xdos:	jmp	$-$
 000F 0000      sysdat: dw	$-$
                
                ; These locations are fixed, after combas block.
 0011 0000      @vect:	dw	$-$
 0013 0000      dbuga:	dw	$-$
 0015 0000      dbugv:	dw	$-$
 0017 0000      biosjmp:dw	$-$
 0019           @dbnk:	ds	1	; bank for user I/O (user DMA addr)
 001A           @eops:	ds	1
 001B           @intby: ds	1	; Port F2 image
                
 001C           @dirbf: ds	128
                
                 if z180
                	; Z180 internal devices interrupt vector table.
                	; If external devices also generate interrupts,
                	; this must be expanded/realigned to compensate.
                	; need 32-byte aligned address:
                	rept	(32 - (($-combas) AND 1fh)) AND 1fh
                	db	0
                	endm
                vect:	dw	nulint	; 0 - /INT1
                	dw	nulint	; 1 - /INT2
                	dw	tick	; 2 - PRT0 (TMDR0 -> 0)
                	dw	nulint	; 3 - PRT1 (TMDR1 -> 0)
                	dw	nulint	; 4 - DMA0
                	dw	nulint	; 5 - DMA1
                	dw	nulint	; 6 - CSIO
                	dw	nulint	; 7 - ASCI0
                	dw	nulint	; 8 - ASCI1
                	dw	nulint	; 9 - unused by Z180
                	dw	nulint	; 10 - unused by Z180
                	dw	nulint	; 11 - unused by Z180
                	dw	nulint	; 12 - unused by Z180
                	dw	nulint	; 13 - unused by Z180
                	dw	nulint	; 14 - unused by Z180
                	dw	nulint	; 15 - unused by Z180
                 endif
                
                wboot:
                colds:
                 if z180
                	; possible TRAP
                	in0	a,itc
                	tsti	10000000b	; TRAP bit
                	jrnz	trap
                 endif
 009C 0E00      	mvi	c,0
 009E C30C00    	jmp	xdos
                
                 if z180
                ; For now, any TRAP is fatal
                trap:	lxi	h,trpmsg
                	jmp	errx
                
                trpmsg:	db	cr,lf,'*TRAP*',cr,lf,'$'
                 endif
                
 00A1 FB        nulint:	ei
                	reti
 00A2+ED4D      	DB	0EDH,4DH
                
                ; C=device to poll, 0-N char I/O devices (input status)
                poll$dev:
 00A4 79        	mov	a,c
 00A5 FE08      	cpi	8
                	jrnc	pd0	; not char I/O...
 00A7+300A      	DB	30H,PD0-$-1
 00A9 51        	mov	d,c
 00AA D604      	sui	4
 00AC DADC01    	jc	const
 00AF 57        	mov	d,a
 00B0 C3B901    	jmp	conost
 00B3 0600      pd0:	mvi	b,0
 00B5 21BF00    	lxi	h,polltb
 00B8 09        	dad	b
 00B9 09        	dad	b
 00BA 5E        	mov	e,m
 00BB 23        	inx	h
 00BC 56        	mov	d,m
                	; TODO: check DE=NULL?
 00BD EB        	xchg
 00BE E9        	pchl
                
                ; Devices 8..15, starting at +0...
 00BF 0000000000polltb:	dw	$-$,$-$,$-$,$-$,$-$,$-$,$-$,$-$ ; 8..15 unassigned (yet)
                
 00CF 3E00      maxcon: mvi	a,0	;filled in at init from SYSDAT and config
 00D1 C9        	ret
                
                exitreg:
 00D2 3AE300    	lda	preempt
 00D5 B7        	ora	a
 00D6 C0        	rnz
 00D7 FB        	ei
 00D8 C9        	ret
                
 00D9 3EFF      strtclk: mvi	a,true
                	 jr	sc00
 00DB+1802      	DB	18H,SC00-$-1
 00DD 3E00      stopclk: mvi	a,false
 00DF 32E400    sc00:	 sta	clock
 00E2 C9        	 ret
                
 00E3 00        preempt: db	0
 00E4 00        clock:	 db	0
                
 00E5 0000      @secnd: dw	$-$	;used to do timeouts
                
 00E7 00        tps:	db	0	; from system data page on boot
 00E8 00        pcnt:	db	0	; pre-scale for interrupts to MP/M ticks
 00E9 00        tcnt:	db	0	; must immediately follow pcnt...
                
                second:
 00EA 2AE500    	lhld	@secnd
 00ED 7C        	mov	a,h
 00EE B5        	ora	l
 00EF C40802    	cnz	icall
 00F2 1E02      	mvi	e,2
 00F4 0E85      	mvi	c,flagset
 00F6 CD0C00    	call	xdos
                	jr	tk1
 00F9+1836      	DB	18H,TK1-$-1
                
                tick:	sspd	istk
 00FB+ED73      	DB	0EDH,73H
 00FD+8B01      	DW	ISTK
 00FF 318B01    	lxi	sp,intstk
 0102 F5        	push	psw
 0103 E5        	push	h
 0104 D5        	push	d
 0105 C5        	push	b
                 if z180tick
                	in0	a,tmdr0l	; reset INT
                 endif
                 if h89tick
 0106 3A1B00    	lda	@intby
 0109 D3F2      	out	0f2h	; reset INT
 010B 21E800    	lxi	h,pcnt
 010E 35        	dcr	m
                	jrnz	iexit
 010F+2030      	DB	20H,IEXIT-$-1
 0111 360A      	mvi	m,tick$tick
                 endif
 0113 3EFF      	mvi	a,true
 0115 32E300    	sta	preempt
 0118 3AE400    	lda	clock
 011B B7        	ora	a
                	jrz	tk0
 011C+2807      	DB	28H,TK0-$-1
 011E 1E01      	mvi	e,1
 0120 0E85      	mvi	c,flagset
 0122 CD0C00    	call	xdos
                tk0:
 0125 21E900    	lxi	h,tcnt
 0128 35        	dcr	m
                	jrnz	tk1
 0129+2006      	DB	20H,TK1-$-1
 012B 3AE700    	lda	tps
 012E 77        	mov	m,a
                	jr	second
 012F+18B9      	DB	18H,SECOND-$-1
 0131 3E00      tk1:	mvi	a,false
 0133 32E300    	sta	preempt
                 if z180tick
                	lxi	d,nexti
                	push	d
                	reti	; required by Z180?
                nexti:
                 endif
 0136 C1        	pop	b
 0137 D1        	pop	d
 0138 E1        	pop	h
 0139 F1        	pop	psw
                	lspd	istk
 013A+ED7B      	DB	0EDH,07BH
 013C+8B01      	DW	ISTK
 013E C30900    	jmp	pdisp
                
                 if h89tick
                iexit:
 0141 C1        	pop	b
 0142 D1        	pop	d
 0143 E1        	pop	h
 0144 F1        	pop	psw
                	lspd	istk
 0145+ED7B      	DB	0EDH,07BH
 0147+8B01      	DW	ISTK
 0149 FB        	ei
 014A C9        	ret
                 endif
                
 014B           	ds	64	;32 levels of stack
 018B           intstk: ds	0
 018B 0000      istk:	dw	0
                
                ; SEARCH for a module by device #.
                ;   entry:	C = device # (0-249)
                ;   exit:	[CY] = not found
                ;	   else HL=module address ("init" entry)
                ;		A=device number (relative to module's #0)
                ;
 018D 113F02    search: lxi	d,thread	;C=device number
 0190 EB        snext:	xchg
 0191 5E        	mov	e,m
 0192 23        	inx	h
 0193 56        	mov	d,m
 0194 23        	inx	h
 0195 7A        	mov	a,d
 0196 B3        	ora	e
 0197 D601      	sui	1	;produce [CY] if DE=0000
 0199 D8        	rc		;return if device not found, DE=0000
 019A 79        	mov	a,c
 019B 96        	sub	m
                	jrc	snext
 019C+38F2      	DB	38H,SNEXT-$-1
 019E 23        	inx	h
 019F BE        	cmp	m
                	jrnc	snext
 01A0+30EE      	DB	30H,SNEXT-$-1
 01A2 23        	inx	h	;point to "init" vector
 01A3 B7        	ora	a	;set [NC] condition
 01A4 C9        	ret
                
 01A5 0000      ciomdl:	dw	0	;character device driver, filled at cold-start.
 01A7 00        cionum:	db	0	;max num cio devices (numcon+numlst)
                
                cinit:	;C=device number (0-11)
 01A8 2AA501    	lhld	ciomdl	; init routine
 01AB 41        	mov	b,c
 01AC E9        	pchl		;jump to modules "init" with B=device #
                
 01AD 3E1A      auxin:	mvi	a,1ah	; EOF
 01AF B7        	ora	a
 01B0 C9        auxout:	ret
                
 01B1 F1        nodev:	pop	psw
 01B2 AF        nost:	xra	a	; never ready
 01B3 C9        	ret
                
                ; D=device number
                listst:
 01B4 3AD000    	lda	maxcon+1
 01B7 82        	add	d
 01B8 57        	mov	d,a	; LST: #0 = con#N+1
                conost:
 01B9 3E09      	mvi	a,9
                	jr	devio
 01BB+1821      	DB	18H,DEVIO-$-1
                
                ; D=device number, C=char
                list:
 01BD 3AD000    	lda	maxcon+1
 01C0 82        	add	d
 01C1 57        	mov	d,a	; LST: #0 = con#N+1
                conout:
 01C2 C5        	push	b
 01C3 D5        	push	d
 01C4 CDB901    	call	conost	; is ready now?
 01C7 B7        	ora	a
 01C8 C2D601    	jnz	co0
 01CB D1        	pop	d
 01CC D5        	push	d
 01CD 7A        	mov	a,d
 01CE C604      	adi	4
 01D0 5F        	mov	e,a
 01D1 0E83      	mvi	c,poll
 01D3 CD0C00    	call	xdos	; sleep until ready
 01D6 D1        co0:	pop	d
 01D7 C1        	pop	b
 01D8 3E0C      coo:	mvi	a,12
                	jr	devio
 01DA+1802      	DB	18H,DEVIO-$-1
                
                ; D=device number
 01DC 3E03      const:	mvi	a,3
                	;jr	devio
                
                ; A=JMP tbl off, D=devnum [C=char]
 01DE F5        devio:	push	psw
 01DF 3AA701    	lda	cionum	;see if device exists
 01E2 3D        	dcr	a
 01E3 BA        	cmp	d
                	jrc	nodev
 01E4+38CB      	DB	38H,NODEV-$-1
 01E6 F1        	pop	psw	; driver JMP offset
 01E7 42        	mov	b,d	;device number in B for modules
                	jr	indjmp0
 01E8+1815      	DB	18H,INDJMP0-$-1
                
                ; D=device number
 01EA D5        conin:	push	d
 01EB CDDC01    	call	const	; is ready now?
 01EE B7        	ora	a
 01EF C2FA01    	jnz	ci0
 01F2 D1        	pop	d
 01F3 D5        	push	d
 01F4 5A        	mov	e,d
 01F5 0E83      	mvi	c,poll
 01F7 CD0C00    	call	xdos	; sleep until ready
 01FA D1        ci0:	pop	d
 01FB 3E06      	mvi	a,6
                	jr	devio
 01FD+18DF      	DB	18H,DEVIO-$-1
                
                ; char I/O driver function calls
                ; A=offset (0,3,6,9,...), B=device number (0..N)
                indjmp0:
 01FF 2AA501    	lhld	ciomdl
 0202 85        	add	l	;a=0,3,6,9,12,...
 0203 6F        	mov	l,a
 0204 3E00      	mvi	a,0
 0206 8C        	adc	h
 0207 67        	mov	h,a
 0208 E9        icall:	pchl		;indirect call
                
                
 0209 00        @cbnk:	db	0	; bank for processor operations
 020A           bnkflg: ds	1	;flag for enough memory installed.
                
                getusrbnk:	;finds the bank number for calling process
 020B CD0300    	call	swtusr		; would like better way...
 020E 3A0902    	lda	@cbnk
 0211 321900    	sta	@dbnk
 0214 C30600    	jmp	swtsys
                
                 if h89
                ; CPU clock rate selected, ORG0+2mS handled by user
 0217 00100414  cpuspd:	db	00h,10h,04h,14h
                 endif
                
                ; A=0,1,2,3[...] speed index, FF=get current speed
                ; Returns A: FF=error, FE=not supported, 0,1,2,3...=success
                ; Called from user bank, must be in common mem.
                setspd:
                 if h89
 021B FEFF      	cpi	0ffh
                	jrz	ssx
 021D+281C      	DB	28H,SSX-$-1
 021F 326400    	sta	speed
 0222 5F        	mov	e,a
 0223 FE04      	cpi	4
 0225 3EFF      	mvi	a,0ffh
 0227 D0        	rnc
 0228 211702    	lxi	h,cpuspd
 022B 1600      	mvi	d,0
 022D 19        	dad	d
 022E 56        	mov	d,m
 022F F3        	di
 0230 3A1B00    	lda	@intby
 0233 E6EB      	ani	11101011b
 0235 B2        	ora	d
 0236 321B00    	sta	@intby
 0239 D3F2      	out	0f2h	; speed changes now
                  if z180tick
                	; there will be a small error until next tick
                	lxi	h,maxclk
                	mov	a,e
                	cpi	3
                	jrz	ss0
                	lxi	h,minclk
                	ora	a
                	jrz	ss0
                ss1:	dad	h
                	dcr	a
                	jrnz	ss1
                ss0:	; HL=timer value for 50Hz tick
                	out0	l,rldr0l	; update timer reload count
                	out0	h,rldr0h	;
                  endif
 023B 3A6400    ssx:	lda	speed	; always return current speed
                 else
                	mvi	a,0feh	; not supported
                 endif
 023E C9        	ret
                
 023F =         thread: equ	$	;must be last in dseg (common mem)
                
                	cseg	; rest is in banked memory...
                
 008C 0D0A07    signon: db	cr,lf,bell
                 if h89
 008F 48382D    	db	'H8-'
                 endif
                ; TODO: other platforms...
                 if z180
                	db	'Z180'
                 else
 0092 5A3830    	db	'Z80'
                 endif
 0095 204D502F4D	db	' MP/M-II v3.00'
 00A3 3061      	dw	vers
 00A5 2020286329	db	'  (c) 1984 DRI and MMS',cr,lf,'$'
                
 00BE 0D0A074E6Fbnkerr:	db	cr,lf,bell,'Not enough memory banks$'
                
                ; Interrupts are disabled
                ; HL = BIOS JMP table
                ; DE = debug entry
                ; C = debug RST num
                boot:
                 if h89
                	; This is H89-specific...
 00D9 3E00      	mvi	a,defspd
 00DB 326400    	sta	speed
 00DE 3A1702    	lda	cpuspd+defspd
 00E1 F620      	ori	00100000b	; ORG0 only, right now
 00E3 321B00    	sta	@intby
 00E6 D3F2      	out	0f2h	; prevent undesirable intrs
                			; Console 8250 should already be off
                 endif
                 if z180
                	; speed things up...
                	mvi	a,z$dcntl
                	out0	a,dcntl	; set WAIT states
                	mvi	a,z$rcr
                	out0	a,rcr	; set RESFRESH cycles
                 endif
                	;
                	sded	dbuga
 00E8+ED53      	DB	0EDH,53H
 00EA+1300      	DW	DBUGA
 00EC 221700    	shld	biosjmp
 00EF 79        	mov	a,c
 00F0 87        	add	a
 00F1 87        	add	a
 00F2 87        	add	a
 00F3 6F        	mov	l,a
 00F4 2600      	mvi	h,0
 00F6 221500    	shld	dbugv
                 if z180tick
                	lxi	h,vect
                	shld	@vect
                	mov	a,h
                	stai
                	out0	l,il
                 endif
                 if h89tick
 00F9 3EC3      	mvi	a,JMP
 00FB 320800    	sta	0008h
 00FE 21FB00    	lxi	h,tick
 0101 220900    	shld	0008h+1
 0104 3A1B00    	lda	@intby
 0107 F602      	ori	02h
 0109 321B00    	sta	@intby
 010C D3F2      	out	0f2h
                 endif
                
 010E 2A0F00    	lhld	sysdat
 0111 2E7A      	mvi	l,122	;ticks/sec
 0113 7E        	mov	a,m
 0114 32E700    	sta	tps
 0117 32E900    	sta	tcnt
 011A 2EFC      	mvi	l,252	;XDOS internal data page
 011C 5E        	mov	e,m
 011D 23        	inx	h
 011E 56        	mov	d,m
 011F 210500    	lxi	h,5
 0122 19        	dad	d	; skip past TOD
 0123 220906    	shld	rlr
 0126 219600    	lxi	h,0096h	; osmsegtbl
 0129 19        	dad	d
 012A 220B06    	shld	msegtbl
                ; get common size from SYSDAT
 012D 2A0F00    	lhld	sysdat
 0130 2E7C      	mvi	l,124		;common memory base page
 0132 7E        	mov	a,m
                ; Verify that we have banked RAM... A=compag from MP/M
 0133 CD0000    	call	?bnkck
 0136 320A02    	sta	bnkflg
                 if z180tick
                ; initialize timer interrupts
                	lxi	h,tickrate	; phi/20/tickrate = ticks per sec
                	out0	l,tmdr0l
                	out0	h,tmdr0h
                	out0	l,rldr0l
                	out0	h,rldr0h
                	in0	a,tcr
                	ori	00010001b	; TIE0, TDE0
                	out0	a,tcr		; start the timer
                 endif
                ; Initialize all modules and build tables.
 0139 213F02    	lxi	h,thread	;thread our way through the modules,
 013C 5E        iin0:	mov	e,m		;initializing as we go.
 013D 23        	inx	h
 013E 56        	mov	d,m	;next module, or "0000" if we're past the end.
 013F 23        	inx	h
 0140 7A        	mov	a,d
 0141 B3        	ora	e
 0142 CA8701    	jz	init$done
 0145 7E        	mov	a,m	;device base number
 0146 23        	inx	h
 0147 23        	inx	h	;thread+4 = init entry (JMP)
 0148 D6C8      	sui	200	;if Char I/O module, build entry(s) in tables.
 014A DA7F01    	jc	notchr
                	; should only be one...
 014D 22A501    	shld	ciomdl
 0150 D5        	push	d	;save NEXT module address
 0151 2B        	dcx	h	;number of devices
 0152 E5        	push	h
 0153 2A0F00    	lhld	sysdat
 0156 23        	inx	h	;nmb$cns
 0157 56        	mov	d,m	;E=nmb$cns
 0158 2EC5      	mvi	l,197
 015A 5E        	mov	e,m	;D=nmb$lst
 015B E1        	pop	h	;HL=ciomdl.ndev
 015C 7B        	mov	a,e
 015D 82        	add	d	;total ndev needed (never 0)
 015E 3D        	dcr	a
 015F 96        	sub	m	; (nmb$cns+nmb$lst-1) - ciomdl.ndev
                	jrc	iin50	; OK, we have enough
 0160+3811      	DB	38H,IIN50-$-1
 0162 3C        	inr	a	; num devs to drop
 0163 93        	sub	e	; drop printers first
                	jrz	iin3
 0164+2802      	DB	28H,IIN3-$-1
                	jrnc	iin1
 0166+3005      	DB	30H,IIN1-$-1
                iin3:	neg
 0168+ED44      	DB	0EDH,44H
 016A 5F        	mov	e,a	; num$lst remaining
                	jr	iin50
 016B+1806      	DB	18H,IIN50-$-1
 016D 1E00      iin1:	mvi	e,0	; no printers left, must reduce nmb$cns
 016F 92        	sub	d	; must be neg
                	neg
 0170+ED44      	DB	0EDH,44H
 0172 57        	mov	d,a
 0173 7A        iin50:	mov	a,d	; adjusted nmb$cns
 0174 32D000    	sta	maxcon+1
 0177 83        	add	e	; adjusted nmb$lst
 0178 32A701    	sta	cionum	; initialize only what is needed
 017B E1        	pop	h	; next module
 017C C33C01    	jmp	iin0
                
                notchr: 		;HL point to init entry
 017F D5        	push	d
 0180 CD0802    	call	icall	;"call" (HL)
 0183 E1        	pop	h
 0184 C33C01    	jmp	iin0
                
                init$done:	;all Disk I/O modules are initialized.
                		; now initialize the chrio devices
 0187 3AA701    	lda	cionum
 018A 4F        	mov	c,a	; last dev + 1
 018B 0D        iin5:	dcr	c
 018C FA9601    	jm	iin2	; include dev 0
 018F C5        	push	b
 0190 CDA801    	call	cinit
 0193 C1        	pop	b
                	jr	iin5
 0194+18F5      	DB	18H,IIN5-$-1
                iin2:
 0196 218C00    	lxi	h,signon
 0199 CD0E02    	call	msgout
 019C 3A0A02    	lda	bnkflg
 019F B7        	ora	a	;is enough memory installed?
 01A0 CA0602    	jz	ramerr
 01A3 CDB201    	call	segchk	; check memsegtbl (if banked RAM good)
 01A6 B7        	ora	a
 01A7 CA0102    	jz	segerr
 01AA CDCA01    	call	set$jumps  ;setup system jumps and put in all banks
 01AD CD0000    	call	?itime	; get (starting) TOD from RTC
                
                 if z180tick
                	im2
                 endif
 01B0 AF        	xra	a
 01B1 C9        	ret
                
                ; Verify that memsegtbl has no bank >= @nbnk
                segchk:
 01B2 2A0F00    	lhld	sysdat
 01B5 2E0F      	mvi	l,15	; max$mem$seg
 01B7 46        	mov	b,m
 01B8 3A0000    	lda	@nbnk	; num banks
 01BB 3D        	dcr	a	; largest bank num allowed
                sgck0:
 01BC 23        	inx	h
 01BD 23        	inx	h
 01BE 23        	inx	h
 01BF 23        	inx	h	; memsegtbl[x].bank
 01C0 BE        	cmp	m
                	jrc	sgck1
 01C1+3805      	DB	38H,SGCK1-$-1
                	djnz	sgck0
 01C3+10F7      	DB	10H,SGCK0-$-1
 01C5 F6FF      	ori	true
 01C7 C9        	ret
 01C8 AF        sgck1:	xra	a	; error - not enough banks
 01C9 C9        	ret
                
                ; Interrupts disabled, must not enable
                set$jumps:
                	liyd	dbugv
 01CA+FD2A      	DB	0FDH,2AH
 01CC+1500      	DW	DBUGV
 01CE 3EC3      	mvi	a,(JMP)
 01D0 320000    	sta	cpm
                	sty	a,+0      ; set up jumps in page zero
 01D3+FD7700    	DB	0FDH,70H+A,+0
 01D6 2A17002201	lhld	biosjmp ! shld cpm+1	; BIOS warm start entry
 01DC 2A1300    	lhld	dbuga
                	sty	l,+1
 01DF+FD7501    	DB	0FDH,70H+L,+1
                	sty	h,+2	; DEBUGGER entry point
 01E2+FD7402    	DB	0FDH,70H+H,+2
 01E5 3A0000    	lda	@nbnk
 01E8 47        	mov	b,a	;number of banks (also, -1 is dest bank)
 01E9 0E00      	mvi	c,0	;source bank
                sj0:
 01EB 05        	dcr	b
 01EC C8        	rz
 01ED C5        	push	b
                	; must setup DE,HL before ?xmove
 01EE 210000    	lxi	h,0	; page 0 in all banks
 01F1 54        	mov	d,h
 01F2 5D        	mov	e,l
 01F3 CD0000    	call	?xmove
 01F6 014000    	lxi	b,64
 01F9 AF        	xra	a	; interrupts are disabled
 01FA CD0000    	call	?move
 01FD C1        	pop	b
                	jr	sj0		;
 01FE+18EB      	DB	18H,SJ0-$-1
 0200 C9        	ret
                
 0201 21BE00    segerr: lxi	h,bnkerr
                	jr	errx
 0204+1803      	DB	18H,ERRX-$-1
 0206 210000    ramerr: lxi	h,@mmerr
 0209 CD0E02    errx:	call	msgout
 020C F376      	di ! hlt
                
                msgout:
 020E 7E        	mov	a,m
 020F FE24      	cpi	'$'
 0211 C8        	rz
 0212 E5        	push	h
 0213 4E        	mov	c,m
 0214 1600      	mvi	d,0
 0216 CDD801    	call	coo
 0219 E1        	pop	h
 021A 23        	inx	h
                	jr	msgout
 021B+18F1      	DB	18H,MSGOUT-$-1
                
 021D 0000000000@dtbl:	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                
                seldsk:
 023D 79326B00  	mov a,c ! sta @adrv			; save drive select code
 0241 210000    	lxi	h,@lptbl
 0244 060009    	mvi b,0 ! dad b 	      ; create index from drive code
 0247 7E        	mov	a,m
 0248 FEFF      	cpi	255
 024A CACB02    	jz	selerr
 024D 326C00    	sta	@pdrv
 0250 4F        	mov	c,a
 0251 43        	mov	b,e	;save login flag thru "search" routine
 0252 CD8D01    	call	search
 0255 DACB02    	jc	selerr
 0258 326D00    	sta	@rdrv
 025B 226E00    	shld	curmdl
 025E C5        	push	b	;save login bit
 025F 110E00    	lxi	d,14
 0262 19        	dad	d	;point to dphtbl
 0263 5E        	mov	e,m	;DE=dphtbl
 0264 23        	inx	h
 0265 56        	mov	d,m
 0266 23        	inx	h
 0267 4E        	mov	c,m	;BC=modtbl
 0268 23        	inx	h
 0269 46        	mov	b,m
 026A 3A6D00    	lda	@rdrv
 026D 87        	add	a
 026E 87        	add	a
 026F 87        	add	a	;*8
 0270 6F        	mov	l,a
 0271 2600      	mvi	h,0
 0273 09        	dad	b	;select mode bytes
 0274 227000    	shld	@cmode	;set current mode pointer
 0277 C1        	pop	b	;get login bit back.
                	bit	0,b	;test for initial select.
 0278+CB40      	DB	0CBH,0*8+B+40H
                	jrnz	notlgi
 027A+2053      	DB	20H,NOTLGI-$-1
 027C EB        	xchg		;DE=modes
 027D 4F        	mov	c,a
 027E 0600      	mvi	b,0
 0280 09        	dad	b	;+*8
 0281 09        	dad	b	;+*16
 0282 227200    	shld	@dph
 0285 EB        	xchg
 0286 3A6B00    	lda	@adrv
 0289 4F        	mov	c,a
 028A 87        	add	a	;*2
 028B 87        	add	a	;*4
 028C 87        	add	a	;*8
 028D 87        	add	a	;*16
 028E 81        	add	c	;*17
 028F 4F        	mov	c,a	;B still = 0
 0290 CD0603    	call	setup$dph
                	jrc	selerr
 0293+3836      	DB	38H,SELERR-$-1
 0295 AF        	xra	a
 0296 32F605    	sta	@rcnfg
 0299 2A6E00    	lhld	curmdl
                	lxiy	@scrcb
 029C+FD21      	DB	0FDH,21H
 029E+3607      	DW	@SCRCB
 02A0 3A6C00    	lda	@pdrv
                	sty	a,hstdsk
 02A3+FD7707    	DB	0FDH,70H+A,HSTDSK
 02A6 3E03      	mvi	a,3
 02A8 CDE805    	call	calmod	;call module's "login" routine.
 02AB B7        	ora	a	;see if an error occured.
                	jrnz	selerr
 02AC+201D      	DB	20H,SELERR-$-1
 02AE 3AF605    	lda	@rcnfg
 02B1 B7        	ora	a
 02B2 C40603    	cnz	setup$dph
                	jrc	selerr
 02B5+3814      	DB	38H,SELERR-$-1
 02B7 3A6B00    	lda	@adrv
 02BA 87        	add	a
 02BB 4F        	mov	c,a
 02BC 0600      	mvi	b,0
 02BE 211D02    	lxi	h,@dtbl
 02C1 09        	dad	b
                	lded	@dph
 02C2+ED5B      	DB	0EDH,5BH
 02C4+7200      	DW	@DPH
 02C6 73        	mov	m,e	;set current DPH in @dtbl
 02C7 23        	inx	h
 02C8 72        	mov	m,d
                	jr	selcom	;DE=dph
 02C9+1816      	DB	18H,SELCOM-$-1
                
 02CB 210000    selerr: lxi	h,0
 02CE C9        	ret
                
 02CF 3A6B00    notlgi: lda	@adrv
 02D2 87        	add	a
 02D3 4F        	mov	c,a
 02D4 0600      	mvi	b,0
 02D6 211D02    	lxi	h,@dtbl
 02D9 09        	dad	b
 02DA 5E        	mov	e,m	;get current DPH from @dtbl
 02DB 23        	inx	h
 02DC 56        	mov	d,m	;DE=dph
                	sded	@dph
 02DD+ED53      	DB	0EDH,53H
 02DF+7200      	DW	@DPH
                selcom:
 02E1 210A00    	lxi	h,+10
 02E4 19        	dad	d	;point to DPB entry
 02E5 4E        	mov	c,m
 02E6 23        	inx	h
 02E7 46        	mov	b,m
 02E8 0A        	ldax	b	;SPT (logical)
 02E9 32F505    	sta	@spt
 02EC 210300    	lxi	h,+3
 02EF 09        	dad	b
 02F0 7E        	mov	a,m	;BSM
 02F1 320206    	sta	blkmsk
 02F4 210D00    	lxi	h,+13	;point to track offset
 02F7 09        	dad	b
 02F8 4E        	mov	c,m
 02F9 23        	inx	h
 02FA 46        	mov	b,m
 02FB 23        	inx	h
                	sbcd	offset
 02FC+ED43      	DB	0EDH,43H
 02FE+F805      	DW	OFFSET
 0300 7E        	mov	a,m	;psh
 0301 32F705    	sta	blcode
 0304 EB        	xchg		;put DPH in (HL) for BDOS
 0305 C9        	ret
                
                setup$dph:
 0306 B7        	ora	a	;reset [CY]
 0307 2A7000    	lhld	@cmode	;HL=modes
                	bit	7,m	;check for hard-disk drive (modes not standard)
 030A+CB7E      	DB	0CBH,7*8+M+40H
 030C C0        	rnz
 030D 37        	stc
 030E C9        	ret
                
 030F 010000    home:	lxi b,0 	; same as set track zero
                settrk: sbcd @trk
 0312+ED43      	DB	0EDH,43H
 0314+F005      	DW	@TRK
 0316 C9        	ret
                
                setsec: sbcd @sect
 0317+ED43      	DB	0EDH,43H
 0319+F205      	DW	@SECT
 031B C9        	ret
                
                setdma:
 031C 78        	mov	a,b
 031D A1        	ana	c
 031E FEFF      	cpi	true
 0320 CA7D05    	jz	flushall
                	sbcd	@dma
 0323+ED43      	DB	0EDH,43H
 0325+8800      	DW	@DMA
 0327 C9        	ret
                
 0328 6960      sectrn: mov l,c ! mov h,b
 032A 7AB3C8    	mov a,d ! ora e ! rz
 032D EB096E2600	xchg ! dad b ! mov l,m ! mvi h,0
 0332 2B        	dcx	h	;sectors numbered 0 - (n-1)
 0333 C9        	ret
                
                
                read:
 0334 3EFF      	mvi	a,true		; FLAG A READ OPERATION
 0336 32FC05    	sta	preread 	; forces FLUSH and Physical READ
 0339 320306    	sta	rdflg
 033C 32FD05    	sta	defer		; never flush if reading (pointless)
 033F 2F        	cma	; false
 0340 32FE05    	sta	unalloc ;terminate any active unallocated-writing
 0343 2A0506    	LHLD	REQTRK
 0346 3AF805    	lda	OFFSET
 0349 95        	sub	l	; DIR track must be < 256
 034A B4        	ora	h	; 00=on DIR track
 034B 2AF205    	lhld	@sect
 034E B4        	ora	h	;
 034F B5        	ora	l	; 00=first sector of directory
 0350 D601      	sui	1	; CY = 1st sec of dir
 0352 9F        	sbb	a	; FF = 1st sec of dir, else 00
 0353 32FB05    	sta	dir0
                	jr	rwoper
 0356+186B      	DB	18H,RWOPER-$-1
                
                write:
                	; For CP/NET servers, check if drive R/O.
                	; must preserve DE, BC.
                 if only$prot$A
 0358 3A6B00    	lda	@adrv
 035B B7        	ora	a
                	jrnz	wr2
 035C+2013      	DB	20H,WR2-$-1
 035E 2A0906    	lhld	rlr
 0361 7E        	mov	a,m
 0362 C61D      	adi	29	; process compat attrs (and R/O vec)
 0364 23        	inx	h
 0365 66        	mov	h,m
 0366 6F        	mov	l,a
 0367 3E00      	mvi	a,0
 0369 8C        	adc	h
 036A 67        	mov	h,a
 036B 7E        	mov	a,m	; get R/O vec
 036C E601      	ani	0001b
 036E 3E02      	mvi	a,2	; error: disk read/only
 0370 C0        	rnz
                 else
                	lhld	rlr
                	mov	a,m
                	adi	29	; process compat attrs (and R/O vec)
                	inx	h
                	mov	h,m
                	mov	l,a
                	mvi	a,0
                	adc	h
                	mov	h,a
                	mov	a,m	; get R/O vec
                	ani	00001111b
                	jrz	wr2
                	mov	l,a
                	lda	@adrv	; CP/M drive
                	cpi	4
                	jrnc	wr2
                	inr	a
                	mov	h,a
                	mvi	a,0001b
                wr0:	dcr	h
                	jrz	wr1
                	rlc
                	jr	wr0
                wr1:	ana	l	; test if selected drive is R/O
                	mvi	a,2	; error: disk read/only
                	rnz
                 endif
                wr2:
 0371 AF        	xra	a
 0372 32FB05    	sta	dir0
 0375 320306    	sta	rdflg
 0378 3EFF      	mvi	a,true
 037A 32FC05    	STA	preread 	; assume a PRE-READ
 037D 79        	mov	a,c
 037E E601      	ani	1		; 00 = defered write, else 01
 0380 3D        	dcr	a		; FF = defer, else 00
 0381 32FD05    	sta	defer
                	bit	1,c		; write to 1st sector of unallocated block ?
 0384+CB49      	DB	0CBH,1*8+C+40H
                	jrz	CHKUNA
 0386+280D      	DB	28H,CHKUNA-$-1
                	SDED	URECORD 	; SET UNALLOCATED RECORD #
 0388+ED53      	DB	0EDH,53H
 038A+FF05      	DW	URECORD
 038C 78        	mov	a,b
 038D 320106    	sta	urecord+2
 0390 3EFF      	mvi	a,true
 0392 32FE05    	STA	UNALLOC 	; FLAG WRITING OF AN UNALLOCATED BLOCK
 0395 3AFE05    CHKUNA: LDA	UNALLOC 	; ARE WE WRITING AN UNALLOCATED BLOCK ?
 0398 B7        	ORA	A
                	JRZ	rwoper
 0399+2828      	DB	28H,RWOPER-$-1
 039B 2AFF05    	LHLD	URECORD 	; IS REQUESTED RECORD SAME AS EXPECTED
                	DSBC	D		;  SAME AS EXPECTED UNALLOCATED RECORD ?
 039E+ED52      	DB	0EDH,D*8+42H
                	JRNZ	ALLOC		; IF NOT, THEN DONE WITH UNALLOCATED BLOCK
 03A0+201D      	DB	20H,ALLOC-$-1
 03A2 3A0106    	lda	urecord+2
 03A5 90        	sub	b
                	jrnz	alloc
 03A6+2017      	DB	20H,ALLOC-$-1
 03A8 AF        	XRA	A		; CLEAR PRE-READ FLAG
 03A9 32FC05    	STA	preread
 03AC 210100    	lxi	h,1		; INCREMENT TO NEXT EXPECTED UNALLOCATED RECORD
 03AF 19        	dad	d
 03B0 22FF05    	shld	urecord
 03B3 3E00      	mvi	a,0
 03B5 88        	adc	b
 03B6 320106    	sta	urecord+2
 03B9 3A0206    	LDA	BLKMSK
 03BC A5        	ana	l		; IS IT THE START OF A NEW BLOCK ?
                	JRNZ	rwoper
 03BD+2004      	DB	20H,RWOPER-$-1
 03BF AF        ALLOC:	XRA	A		; NO LONGER WRITING AN UNALLOCATED BLOCK
 03C0 32FE05    	STA	UNALLOC
                rwoper:
                	; RLR - Ready List Root - points to the current process
 03C3 2A0906    	lhld	rlr
 03C6 4E        	mov	c,m
 03C7 23        	inx	h
 03C8 46        	mov	b,m	;BC=PDAdr, must be preserved throughout.
                ; get a buffer for this disk access...
                 if lrubuf
                	lixd	hsttop
 03C9+DD2A      	DB	0DDH,2AH
 03CB+0D06      	DW	HSTTOP
 03CD 210000    	lxi	h,0
 03D0 221106    	shld	previous
 03D3 2A0D06    	lhld	hsttop
 03D6 7C        	mov	a,h
 03D7 B5        	ora	l
 03D8 C2E103    	jnz	sd0
 03DB 2A0F06    	lhld	fretop
 03DE C30E04    	jmp	sd1
                sd0:	ldx	e,link
 03E1+DD5E00    	DB	0DDH,E*8+46H,LINK
                	ldx	d,link+1
 03E4+DD5601    	DB	0DDH,D*8+46H,LINK+1
                	ldx	l,hstpda
 03E7+DD6E02    	DB	0DDH,L*8+46H,HSTPDA
                	ldx	h,hstpda+1
 03EA+DD6603    	DB	0DDH,H*8+46H,HSTPDA+1
 03ED B7        	ora	a
                	dsbc	b	;compare P.D.Adr
 03EE+ED42      	DB	0EDH,B*8+42H
 03F0 CA1904    	jz	sd2
 03F3 7A        	mov	a,d
 03F4 B3        	ora	e
 03F5 CA0204    	jz	sd3
                	sixd	previous
 03F8+DD22      	DB	0DDH,22H
 03FA+1106      	DW	PREVIOUS
 03FC D5        	push	d
                	popix
 03FD+DDE1      	DB	0DDH,0E1H
 03FF C3E103    	jmp	sd0
                sd3:	sixd	last
 0402+DD22      	DB	0DDH,22H
 0404+1306      	DW	LAST
 0406 2A0F06    	lhld	fretop
 0409 7C        	mov	a,h
 040A B5        	ora	l
 040B CA2A04    	jz	sd4
 040E 5E        sd1:	mov	e,m
 040F 23        	inx	h
 0410 56        	mov	d,m
 0411 2B        	dcx	h
                	sded	fretop
 0412+ED53      	DB	0EDH,53H
 0414+0F06      	DW	FRETOP
 0416 C34004    	jmp	setbuf
                ; found our buffer, may not be at top of list.
 0419 2A1106    sd2:	lhld	previous	;patch previous bufr to skip this one,
 041C 7C        	mov	a,h		;unless this is already first.
 041D B5        	ora	l
 041E CA5604    	jz	sd5
 0421 73        	mov	m,e
 0422 23        	inx	h
 0423 72        	mov	m,d
                	pushix
 0424+DDE5      	DB	0DDH,0E5H
 0426 E1        	pop	h	; move this bufr to top of list (most recently used)
 0427 C34804    	jmp	setbuf1
                ; No existing buffer, no free buffers, must take last on list.
                sd4:	lixd	previous	;no existing in-use bufr, no free bufr.
 042A+DD2A      	DB	0DDH,2AH
 042C+1106      	DW	PREVIOUS
                	mvix	0,link		;remove last buffer in list,
 042E+DD360000  	DB	0DDH,36H,LINK,0
                	mvix	0,link+1	;patching previous to be new end.
 0432+DD360100  	DB	0DDH,36H,LINK+1,0
                	liyd	last	;must flush this buffer, if write pending.
 0436+FD2A      	DB	0FDH,2AH
 0438+1306      	DW	LAST
 043A CDCB05    	call	flush	; ERROR will return directly to BDOS (pop h, ret)
 043D 2A1306    	lhld	last	;
                ;	jmp	setbuf
 0440 EB        setbuf: xchg
 0441 210700    	lxi	h,hstdsk
 0444 19        	dad	d
 0445 36FF      	mvi	m,-1	;invalidate buffer.
 0447 EB        	xchg
                setbuf1:lded	hsttop	;used to be top of list, now make it 2nd.
 0448+ED5B      	DB	0EDH,5BH
 044A+0D06      	DW	HSTTOP
 044C 220D06    	shld	hsttop	;put selected bufr at top of list.
 044F 73        	mov	m,e	;set link
 0450 23        	inx	h
 0451 72        	mov	m,d
 0452 23        	inx	h
 0453 71        	mov	m,c	;BC must still = P.D.Adr
 0454 23        	inx	h
 0455 70        	mov	m,b
                sd5:
                 else
                	lxi	h,xxhdr
                	shld	hsttop
                 endif
                	; BC is still PDAdr
                	liyd	hsttop
 0456+FD2A      	DB	0FDH,2AH
 0458+0D06      	DW	HSTTOP
 045A 3A6C00    	lda	@pdrv		; Calculate physical sector, etc
 045D 320406    	sta	reqdsk
 0460 CD0B02    	call	getusrbnk
 0463 2AF005    	lhld	@trk
 0466 220506    	shld	reqtrk
 0469 0E00      	MVI	C,0		; CALCULATE PHYSICAL SECTOR
 046B 3AF705    	LDA	blcode		; PHYSICAL SECTOR SIZE CODE
 046E B7        	ORA	A		; TEST FOR ZERO
 046F 47        	MOV	B,A
                	lded	@sect
 0470+ED5B      	DB	0EDH,5BH
 0472+F205      	DW	@SECT
                	JRZ	DBLOK3		; 128 BYTE SECTORS ?
 0474+280D      	DB	28H,DBLOK3-$-1
                DBLOK1: srlr	d		; DIVIDE BY 2
 0476+CB3A      	DB	0CBH, 38H + D
                	rarr	e
 0478+CB1B      	DB	0CBH, 18H + E
                	RARR	C		; SAVE OVERFLOW BITS
 047A+CB19      	DB	0CBH, 18H + C
                	DJNZ	DBLOK1		; AND CONTINUE IF BLOCKING STILL <> 0
 047C+10F8      	DB	10H,DBLOK1-$-1
 047E 47        	mov	b,a
                DBLOK2: RLCR	C		; NOW RESTORE THE OVERFLOW BY
 047F+CB01      	DB	0CBH, 00H + C
                	DJNZ	DBLOK2		; ROTATING IT RIGHT
 0481+10FC      	DB	10H,DBLOK2-$-1
 0483 79        DBLOK3: MOV	A,C
 0484 32FA05    	sta	blksec		; STORE IT
                	sded	reqsec
 0487+ED53      	DB	0EDH,53H
 0489+0706      	DW	REQSEC
                
                chk1:	ldy	e,link		; next buffer, or 0000
 048B+FD5E00    	DB	0FDH,E*8+46H,LINK
                	ldy	d,link+1	;
 048E+FD5601    	DB	0FDH,D*8+46H,LINK+1
 0491 7A        	mov	a,d
 0492 B3        	ora	e
                	jrz	chk2
 0493+2859      	DB	28H,CHK2-$-1
 0495 D5        	push	d
                	popiy
 0496+FDE1      	DB	0FDH,0E1H
 0498 210700    	lxi	h,hstdsk
 049B 19        	dad	d
 049C 110406    	lxi	d,reqdsk
 049F 0605      	mvi	b,5
 04A1 1A        chk0:	ldax	d
 04A2 BE        	cmp	m
                	jrnz	chk1
 04A3+20E6      	DB	20H,CHK1-$-1
 04A5 23        	inx	h
 04A6 13        	inx	d
                	djnz	chk0
 04A7+10F8      	DB	10H,CHK0-$-1
 04A9 CDCB05    	call	flush	;an error bumps us out here.
                	siyd	previous	;save pointer
 04AC+FD22      	DB	0FDH,22H
 04AE+1106      	DW	PREVIOUS
 04B0 3A0306    	lda	rdflg
 04B3 B7        	ora	a
                	jrnz	chk3
 04B4+2004      	DB	20H,CHK3-$-1
                	mviy	-1,hstdsk	;invalidate their buffer if we are writing.
 04B6+FD3607FF  	DB	0FDH,36H,HSTDSK,-1
                chk3:	liyd	hsttop	;restore IY
 04BA+FD2A      	DB	0FDH,2AH
 04BC+0D06      	DW	HSTTOP
 04BE 3AFB05    	lda	dir0
 04C1 B7        	ora	a
                	jrnz	readit	;don't bother to move data if a read is forced...
 04C2+204B      	DB	20H,READIT-$-1
 04C4 CDCB05    chk4:	call	flush		; must flush our buffer BEFORE changing data.
                	ldy	l,hstbuf	; destination - our buffer
 04C7+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1	;
 04CA+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
                	ldy	b,hstbnk	;
 04CD+FD460E    	DB	0FDH,B*8+46H,HSTBNK
                	lixd	previous
 04D0+DD2A      	DB	0DDH,2AH
 04D2+1106      	DW	PREVIOUS
                	ldx	e,hstbuf	; source
 04D4+DD5E0C    	DB	0DDH,E*8+46H,HSTBUF
                	ldx	d,hstbuf+1	;
 04D7+DD560D    	DB	0DDH,D*8+46H,HSTBUF+1
                	ldx	c,hstbnk	;
 04DA+DD4E0E    	DB	0DDH,C*8+46H,HSTBNK
 04DD 3E01      	mvi	a,1	; interrupts are enabled
 04DF CD0000    	call	?xmove		;
 04E2 010002    	lxi	b,secsize	; put requested sector data in our buffer
 04E5 CD0000    	call	?move		;
 04E8 AF        	xra	a
 04E9 32FC05    	sta	preread
                	jr	readit0
 04EC+1824      	DB	18H,READIT0-$-1
                chk2:	liyd	hsttop	;restore IY
 04EE+FD2A      	DB	0FDH,2AH
 04F0+0D06      	DW	HSTTOP
 04F2 3AFB05    	lda	dir0
 04F5 B7        	ora	a
                	jrnz	readit
 04F6+2017      	DB	20H,READIT-$-1
 04F8 2A0D06    chkbuf: lhld	hsttop
 04FB 110700    	lxi	d,hstdsk
 04FE 19        	dad	d
 04FF EB        	xchg
 0500 210406    	lxi	h,reqdsk
 0503 0605      	mvi	b,5
 0505 1A        chkbuf1:ldax	d
 0506 BE        	cmp	m
                	jrnz	readit
 0507+2006      	DB	20H,READIT-$-1
 0509 23        	inx	h
 050A 13        	inx	d
                	djnz	chkbuf1
 050B+10F8      	DB	10H,CHKBUF1-$-1
                	jr	noread		;  THEN NO NEED TO PRE-READ
 050D+182D      	DB	18H,NOREAD-$-1
 050F CDCB05    readit: call	flush
 0512 2A0D06    readit0:lhld	hsttop		; SET UP NEW BUFFER PARAMETERS
 0515 110700    	lxi	d,hstdsk
 0518 19        	dad	d
 0519 EB        	xchg
 051A 210406    	lxi	h,reqdsk	; set HSTDSK,HSTTRK,HSTSEC
 051D 010500    	lxi	b,5		;
                	ldir			;
 0520+EDB0      	DB	0EDH,0B0H
 0522 2A6E00    	lhld	curmdl
                	sty	l,hstmdl
 0525+FD750F    	DB	0FDH,70H+L,HSTMDL
                	sty	h,hstmdl+1
 0528+FD7410    	DB	0FDH,70H+H,HSTMDL+1
 052B 2A7000    	lhld	@cmode
                	sty	l,hstmod
 052E+FD7504    	DB	0FDH,70H+L,HSTMOD
                	sty	h,hstmod+1
 0531+FD7405    	DB	0FDH,70H+H,HSTMOD+1
 0534 3AFC05    	lda	preread
 0537 B7        	ora	a
 0538 C4DA05    	cnz	pread		; READ THE SECTOR
 053B C0        	rnz		;stop here if error
                noread: ldy	l,hstbuf	; POINT TO START OF SECTOR BUFFER
 053C+FD6E0C    	DB	0FDH,L*8+46H,HSTBUF
                	ldy	h,hstbuf+1
 053F+FD660D    	DB	0FDH,H*8+46H,HSTBUF+1
 0542 018000    	lxi	b,128
 0545 3AFA05    	lda	blksec		; POINT TO LOCATION OF CORRECT LOGICAL SECTOR
 0548 3D        movit1: dcr	a
 0549 FA4F05    	jm	movit2
 054C 09        	dad	b
                	jr	movit1
 054D+18F9      	DB	18H,MOVIT1-$-1
                movit2:
                	; TODO: need to handle possible common memory DMA
                	lded	@dma		; POINT TO DMA
 054F+ED5B      	DB	0EDH,5BH
 0551+8800      	DW	@DMA
 0553 3A1900    	lda	@dbnk
 0556 EB        	xchg		;DE is source, HL is dest.
 0557 47        	mov	b,a		;B=dest. bank
                	ldy	c,hstbnk	;C=source bank
 0558+FD4E0E    	DB	0FDH,C*8+46H,HSTBNK
 055B 3A0306    	lda	rdflg		; IS IT A WRITE ?
 055E B7        	ora	a
                	jrnz	movit3
 055F+2008      	DB	20H,MOVIT3-$-1
 0561 79        	mov	a,c
 0562 48        	mov	c,b
 0563 47        	mov	b,a
 0564 EB        	xchg			; SWITCH DIRECTION OF MOVE FOR WRITE
                	mviy	true,pndwrt	; FLAG A PENDING WRITE
 0565+FD3606FF  	DB	0FDH,36H,PNDWRT,TRUE
 0569 CD0000    movit3: call	?xmove
 056C 018000    	lxi	b,128
 056F 3E01      	mvi	a,1	; interrupts are enabled
 0571 CD0000    	call	?move		; MOVE IT
 0574 3AFD05    	lda	defer		; CHECK FOR non-defered write
 0577 B7        	ora	a
 0578 CCCB05    	cz	flush		; WRITE THE SECTOR IF IT IS
 057B AF        	xra	a		; FLAG NO ERROR
 057C C9        	ret			; RETURN TO BDOS
                
                flushall:
                 if lrubuf
                	lded	hsttop
 057D+ED5B      	DB	0EDH,5BH
 057F+0D06      	DW	HSTTOP
 0581 7A        	mov	a,d
 0582 B3        	ora	e
 0583 C8        	rz		;no buffers in use.
 0584 210D06    	lxi	h,hsttop
 0587 221106    	shld	previous
 058A 2A0906    	lhld	rlr
 058D 4E        	mov	c,m
 058E 23        	inx	h
 058F 46        	mov	b,m	;BC = PDAdr, must be preserved
 0590 210200    fls0:	lxi	h,hstpda
 0593 19        	dad	d
 0594 7E        	mov	a,m
 0595 23        	inx	h
 0596 66        	mov	h,m
 0597 6F        	mov	l,a
 0598 B7        	ora	a
                	dsbc	b	;compare P.D. adr
 0599+ED42      	DB	0EDH,B*8+42H
 059B CAAB05    	jz	flush1
 059E EB        	xchg
 059F 221106    	shld	previous
 05A2 5E        	mov	e,m
 05A3 23        	inx	h
 05A4 56        	mov	d,m
 05A5 7A        	mov	a,d
 05A6 B3        	ora	e
 05A7 C29005    	jnz	fls0
 05AA C9        	ret
                
                ; TODO: could there be more than one?
                ; might need to resume flushall...
 05AB D5        flush1: push	d
                	popiy
 05AC+FDE1      	DB	0FDH,0E1H
 05AE 2A1106    	lhld	previous
                	ldy	a,link
 05B1+FD7E00    	DB	0FDH,A*8+46H,LINK
 05B4 77        	mov	m,a
 05B5 23        	inx	h
                	ldy	a,link+1
 05B6+FD7E01    	DB	0FDH,A*8+46H,LINK+1
 05B9 77        	mov	m,a
 05BA 2A0F06    	lhld	fretop
                	sty	l,link
 05BD+FD7500    	DB	0FDH,70H+L,LINK
                	sty	h,link+1
 05C0+FD7401    	DB	0FDH,70H+H,LINK+1
                	siyd	fretop
 05C3+FD22      	DB	0FDH,22H
 05C5+0F06      	DW	FRETOP
                 else
                	lxiy	xxhdr
                 endif
 05C7 CDCB05    	call	flush	; must handle stupid stack tricks
 05CA C9        	ret
                
                ; Requires 2 ret adrs on stack, returns to imm caller on success,
                ; returns to caller's caller on error.
                flush:	ldy	a,pndwrt
 05CB+FD7E06    	DB	0FDH,A*8+46H,PNDWRT
 05CE B7        	ora	a
 05CF C8        	rz
                	mviy	false,pndwrt
 05D0+FD360600  	DB	0FDH,36H,PNDWRT,FALSE
 05D4 CDDF05    	call	pwrite
 05D7 C8        	rz
 05D8 E1        	pop	h
 05D9 C9        	ret
                
                ; IY=buffer header
 05DA 1E06      pread:	mvi	e,6	;read entry is +6
 05DC C3E105    	jmp rw$common			; use common code
                
 05DF 1E09      pwrite: mvi	e,9	;write entry is +9
                
                rw$common:	;do any track/sector/side conversion...
                ;	xra	a
                ;	sta	@side
                ;	; Only "hard disk" supported...
                ;	ldy	l,hstmod
                ;	ldy	h,hstmod+1
                ;	bit	7,m	;floppy or hard-disk?
                ;	jrnz	rw0
                rw0:
 05E1 7B        	mov	a,e	; read(6) or write(9)
                	ldy	l,hstmdl
 05E2+FD6E0F    	DB	0FDH,L*8+46H,HSTMDL
                	ldy	h,hstmdl+1
 05E5+FD6610    	DB	0FDH,H*8+46H,HSTMDL+1
                calmod:
 05E8 85        	add	l
 05E9 6F        	mov	l,a
 05EA 3E00      	mvi	a,0
 05EC 8C        	adc	h
 05ED 67        	mov	h,a
 05EE E9        	pchl		; leap to driver
                
 05EF           @side:	ds	1		; current side of media (floppy only)
 05F0           @trk:	ds	2		; current track number
 05F2           @sect:	ds	2		; current sector number
 05F4 00        @cnt:	db	0		; record count for multisector transfer
 05F5           @spt:	ds	1
 05F6           @rcnfg: ds	1
                
 05F7           blcode: ds	1	;blocking code, PSH
 05F8           offset: ds	2
 05FA           blksec: ds	1
 05FB           dir0:	ds	1
 05FC           preread:ds	1
 05FD           defer:	ds	1
 05FE           unalloc:ds	1
 05FF           urecord:ds	3
 0602           blkmsk: ds	1
 0603           rdflg:	ds	1
                
 0604           reqdsk: ds	1
 0605           reqtrk: ds	2
 0607           reqsec: ds	2
                
 0609 0000      rlr:	dw	0
 060B 0000      msegtbl: dw	0
                
 060D 0000      hsttop:   dw	0
                 if lrubuf
 060F 1506      fretop:   dw	hsthdr
 0611 0000      previous: dw	0
 0613 0000      last:	  dw	0
                
 0010 =         numbuf	equ	16
 0000 =         @@bnk	equ	0
 0100 #         @@ set 0100h	;start of buffers in bank
                		; (numbuf + 2) * secsize, buffers used,
                		; must not overrun system. At 512b and 16 bufs,
                		; this consumes 0100-2500, MP/M starts about A900.
                hsthdr: rept	numbuf
                	dw	$+hstlen ;Link
                	dw	0	;hstpda - Process Descriptor Address
                	dw	0	;hstmod
                	db	false	;pndwrt
                	db	-1	;hstdsk
                	dw	0	;hsttrk
                	dw	0	;hstsec
                	dw	@@	;hstbuf
                	db	@@bnk	;hstbnk
                	dw	0	;hstmdl
                @@ set @@+secsize
                	endm
 0615+2606      	DW	$+HSTLEN ;LINK
 0617+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0619+0000      	DW	0	;HSTMOD
 061B+00        	DB	FALSE	;PNDWRT
 061C+FF        	DB	-1	;HSTDSK
 061D+0000      	DW	0	;HSTTRK
 061F+0000      	DW	0	;HSTSEC
 0621+0001      	DW	@@	;HSTBUF
 0623+00        	DB	@@BNK	;HSTBNK
 0624+0000      	DW	0	;HSTMDL
 0626+3706      	DW	$+HSTLEN ;LINK
 0628+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 062A+0000      	DW	0	;HSTMOD
 062C+00        	DB	FALSE	;PNDWRT
 062D+FF        	DB	-1	;HSTDSK
 062E+0000      	DW	0	;HSTTRK
 0630+0000      	DW	0	;HSTSEC
 0632+0003      	DW	@@	;HSTBUF
 0634+00        	DB	@@BNK	;HSTBNK
 0635+0000      	DW	0	;HSTMDL
 0637+4806      	DW	$+HSTLEN ;LINK
 0639+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 063B+0000      	DW	0	;HSTMOD
 063D+00        	DB	FALSE	;PNDWRT
 063E+FF        	DB	-1	;HSTDSK
 063F+0000      	DW	0	;HSTTRK
 0641+0000      	DW	0	;HSTSEC
 0643+0005      	DW	@@	;HSTBUF
 0645+00        	DB	@@BNK	;HSTBNK
 0646+0000      	DW	0	;HSTMDL
 0648+5906      	DW	$+HSTLEN ;LINK
 064A+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 064C+0000      	DW	0	;HSTMOD
 064E+00        	DB	FALSE	;PNDWRT
 064F+FF        	DB	-1	;HSTDSK
 0650+0000      	DW	0	;HSTTRK
 0652+0000      	DW	0	;HSTSEC
 0654+0007      	DW	@@	;HSTBUF
 0656+00        	DB	@@BNK	;HSTBNK
 0657+0000      	DW	0	;HSTMDL
 0659+6A06      	DW	$+HSTLEN ;LINK
 065B+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 065D+0000      	DW	0	;HSTMOD
 065F+00        	DB	FALSE	;PNDWRT
 0660+FF        	DB	-1	;HSTDSK
 0661+0000      	DW	0	;HSTTRK
 0663+0000      	DW	0	;HSTSEC
 0665+0009      	DW	@@	;HSTBUF
 0667+00        	DB	@@BNK	;HSTBNK
 0668+0000      	DW	0	;HSTMDL
 066A+7B06      	DW	$+HSTLEN ;LINK
 066C+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 066E+0000      	DW	0	;HSTMOD
 0670+00        	DB	FALSE	;PNDWRT
 0671+FF        	DB	-1	;HSTDSK
 0672+0000      	DW	0	;HSTTRK
 0674+0000      	DW	0	;HSTSEC
 0676+000B      	DW	@@	;HSTBUF
 0678+00        	DB	@@BNK	;HSTBNK
 0679+0000      	DW	0	;HSTMDL
 067B+8C06      	DW	$+HSTLEN ;LINK
 067D+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 067F+0000      	DW	0	;HSTMOD
 0681+00        	DB	FALSE	;PNDWRT
 0682+FF        	DB	-1	;HSTDSK
 0683+0000      	DW	0	;HSTTRK
 0685+0000      	DW	0	;HSTSEC
 0687+000D      	DW	@@	;HSTBUF
 0689+00        	DB	@@BNK	;HSTBNK
 068A+0000      	DW	0	;HSTMDL
 068C+9D06      	DW	$+HSTLEN ;LINK
 068E+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0690+0000      	DW	0	;HSTMOD
 0692+00        	DB	FALSE	;PNDWRT
 0693+FF        	DB	-1	;HSTDSK
 0694+0000      	DW	0	;HSTTRK
 0696+0000      	DW	0	;HSTSEC
 0698+000F      	DW	@@	;HSTBUF
 069A+00        	DB	@@BNK	;HSTBNK
 069B+0000      	DW	0	;HSTMDL
 069D+AE06      	DW	$+HSTLEN ;LINK
 069F+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06A1+0000      	DW	0	;HSTMOD
 06A3+00        	DB	FALSE	;PNDWRT
 06A4+FF        	DB	-1	;HSTDSK
 06A5+0000      	DW	0	;HSTTRK
 06A7+0000      	DW	0	;HSTSEC
 06A9+0011      	DW	@@	;HSTBUF
 06AB+00        	DB	@@BNK	;HSTBNK
 06AC+0000      	DW	0	;HSTMDL
 06AE+BF06      	DW	$+HSTLEN ;LINK
 06B0+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06B2+0000      	DW	0	;HSTMOD
 06B4+00        	DB	FALSE	;PNDWRT
 06B5+FF        	DB	-1	;HSTDSK
 06B6+0000      	DW	0	;HSTTRK
 06B8+0000      	DW	0	;HSTSEC
 06BA+0013      	DW	@@	;HSTBUF
 06BC+00        	DB	@@BNK	;HSTBNK
 06BD+0000      	DW	0	;HSTMDL
 06BF+D006      	DW	$+HSTLEN ;LINK
 06C1+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06C3+0000      	DW	0	;HSTMOD
 06C5+00        	DB	FALSE	;PNDWRT
 06C6+FF        	DB	-1	;HSTDSK
 06C7+0000      	DW	0	;HSTTRK
 06C9+0000      	DW	0	;HSTSEC
 06CB+0015      	DW	@@	;HSTBUF
 06CD+00        	DB	@@BNK	;HSTBNK
 06CE+0000      	DW	0	;HSTMDL
 06D0+E106      	DW	$+HSTLEN ;LINK
 06D2+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06D4+0000      	DW	0	;HSTMOD
 06D6+00        	DB	FALSE	;PNDWRT
 06D7+FF        	DB	-1	;HSTDSK
 06D8+0000      	DW	0	;HSTTRK
 06DA+0000      	DW	0	;HSTSEC
 06DC+0017      	DW	@@	;HSTBUF
 06DE+00        	DB	@@BNK	;HSTBNK
 06DF+0000      	DW	0	;HSTMDL
 06E1+F206      	DW	$+HSTLEN ;LINK
 06E3+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06E5+0000      	DW	0	;HSTMOD
 06E7+00        	DB	FALSE	;PNDWRT
 06E8+FF        	DB	-1	;HSTDSK
 06E9+0000      	DW	0	;HSTTRK
 06EB+0000      	DW	0	;HSTSEC
 06ED+0019      	DW	@@	;HSTBUF
 06EF+00        	DB	@@BNK	;HSTBNK
 06F0+0000      	DW	0	;HSTMDL
 06F2+0307      	DW	$+HSTLEN ;LINK
 06F4+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 06F6+0000      	DW	0	;HSTMOD
 06F8+00        	DB	FALSE	;PNDWRT
 06F9+FF        	DB	-1	;HSTDSK
 06FA+0000      	DW	0	;HSTTRK
 06FC+0000      	DW	0	;HSTSEC
 06FE+001B      	DW	@@	;HSTBUF
 0700+00        	DB	@@BNK	;HSTBNK
 0701+0000      	DW	0	;HSTMDL
 0703+1407      	DW	$+HSTLEN ;LINK
 0705+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0707+0000      	DW	0	;HSTMOD
 0709+00        	DB	FALSE	;PNDWRT
 070A+FF        	DB	-1	;HSTDSK
 070B+0000      	DW	0	;HSTTRK
 070D+0000      	DW	0	;HSTSEC
 070F+001D      	DW	@@	;HSTBUF
 0711+00        	DB	@@BNK	;HSTBNK
 0712+0000      	DW	0	;HSTMDL
 0714+2507      	DW	$+HSTLEN ;LINK
 0716+0000      	DW	0	;HSTPDA - PROCESS DESCRIPTOR ADDRESS
 0718+0000      	DW	0	;HSTMOD
 071A+00        	DB	FALSE	;PNDWRT
 071B+FF        	DB	-1	;HSTDSK
 071C+0000      	DW	0	;HSTTRK
 071E+0000      	DW	0	;HSTSEC
 0720+001F      	DW	@@	;HSTBUF
 0722+00        	DB	@@BNK	;HSTBNK
 0723+0000      	DW	0	;HSTMDL
                 endif
 0725 0000      xxhdr:	dw	0	;Link - initially last in list.
 0727 0000      	dw	0	;hstpda
 0729 0000      	dw	0	;hstmod
 072B 00        	db	false	;pndwrt
 072C FF        	db	-1	;hstdsk
 072D 0000      	dw	0	;hsttrk
 072F 0000      	dw	0	;hstsec
 0731 0021      	dw	@@	;hstbuf
 0733 00        	db	@@bnk	;hstbnk
 0734 0000      	dw	0	;hstmdl
 2300 #         @@ set @@+secsize
                
                ; NOTE: this buffer can be used for reading only. (it is never flushed)
 0736 0000      @scrcb: dw	0	;link - not used
 0738 0000      	dw	0	;hstpda - not used
 073A 0000      	dw	0	;hstmod
 073C 00        	db	false	;pndwrt - assumed always false
 073D FF        	db	-1	;hstdsk
 073E 0000      	dw	0	;hsttrk
 0740 0000      	dw	0	;hstsec
 0742 0023      	dw	@@	;hstbuf
 0744 00        	db	@@bnk	;hstbnk
 0745 0000      	dw	0	;hstmdl
                
 0747           	end
