; July 16, 1984 12:59 drm "INITMAIN.CSM"
;**************************************************
; INITIALIZATION routines called by DEFSASI
;**************************************************

	INCLUDE BDS.LIB 	; crl opcode to include a file
	MACLIB	Z80
	$-MACRO


PRINTS	EQU	9
BDOS	EQU	5
ESC	EQU	1BH

RECAL	EQU	1		; CONTROLLER COMMANDS
FMT	EQU	4
CHKTRK	EQU	5
CHKRAM	EQU	11100000B
CHKCON	EQU	11100100B
SENSE	EQU	00000011B
RDBL	EQU	8
WRBL	EQU	10
TSTDRV	EQU	0E3H

DCTYPE	EQU	3		; LOCATIONS IN MAGIC SECTOR
CBYTE	EQU	4
DDATA	EQU	5
CSTRNG	EQU	13
NPART	EQU	19
DDPB	EQU	47
SECTBL	EQU	20

;
; ERROR CODES	
;

NOERRCD EQU	0	;NO ERRORS
NRDYMSG EQU	1	;CONTROLLER NOT READY
PRTMSG1 EQU	2	;SW501 SETTING INCORRECT - NO PORT SELECTED
PRTMSG2 EQU	3	;SW501 SETTING DOES NOT MATCH PORT CHOICE
DNRMSG	EQU	4	;Drive not ready
PRECONF EQU	5	;Drive has been previously initialized 
CERR	EQU	6	;controller error 
VERR	EQU	7	;verify error
CMERR	EQU	8	;command error code


	FUNCTION INITSASI	; crl file pseudo-operation
	EXTERNAL REPOS		; external func to eliminate save/rest cursor

START:	CALL	ARGHAK		; put arg in buffer in runtime package
	PUSH	B
	LDA	ARG1
	LXI	H,CMERR
	CPI	CCLEN
	JNC	START1
	LXI	H,CCTBL
	ORA	A		; CLEAR CARRY
	RAL			; SHIFT RIGHT
	MOV	C,A
	MVI	B,0
	DAD	B
	MOV	C,M
	INX	H
	MOV	H,M
	MOV	L,C
	CALL	ICALL
START1:
	POP	B
	RET

ICALL:	PCHL

CCTBL	DW	RAMCHK		;0  command code
	DW	DRVCHK		;1
	DW	OUTCERR 	;2
	DW	INSPEC		;3
	DW	FORMAT		;4
	DW	VERIFY		;5
	DW	CONFIG		;6
	DW	CLRDIR		;7
	DW	BUFADR		;8
	DW	CONCHK		;9
	DW	CL$RST		;10
	DW	GET$PORT	;11
	DW	PUTLUN		;12
	DW	PUTCNUM 	;13
	DW	GETSECS 	;14
	DW	GETSEN		;15
	DW	GETERS		;16
CCLEN	EQU	17

;
;	TEST CONTROLLER RAM  initsasi(0)
;

RAMCHK: MVI	A,CHKRAM	; SET UP COMMAND CODE
	STA	CMBFR
	CALL	GETCON		; GET CONTROLLER'S ATTENTION
	CZ	OUTCOM		; OUTPUT THE COMMAND
	LXI	H,NRDYMSG
	JNZ	RAMCHK1
	CALL	CHK$STAT	; CHECK THE STATUS
	LXI	H,0
	JZ	RAMCHK1 	; DONE IF NO ERROR
	LXI	H,CERR
RAMCHK1:
	RET

;		   
;	TEST DRIVE    initsasi(1)
;

DRVCHK: CALL	CLRTICK
	MVI	A,TSTDRV	; SET UP COMMAND CODE
	STA	CMBFR
	LDA	BUFFER+CBYTE	; CONTROL BYTE
	ORI	10000000B	; CODE TO DISABLE RETRIES
	STA	CMBFR+5
	CALL	GETCON
	CZ	OUTCOM		; EXECUTE THE COMMAND
	LXI	H,NRDYMSG
	JNZ	DRVCHK1
	CALL	CHKTIM		; CHECK STATUS AND PRINT TIMER TICKS
	LXI	H,NOERRCD
	JZ	DRVCHK1
	LXI	H,CERR
DRVCHK1:
	RET

;
;	GET POINTER TO CONTROLLER ERROR MSG char *initsasi(2)
;

OUTCERR:
	LDA	ERSTAT
	ANI	00110000B	; GET ERROR TYPE
	MVI	B,7
	LXI	H,TYPE0
	CPI	00000000B
	JZ	GOTTYPE 	; IT'S TYPE 0
	MVI	B,11
	LXI	H,TYPE1
	CPI	00010000B
	JZ	GOTTYPE 	; IT'S TYPE 1
	LXI	H,TYPE2
	MVI	B,2
	CPI	00100000B
	JZ	GOTTYPE 	; IT'S TYPE 2
	LXI	H,TYPE3
	MVI	B,3		; IT'S TYPE 3
GOTTYPE:LDA	ERSTAT
	ANI	00001111B	; GET ERROR CODE
	CMP	B
	JNC	EXITER		; FOR ERROR TYPE
	RLC			; INDEX INTO MESSAGE ADDRESS TABLE FOR 
	MVI	D,0		; ERROR TYPE
	MOV	E,A
	DAD	D
	MOV	E,M		; ERROR MESSAGE ADDRESS TO REG. D
	INX	H
	MOV	D,M
	XCHG
	JMP	EXITER1
EXITER: 
	LXI	H,UNDEFMSG
EXITER1:
	RET

;
;	ERROR MESSAGE ADDRESS TABLES
;

TYPE0:	DW	OKMSG
	DW	MSG01
	DW	MSG02
	DW	MSG03
	DW	MSG04
	DW	MSG05
	DW	MSG06
	DW	MSG07
	DW	MSG08
	DW	UNDEFMSG
	DW	MSG0A
	DW	MSG0B

TYPE1:	DW	MSG10
	DW	MSG11
	DW	MSG12
	DW	MSG13
	DW	MSG14
	DW	MSG15
	DW	UNDEFMSG
	DW	MSG17
	DW	MSG18
	DW	MSG19
	DW	MSG1A

TYPE2:	DW	MSG20
	DW	MSG21
	DW	MSG22

TYPE3:	DW	MSG30
	DW	MSG31
	DW	MSG32

;	ERROR MESSAGES

OKMSG:	DB	'No Errors',0
MSG01:	DB	'No index signal',0
MSG02:	DB	'Seek not completed',0
MSG03:	DB	'Drive fault',0
MSG04:	DB	'Drive not ready',0
MSG05:	DB	'Drive not selected',0
MSG06:	DB	'Track 0 not found (Check Configuration Jumpers)',0
MSG07:	DB	'Multiple drives selected',0
MSG08:	DB	'No address acknowledge from DP100',0
MSG0A:	DB	'Addr ACK/INV fault',0
MSG0B:	DB	'No data transition',0
MSG10:	DB	'ID read error',0
MSG11:	DB	'Uncorrectable data error',0
MSG12:	DB	'No ID address mark',0
MSG13:	DB	'No data address mark',0
MSG14:	DB	'Sector not found',0
MSG15:	DB	'Seek error',0
MSG17:	DB	'Write protected sector',0
MSG18:	DB	'Correctable data error',0
MSG19:	DB	'Bad track',0
MSG1A:	DB	'Format error',0
MSG20:	DB	'Invalid command',0
MSG21:	DB	'Illegal disk address',0
MSG22:	DB	'Illegal function for current drive type',0
MSG30:	DB	'Ram error',0
MSG31:	DB	'Program memory checksum error',0
MSG32:	DB	'ECC polynomial error',0
UNDEFMSG: DB	'Undefined error',0

;
;	TRY TO READ SECTOR MAGIC SECTOR OF THE DISK AND SEE IF IT HAS BEEN
;	PREVIOUSLY CONFIGURED.	  initsasi(3) returns PRECONF
;	    

INSPEC: XRA	A
	STA	CMBFR		; FIRST TEST DRIVE READY
	CALL	GETCON
	LXI	H,NRDYMSG	; CONTROLLER NOT READY
	JNZ	INSPEC2
	CZ	OUTCOM
	CZ	CHK$STAT
	LXI	H,DNRMSG	; DRIVE NOT READY
	JNZ	INSPEC2
	CALL	READ0		;READ SECTOR ZERO (MAGIC SECTOR)
	JNZ	INSPEC2

	LXI	H,BUFFER
	MOV	A,M
	CPI	0C3H		; IF DRIVE HAS BEEN PREVIOUSLY CONFIGURED,
	JNZ	INSPEC1 	;  FIRST BYTE SHOULD BE C3
	INX	H
	MOV	A,M
	CPI	80H		; SECOND BYTE SHOULD BE 80
	JNZ	INSPEC1
	INX	H
	MOV	A,M
	CPI	24H		; THIRD BYTE SHOULD BE 24
	JNZ	INSPEC1
	LXI	H,PRECONF	; PREVIOUSLY CONFIGURED CODE 
	JMP	INSPEC2
INSPEC1:
	LXI	H,NOERRCD
INSPEC2:
	RET

;
;	FORMAT THE DISK  initsasi(4,interleave)
;

FORMAT	LDA	ARG2
	ANI	0001$1111B
	STA	CMBFR+4
	CALL	CLRTICK
	LXI	H,BUFFER+DDATA	; CALCULATE MAXIMUM TRACK NUMBER
	MOV	D,M		;  NUM. CYLINDERS x NUM. HEADS
	INX	H
	MOV	E,M
	INX	H
	MOV	B,M
	LXI	H,0
MULT:	DAD	D
	DCR	B
	JNZ	MULT
	DCX	H
	MVI	A,FMT		; FORMAT DRIVE COMMAND
	STA	CMBFR
	CALL	GETCON		; GET CONTROLLER'S ATTENTION
	LXI	H,NRDYMSG
	JNZ	FORMAT2
	CZ	OUTCOM		; OUTPUT THE COMMAND
	CZ	CHKTIM		; CHECK THE STATUS AND PRINT TIMER TICKS
	LXI	H,NOERRCD
	JZ	FORMAT2
	LXI	H,CERR
FORMAT2:
	RET

;
;	VERIFY FORMAT	initsasi(5,spt,interleave)
;

VERIFY:
	LDA	ARG2
	STA	SPT
	LDA	ARG3
	ANI	0001$1111B
	STA	CMBFR+4
	MVI	A,CHKTRK	; CHECK TRACK FORMAT COMMAND
	STA	CMBFR
	CALL	GETCON		; GET CONTROLLER'S ATTENTION
	LXI	H,NRDYMSG
	JNZ	VERIFY1
	CZ	OUTCOM		; OUTPUT THE COMMAND
	CZ	CHK$STAT	; CHECK THE STATUS
	LXI	H,VERR
	JNZ	VERIFY1 
	CALL	INCRE		; INCREMENT TO NEXT TRACK
	LXI	H,NOERRCD
VERIFY1:
	RET

INCRE:	LXI	H,CMBFR+1	;INCREMENT TO NEXT TRACK
	MOV	C,M
	INX	H
	MOV	D,M		; BY ADDING S.P.T. TO SECTOR ADDRESS 
	INX	H		; IN COMMAND BUFFER
	MOV	E,M
	LDA	SPT
	MOV	L,A
	MVI	H,0
	DAD	D
	JNC	NOCAR1
	INR	C
NOCAR1: XCHG
	LXI	H,CMBFR+1
	MOV	M,C
	INX	H
	MOV	M,D
	INX	H
	MOV	M,E
	RET			; CARRY IS SET IF NO MORE TRACKS TO CHECK

;
;	WRITE MAGIC SECTOR   initsasi(6)
;

CONFIG: XRA	A		; WRITE TO SECTOR 0
	STA	CMBFR+1
	STA	CMBFR+2
	STA	CMBFR+3
	LDA	BUFFER+CBYTE
	STA	CMBFR+5
	MVI	A,8
	LXI	H,BUFFER	; WRITE BUFFER -- MAGIC SECTOR IS HERE
	CALL	WRBLK		; WRITE THE BLOCK
	JNZ	CONFIG1 	; REPORT ERROR
	LXI	H,NOERRCD
CONFIG1:
	RET

;
;	CLEAR ALL DIRECTORIES  initsasi(7,sector-addres)
;

CLRDIR: LHLD	ARG2		; address of 4 byte sector address
	INX	H		; discard first byte
	MOV	A,M
	STA	CMBFR+1
	INX	H
	MOV	A,M
	STA	CMBFR+2
	INX	H
	MOV	A,M
	STA	CMBFR+3
	LDA	BUFFER+CBYTE
	STA	CMBFR+5
	MVI	A,8
	LXI	H,EMTDIR
	CALL	WRBLK
	JNZ	CLRDIR1
	LXI	H,NOERRCD
CLRDIR1:
	RET

;
;	Get BUFFER address   initsasi(8)
;


BUFADR: LXI	H,BUFFER	; GET ADDRESS OF BUFFER
	RET

;
;	Test controller    initsasi(9)
;

CONCHK: MVI	A,CHKCON	; SET UP COMMAND CODE
	STA	CMBFR
	CALL	GETCON		; GET CONTROLLER'S ATTENTION
	CZ	OUTCOM		; OUTPUT THE COMMAND
	LXI	H,NRDYMSG
	JNZ	CONCHK1
	CALL	CHK$STAT	; CHECK THE STATUS
	LXI	H,NOERRCD
	JZ	CONCHK1 	; DONE IF NO ERROR
	LXI	H,CERR
CONCHK1:
	RET

;
;	CLRST - INITIALIZE DRIVE   initsasi(10)
;

CL$RST:	CALL	RESET
	CALL	INIT$DRIVE 
	JNZ	CL$RST1
	LXI	H,NOERRCD
CL$RST1:
	RET
 
;
;	FUNCTION TO DETERMINE BASE PORT ADDRESS. PSW/Z RESET ON ERROR.
;			initsasi(11) 

GET$PORT:
	CALL	GETPRT
	RET

;
;	PUTLUN	initsasi(12,lun)
;

PUTLUN: LDA	ARG2
	STA	LUN
	LXI	H,NOERRCD
	RET

;
;	PUT CONTROLLER NUMBER Initsasi(13,cnum)
;

PUTCNUM:
	LDA	ARG2
	STA	CNUM
	LXI	H,NOERRCD
	RET

;
;	READ SECTOR TO GET SECTOR SIZE	initsasi(14)
;

GETSECS CALL	READ0
	LXI	H,0FFFFH	;SEND FFFF ON ERROR
	JNZ	GETSECS1
	PUSH	D
	POP	H
GETSECS1:
	RET

;
;	Get sense bytes   initsasi(15)
;


GETSEN: MVI	A,SENSE 	; SET UP REQUEST SENSE COMMAND
	STA	CMBFR
	CALL	GETCON		; EXECUTE COMMAND
	LXI	H,NRDYMSG
	JNZ	GETSEN1
	CALL	OUTCOM
	CZ	INSENSE 	; INPUT THE 4 SENSE BYTES
	CZ	CHK$STAT	; INPUT STATUS COMPLETION BYTES
	LXI	H,NOERRCD
	JZ	GETSEN1
	LXI	H,NRDYMSG
GETSEN1:
	RET

;
;	Get ERSTAT address initsasi(16)
;

GETERS: LXI	H,ERSTAT
	RET

ERSTAT: DB	0,0,0,0


;
;      SUBROUTINES
;


INIT$DRIVE:
	LDA	BUFFER+DCTYPE	; GET DRIVE/CONTROLLER TYPE BYTE
	ANI	11100000B	; ISOLATE CONTROLLER TYPE BITS
	JNZ	NOTXBC
	MVI	A,0CH		; INITIALIZE DRIVE CHARACTERISTICS COMMAND
	STA	CMBFR
	CALL	GETCON		; GET CONTROLLER'S ATTENTION
	LXI	H,NRDYMSG
	RNZ
	CALL	OUTCOM		; OUTPUT COMMAND
	CALL	OUTINIT
	CZ	CHK$STAT	;  AND CHECK STATUS
	LXI	H,CERR
	RNZ
	JMP	RESDR

NOTXBC: LXI	H,BUFFER+CSTRNG ; NOW SEND THE DRIVE ASSIGNMENT COMMAND
	LXI	D,CMBFR 	;  (FOR DATA PERIPHERALS CONTROLLERS)
	LXI	B,6
	LDIR
	CALL	GETCON
	LXI	H,NRDYMSG
	RNZ
	CALL	OUTCOM
	CZ	CHK$STAT
	LXI	H,CERR
	RNZ

RESDR:	LDA	BUFFER+CBYTE	; CONTROL BYTE FOR FUTURE COMMANDS
	STA	CMBFR+5
	CALL	GETCON		; RESTORE DRIVE
	LXI	H,NRDYMSG
	RNZ
	MVI	A,RECAL
	STA	CMBFR
	CALL	OUTCOM
	CZ	CHK$STAT
	LXI	H,CERR
	RET

;
;	WRITE BLOCK
;

WRBLK:	PUSH	H		; SAVE BUFFER ADDRESS
	CALL	SECTRN		; TRANSLATE LOGICAL TO PHYSICAL SECTOR
	STA	CMBFR+4 	; NUMBER OF SECTORS TO WRITE
	MVI	A,WRBL		; WRITE COMMAND TO COMMAND BUFFER
	STA	CMBFR
	CALL	GETCON		; SETUP CONTROLLER
	CZ	OUTCOM		; AND OUTPUT THE COMMAND
	LXI	H,NRDYMSG	; RETURN IF CONTROLLER NOT READY
	RNZ
	POP	H		; WRITE BUFFER TO HL
	CZ	WRITE		; DO WRITE
	CZ	CHK$STAT	; CHECK THE BUS RESPONSE
	LXI	H,CERR		; ERROR CODE (IN CASE IT'S NEEDED)
	RET

;
;	READ SECTOR ZERO
;

READ0:	MVI	A,RDBL		; SET UP READ COMMAND
	STA	CMBFR
	XRA	A
	STA	CMBFR+1 	; SECTOR 0 ADDRESS
	STA	CMBFR+2
	STA	CMBFR+3
	INR	A
	STA	CMBFR+4 	; READ 1 SECTOR
	LDA	BUFFER+CBYTE
	STA	CMBFR+5
	CALL	GETCON
	LXI	H,NRDYMSG
	RNZ
	CZ	OUTCOM
	LXI	H,BUFFER
	CZ	READ
	PUSH	D
	CZ	CHK$STAT
	POP	D
	LXI	H,CERR
	RET

;
;	TRANSLATE LOGICAL SECTOR ADDRESS
;

SECTRN: 
	MOV	E,A
	LDA	BUFFER+DDPB+15	; SECTOR SIZE (FROM 'MAGIC SECTOR')
	ANI	3
	RZ
	MOV	B,A
	ORA	A
	MOV	A,E
ROTATE: RAR
	DCR	B
	JNZ	ROTATE
	RET

;
;	SETS UP TICK COUNTER
;

CLRTICK:
	MVI	A,0
	STA	COUNT
	MVI	A,'1'
	STA	COUNT+1
	CALL	REPOS	;insure cursor is in correct position
	CALL	PRTCNT
	RET

;
;	PRINTS THE TICK COUNTER
;

PRTCNT:
	PUSH	H
	PUSH	D
	PUSH	B
	LXI	D,COUNT
	MVI	C,PRINTS
	CALL	BDOS
	LDA	COUNT+1
	INR	A
	CPI	'9'+1
	JC	PRTCNT2
	LDA	COUNT
	ORA	A
	JNZ	PRTCNT1
	MVI	A,'0'
PRTCNT1:
	INR	A
	STA	COUNT
	MVI	A,'0'
PRTCNT2:
	STA	COUNT+1
	CALL	REPOS	;resposition cursor to start of number field
	POP	B
	POP	D
	POP	H
	RET

COUNT:	DB	0,'1$'

; end of INITMAIN.CSM
;**************************************************
;
;	     HARDWARE DEPENDENT SECTION
;		   FOR Z89/Z90
;      Date lasted modified 12/9/83  7:46 mjm
;
***************************************************

GPIO	EQU	0F2H		; SWITCH 501

ACK	EQU	00000001B	; SASI STATUS PORT BITS
INT	EQU	00000010B
PER	EQU	00000100B
BUSY	EQU	00001000B
CMND	EQU	00010000B
MSG	EQU	00100000B
POUT	EQU	01000000B
REQ	EQU	10000000B

RUN	EQU	00000000B	; SASI CONTROL COMMANDS
SWRS	EQU	00010000B
INTE	EQU	00100000B
SEL	EQU	01000000B

;
;	GET BASE PORT ADDRESS
;

GETPRT:
	MVI	B,7CH
	IN	GPIO
	ANI	00000011B
	CPI	00000010B
	JZ	GOTPRT
	MVI	B,78H
	IN	GPIO
	ANI	00001100B
	CPI	00001000B
	LXI	H,PRTMSG1
	JNZ	GETPRT1
GOTPRT: MOV	A,B
	STA	BASE$PORT
	MVI	A,RECAL
	STA	CMBFR
	CALL	GETCON
	LXI	H,NOERRCD
        JP      GETPRT1
	JZ	GETPRT1
	LDA	BASE$PORT
	XRI	00000100B	; SWITCH PORT NUMBER
	STA	BASE$PORT
	CALL	GETCON		;  AND TRY AGAIN
	LXI	H,NRDYMSG	; NOT READY IF IT WON'T WORK WITH EITHER PORT
	JNZ	GETPRT1
	LXI	H,PRTMSG2	; MESSAGE FOR WRONG PORT SELECTED
GETPRT1:
	RET

;
;	RESET THE CONTROLLER
;

RESET:
	RET

;
;	INPUT THE SENSE BYTES
;

INSENSE:
	LXI	H,ERSTAT
	MVI	B,4
	LDA	BASE$PORT
	MOV	D,A		; STORE DATA PORT ADDRESS IN REG. D
	INR	A
	MOV	E,A		; CONTROL PORT ADDRESS TO REG. E
INCONT: MOV	C,E		; INPUT FROM CONTROL PORT
	INP	A
	ANI	(REQ  OR MSG OR CMND OR POUT)
	CPI	REQ
	JNZ	INCONT
	MOV	C,D		; INPUT FROM DATA PORT
	INP	A
	MOV	M,A
	INX	H
	DCR	B
	JNZ    INCONT
	RET

;
;      SUBROUTINE TO GET THE BUS' ATTENTION
;

GETCON:
	LDA	BASE$PORT
	MOV	C,A
	INR	C		; CONTROL PORT ADDRESS TO REG. C
	MVI	A,RUN
	OUTP	A		; CLEAR SEL BIT
	MVI	B,0		; TIMER COUNTER
GETCN1: DCR	C		; DATA PORT
	XRA	A
	OUTP	A		; CLEAR DATA REGISTER
	LDA	CNUM		; CONTROLLER NUMBER
	ANI	7
	INR	C
	INR	C		; -SENC- PORT
	OUTP	A
	DCR	C		; CONTROL PORT
	INP	A		; READ CONTROL PORT
	ANI	BUSY
	JZ	GETCN2
	DCR	B
	JNZ	GETCN1
	DCR	B		; RESET PSW/Z TO INDICATE ERROR
	RET
GETCN2: 
	MVI	A,SEL
	OUTP	A		; WAKE UP CONTROLER
	MVI	B,0
GETCN3:
	INP	A
	ANI	BUSY
	JNZ	GETCN4
	DCR	B
	JNZ	GETCN3
	DCR	B		; RESET PSW/Z TO INDICATE ERROR
	RET
GETCN4: 
	MVI	A,RUN
	OUTP	A
	XRA	A		; NO ERROR
	RET

;
;	SUBROUTINE TO OUTPUT A COMMAND TO SASI BUS
;

OUTCOM:
	LXI	H,CMBFR 	; SET UP LOGICAL UNIT NUMBER
OUTCM0: INX	H
	MOV	A,M
	ANI	00011111B
	MOV	M,A
	LDA	LUN
	ANI	00000111B
	RRC
	RRC
	RRC
	ORA	M
	MOV	M,A
	DCX	H
	MVI	B,6		; COMMAND IS 6 BYTES LONG
	MVI	E,(REQ OR CMND OR POUT OR BUSY)
	CALL	OUTBYTES
	RET

;	SENDS THE INITIALIZATIONS BYTES TO XEBEC CONTROLLER

OUTINIT:
	LXI	H,BUFFER+DDATA	; DRIVE CHARACTERISITICS DATA
	MVI	B,8
	MVI	E,(REQ OR POUT OR BUSY)
	CALL	OUTBYTES
	RET

;	SEND BYTES, B = NUMBER OF BYTES, E = PORT IMAGE, H = ADDRESS OF STRING

OUTBYTES:
	LDA	BASE$PORT
	MOV	C,A		; AND THE OUTPUT PORT NUMBER
	INR	A
	MOV	D,A		; STORE CONTROL PORT ADDRESS IN REG. D
OUTLOP1:
	PUSH	B
	MVI	B,16		; SET LOOP COUNTER
	MOV	C,D		; CONTROL PORT ADDRESS TO REG. C
OUTLOP: INP	A
	ANI	(REQ OR CMND OR POUT OR BUSY)
	CMP	E
	JZ	OUTOK
	DCR	B
	JNZ	OUTLOP
	DCR	B
	POP	B
	RET
OUTOK:	POP	B		; RETURNS DATA PORT ADDRESS TO REG. C
	OUTI			; OUTPUT COMMAND BYTE
	JNZ	OUTLOP1
	XRA	A
	RET

;
;	SUBROUTINE TO WRITE DATA TO DISK
;

WRITE:	LDA	BASE$PORT
	MOV	C,A		; DATA PORT ADDRESS TO REG. C
WRMORE: INR	C		; INCREMENT TO CONTROL PORT
CKWRIT: INP	A		; FIRST CHECK FOR DRIVE READY
	ANI	(CMND OR BUSY OR REQ OR POUT)
	CPI	(CMND OR BUSY OR REQ)  ; IF POUT DROPS,
	RZ			       ;  WE ARE INTO STATUS PHASE
	ANI	(CMND OR BUSY OR REQ)
	CPI	(BUSY OR REQ)	; WHEN CMND DROPS, SEEK IS COMPLETE, AND WE ARE
	JNZ	CKWRIT		;  READY TO WRITE 1 SECTOR
	DCR	C		; DATA PORT ADDRESS TO REG. C
MORE:	MVI	B,128
	OUTIR
	JMP	WRMORE		; SEE IF THERE'S ANOTHER SECTOR TO READ IN


READ:	LDA	BASE$PORT	; READ IS EXPECTED TO RETURN IN D THE NUMBER
	MOV	C,A		;  OF 128 BYTE RECORDS READ
	LXI	D,0	;1,2,4,8
RDMORE: INR	C
CKREAD: INP	A
	ANI	(CMND OR BUSY OR REQ OR POUT)
	CPI	(CMND OR BUSY OR REQ)
	RZ
	ANI	(CMND OR BUSY OR REQ)
	CPI	(BUSY OR REQ)
	JNZ	CKREAD
	DCR	C
	MVI	B,128
	INX	D	;number of 128 byte sectors in a physical sector
	INIR
	JMP	RDMORE

;
;	SUBROUTINE TO CHECK STATUS OF READ OR WRITE
;

CHK$STAT:
	LXI	H,STAT		; STATUS BUFFER
	LDA	BASE$PORT
	MOV	D,A		; DATA PORT ADDRESS STORED IN REG. D
	INR	A
	MOV	E,A		; CONTROL PORT ADDRESS STORED IN REG. E
	JMP	CHK01
CHKNXT: MOV	C,D		; INPUT FROM DATA PORT
	INP	A
	MOV	M,A		; SAVE IN MEMORY
CHK01:	MOV	C,E		; INPUT FROM CONTROL PORT
	INP	A
	ANI	(MSG OR REQ OR CMND OR POUT)
	CPI	(REQ OR CMND)
	JZ	CHKNXT
	CPI	(MSG OR REQ OR CMND)
	JNZ	CHK01
	MOV	C,D		; INPUT FROM DATA PORT
	INP	A		; GET FINAL BYTE
	MOV	A,M		; AND THROW IT AWAY, GET STATUS
	ANI	03		; EITHER BIT SET IS AN ERROR
	RET

;
;	THIS ROUTINE CHECKS THE STATUS OF A SASI OPERATION AND
;	PRINTS A TICK COUNTER AT APPOX 4 SECOND INTERVALS
;
;	THIS ROUTINE MUST BE ADJUSTED FOR DIFFERENT TYPES OF HARDWARE
;

CHKTIM: 
	LDA	BASE$PORT
	MOV	D,A
	INR	A
	MOV	E,A
				; START OF TIME DEPENDENT ROUTINE
CHKT1:	LXI	H,582-5 	; 4000000us/(14059mc/2.048mhz) - 5 adj
CHKT2:	MVI	B,255		; 10 mc
CHKT3:	MOV	C,E				; 4 mc
	INP	A				; 12 mc
	ANI	(REQ OR MSG OR CMND OR POUT)	; 7 mc
	CPI	(REQ OR CMND)			; 7 mc
	JZ	CHKT4				; 10 mc
	DCR	B				; 5 mc
	JNZ	CHKT3				; 10 mc  total mc 55  * 255
	DCX	H		; 6 mc
	MOV	A,H		; 4 mc
	ORA	L		; 4 mc
	JNZ	CHKT2		; 10 mc  total mc 34   14059 = (55 * 255) + 34 
	CALL	PRTCNT		; IN INITMAIN.CSM
	JMP	CHKT1

CHKT4:	MOV	C,D		; INPUT FIRST BYTE FROM DATA PORT
	INP	A
	STA	STAT		; SAVE DATA IN MEMORY

CHKT5:	MOV	C,E		; INPUT FROM CONTROL PORT
	INP	A
	ANI	(REQ OR MSG OR CMND OR POUT)
	CPI	(REQ OR MSG OR CMND)
	JNZ	CHKT5		; END OF TRANSMISSION CHECK
	MOV	C,D		; INPUT FROM DATA PORT
	INP	A		; GET FINAL BYTE
	LDA	STAT
	ANI	03
	RET


;
; misc storage
;

CMBFR:	DB	0,0,0,0,0,0
STAT:	DB	0
CNUM:	DB	0
BASE$PORT:
	DB	0
SPT:	DB	0		; SECTORS PER TRACK
LUN:	DB	0

;
; BUFFERS
;

BUFFER: DS	1024		; READ/WRITE BUFFER FOR MAGIC SECTOR
EMTDIR: REPT	1024		; TO CLEAR THE DIRECTORY
	DB	0E5H
	ENDM
 
	ENDFUNCTION		; crl	pseduocode

	END

;
; This function identfies the type of machine DEFSASI3 is configured.
;

	FUNCTION  GETMACH
	LXI	H,MACHTYPE
	RET

MACHTYPE:
	DB	'Z89/Z90',0	; Must be terminated by a zero
	ENDFUNCTION

