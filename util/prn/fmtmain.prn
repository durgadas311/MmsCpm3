 2037 =         vers equ '7 ' ; Oct 24, 2018  01:15  drm  "FMTMAIN.ASM" 
                
                ;
                ; Format main routines
                ;
                ; Link commmand: LINK FORMAT=FMTMAIN,FMTZ89 or FMT500,FMTDISP,FMTTBL[NC,NR]
                ;  Note: FMTMAIN must be linked first and FMTTBL last.
                ;
                
                	public	phydrv,vsectb,sid,trk,modes,mfm,stepr,wdflag,curmdl
                
                	extrn	setjmp,inithd,intoff,inton,table,buffer,str
                	extrn	ctrlio,comnd,writt,rdcom,dskxit,getst
                	extrn	restor,stepin,writrk,rdadr
                	extrn	std8,z47d,vskstd
                	extrn	getchr,putchr,putlne,getlne
                	extrn	clrscr,clrend,clrlne,curact,curoff,cursor,prtmsg
                
                	MACLIB Z80
                	$-MACRO
                
 0000 =         false	equ	000h
 00FF =         true	equ	0FFh
 00FF =         ff	equ	0ffh
                
 0000 =         base	equ	0
 0000 =         cpm	equ	base
 0005 =         bdos	equ	base+5
 0080 =         dma	equ	base+80H
                
 0064 =         @intby	equ	100		; BIOS entry points
 0065 =         lptbl	equ	101
 0067 =         thread	equ	103
 0069 =         ?serdp	equ	105
 000C =         stroff	equ	12		; string address offset from init rout of mod
 0010 =         modtbl	equ	16		; mode byte table offset from init rout of mod
                
 0001 =         resdsk	equ	1		; BIOS function numbers
 0002 =         bconst	equ	2
 0003 =         bconin	equ	3
 0004 =         conout	equ	4
 0008 =         home	equ	8
 0009 =         seldsk	equ	9
 000A =         settrk	equ	10
 000B =         setsec	equ	11
 000C =         setdma	equ	12
 000D =         reads	equ	13
 000E =         writes	equ	14
 0010 =         sectrn	equ	16
 005A =         search	equ	90	      
                
 0001 =         conin	equ	1		; BDOS function numbers
 0002 =         conot	equ	2
 0009 =         msgout	equ	9
 000A =         linein	equ	10
 000C =         getver	equ	12
 0019 =         getdsk	equ	25
 0025 =         restt	equ	37
 002D =         seterr	equ	45
 0032 =         cbios	equ	50
 0064 =         sdirlab equ	100
 006D =         setcmod equ	109
                
                ; error codes
                
 0000 =         initerrcd	equ	0	; can not initialize directory
 0001 =         setlabcd	equ	1	; can not set directory label
 0002 =         wrtprocd	equ	2	; write protected disk
 0003 =         notrdycd	equ	3	; drive not ready
 0004 =         hrdsectcd	equ	4	; hard sector media in soft sector controller
 0005 =         z17sftcd	equ	5	; soft sector media in hard sector controller
 0006 =         notsupcd	equ	6	; format not supported error
 0007 =         badportcd	equ	7	; bad port address for z67/z47
 0008 =         dterrcd 	equ	8	; 96/48 tpi mismatch
 0009 =         trk0ercd	equ	9	; can not find track zero
 000A =         dserrcd 	equ	10	; double sided error
 000B =         drverrcd	equ	11	; invalid drive
 000C =         wterrcd 	equ	12	; error during step/format
 000D =         wmerrcd 	equ	13	; can not write Zenith's marker 
                
 0002 =         brl	equ	2		; base message line
 0003 =         drvl	equ	3		; get drive message line
 0004 =         crl	equ	4		; CONTROLLER ID MESSAGE LINE
 0003 =         drl	equ	3		; LINE OF DRIVE MESSAGE
 0005 =         rdl	equ	5		; LINE OF RECORDING DENSITY
 0006 =         sil	equ	6		; LINE FOR SIDE
 0007 =         tpl	equ	7		; TRACKS-PER-INCH MESSAGE LINE
 0008 =         srl	equ	8		; LINE FOR STEP RATE
 0009 =         fsl	equ	9		; FORMAT SOURCE LINE
 000B =         prl	equ	11		; PROMPT LINE
 000D =         bgl	equ	13		; FIRST LINE USED BY BAR GRAPH
 0013 =         erl	equ	19		; ERROR MESSAGE LINE
 0014 =         mfc	equ	20		; COLUMN OF MODE FORMAT DISPLAY
                
 0083 =         srm0:	equ	10000011b
 001C =         srm1:	equ	00011100b ; search mode masks
                
 001B =         esc	equ	27
 000D =         cr	equ	13
 000A =         lf	equ	10
 0007 =         bell	equ	7
 0008 =         bs	equ	8
 0003 =         ctrlC	equ	3
 0004 =         ctrlD	equ	4
                
                	cseg
                
 0000 C34600    	jmp	start
                
                signon1:
 0003 464F524D41	db	'FORMAT $'
                ; string here, from hardware module.
                signon2:
 000B 2076332E31	db	' v3.10'
 0011 3720      	dw	vers
 0013 2028632920	db	' (c) 1983 Magnolia Microsystems$'
                
 0033           vererr: lspd	save$stack
 0037 11B313    	lxi	d,errver
 003A C30000    errt:	jmp	putlne
                
                nogetdp:
 003D           	lspd	save$stack
 0041 11D413    	lxi	d,nodper
 0044           	jr	errt
                
                start:
 0046           	sspd	save$stack	; store stack pointer
 004A 311619    	lxi	sp,stack
                ;
 004D CD0003    	call	prt$signon
                ;
 0050 0E0C      	mvi	c,getver
 0052 CD0500    	call	bdos
 0055 7C        	mov	a,h
 0056 FE01      	cpi	1	;can't run MP/M
 0058 CA3300    	jz	vererr
 005B 7D        	mov	a,l
 005C FE31      	cpi	31h
 005E DA3300    	jc	vererr		; must be CP/M 3.1 or later.
 0061 2A0100    	lhld	cpm+1
 0064 016600    	lxi	b,?serdp-3	; Check if GETDP is linked in
 0067 09        	dad	b
 0068 CDAD03    	call	hlihl
 006B           	lded	cpm+1
 006F AF        	xra	a		; clear A and [cy]
 0070 5F        	mov	e,a
 0071           	dsbc	d
 0073 CA3D00    	jz	nogetdp
 0076 1EFF      	mvi	e,0ffh		; set error mode to return on error
 0078 0E2D      	mvi	c,seterr
 007A CD0500    	call	bdos
 007D 0E19      	mvi	c,getdsk	; GET DURRENTLY LOGGED IN DISK
 007F CD0500    	call	bdos
 0082 328718    	sta	logdsk
 0085 218000    	lxi	h,dma		; check command tail buffer for drive name
 0088 7E        	mov	a,m
 0089 B7        	ora	a
 008A CABE01    	jz	nodsk		; print help msg
 008D 229218    entry0: shld	cmdptr
 0090 CD1603    	call	get$drive	; check for drive name and select it
 0093 C2BE02    	jnz	new$drive
 0096 DAD801    	jc	error		; error if drive does not exist
 0099 CD0000    entry1: call	setjmp		; Set hardware dependent jump vector
 009C DAD801    	jc	error
 009F 21D218    	lxi	h,orgmode
 00A2 11CA18    	lxi	d,modes
 00A5 010400    	lxi	b,4
 00A8           	ldir
 00AA 3ACC18    	lda	modes+2 	; Make media tpi same as drive tpi
 00AD E620      	ani	0010$0000b
 00AF 6F        	mov	l,a
 00B0 3ACD18    	lda	modes+3
 00B3 E6DF      	ani	1101$1111b
 00B5 B5        	ora	l
 00B6 32CD18    	sta	modes+3
 00B9 CDB503    entry2: call	parse
 00BC D2C500    	jnc	parm
 00BF 114110    	lxi	d,invp
 00C2 C36A01    	jmp	err$parm
 00C5 CD0306    parm:	call	show
 00C8 210B00    	lxi	h,prl
 00CB CD0000    	call	cursor
 00CE CD0000    	call	clrend
 00D1 210B00    	lxi	h,prl
 00D4 112914    	lxi	d,askok 	; IS THIS CORRECT? (Y/N)
 00D7 CD0000    	call	prtmsg
 00DA 0E01      	mvi	c,1		; GET RESPONSE
 00DC CD0500    	call	bdos
 00DF E6DF      	ani	0DFh		; MAKE CAPITAL
 00E1 FE59      	cpi	'Y'
 00E3 CAF300    	jz	got$parm	; IF 'Y', RETURN
 00E6 FE0D      	cpi	cr		; DEFAULT IS 'Y'
 00E8 CAF300    	jz	got$parm
 00EB FE03      	cpi	ctrlC		; ^C
 00ED CAE902    	jz	exit
 00F0 C37B01    	jmp	new$parm	; user wants to change params
                got$parm:
                
                ; From this point on, any possible exit from this program must restore
                ; the DPB and MODES to the system.
 00F3 CD0A07    	call	start$dsk
                err$over:
 00F6 CD3907    	call	setup
 00F9 DAD801    	jc	error 
                next$dsk:
 00FC 210B00    	lxi	h,prl
 00FF 116513    	lxi	d,prmt
 0102 CD0000    	call	prtmsg		; prompt to insert a disk...
 0105 CD0000    	call	getchr
 0108 FE04      	cpi	ctrlD
 010A CAB802    	jz	new$fix 	; restore system DPs and prompt for new drive
 010D FE0D      	cpi	cr
 010F C2E602    	jnz	exit$fix	; anything except CR exits to CP/M
 0112 CD1707    	call	log$off		; prepare drive for unformatted access
 0115 210C00    	lxi	h,prl+1
 0118 CD0000    	call	cursor
 011B CD0000    	call	clrend
 011E CD0000    	call	inithd		; initialize hardware dependent varibles,etc.
 0121 CDEF09    	call	image$t0s0	;
 0124 CD0000    	call	restor		; restore drive
 0127 CD0000    	call	getst		; check for drive ready, track zero, etc.
 012A 07        	rlc			; (A) = status from 1797
 012B DA1A02    	jc	not$rdy 	; check for drive ready
 012E 07        	rlc
 012F DA1402    	jc	wrt$pro 	; check for write-protected disk
 0132 E610      	ani	00010000b
 0134 CA3202    	jz	trk0err 	; verify that we made it to track 0
 0137 CD9808    	call	testdt		; do double track test
 013A DAD801    	jc	error
                continue:			; entry from dt error if Ignore option
 013D CDD108    	call	format
 0140 DAD801    	jc	error
 0143 CDA90B    	call	verify		; calls log$on, *always*
 0146 DAD801    	jc	error
 0149 CD0000    	call	curact		; turn cursor back on
 014C CD790E    	call	display$count	; display disk count
 014F 211600    	lxi	h,22
 0152 11FC12    	lxi	d,mormed
 0155 CD0000    	call	prtmsg		; ask if more media to format
 0158 CD0000    	call	getchr
 015B E6DF      	ani	0DFH		; make response capital
 015D FE59      	cpi	'Y'
 015F CAFC00    	jz	next$dsk
 0162 FE0D      	cpi	cr
 0164 C2E602    	jnz	exit$fix	; if not Y or CR, quit
 0167 C3FC00    	jmp	next$dsk	; prompt for another disk(but don't do DT test)
                
                ;
                ;	Gets new parmeters and/or drive from console
                ;	D reg = error msg to be printed
                ;
                
                err$parm:
 016A 210B00    	lxi	h,prl
 016D CD0000    	call	cursor
 0170 CD0000    	call	clrend
 0173 210B00    	lxi	h,prl
 0176 CD0000    	call	prtmsg
 0179           	jr	new$parm2
                
                new$parm:
 017B 210B00    	lxi	h,prl
 017E CD0000    	call	cursor
 0181 CD0000    	call	clrend
                new$parm2:
 0184 210C00    	lxi	h,prl+1
 0187 111F10    	lxi	d,parprm
 018A CD0000    	call	prtmsg
 018D 210E00    	lxi	h,prl+3
 0190 11DD15    	lxi	d,valid
 0193 CD0000    	call	prtmsg		; show valid parmeters
 0196 210C21    	lxi	h,256*33+PRL+1	; restore cursor
 0199 CD0000    	call	cursor
 019C 116918    	lxi	d,line
 019F CD0000    	call	getlne		; linein, W/OUT ^C reboot
 01A2 216B18    	lxi	h,line+2
 01A5 7E        	mov	a,m
 01A6 FE03      	cpi	ctrlC
 01A8 CAE902    	jz	exit		; exit on ctrl-C
 01AB 2B        	dcx	h
 01AC 229218    	shld	cmdptr
 01AF CD1603    	call	get$drive	; sets SYSDPB/ORGMODES
 01B2 C2B900    	jnz	entry2		; if no drive in parms, use old mode bytes
 01B5 11B210    	lxi	d,dr$err
 01B8 DA6A01    	jc	err$parm	; if error display message and repeat new$parm
 01BB C39900    	jmp	entry1		; if a drive letter in line, copy orig modes
                
                ;
                ;	Output help message and exit
                ;
                
 01BE 11A214    nodsk:	lxi	d,help
 01C1 CD0000    	call	putlne
 01C4 115D17    	lxi	d,thisut	; other info
 01C7 CD0000    	call	putlne
 01CA CD0000    	call	getchr
 01CD FE03      	cpi	ctrlC		; ^C
 01CF CAE902    	jz	exit		; reboot on ^C
 01D2 CD0003    	call	prt$signon
 01D5 C3BE02    	jmp	new$drive
                
                ;
                ;	Error routines -  
                ;	 A reg contains the error code
                ;
                
                error:
 01D8           	slar	a		;double A
 01DA 21E601    	lxi	h,errtbl
 01DD 5F        	mov	e,a
 01DE 1600      	mvi	d,0
 01E0 19        	dad	d
 01E1 5E        	mov	e,m
 01E2 23        	inx	h
 01E3 56        	mov	d,m
 01E4 EB        	xchg
 01E5 E9        	pchl
                
 01E6 0202      errtbl: dw	initer		;0
 01E8 0802      	dw	setlaber	;1
 01EA 1402      	dw	wrt$pro 	;2
 01EC 1A02      	dw	not$rdy 	;3
 01EE 2002      	dw	hrd$sect	;4
 01F0 2602      	dw	z17$sft 	;5
 01F2 4402      	dw	not$sup 	;6
 01F4 4A02      	dw	bad$port	;7
 01F6 5602      	dw	dterr		;8
 01F8 3202      	dw	trk0err 	;9 
 01FA 9902      	dw	dserr		;10
 01FC 5002      	dw	drv$err 	;11
 01FE 2C02      	dw	wterr0		;12
 0200 0E02      	dw	wmer		;13
                
                initer:
 0202 11C312    	lxi	d,initerr
 0205 C33502    	jmp	errms
                
                setlaber:
 0208 118D12    	lxi	d,slaberr
 020B C33502    	jmp	errms
                
                wmer:
 020E 116B12    	lxi	d,wmerr
 0211 C33502    	jmp	errms
                
                wrt$pro:
 0214 11C810    	lxi	d,wr$pt 	; disk is write-protected
 0217 C33502    	jmp	errms
                
                not$rdy:
 021A 11E610    	lxi	d,nt$rd 	; drive is not ready (disk not in drive)
 021D C33502    	jmp	errms
                
                hrd$sect:
 0220 118A11    	lxi	d,h$sec
 0223 C33502    	jmp	errms
                
 0226 11C311    z17sft: lxi	d,s$z17
 0229 C33502    	jmp	errms
                
 022C 111611    wterr0: lxi	d,wterr
 022F C33502    	jmp	errms
                
                trk0err:
 0232 119910    	lxi	d,hm$err	; error: track zero not found
                
 0235 CD0000    errms:	call	curact		; turn on cursor
 0238 211300    	lxi	h,erl
 023B CD0000    	call	prtmsg
 023E CD0000    	call	dskxit
 0241 C3F600    	jmp	err$over
                
 0244 114F11    notsup: lxi	d,nosup
 0247 C39C02    	jmp	err$fix 	; ask for correct format
                
                badport:
 024A 116511    	lxi	d,badprt
 024D C3A402    	jmp	err$drive
                
                drv$err:
 0250 11B210    	lxi	d,dr$err
 0253 C3A402    	jmp	err$drive
                
                dterr:
 0256 2ACC18    	lhld	modes+2
 0259           	bit	5,h		; test track bit
 025B 213438    	lxi	h,'48'		; assume requested 48tpi
 025E 113936    	lxi	d,'96'		; but drive was 96 tpi
 0261           	jrz	q1
 0263 EB        	xchg			; if not, request was 96, etc.
 0264 44        q1:	mov	b,h
 0265 4D        	mov	c,l
 0266 210B12    	lxi	h,gap1		;point to "requested" field
 0269 71        	mov	m,c		;put tpi in message
 026A 23        	inx	h
 026B 70        	mov	m,b
 026C 211712    	lxi	h,gap2		;point to "drive was" field
 026F 73        	mov	m,e
 0270 23        	inx	h
 0271 72        	mov	m,d		; move alternate track density
 0272 210B00    	lxi	h,prl
 0275 11FC11    	lxi	d,dter
 0278 CD0000    	call	prtmsg
 027B CD0000    	call	clrlne		; clear rest of line
 027E CD0000    	call	dskxit
 0281 CD0000    	call	getchr		; get user response
 0284 FE03      	cpi	ctrlC
 0286 CAE602    	jz	exit$fix 
 0289 E6DF      	ani	0DFh		; make capital
 028B FE49      	cpi	'I'
 028D CA3D01    	jz	continue	
 0290 CDF70E    	call	done$dsk	; fix module
 0293 210D00    	lxi	h,prl+2
 0296 C3CA02    	jmp	new$drive2
                
                dserr:
 0299 114612    	lxi	d,dser
                
                err$fix:			; fix module, print error and get new drive
 029C D5        	push	d		 
 029D CD0000    	call	dskxit		; hardware disk exit
 02A0 CDF70E    	call	done$dsk
 02A3 D1        	pop	d
                err$drive:			; print error and get new drive and parms
 02A4 210200    	lxi	h,brl
 02A7 CD0000    	call	cursor
 02AA CD0000    	call	clrend
 02AD 210200    	lxi	h,drvl-1
 02B0 CD0000    	call	prtmsg
 02B3 210300    	lxi	h,drvl
 02B6           	jr	newdrive2
                
                new$fix:			; fixes module and mode bytes
 02B8 CD0000    	call	dskxit
 02BB CDF70E    	call	done$dsk
                new$drive:			; get a new drive letter
 02BE 210200    	lxi	h,brl
 02C1 CD0000    	call	cursor
 02C4 CD0000    	call	clrend
 02C7 210300    	lxi	h,drvl
                new$drive2:
 02CA 11F90F    	lxi	d,ndsk		; prompt for user to enter drive name
 02CD CD0000    	call	prtmsg
 02D0 CD0000    	call	curact		; turn cursor on
 02D3 116918    	lxi	d,line
 02D6 CD0000    	call	getlne
 02D9 216B18    	lxi	h,line+2
 02DC 7E        	mov	a,m
 02DD FE03      	cpi	ctrlC
 02DF CAE902    	jz	exit
 02E2 2B        	dcx	h
 02E3 C38D00    	jmp	entry0
                
                ;
                ;	Exits to the program
                ;
                
                exit$fix:
 02E6 CDF70E    	call	done$dsk	; fix what start$dsk did
                exit:	
 02E9 211600    	lxi	h,22		; position cursor to 23rd line
 02EC CD0000    	call	cursor
 02EF CD0000    	call	curact		; turn cursor on
 02F2 3A8718    	lda	logdsk		; re-select LOGIN drive
 02F5 4F        	mov	c,a
 02F6 1E00      	mvi	e,0
 02F8 3E09      	mvi	a,seldsk
 02FA CD2E0F    	call	biosc
                ;
 02FD C30000    	jmp	cpm		; return to system
                
                
                *******************************************************************************
                ; Subroutines 
                *******************************************************************************
                
                prt$signon:
 0300 CD0000    	call	clrscr
 0303 110300    	lxi	d,signon1
 0306 CD0000    	call	putlne
 0309 110000    	lxi	d,str
 030C CD0000    	call	putlne
 030F 110B00    	lxi	d,signon2
 0312 CD0000    	call	putlne
 0315 C9        	ret
                       
                ;
                ; GET$DRIVE:  parses command line for optional drive name. returns:
                ;    [NZ] if no drive name was specified
                ;    [CY] if the specified drive was invalid (not in system)
                ;
                
                get$drive:
 0316 2A9218    	lhld	cmdptr
 0319 46        	mov	b,m
 031A 23        	inx	h
 031B CDF305    skp:	call	xchar		; SKIP OVER SPACES
 031E FAA403    	jm	nzcy
 0321 FE20      	cpi	' '
 0323 CA1B03    	jz	skp
 0326 FE41      	cpi	'A'		; ERROR IF NOT A-P
 0328 DAA403    	jc	nzcy
 032B FE51      	cpi	'P'+1
 032D D2A403    	jnc	nzcy
 0330 4F        	mov	c,a
 0331 CDF305    	call	xchar
 0334 FAA403    	jm	nzcy
 0337 FE3A      	cpi	':'		; ERROR IF NO ":"
 0339 C2A403    	jnz	nzcy
 033C 79        	mov	a,c
 033D 2B        	dcx	h
 033E 70        	mov	m,b
 033F 229218    	shld	cmdptr
 0342 32B518    	sta	tdrv
 0345 D641      	sui	'A'
 0347 4F        	mov	c,a
 0348 2A0100    	lhld	cpm+1		; LOOK UP PHYSICAL DRIVE NUMBER
 034B 116200    	lxi	d,lptbl-3	;  IN LOGICAL/PHYSICAL TABLE
 034E 19        	dad	d
 034F CDAD03    	call	hlihl
 0352 59        	mov	e,c
 0353 1600      	mvi	d,0
 0355 19        	dad	d
 0356 7E        	mov	a,m
 0357 32B418    	sta	tphy	       ; GOT PHYSICAL DRIVE NUMBER
 035A FEFF      	cpi	0ffh
 035C CAA803    	jz	zrcy
 035F 4F        	mov	c,a
 0360 2A0100    	lhld	cpm+1		; call search routine
 0363 115700    	lxi	d,search-3
 0366 19        	dad	d
 0367 CDB403    	call	icall		; returns module address
 036A DAA803    	jc	zrcy		; and relative drive number
 036D 4F        	mov	c,a		; save reldrv in C
 036E E5        	push	h		; save curmdl
 036F 111000    	lxi	d,modtbl	 
 0372 19        	dad	d
 0373 CDAD03    	call	hlihl		; get address of mode byte table
 0376 87        	add	a
 0377 87        	add	a
 0378 87        	add	a
 0379 5F        	mov	e,a
 037A 1600      	mvi	d,0
 037C 19        	dad	d		; index relative drive
 037D           	bit	7,m		; check for hard disk flag
 037F D1        	pop	d		; restore curmdl to D
 0380 C2A803    	jnz	zrcy
 0383 22B918    	shld	modptr
 0386 79        	mov	a,c		; store reldrv
 0387 328618    	sta	reldrv		 
 038A           	sded	curmdl
 038E 3AB418    	lda	tphy
 0391 32B318    	sta	phydrv
 0394 3AB518    	lda	tdrv
 0397 328013    	sta	drive
 039A 11D218    	lxi	d,orgmode
 039D 010400    	lxi	b,4
 03A0           	ldir
 03A2 AF        	xra	a 
 03A3 C9        	ret
                
 03A4 AF        nzcy:	xra	a		; No drive specfied exit
 03A5 3C        	inr	a
 03A6 37        	stc
 03A7 C9        	ret
                
 03A8 AF        zrcy:	xra	a		; Invalid drive exit
 03A9 3E0B      	mvi	a,drverrcd
 03AB 37        	stc
 03AC C9        	ret
                
 03AD F5        hlihl:	push	psw
 03AE 7E        	mov	a,m
 03AF 23        	inx	h
 03B0 66        	mov	h,m
 03B1 6F        	mov	l,a
 03B2 F1        	pop	psw
 03B3 C9        	ret
                
 03B4 E9        icall:	pchl
                
                ;
                ; Parse command line for mode info, if present.  Enter with current mode
                ; value in MODES, pointer to command string in CMDPTR
                ;
                
                PARSE:
 03B5 3E00      	MVI	A,FALSE
 03B7 328918    	STA	TRCK
 03BA 328A18    	STA	SDE
 03BD 328B18    	STA	DENSITY
 03C0 328818    	STA	CNFIG
 03C3 328C18    	STA	STEPRT
 03C6 3A8218    	LDA	VFLAG0
 03C9 328318    	STA	VFLAG
 03CC 21CA18    	LXI	H,MODES
 03CF 11CE18    	LXI	D,TMODE
 03D2 010400    	LXI	B,4
 03D5           	LDIR
 03D7 2A9218    	LHLD	CMDPTR		; number of characters input
 03DA 4E        	MOV	C,M
 03DB 23        	INX	H
 03DC 0600      	MVI	B,0
 03DE 09        	DAD	B
 03DF 3600      	MVI	M,0
 03E1 79        	MOV	A,C
 03E2 B7        	ORA	A
 03E3 CA9B05    	JZ	NOCOMD
 03E6 2A9218    	LHLD	CMDPTR
 03E9 23        SKPBL:	INX	H
 03EA CDF905    NXOPT:	CALL	CHAR		; get a character for the loop
 03ED FE20      	CPI	' '
 03EF CAE903    	JZ	SKPBL
 03F2 FE2C      	CPI	','
 03F4 CAE903    	JZ	SKPBL
 03F7 FE44      	CPI	'D'		; check for 'D' command
 03F9 CA5D04    	JZ	DPROC
 03FC FE53      	CPI	'S'		; check for step rate
 03FE CA8E04    	JZ	STEP
 0401 FE4E      	CPI	'N'		; check of nv, ns, or ni options
 0403 CACF04    	JZ	N$opts
 0406 E5        	push	h	
 0407 CDDD05    	call	serdp	
 040A E5        	push	h
 040B           	popix		; ix = address of format string table
 040D E1        	pop	h	; hl = buffer pointer
 040E 0E00      	MVI	C,0	; c = format bit number counter
 0410 0608      CONFIG: mvi	b,8	; b = length of entry in format string table
 0412 E5        	PUSH	h
 0413 79        	mov	a,c
 0414 FE0F      	CPI	15	; if c = 15 then end of table
 0416 CAD805    	jz	nochg	;NMEMONIC NOT FOUND
 0419           fig0:	ldx	d,+0
 041C CDF905    	call	char	; get char from buffer and make upper case
 041F BA        	CMP	d	; compare with serdp table
 0420 C25404    	JNZ	FIG1
 0423 23        	INX	H
 0424           	inxix
 0426 05        	dcr	b
 0427 CA3204    	jz	fig5
 042A           	ldx	a,+0	; see if end of format table
 042D FE20      	CPI	' '
 042F C21904    	JNZ	FIG0
 0432 CDF905    fig5:	call	char
 0435 B7        	ORA	A
 0436 CA4304    	JZ	FIG2
 0439 FE2C      	CPI	','
 043B CA4304    	JZ	FIG2
 043E FE20      	CPI	' '
 0440 C25404    	JNZ	FIG1
 0443 D1        FIG2:	POP	d	;DISCARD OLD BUFFER POINTER
 0444 3A8818    	LDA	CNFIG
 0447 B7        	ORA	A	;IS THIS THE SECOND ENTRY OF THIS TYPE?
 0448 C2D905    	JNZ	BADCMD	;ERROR IF IT IS.
 044B 79        	MOV	A,C
 044C C630      	ADI	'0'
 044E 328818    	STA	CNFIG
 0451 C3ED04    	JMP	MORE
                
 0454           FIG1:	inxix		;go to end of format string table
 0456           	djnz	FIG1
 0458 E1        FIN3:	pop	h
 0459 0C        	inr	c		; and increment the entry counter
 045A C31004    	jmp	config
                
                SPROC:	
 045D CDF905    DPROC:	CALL	CHAR
 0460 4F        	MOV	C,A
 0461 23        	INX	H		; save SINGLE or DOUBLE
 0462 CDF905    	CALL	CHAR		; get the character
 0465 23        	INX	H
 0466 B7        	ORA	A
 0467 CAD905    	JZ	BADCMD
 046A FE54      	CPI	'T'
 046C CA8704    	JZ	TRK000
 046F FE44      	CPI	'D'
 0471 CA8004    	JZ	DNS
 0474 FE53      	CPI	'S'
 0476 C2D905    	JNZ	BADCMD
 0479 79        	MOV	A,C		; get the argument
 047A 328A18    	STA	SDE
 047D C3ED04    	JMP	MORE
 0480 79        DNS:	MOV	A,C		; get the argument
 0481 328B18    	STA	DENSITY
 0484 C3ED04    	JMP	MORE
 0487 79        TRK000: MOV	A,C
 0488 328918    	STA	TRCK
 048B C3ED04    	JMP	MORE
                
 048E 23        STEP:	INX	H
 048F CDF905    	CALL	CHAR		; test next argument
 0492 2B        	DCX	H
 0493 FE30      	CPI	'0'		; must be numeric
 0495 DAD905    	JC	BADCMD		; ERROR IF < '0'
 0498 FE3A      	CPI	'9'+1
 049A D25D04    	JNC	SPROC		;TRY 'SINGLE'
 049D 23        	INX	H
 049E 23        	INX	H
 049F D630      	SUI	'0'		; make it numeric
 04A1 4F        	MOV	C,A		; and save it
 04A2 CDF905    	CALL	CHAR	;test next, it must be a number, a comma, or null
 04A5 B7        	ORA	A		; we accept spaces also
 04A6 CAC804    	JZ	SOK
 04A9 FE2C      	CPI	','
 04AB CAC804    	JZ	SOK
 04AE FE20      	CPI	' '
 04B0 CAC804    	JZ	SOK
 04B3 FE30      	CPI	'0'
 04B5 DAD905    	JC	BADCMD
 04B8 FE3A      	CPI	'9'+1
 04BA D2D905    	JNC	BADCMD
 04BD 23        	INX	H
 04BE D630      	SUI	'0'		; numeric, make it binary
 04C0 5F        	MOV	E,A		; and save it
 04C1 79        	MOV	A,C		; get first number
 04C2 87        	ADD	A
 04C3 87        	ADD	A
 04C4 81        	ADD	C
 04C5 87        	ADD	A		; TIMES 10
 04C6 83        	ADD	E		; plus second number
 04C7 4F        	MOV	C,A		; expected in C
 04C8 79        SOK:	MOV	A,C		; get step rate
 04C9 328C18    	STA	STEPRT		; and save it
 04CC C3ED04    	JMP	MORE
                
 04CF 23        N$opts: INX	H		; FIRST CHARACTER IS 'N'
 04D0 CDF905    	CALL	CHAR		; GET NEXT CHARACTER
 04D3 23        	INX	H
 04D4 FE49      	cpi	'I'		; turn off directory initialization
 04D6           	jrnz	not$I		; and set label
 04D8 3EFF      inoff:	mvi	a,0ffh
 04DA 32AB18    	sta	initflg
 04DD           	jr	more
 04DF FE53      not$I:	cpi	'S'		; turn off directory initialization
 04E1           	jrz	inoff
 04E3 FE56      not$S:	CPI	'V'		; NEXT CHARACTER MUST BE A 'V'
 04E5 C2D905    	JNZ	BADCMD
 04E8 3E00      	MVI	A,FALSE 	; SET VERIFICATION FLAG TO FALSE
 04EA 328318    	STA	VFLAG
                
 04ED CDF905    MORE:	CALL	CHAR		; point to next character and get it
 04F0 23        	INX	H
 04F1 FE2C      	CPI	','		; continue if a comma
 04F3 CAEA03    	JZ	NXOPT
 04F6 FE20      	CPI	' '		; or a space
 04F8 CAEA03    	JZ	NXOPT
 04FB B7        	ORA	A		; if a null, it's OK too
 04FC C2D905    	JNZ	BADCMD		; if not, it's an error
                ;
                ;	update the present mode value
                ;
 04FF           	lxix	tmode
 0503 3A8818    	LDA	CNFIG		; see if configuration was specified
 0506 B7        	ORA	A
 0507 CA1C05    	JZ	BIT1
 050A D630      	sui	'0'	;make it binary 0,1,2...
 050C 210100    	lxi	h,00000000$00000001b
 050F 3C        	inr	a
 0510 3D        gc1:	dcr	a
 0511           	jrz	gc0
 0513 29        	dad	h
 0514           	jr	gc1
                GC0:
 0516           	stx	H,+0
 0519           	stx	L,+1
                BIT1:
 051C 3A8A18    	LDA	sde		; see if side was specified
 051F B7        	ORA	A
 0520 CA3205    	JZ	BIT3
 0523           	resx	6,+3		; clear the side bit
 0527 2F        	CMA
 0528 E601      	ANI	1		; mask the lsb
 052A 0F        	RRC
 052B 0F        	RRC			; to bit 6
 052C           	orax	+3		; into the mode byte
 052F           	stx	a,+3		; and update the byte
 0532 3A8B18    BIT3:	LDA	DENSITY 	; see if density was specified
 0535 B7        	ORA	A
 0536 CA4A05    	JZ	BIT4
 0539           	resx	4,+3		; clear density bit
 053D 2F        	CMA
 053E E601      	ANI	1
 0540 0F        	RRC
 0541 0F        	RRC
 0542 0F        	rrc
 0543 0F        	rrc			; to bit 4
 0544           	orax	+3		; mask the bit
 0547           	stx	a,+3		; and save it in memory
 054A 3A8918    BIT4:	LDA	trck 
 054D B7        	ORA	A
 054E CA6705    	JZ	BIT5
 0551 FE53      	cpi	'S'
 0553           	jrz	sst 
 0555           	setx	5,+3	;
 0559           	SETX	5,+2
 055D           	jr	bit5
 055F           SST:	resx	5,+3
 0563           	RESX	5,+2
 0567 3A8C18    BIT5:	LDA	STEPRT		; get the requested step rate
 056A B7        	ORA	A		; see if user specified one
 056B CA9B05    	JZ	BIT6
 056E           	bitx	7,+2		; size, 5.25 or 8
 0572 219817    	LXI	H,STEPTB
 0575 110400    	LXI	D,4		; table is 4 bytes long
 0578 CA7C05    	JZ	FIVE
 057B 19        	DAD	D		; add offset
 057C 0600      FIVE:	MVI	B,0		; initial step rate
 057E BE        NXRT:	CMP	M		; compare request with table
 057F DA8A05    	JC	GSRT		; memory is greater, this is it
 0582 23        	INX	H
 0583 04        	INR	B
 0584 1D        	DCR	E
 0585 C27E05    	JNZ	NXRT
 0588 0603      	MVI	B,3		; in case of overflow
 058A 78        GSRT:	MOV	A,B		; step rate mask
 058B           	resx	2,+2
 058F           	resx	3,+2		; clear bits
 0593 07        	rlc
 0594 07        	rlc
 0595           	orax	+2		; and update mode value
 0598           	stx	a,+2
                BIT6:	
 059B CDDD05    nocomd: call	serdp
 059E B7        	ORA	A
 059F C2D905    	JNZ	badcmd		; error if non-zero (NO DPB FOUND)
 05A2           	sbcd	sectbl		; save x-late table pointer
 05A6           	sded	sysdpb		; save dpb pointer
 05AA 2AB918    	LHLD	MODPTR		; check if mode-mask prevent user's selection
 05AD 23        	INX	H
 05AE 23        	INX	H
 05AF 23        	INX	H
 05B0 23        	inx	h
 05B1 EB        	XCHG			;DE = mode byte mask pointer
 05B2 21CE18    	LXI	H,TMODE
 05B5 01CA18    	LXI	B,MODES
 05B8 3E04      	MVI	A,4	;NUMBER OF MODE BYTES
 05BA F5        ANOTHR: PUSH	PSW		; save the counter
 05BB 0A        	LDAX	B		; get old mode byte
 05BC AE        	XRA	M		; set bit for values changed
 05BD EB        	XCHG
 05BE A6        	ANA	M		; check for changed bytes
 05BF EB        	XCHG
 05C0 C2D805    	JNZ	NOCHG		; error if non zero
 05C3 13        	INX	D
 05C4 03        	INX	B
 05C5 23        	INX	H		; point to the next byte
 05C6 F1        	POP	PSW		; get counter
 05C7 3D        	DCR	A		; and decrement it
 05C8 C2BA05    	JNZ	ANOTHR
 05CB 21CE18    	LXI	H,TMODE
 05CE 11CA18    	LXI	D,MODES
 05D1 010400    	LXI	B,4
 05D4           	LDIR
 05D6 AF        	XRA	A
 05D7 C9        	RET			; and return
                
 05D8 F1        NOCHG:	POP	PSW
 05D9 AF        BADCMD: XRA	A
 05DA 3C        	INR	A		; set [NZ] flag
 05DB 37        	STC
 05DC C9        	RET	;[NZ] [CY] IF ERROR
                 
                
 05DD 11CE18    serdp	LXI	D,tmode 	; MODE BYTE POINTER TO DE
 05E0 2A0100    	LHLD	CPM+1		; call serdp
 05E3 016600    	LXI	B,?SERDP-3
 05E6 09        	DAD	B		; POINTER TO SERDP CALL ADDRESS
 05E7 CDAD03    	CALL	HLIHL		; GET CALL ADDRESS
 05EA E5        	push	h
 05EB CDB403    	CALL	ICALL		; CALL "GETDP" TO FIND A DPB FOR THIS MODE
 05EE EB        	xchg			; hl <> de  table offset to de - dpb ptr to hl
 05EF E3        	xthl			; hl <> tos dpb ptr to tos - serdp addr to hl
 05F0 19        	dad	d		; format string table - add serdp addr & offset
 05F1 D1        	pop	d		; restore de to dpb pointer
 05F2 C9        	ret		
                
                ;
                ;	Gets a character from the buffer and points to next character
                ;
                
 05F3 CDF905    xchar:	call	char
 05F6 23        	inx	h
 05F7 05        	dcr	b
 05F8 C9        	ret
                
                ;
                ;	Gets a character from the buffer and makes upper case
                ;
                
 05F9 7E        char:	mov	a,m		; remove a character from buffer
 05FA FE61      	cpi	'a'
 05FC D8        	rc
 05FD FE7B      	cpi	'z'+1
 05FF D0        	rnc
 0600 D620      	sui	'a'-'A'
 0602 C9        	ret
                
                ;
                ;	output the mode data to the CRT
                ;
                
                SHOW:	
 0603 210200    	lxi	h,brl		; clear rest of screen
 0606 CD0000    	call	cursor
 0609 CD0000    	call	clrend
 060C 210200    	lxi	h,brl
 060F 114C0F    	lxi	d,basmsg	; POSITION THE MODE INFO
 0612 CD0000    	call	prtmsg
 0615 3AB318    	LDA	PHYDRV		;  get physical drive number
 0618 010000    	LXI	B,0		;  tens counter in C and ones in B
 061B 0C        MORTEN: INR	C
 061C D60A      	SUI	10
 061E CA2806    	JZ	GOTNUM
 0621 F21B06    	JP	MORTEN
 0624 0D        	DCR	C
 0625 C60A      	ADI	10
 0627 47        	MOV	B,A
 0628 213030    GOTNUM: LXI	H,'00'		;  numeric offset to ASCII
 062B 09        	DAD	B
 062C 7D        	MOV	A,L		;  tens digit
 062D FE30      	CPI	'0'		;  check for zero
 062F C23406    	JNZ	NOZE
 0632 3E20      	MVI	A,' '		;  if so, replace with a space
 0634 6F        NOZE:	MOV	L,A
 0635 229A14    	SHLD	DSKNM
 0638 3A8013    	LDA	DRIVE		;  get drive letter
 063B 119614    	lxi	d,dsklt
 063E 12        	stax	d		;  put in string
 063F 210314    	lxi	h,mfc*256+drl
 0642 CD0000    	call	prtmsg
 0645           	LXIX	MODES
 0649           	BITX	7,+2		;  size, 0=5" and 1=8"
 064D 114F14    	LXI	D,INCH5
 0650 CA5606    	JZ	PRINCH
 0653 116014    	LXI	D,INCH8
 0656 CD0000    PRINCH: call	putlne
 0659 CDFF06    	call	getstr
 065C 210414    	lxi	h,mfc*256+crl
 065F CD0000    	call	prtmsg
 0662           	BITX	6,+3		;  check the side bit
 0666 CA6F06    	JZ	SS		;  single sided if zero
 0669 117014    	LXI	D,DSMSG 	;  double sided drive message
 066C C37206    	JMP	DDS
 066F 116E14    SS:	LXI	D,SSMSG 	;  single sided drive message
 0672 210614    DDS:	lxi	h,mfc*256+sil
 0675 CD0000    	call	prtmsg
 0678           	BITX	4,+3
 067C CA8506    	JZ	SD		;  single density if zero
 067F 117914    	LXI	D,DDMSG 	;  double density drive message
 0682 C38806    	JMP	DD
 0685 117214    SD:	LXI	D,SDMSG 	;  single density drive message
 0688 210514    DD:	lxi	h,mfc*256+rdl
 068B CD0000    	call	prtmsg
 068E           	BITX	5,+3		;  mask out track density
 0692 CA9B06    	JZ	T48		;  48 tpi if zero
 0695 118314    	LXI	D,T96MSG	; 96 tpi message
 0698 C39E06    	JMP	HTRK
 069B 118014    T48:	LXI	D,T48MSG	; 48 tpi message
 069E 210714    HTRK:	lxi	h,mfc*256+tpl
 06A1 CD0000    	call	prtmsg
 06A4 CDD706    	call	setcn		;  handle configuration
 06A7           	ldx	a,+2		;  GET STEPRATE BYTE
 06AA E60C      	ani	00001100B
 06AC 0F        	rrc
 06AD 0F        	rrc			; move steprate bits down
 06AE           	bitx	7,+2
 06B2 CAB706    	jz	sr5
 06B5 F604      	ori	00000100b	; or in 8" bit
 06B7 218817    sr5:	LXI	H,STRTBL	; step rate table
 06BA 87        	ADD	A		;  two bytes per entry
 06BB 5F        	MOV	E,A
 06BC 1600      	MVI	D,0		;  16 bit value for offset
 06BE 19        	DAD	D
 06BF 5E        	MOV	E,M		;  first byte of step rate
 06C0 23        	INX	H
 06C1 56        	MOV	D,M		;  and the second
 06C2 EB        	XCHG
 06C3 228614    	SHLD	STRATE		;  save text in message
 06C6 118614    	LXI	D,STRATE	; step rate message
 06C9 1A        	LDAX	D
 06CA FE20      	CPI	' '		;  skip a character if a space
 06CC C2D006    	JNZ	NSPC
 06CF 13        	INX	D
 06D0 210814    NSPC:	lxi	h,mfc*256+srl
 06D3 CD0000    	call	prtmsg
 06D6 C9        	ret
                
 06D7 210914    SETCN:	lxi	h,mfc*256+fsl
 06DA CD0000    	call	cursor
 06DD 21CA18    	lxi	h,modes 	; get pointer to format origin bytes
 06E0 56        	mov	d,m		; load bytes in de
 06E1 23        	inx	h
 06E2 5E        	mov	e,m
 06E3 D5        	push	d
 06E4 CDDD05    	call	serdp		; get start of format string table in hl
 06E7 D1        	pop	d
 06E8 010800    	lxi	b,8
 06EB AF        	xra	a
 06EC           fmt1:	srlr	d
 06EE           	rarr	e	;shift and wait for a carry...
 06F0           	jrc	fmt2
 06F2 09        	dad	b
 06F3           	jr	fmt1
 06F5 0608      fmt2:	mvi	b,8
 06F7 7E        fmt3:	mov	a,m	; got format string - now print 8 characters
 06F8 CD0000    	call	putchr	
 06FB 23        	inx	h
 06FC           	djnz	fmt3
 06FE C9        	ret
                
                getstr: 
 06FF 2A8418    	lhld	curmdl
 0702 110C00    	lxi	d,stroff	; address text string offset
 0705 19        	dad	d
 0706 5E        	mov	e,m		; move to de
 0707 23        	inx	h
 0708 56        	mov	d,m
 0709 C9        	ret
                
                ;
                ;	This routine modifies the driver module so that the login function
                ;	is not called. It also copys the new mode bytes into the system.
                ;	Done$dsk undos what this routine did.
                ;
                
                start$dsk:
 070A 21CA18    	lxi	h,modes
 070D           	lded	modptr
 0711 010400    	lxi	b,4
 0714           	ldir
 0716 C9        	ret
                log$off:
 0717 2A8418    	lhld	curmdl		; go into driver
 071A 010300    	lxi	b,3
 071D 09        	dad	b		; POINT TO JUMP TO LOGIN ROUTINE
 071E 3EAF      	mvi	a,0afh		; code for "XRA A"
 0720 BE        	cmp	m
 0721 C8        	rz	; don't do this twice
 0722 77        	mov	m,a		; overlay "JMP" instruction
 0723 23        	inx	h		;  so that LOGIN never gets called
 0724 7E        	mov	a,m		; byte to be saved
 0725 32B618    	sta	savbyte
 0728 3EC9      	mvi	a,0c9h		; code for "RET"
 072A 77        	mov	m,a
 072B 3A8013    	lda	drive
 072E D641      	sui	'A'		; logical drive number
 0730 4F        	mov	c,a
 0731 1E00      	mvi	e,0		; flag drive not logged in
 0733 3E09      	mvi	a,seldsk	; select the disk (this will put dpb address
 0735 CD2E0F    	call	biosc		;  into dph)
 0738 C9        	ret
                
                setup:
 0739 AF        	xra	a
 073A 32A318    	sta	dsflag
 073D 2ABE18    	lhld	sysdpb		; get DPB address
 0740 7E        	mov	a,m		; get the number of sectors per track
 0741 329418    	sta	spt0		; must be changed if mode is changed
 0744 113A18    	lxi	d,dpb
 0747 010F00    	lxi	b,15
 074A           	ldir			; copy DPB into local area
 074C 2ACC18    	lhld	modes+2 	; get corrected mode value
 074F 0E00      	mvi	c,0
 0751           	bit	4,h	;DD BIT
 0753 CA5807    	jz	nodd
 0756           	setb	1,c	;SET DOUBLE DENSITY
 0758           nodd:	bit	6,h	;DS BIT
 075A CA5F07    	jz	nods
 075D           	setb	0,c	;SET DOUBLE SIDED
 075F           nods:	bit	5,h
 0761 CA6607    	jz	nodt
 0764           	setb	3,c
 0766           nodt:	lxix	modes
 076A           	bitx	0,+0		; see if z100
 076E           	jrz	no$z100
 0770 3E24      	mvi	a,00100100b	; mark as z100 (z207 controller)
 0772           	jr	markfmt
 0774           no$z100 bitx	5,+1
 0778           	jrz	no$z47
 077A 3E80      	mvi	a,10000000b	; mark as z47
 077C           	jr	markfmt
 077E           no$z47: bitx	6,+1
 0782           	jrz	no$z47x
 0784 3E84      	mvi	a,10000100b	; mark as z47x
 0786           	jr	markfmt
 0788           no$z47x bitx	7,+1
 078C           	jrz	no$z67
 078E 3EC0      	mvi	a,11000000b	; mark as z67
 0790           	jr	markfmt
 0792           no$z67: bitx	3,+1
 0796           	jrz	no$z37		; no valid format
 0798 3E60      	MVI	A,01100000B	; mark as Z37 type disk
 079A           	jr	markfmt
 079C           no$z37: bitx	4,+1		; test for z37 extended
 07A0           	jrz	markfmt
 07A2 3E64      	mvi	a,01100100b	; mark as z37 extended
 07A4 B1        markfmt ORA	C
 07A5 328D18    	STA	Z37MODE
 07A8 7C        	MOV	A,h
 07A9 E640      	ANI	01000000B	; determine how many sides to format
 07AB 07        	RLC
 07AC 07        	RLC
 07AD 32A018    	STA	SIDES
 07B0 7D        	MOV	A,l
 07B1 E60C      	ANI	00001100B	; get the steprate for this drive
 07B3 0F        	rrc
 07B4 0F        	rrc
 07B5 32B818    	STA	STEPR
 07B8 3A9418    	LDA	SPT0		; convert SPT to physical, if neccessary
 07BB 47        	MOV	B,A
 07BC 7D        	MOV	A,L
 07BD E603      	ANI	00000011B	; sector size code (0,1,2,3)
 07BF 329E18    	STA	SZ
 07C2 3C        	INR	A
 07C3 3D        ST0:	DCR	A
 07C4 CACC07    	JZ	SD80
 07C7           	SRLR	B		; shift SPT down to physical equivilent.
 07C9 C3C307    	JMP	ST0
 07CC 78        SD80:	MOV	A,B
 07CD 329918    	STA	SPT
 07D0 114D4D    	LXI	D,(77)+(77)*256 ; determine the number of tracks on the drive.
 07D3           	BIT	7,l		; (E = tracks on 1st side, D = tracks on 2nd)
 07D5 C2EE07    	JNZ	GOTT		; 8" DT is not supported.
 07D8 112828    	LXI	D,(40)+(40)*256
 07DB 3ACB18    	LDA	MODES+1 	; check ORG for "Z17"
 07DE FE02      	CPI	00000010B
 07E0 C2E507    	JNZ	NZ17
 07E3 1624      	MVI	D,(36)		; only 36 tracks on second side of Z17 disk
 07E5           NZ17:	BIT	5,L		; check DT bit
 07E7 CAEE07    	JZ	GOTT
 07EA           	SLAR	E		; twice as many tracks if double track density.
 07EC           	SLAR	D
 07EE           GOTT:	SDED	TRKS
 07F2 3ACB18    	LDA	MODES+1
 07F5 FE01      	CPI	00000001B	; IF IT'S AN MMS FORMAT
 07F7 C21008    	JNZ	NMMS
 07FA           	bit	7,l
 07FC CA1008    	jz	nmms
 07FF           	bit	4,h
 0801 CA1008    	jz	nmms
 0804 3AB318    	lda	phydrv		;  THEN Z47/M47 CONTROLLER CANNOT FORMAT IT.
 0807 D605      	sui	5
 0809 FE04      	cpi	4
 080B 3E06      	mvi	a,notsupcd
 080D DA3208    	jc	exit$setup
 0810 3AA118    nmms:	lda	wd$flag
 0813 B7        	ora	a
 0814 CA1D08    	jz	not$wd		;SKIP search IF NOT 1797-TYPE FORMATTER
 0817 CD3308    	call	search$table	; searches table for 1797 track format entry
 081A DA3208    	jc	exit$setup	; jmp to exit if format not supported
                not$wd:
 081D 3ACC18    	lda	modes+2
 0820 E680      	ani	10000000B	; 8" bit
 0822 3EFF      	mvi	a,true
 0824 32A318    	sta	dsflag		; allow test for DS error.
 0827 3A8118    	lda	dtflag0
 082A           	jrz	fivnch		; disallow test for DT if 8" drive
 082C 3E00      	mvi	a,false
                fivnch: 
 082E 32A418    	sta	dtflag
 0831 B7        	ora	a		; clear [CY]
                exit$setup:			; returns [CY] if error
 0832 C9        	ret
                
                
                ;
                ;	Searches format table 
                ;
                
                search$table:			;searches table for format and dd type
 0833 21CA18    	lxi	h,modes  
 0836 4E        	mov	c,m		;no need to mask format origin code.
 0837 23        	inx	h
 0838 46        	mov	b,m
 0839 23        	inx	h
 083A 7E        	mov	a,m		; get first mode byte
 083B E683      	ani	srm0		; mask FIRST BYTE
 083D 5F        	mov	e,a    
 083E 23        	inx	h		; and point to the second
 083F 7E        	mov	a,m
 0840 E61C      	ani	srm1		; mask SECOND BYTE
 0842 57        	mov	d,a
 0843 210000    	lxi	h,table 	; table lookup...
                nxtxt:
 0846 7E        	mov	a,m		; format origin code.
 0847 23        	inx	h
 0848 A1        	ana	c	;compare it: if the format requested matches
 0849           	jrnz	got1	    ;(if the bit is set in both DPB and requested
 084B 7E        	mov	a,m	    ; mode ([NZ] condition) then we have a match.)
 084C A0        	ana	b		;check for possible extend format origin
 084D           	jrz	nxd1	;...
 084F 23        got1:	inx	h
 0850 7E        	mov	a,m		; get first byte
 0851 23        	inx	h
 0852 E683      	ani	srm0		;mask it also
 0854 BB        	cmp	e		;compare to target mode
 0855           	jrnz	nxd3
 0857 7E        	mov	a,m		; and the second
 0858 E61C      	ani	srm1		;mask it
 085A BA        	cmp	d		;compare it
 085B           	jrnz	nxd3
 085D 3ACD18    	lda	modes+3 	; we don't format double sided/single density
 0860 E650      	ani	01010000b		     
 0862 FE40      	cpi	01000000b
 0864 CA9408    	jz	errout
 0867           	bit	7,m		; check confg bit in table
 0869           	jrz	no$cfg
 086B 3EFF      	mvi	a,true
 086D           	jr	c1
 086F 3E00      no$cfg: mvi	a,false
 0871 32AC18    c1:	sta	cflg
 0874 23        	inx	h
 0875 7E        	mov	a,m	;pick up format table
 0876 23        	inx	h
 0877 66        	mov	h,m
 0878 6F        	mov	l,a
 0879 228E18    	shld	xtable		
 087C 110600    	lxi	d,6	;pick verify sector table
 087F 19        	dad	d
 0880 7E        	mov	a,m
 0881 23        	inx	h
 0882 66        	mov	h,m
 0883 6F        	mov	l,a
 0884 22C018    	shld	vsectb
 0887 B7        	ora	a	;clear [CY]
 0888           	jr	search$exit
 088A 23        nxd1:	inx	h
 088B 23        nxd2:	inx	h
 088C 23        nxd3:	inx	h
 088D 23        	inx	h
 088E 23        	inx	h
 088F 7E        	mov	a,m
 0890 FEFF      	cpi	11111111b
 0892           	jrnz	nxtxt		; loop if more entries in table
 0894 3E06      errout: mvi	a,notsupcd
 0896 37        	stc
                search$exit:
 0897 C9        	ret
                
                ;
                ;	Tests drives for incorrect drive/media requests tpi mismatch
                ;	       Assumes drive has been restored already
                ;
                
                testdt: 			
 0898 3AA418    	lda	dtflag		; if zero don't do the test
 089B B7        	ora	a
 089C CAD008    	jz	testdt2
 089F AF        	xra	a
 08A0 32A418    	sta	dtflag		; prevent further tests until something changes
 08A3 1E2F      	mvi	e,47		; step in 47 tracks (will only go about 45 if
 08A5 3E4B      stin0:	mvi	a,01001011B	; drive is 48 tpi).
 08A7 CD0000    	call	comnd		; step-in
 08AA 1D        	dcr	e
 08AB C2A508    	jnz	stin0
 08AE 1E2E      	mvi	e,46		; step out 46 tracks (on 96 tpi drive head will
 08B0 3E6B      stot0:	mvi	a,01101011B	; not get back to track 00).
 08B2 CD0000    	call	comnd		; step-out
 08B5 1D        	dcr	e
 08B6 C2B008    	jnz	stot0		; (A) = status, check TR00 bit.
 08B9 EE04      	xri	00000100B	; make [ZR] for 48 tpi (std DT bit)
 08BB 07        	rlc			; put bit in same position as system DT bit
 08BC 07        	rlc
 08BD 07        	rlc
 08BE 2ACC18    	lhld	modes+2
 08C1 AD        	xra	l		; test if DT mode is diff from actual drive...
 08C2 E620      	ani	00100000B	; ignore other bits - returns [CY] if tpi error
 08C4 CACC08    	jz	testdt1
 08C7 3E08      	mvi	a,dterrcd	 
 08C9 37        	stc
 08CA           	jr	testdt2
                testdt1:
 08CC CD0000    	call	restor		; restore drive for format
 08CF B7        	ora	a		; clear [CY]
                testdt2:
 08D0 C9        	ret
                
                ;
                ;  This section the actual formatting of each track
                ;
                
                format:
 08D1 CDEF09    	call	image$t0s0	; set up trk0 side 0 image & set up controller 
 08D4 3A9518    	lda	trks		; move base values to temp variable space
 08D7 32A618    	sta	trks1
 08DA AF        	xra	a
 08DB 329718    	sta	trk		; track = 0
 08DE 329818    	sta	sid		; side = 0
 08E1 CD1A0B    	call	bargraph	; setup display of tracks formatted
 08E4 CD780B    	call	fmtprog
 08E7 CD4309    	call	sec$header	; format trk0 side 0 
 08EA CD5F09    	call	trk$write
 08ED DA4109    	jc	fmterr
 08F0 3AA018    	lda	sides
 08F3 B7        	ora	a
 08F4           	jrz	fmt$ss
 08F6 CDBA09    	call	nxt$side
 08F9 CDFF09    	call	image$t0s1	; format trk0 side 1
 08FC CD780B    	call	fmtprog
 08FF CD4309    	call	sec$header
 0902 CD5F09    	call	trk$write
 0905 DA4109    	jc	fmterr
 0908 3AA318    	lda	dsflag		; ds test
 090B B7        	ora	a
 090C CA1509    	jz	no$dstest
 090F CD8B0B    	call	testds
 0912 DA4109    	jc	fmterr
                no$dstest:
 0915 CDBA09    	call	nxt$side
 0918 CDC209    fmt$ss: call	nxt$trk
 091B DA4109    	jc	fmterr
 091E CDDB09    	call	image$trk	; set up buffer for rest of disk
                trk$loop:
 0921 CD780B    	call	fmtprog
 0924 CD4309    	call	sec$header
 0927 CD5F09    	call	trk$write
 092A DA4109    	jc	fmterr
 092D 3AA018    	lda	sides		; if double sided switch sides and format
 0930 B7        	ora	a
 0931 C4BA09    	cnz	nxt$side
 0934           	jrnz	trk$loop	; if side 1 ([Z]=0) do loop again
 0936 CDC209    	call	nxt$trk
 0939 DA4109    	jc	fmterr
 093C CA2109    	jz	trk$loop 
 093F B7        	ora	a		; clear [CY]
 0940 C9        	ret
                fmterr:
 0941 37        	stc			; set [CY] for error
 0942 C9        	ret
                
                ;
                ;	This routine puts the sector headers in the buffer
                ;
                
                sec$header:		 
 0943 3AA118    	lda	wd$flag
 0946 B7        	ora	a
 0947 C8        	rz
 0948 3A9918    	lda	spt		; setup registers to update track-side fields
 094B           	lbcd	trk
 094F           	lded	bias 
 0953 2AA718    	lhld	first$trk
                fill$num:
 0956 71        	mov	m,c		; put track and side number in sector header
 0957 23        	inx	h
 0958 70        	mov	m,b
 0959 19        	dad	d		; step to next sector field
 095A 3D        	dcr	a		; count sectors
 095B C25609    	jnz	fill$num	; continue if more sectors to fill
 095E C9        	ret
                
                ;
                ;	This routines writes the buffer out
                ;
                
                trk$write:
 095F CD0000    	call	intoff		;TURN SPECIFIC INTERUPTS OFF
 0962 210000    	lxi	h,buffer	; point to track buffer for data source
 0965 CD0000    	call	writrk		; write a track to disk
 0968 32B718    	sta	dskst
 096B F5        	push	psw		; save CARRY bit
 096C E5        	push	h		; save address of last byte written
 096D CD0000    	call	inton		;TURN INTERUPTS ON AGAIN
 0970 E1        	pop	h
 0971 F1        	pop	psw		;restore carry bit
 0972 DAB209    	jc	err1		;error: soft-sector media in hard-sector ctrlr.
 0975 110000    	lxi	d,buffer
 0978 B7        	ora	a
 0979           	dsbc	d		; calculate number of bytes written
 097B 11D007    	lxi	d,2000		; compare to 2000
 097E B7        	ora	a
 097F           	dsbc	d		; if less than 2000,
 0981 DAB609    	jc	err2		; must be 10-sector disk on soft-sector ctrlr.
 0984 3E92      	mvi	a,146		; 1000 microsecond delay:
 0986 3D        dly:	dcr	a		; The tunnel erase is active for up
                				; to 500 microseconds
 0987 C28609    	jnz	dly		; after write-gate is turned off.
 098A 3AB718    	lda	dskst		; check status of write-track command
 098D B7        	ora	a		; clear [CY]
 098E C8        	rz
 098F 4F        	mov	c,a
 0990 3AA318    	lda	dsflag		; HAS DOUBLE SIDED TEST BEEN DONE YET ?
 0993 B7        	ora	a
 0994 79        	mov	a,c
 0995 CA9E09    	jz	ndserr
 0998 3A9818    	lda	sid		; IF IT HASN'T AND WE ARE ON SIDE 1,
 099B B7        	ora	a		;  THEN TREAT AS IF NO ERROR
 099C 79        	mov	a,c		;  SO THAT DOUBLE SIDED TEST WILL BE DONE
 099D C0        	rnz	
 099E 07        ndserr: rlc
 099F D2A609    	jnc	noerr1		; NOT READY ERROR
 09A2 3E03      	mvi	a,notrdycd
 09A4           	jr	wrterr
 09A6 07        noerr1: rlc
 09A7 D2AE09    	jnc	err0		; WRITE PROTECT ERROR
 09AA 3E02      	mvi	a,wrtprocd
 09AC           	jr	wrterr
 09AE 3E0C      err0:	mvi	a,wterrcd
 09B0           	jr	wrterr		; error if anything ELSE went wrong
 09B2 3E05      err1:	mvi	a,z17sftcd
 09B4           	jr	wrterr
 09B6 3E04      err2:	mvi	a,hrdsectcd
 09B8 37        wrterr: stc
 09B9 C9        	ret
                
                ;
                ;	Increments to next side
                ;
                
                nxt$side:
 09BA 219818    	lxi	h,sid		; update side
 09BD 7E        	mov	a,m 
 09BE EE01      	xri	00000001B
 09C0 77        	mov	m,a
 09C1 C9        	ret			; [Z] is set if side 0
                
                ;
                ;	increments to next trk
                ;
                
                nxt$trk:
 09C2 219718    	lxi	h,trk		; update track numbers
 09C5 34        	inr	m
 09C6 21A618    	lxi	h,trks1
 09C9 35        	dcr	m		; count each track
 09CA CAD709    	jz	nxt$trk1
 09CD CD0000    	call	step$in 	; step head towards hub
 09D0 E6C9      	ani	11001001B	; (A) = status from 1797, clears carry
 09D2 C8        	rz
 09D3 3E0C      	mvi	a,wterrcd
 09D5 37        	stc			; [CY] = error
 09D6 C9        	ret
                nxt$trk1:
 09D7 3E01      	mvi	a,1		; [NZ] = last track
 09D9 B7        	ora	a
 09DA C9        	ret
                
                ;
                ;	These routines build the image needed to write to the disk
                ;
                
                image$trk:
 09DB 3A9718    	lda	trk
 09DE FE01      	cpi	1		; if track not 1, return
 09E0 C0        	rnz
 09E1 3A9818    	lda	sid		; if not side 0, return
 09E4           	bit	0,a
 09E6 C0        	rnz
 09E7 3ACD18    	lda	modes+3
 09EA E60C      	ani	0000$1100b
 09EC           	jrnz	image$norm	; if trk0 side 0 or side1 was different reimage
 09EE C9        	ret
                
                image$t0s0:
 09EF 3ACD18    	lda	modes+3
 09F2           	bit	3,a		; if dd with trk 0 side 0 dd, jump
 09F4           	jrz	image$norm
 09F6 210000    	lxi	h,std8		; select SD 8" for this track
 09F9 0E00      	mvi	c,0		; sector size = 128 bytes
 09FB 3E1A      	mvi	a,26		; 26 physical sectors per track
 09FD           	jr	put$image
                
                image$t0s1:
 09FF 3ACD18    	lda	modes+3
 0A02           	bit	2,a		; jmp if trk 0 side 1 is the z47d format (256)
 0A04           	jrnz	imag1
 0A06           	bit	3,a		; see if trk 0 side 0 was different
 0A08 C8        	rz			; return if it wasn't different
 0A09           	jr	image$norm
 0A0B 210000    imag1:	lxi	h,z47d		; select dd trk0 side 1 on z47x
 0A0E 0E01      	mvi	c,1		; sector size = 256
 0A10 3E1A      	mvi	a,26		; 26 physical sectors per track
 0A12           	jr	put$image
                
                image$norm:			  
 0A14 2A8E18    	LHLD	XTABLE
 0A17 3A9E18    	LDA	SZ
 0A1A 4F        	MOV	C,A
 0A1B 3A9918    	LDA	SPT
                put$image:
 0A1E 329A18    	STA	SPTC
 0A21 79        	MOV	A,C		; sector size code
 0A22 329F18    	STA	SZ0		; save for later stuffing into image
 0A25 014000    	LXI	B,128/2 	; B = 0, C = 128/2
 0A28 3C        	INR	A
 0A29           SI0:	SLAR	C		; mult BC by 2
 0A2B           	RALR	B
 0A2D 3D        	DCR	A		; do it A times
 0A2E C2290A    	JNZ	SI0
 0A31           	SBCD	SECSIZ		; used by data-fill routine and VERIFY
 0A35 3AA118    	LDA	WD$FLAG
 0A38 B7        	ORA	A
 0A39 CA0000    	jz	ctrlio
 0A3C 5E        	MOV	E,M
 0A3D 23        	INX	H
 0A3E 56        	MOV	D,M
 0A3F 23        	INX	H
 0A40           	SDED	FMTBL		; table that discribes format
 0A44 7E        	MOV	A,M
 0A45 32A218    	STA	MFM		; DD enable flag
 0A48 23        	INX	H
 0A49 23        	INX	H
 0A4A 5E        	MOV	E,M
 0A4B 23        	INX	H
 0A4C 56        	MOV	D,M
 0A4D 23        	INX	H
 0A4E           	SDED	FMTTBL		; skew table for format
 0A52 3E02      	MVI	A,2
 0A54 32A518    	STA	FLAG
 0A57 210000    	LXI	H,BUFFER
 0A5A AF        	XRA	A
 0A5B 329B18    	STA	SE		; set starting sector number = 0
 0A5E CD720A    	CALL	FILL$BUFF	; build buffer image
 0A61 2AA918    	LHLD	BIAS
 0A64           	LDED	FIRST$TRK
 0A68 B7        	ORA	A
 0A69           	DSBC	D		; compute length of (each) sector image
 0A6B 2B        	DCX	H
 0A6C 22A918    	SHLD	BIAS		; used to update track and side in track image
 0A6F C30000    	jmp	ctrlio		; setup controll port image
                
                FILL$BUFF:
 0A72 54        	MOV	D,H		; DE = HL+1
 0A73 5D        	MOV	E,L
 0A74 13        	INX	D
 0A75 E5        	PUSH	H		; TOS = buffer start address
 0A76 2AB118    	LHLD	FMTBL		; HL = table address
 0A79 0600      	MVI	B,0
                POST$INDEX:
 0A7B 7E        	MOV	A,M
 0A7C 23        	INX	H
 0A7D B7        	ORA	A
 0A7E CA8C0A    	JZ	FILL$SECT
 0A81 4F        	MOV	C,A
 0A82 7E        	MOV	A,M
 0A83 23        	INX	H
 0A84 E3        	XTHL
 0A85 77        	MOV	M,A
 0A86           	LDIR
 0A88 E3        	XTHL
 0A89 C37B0A    	JMP	POST$INDEX
                FILL$SECT:
 0A8C 4D        	MOV	C,L
 0A8D 44        	MOV	B,H		; BC = HL (table)
 0A8E E3        	XTHL			; TOS = table, HL = buffer
 0A8F C5        	PUSH	B		; -TOS = TOS = table
 0A90 0600      	MVI	B,0
 0A92 E3        FILL$S: XTHL			; HL = table, TOS = buffer
 0A93 7E        	MOV	A,M
 0A94 23        	INX	H
 0A95 B7        	ORA	A
 0A96 CAFA0A    	JZ	END$SECT
 0A99 4F        	MOV	C,A
 0A9A 7E        	MOV	A,M
 0A9B 23        	INX	H
 0A9C E3        	XTHL
 0A9D 77        	MOV	M,A
 0A9E           	LDIR
 0AA0 FEFE      	CPI	0FEH		; ID address mark
 0AA2 CAB90A    	JZ	SECT$ID
 0AA5 FEFB      	CPI	0FBH		; Data address mark
 0AA7 C2920A    	JNZ	FILL$S
 0AAA           	LBCD	SECSIZ		; fill data field of sector
 0AAE 36E5      	MVI	M,0E5H		; fill constant
 0AB0           	LDIR
 0AB2 36F7      	MVI	M,0F7H		; crc flag
 0AB4 23        	INX	H
 0AB5 13        	INX	D		; keep DE = HL + 1
 0AB6 C3920A    	JMP	FILL$S
                SECT$ID:			; save HL 1st time as FIRST$TRK, next as BIAS
 0AB9 3AA518    	LDA	FLAG
 0ABC 3D        	DCR	A
 0ABD FACF0A    	JM	NOSAVE		; 0 = don't save buffer address
 0AC0 32A518    	STA	FLAG
 0AC3 CACC0A    	JZ	SAVEBIAS	; 1 = calc diff and save
 0AC6 22A718    	SHLD	FIRST$TRK	; 2 = save first sectors ID address
 0AC9 C3CF0A    	JMP	NOSAVE
                SAVEBIAS:
 0ACC 22A918    	SHLD	BIAS		; note: BIAS must have FIRST$TRK subtracted
 0ACF 3600      NOSAVE: MVI	M,0		; current track number, filled in later
 0AD1 23        	INX	H
 0AD2 3600      	MVI	M,0		; side value, filled in later
 0AD4 23        	INX	H
 0AD5           	LDED	FMTTBL		; get logical-physical sector table
 0AD9 7B        	MOV	A,E
 0ADA B2        	ORA	D
 0ADB 3A9B18    	LDA	SE		; do log/phy sector translation
 0ADE CAE90A    	JZ	NOSK		; skip if no skew
 0AE1 83        	ADD	E		; index table
 0AE2 5F        	MOV	E,A
 0AE3 3E00      	MVI	A,0
 0AE5 8A        	ADC	D
 0AE6 57        	MOV	D,A
 0AE7 1A        	LDAX	D		; physical sector
 0AE8 3D        	DCR	A
 0AE9 3C        NOSK:	INR	A
 0AEA 77        	MOV	M,A
 0AEB 23        	INX	H
 0AEC 3A9F18    	LDA	SZ0		; sector size code
                NNNN:
 0AEF 77        	MOV	M,A
 0AF0 23        	INX	H
 0AF1 36F7      	MVI	M,0F7H		; crc flag
 0AF3 23        	INX	H
 0AF4 5D        	MOV	E,L
 0AF5 54        	MOV	D,H
 0AF6 13        	INX	D		; DE = HL + 1
 0AF7 C3920A    	JMP	FILL$S
                END$SECT:
 0AFA 019B18    	LXI	B,SE		; sector + 1
 0AFD 0A        	LDAX	B
 0AFE 3C        	INR	A
 0AFF 02        	STAX	B
 0B00 019A18    	LXI	B,SPTC		; sector-per-track counter
 0B03 0A        	LDAX	B
 0B04 3D        	DCR	A
 0B05 02        	STAX	B
 0B06 CA120B    	JZ	FILL$LAST
 0B09 E1        	POP	H		; HL = buffer
 0B0A C1        	POP	B		; BC = table
 0B0B C5        	PUSH	B		; TOS = table
 0B0C C5        	PUSH	B		; -TOS = table, TOS = table
 0B0D 0600      	MVI	B,0
 0B0F C3920A    	JMP	FILL$S		; do next sector
                FILL$LAST:
 0B12 4E        	MOV	C,M
 0B13 23        	INX	H
 0B14 46        	MOV	B,M		; BC = fill size
 0B15 E1        	POP	H		; HL = buffer (DE = HL+1)
 0B16 F1        	POP	PSW		; discard table
 0B17           	LDIR			; fill last used byte to end of track
 0B19 C9        	RET
                
                
                ;
                ;	Prints bar graph on screen
                ;
                
                bargraph:
 0B1A CD0000    	call	curoff
 0B1D 210B00    	lxi	h,prl
 0B20 CD0000    	call	cursor
 0B23 CD0000    	call	clrend		; clear bottom half of screen
 0B26 210D00    	lxi	h,bgl
 0B29 11F017    	lxi	d,side0 	; print 'SIDE 0'
 0B2C CD0000    	call	prtmsg
 0B2F 210F00    	lxi	h,bgl+2 	  
 0B32 CD0000    	call	cursor		; position display
 0B35 CD690B    	call	writbar 	; MAKE THE BAR
 0B38 3AA018    	lda	sides
 0B3B B7        	ora	a		; SS OR DS?
 0B3C C8        	rz
 0B3D 211100    	lxi	h,bgl+4
 0B40 11F717    	lxi	d,side1 	; WRITE 'SIDE 1'
 0B43 CD0000    	call	prtmsg
 0B46 2A9518    	lhld	trks		;see if any tracks on side 1 are skipped.
 0B49 7D        	mov	a,l
 0B4A BC        	cmp	h
 0B4B C8        	rz		
 0B4C 2D        	dcr	l
 0B4D E5        	push	h
 0B4E 11FE17    	lxi	d,tkmsg
 0B51 CD0000    	call	putlne
 0B54 E1        	pop	h
 0B55 7C        	mov	a,h
 0B56 CDE50E    	call	decout
 0B59 3E2D      	mvi	a,'-'
 0B5B CD0000    	call	putchr
 0B5E 7D        	mov	a,l
 0B5F CDE50E    	call	decout
 0B62 110A18    	lxi	d,anu
 0B65 CD0000    	call	putlne
 0B68 C9        	ret
                
                writbar:
 0B69 11A017    	lxi	d,bar		; START OF BAR
 0B6C 3A9518    	lda	trks		; HOW MANY TRACKS?
 0B6F 47        	mov	b,a
 0B70 1A        wb0:	ldax	d
 0B71 13        	inx	d
 0B72 CD0000    	call	putchr
 0B75           	djnz	wb0
 0B77 C9        	ret
                
                ;
                ;	Prints the progress of the format on the bargraph
                ;
                
                fmtprog:			; SEND NEXT 'F' TO BARGRAPH
 0B78 3A9818    	lda	sid		; CURRENT SIDE NUMBER
 0B7B 87        	add	a
 0B7C C60E      	adi	bgl+1		; OFFSET TO DISPLAY POSITION
 0B7E 6F        	mov	l,a
 0B7F 3A9718    	lda	trk
 0B82 67        	mov	h,a
 0B83 CD0000    	call	cursor
 0B86 3E66      	mvi	a,'f'
 0B88 C30000    	jmp	putchr
                
                ;
                ;	Tests for single sided drive or media 
                ;
                
                testds:
 0B8B AF        	xra	a
 0B8C 32A318    	sta	dsflag
 0B8F 3E01      	mvi	a,1		; side 1
 0B91 CD0000    	call	rdadr		; try to read valid side-1 address
 0B94 C2A50B    	jnz	tstdserr	; [NZ] = side 1 not formatted
 0B97 3C        	inr	a
 0B98 DAA50B    	jc	tstdserr	; crc error on side-1 indicates DS error
 0B9B 3E00      	mvi	a,0		; side 0
 0B9D CD0000    	call	rdadr		; try to read valid side-0 address
 0BA0 C2A50B    	jnz	tstdserr	; [NZ] = side 0 not formatted
 0BA3 B7        	ora	a		; Clear [CY]
 0BA4 C9        	ret
                tstdserr:
 0BA5 3E0A      	mvi	a,dserrcd
 0BA7 37        	stc
 0BA8 C9        	ret
                
                ;
                ;	Reads each sector on the disk, writes initdir data and Zenith label
                ;
                
                verify: 			; formatting done, verify each sector
 0BA9 CD0000    	call	inton
 0BAC 2A9C18    	lhld	secsiz
 0BAF 29        	dad	h
 0BB0 7C        	mov	a,h
 0BB1 32BB18    	sta	lps
 0BB4 CD0000    	call	restor		; put head in known position
 0BB7 CD0000    	call	dskxit
 0BBA 010000    	lxi	b,buffer	; set DMAA to a controlled location...
 0BBD 3E0C      	mvi	a,setdma	;
 0BBF CD2E0F    	call	biosc		; (we must reserve at least 1024 bytes)
 0BC2 3A8013    	lda	drive
 0BC5 D641      	sui	'A'
 0BC7 4F        	mov	c,a
 0BC8 3C        	inr	a		; setup drive for set dir label
 0BC9 324918    	sta	sfcb
 0BCC 1E01      	mvi	e,1		; to tell bios disk is already logged in
 0BCE 3E09      	mvi	a,seldsk
 0BD0 CD2E0F    	call	biosc		; select drive
 0BD3 3E08      	mvi	a,home
 0BD5 CD2E0F    	call	biosc		; request track zero
 0BD8 010000    	lxi	b,0
 0BDB 3E0B      	mvi	a,setsec
 0BDD CD2E0F    	call	biosc
 0BE0 3E0D      	mvi	a,reads
 0BE2 CD2E0F    	call	biosc
 0BE5 3EFF      	mvi	a,0FFh		; FLAG DISK NOT VERIFIED
 0BE7 32C918    	sta	tec
 0BEA 3A8318    	lda	vflag		; CHECK FOR NO VERIFICATION OPTION
 0BED B7        	ora	a
 0BEE CAAC0C    	jz	verify$end2
 0BF1           	lded	trks
 0BF5 7B        	mov	a,e	; number of tracks on first side
 0BF6 2ACC18    	lhld	modes+2
 0BF9           	bit	6,h	; check double-sided bit
 0BFB CA040C    	jz	ntsd1	; 
 0BFE           	bit	1,h	; check for XO/GNAT track numbering. (cont)
 0C00 C2040C    	jnz	ntsd1	;
 0C03 82        	add	d	; add in number of tracks on second side
 0C04 6F        ntsd1:	mov	l,a
 0C05 2600      	mvi	h,0
 0C07 22C418    	shld	vtrk		; save counter values
 0C0A 6C        	mov	l,h		; both have zero in them
 0C0B 22C218    	shld	vsec
 0C0E AF        	xra	a
 0C0F 32C918    	sta	tec		; init track error counter
                verify0:
 0C12 CD2B0D    	call	outv		; temporarely put a "." on track display
 0C15           	lbcd	vtrk
 0C19 3E03      	mvi	a,3
 0C1B B9        	cmp	c		; see if <= track 3 and z17
 0C1C           	jrc	v1
 0C1E 3ACB18    	lda	modes+1
 0C21           	bit	1,a
 0C23           	jrz	v0
 0C25 3A9918    	lda	spt
 0C28 210000    	lxi	h,0		; no skew on track 0 and 1 of z17 format
 0C2B           	jr	v2
 0C2D 0D        v0:	dcr	c
 0C2E           	jrnz	v1		; jmp if not trk0
 0C30 3ACD18    	lda	modes+3 	; see if trk0 sd
 0C33           	bit	3,a
 0C35           	jrz	v1
 0C37 3E1A      	mvi	a,26
 0C39 210000    	lxi	h,vskstd
 0C3C           	jr	v2
 0C3E 2AC018    v1:	lhld	vsectb
 0C41 3A9918    	lda	spt
 0C44 32C618    v2:	sta	sptv
 0C47 22C718    	shld	vskew 
                verify1:
 0C4A           	lbcd	vtrk		; set trk #
 0C4E 0B        	dcx	b
 0C4F 3E0A      	mvi	a,settrk	
 0C51 CD2E0F    	call	biosc
 0C54 2AC718    	lhld	vskew
 0C57           	lbcd	vsec
 0C5B 7C        	mov	a,h
 0C5C B5        	ora	l
 0C5D CA650C    	jz	no$skw
 0C60 09        	dad	b
 0C61 4E        	mov	c,m
 0C62 0600      	mvi	b,0
 0C64 0B        	dcx	b
 0C65 3E0B      no$skw: mvi	a,setsec
 0C67 CD2E0F    	call	biosc
 0C6A 3E0D      	mvi	a,reads
 0C6C CD2E0F    	call	biosc
 0C6F B7        	ora	a		; check if system found an error
 0C70 C2830C    	jnz	verify$err	; RECORD error if there was one
 0C73 21C218    	lxi	h,vsec		; count to next sector
 0C76 3AC618    	lda	sptv
 0C79 34        	inr	m
 0C7A 3D        	dcr	a
 0C7B BE        	cmp	m		; check for last sector on track
 0C7C D24A0C    	jnc	verify1
                
 0C7F 3E76      	mvi	a,'v'
 0C81           	jr	verify2
                verify$err:
 0C83 21C918    	lxi	h,tec
 0C86 34        	inr	m		; INR TEC
 0C87 3E45      	mvi	a,'E'		; send E
                verify2:
 0C89 CD0000    	call	putchr		; send whatever to display
 0C8C CDE30C    	call	vend		; check for Q or ^C
 0C8F DA9F0C    	jc	verify$end
 0C92 210000    	lxi	h,0
 0C95 22C218    	shld	vsec
 0C98 21C418    	lxi	h,vtrk
 0C9B 35        	dcr	m		; step to next track number
 0C9C C2120C    	jnz	verify0
                
                verify$end:
 0C9F 3AC918    	lda	tec		; check if any errors occured
 0CA2 B7        	ora	a
 0CA3 CAAC0C    	jz	verify$end2
 0CA6 CDD30C    	call	disperr 	; display message if errors
 0CA9 C3CF0C    	jmp	exit$verify
                verify$end2:
 0CAC CD0D0E    	call	setmark
 0CAF DACF0C    	jc	exit$verify
 0CB2 CD770D    	call	initdir
 0CB5 DACF0C    	jc	exit$verify
 0CB8 3AAB18    	lda	initflg
 0CBB B7        	ora	a		; see if to create a disk label and enable
 0CBC           	jrnz	exit$verify	;   time and date stamping
 0CBE CD040F    	call	log$on		; prepare drive for BDOS use
 0CC1 114918    	lxi	d,sfcb
 0CC4 0E64      	mvi	c,sdirlab
 0CC6 CD0500    	call	bdos
 0CC9 B7        	ora	a
 0CCA           	jrz	exit$verify	; jump if no error
 0CCC 3E01      	mvi	a,setlabcd
 0CCE 37        	stc
                exit$verify:
 0CCF CD040F    	call	log$on	; should be safe to call twice
 0CD2 C9        	ret
                
                disperr:
 0CD3 CD0000    	call	curact
 0CD6 211300    	lxi	h,erl
 0CD9 116010    	lxi	d,frm$err	; inform user that at least one error
 0CDC CD0000    	call	prtmsg		; was encountered during verify
 0CDF CD0000    	call	clrlne
 0CE2 C9        	ret    
                
                ;
                ;	Check for error on verify.  If error, notify user that he may end
                ;	 verification by typeing 'Q' or ctrl-C
                ;
                   
                vend:
 0CE3 3AC918    	lda	tec		;ERROR COUNTER
 0CE6 B7        	ora	a
 0CE7           	jrz	ve0		;IF NO ERRORS, CHECK FOR ^C AND RETURN
 0CE9 3D        	dcr	a		;1ST ERROR?
 0CEA C2F90C    	jnz	ve0
 0CED 211300    	lxi	h,erl
 0CF0 112113    	lxi	d,vqmess
 0CF3 CD0000    	call	prtmsg		;IF 1ST ERROR, PRINT MESSAGE
 0CF6 CD0000    	call	clrlne
 0CF9 CD1D0D    ve0:	call	conc		;CHECK FOR ^C, RETURN CHAR
 0CFC CA1C0D    	jz	vend$exit	;NO CHAR READY
 0CFF FE03      	cpi	ctrlC
 0D01 CA0B0D    	jz	ve1
 0D04 E6DF      	ani	0DFh		;CAPITAL
 0D06 FE51      	cpi	'Q'
 0D08 C21C0D    	jnz	vend$exit	;IGNORE IF NOT 'Q'
 0D0B 3AC918    ve1:	lda	tec
 0D0E B7        	ora	a
 0D0F C21B0D    	jnz	ve2		;IF ERROR, THINGS WILL BE FINE
 0D12 3AFB13    	lda	medcnt
 0D15 D601      	sui	1		;IF NO ERROR, DISPLAY$COUNT WILL INCREMENT
 0D17 27        	daa			;  MEDCNT, SO WE'LL DECREMENT IT NOW.
 0D18 32FB13    	sta	medcnt
 0D1B 37        ve2:	stc
                vend$exit:
 0D1C C9        	ret
                
                conc:				;CHECK FOR ^C
 0D1D 3E02      	mvi	a,bconst
 0D1F CD2E0F    	call	biosc
 0D22 B7        	ora	a
 0D23 C8        	rz
 0D24 3E03      	mvi	a,bconin
 0D26 CD2E0F    	call	biosc
 0D29 B7        	ora	a	; NOT NULL?
 0D2A C9        	ret		; return with character
                
                ;
                ;	Prints the progress of the verify on the bargraph
                ;
                
                outv:
 0D2B E5        	push	h
 0D2C 2ACC18    	lhld	modes+2
 0D2F 7C        	mov	a,h
 0D30 E603      	ani	00000011B	;TRACK NUMBERING CODE
 0D32 FE01      	cpi	00000001B	; ZENITH NUMBER SCHEME
 0D34 C25A0D    	jnz	notzen
 0D37 3AC418    	lda	vtrk		; BIOS TRACK NUMBER
 0D3A 3D        	dcr	a
 0D3B 6F        	mov	l,a
 0D3C 3E00      	mvi	a,0
 0D3E           	bit	6,h		; CONVERT ZENITH TRACK ONLY IF DS
 0D40 CA470D    	jz	zen0
 0D43           	srlr	l		; DIVIDE BY 2 AND GET REMAINDER IN CARRY
 0D45 17        	ral			; GET SIDE FROM REMAINDER
 0D46 87        mz0:	add	a		; MULT BY 2 (2 LINES BETWEEN SIDE DISPLAYS)
 0D47 C60E      zen0:	adi	bgl+1		; OFFSET BY BAR-GRAPH LINE (SIDE 0)
 0D49 65        	mov	h,l
 0D4A 6F        	mov	l,a
 0D4B E5        	push	h
 0D4C CD0000    	call	cursor		; POSITION CURSOR
 0D4F 3E2E      	mvi	a,'.'		; mark track as "being verified"
 0D51 CD0000    	call	putchr
 0D54 E1        	pop	h
 0D55 CD0000    	call	cursor		; put cursor back to previos position
 0D58 E1        	pop	h
 0D59 C9        	ret
                notzen: 			; DO MMS TRACK-SIDE CONVERSION
 0D5A 3A9518    	lda	trks
 0D5D 6F        	mov	l,a		; H = TOTAL NUMBER OF TRACKS ON A SIDE
 0D5E 2600      	mvi	h,0		; ASSUME SIDE 0
 0D60 3AC418    	lda	vtrk		; BIOS TRACK NUMBER
 0D63 3D        	dcr	a
 0D64 BD        	cmp	l
 0D65 DA720D    	jc	mds0
 0D68 2A9518    	lhld	trks
 0D6B 95        	sub	l	;make logical track on second side
 0D6C           	neg
 0D6E 84        	add	h	;reverse ( N's compliment)
 0D6F 3D        	dcr	a	; -1 because tracks start at 0
 0D70 2601      	mvi	h,1		; SIDE 1
 0D72 6F        mds0:	mov	l,a
 0D73 7C        	mov	a,h
 0D74 C3460D    	jmp	mz0
                
                ;
                ;	Write the directory initialization entries for time and date stamping
                ;
                
                initdir:
 0D77 3AAB18    	lda	initflg
 0D7A B7        	ora	a
 0D7B C20C0E    	jnz	initdir8
 0D7E 110100    	lxi	d,buffer+1		; set up buffer for directory init
 0D81 210000    	lxi	h,buffer
 0D84 010004    	lxi	b,1024
                initdir1:
 0D87 79        	mov	a,c
 0D88 E67F      	ani	0111$1111b
 0D8A FE20      	cpi	20h
 0D8C           	jrnz	initdir2
 0D8E 3621      	mvi	m,21h
 0D90           	jr	initdir3
                initdir2:
 0D92 36E5      	mvi	m,0e5h
                initdir3:
 0D94           	ldi
 0D96 EA870D    	jpe	initdir1
 0D99 010000    	lxi	b,buffer		; set dma address to point to buffer
 0D9C 3E0C      	mvi	a,setdma
 0D9E CD2E0F    	call	biosc
 0DA1           	lixd	sysdpb
 0DA5           	ldx	h,+8			; get DRM 
 0DA8           	ldx	l,+7
 0DAB 23        	inx	h			; add one
 0DAC           	ldx	b,+15			; get PSH
 0DAF 04        	inr	b			; PSH and divide by 4
 0DB0 04        	inr	b 
                initdir4:
 0DB1           	srlr	h			; make DRM number of physical directory
 0DB3           	rarr	l			;  sectors
 0DB5           	djnz	initdir4
 0DB7 45        	mov	b,l
 0DB8 210000    	lxi	h,0
 0DBB 22AD18    	shld	isec			; initialize varaibles
 0DBE 22AF18    	shld	itrk
 0DC1           	ldx	a,+13
 0DC4 32AF18    	sta	itrk
                initdir5:
 0DC7 C5        	push	b
 0DC8           	lbcd	itrk
 0DCC 3E0A      	mvi	a,settrk		; set track number
 0DCE CD2E0F    	call	biosc
 0DD1           	lbcd	isec
 0DD5           	lded	sectbl			; do sector translation
 0DD9 3E10      	mvi	a,sectrn
 0DDB CD2E0F    	call	biosc
 0DDE 44        	mov	b,h
 0DDF 4D        	mov	c,l
 0DE0 3E0B      	mvi	a,setsec		; set sector number
 0DE2 CD2E0F    	call	biosc
 0DE5 3E0E      	mvi	a,writes		; write sector
 0DE7 CD2E0F    	call	biosc
 0DEA C1        	pop	b
 0DEB B7        	ora	a
 0DEC CAF40D    	jz	initdir6
 0DEF 3E00      	mvi	a,initerrcd
 0DF1 37        	stc
 0DF2           	jr	initdir8
                initdir6:
 0DF4 21AD18    	lxi	h,isec
 0DF7 34        	inr	m
 0DF8 3A9918    	lda	spt
 0DFB BE        	cmp	m
 0DFC C2090E    	jnz	initdir7
 0DFF 21AF18    	lxi	h,itrk
 0E02 34        	inr	m
 0E03 210000    	lxi	h,0
 0E06 22AD18    	shld	isec
                initdir7:
 0E09           	djnz	initdir5
 0E0B B7        	ora	a
                initdir8:
 0E0C C9        	ret
                
                ;
                ;	Writes the z37, z47, z100 sector zero label
                ;
                
                setmark:
 0E0D 3AAC18    	lda	cflg
 0E10 B7        	ora	a		; check if need to write configuration data
 0E11 CA780E    	jz	exit$setm
 0E14 210000    	lxi	h,buffer
 0E17 110100    	lxi	d,buffer+1
 0E1A 010004    	lxi	b,1024		; 1024 is largest sector size
 0E1D 36E5      	mvi	m,0E5H
 0E1F           	ldir
 0E21 210400    	lxi	h,buffer+4
 0E24 3600      	mvi	m,0		; 1 byte "00" marker
 0E26 23        	inx	h
 0E27 3A8D18    	lda	z37mode
 0E2A 77        	mov	m,a		; 1 byte mode control
 0E2B 23        	inx	h
 0E2C 23        	inx	h		; 1 byte "E5"
 0E2D 3ABB18    	lda	lps
 0E30 77        	mov	m,a		; 1 byte "records per physical sector"
 0E31 23        	inx	h
 0E32 3A3D18    	lda	dpb+3
 0E35 3C        	inr	a
 0E36 77        	mov	m,a		; 1 byte "records per allocation block"
 0E37 23        	inx	h
 0E38 23        	inx	h
 0E39 23        	inx	h		; 2 bytes "E5"
 0E3A 3600      	mvi	m,0		; 1 byte "00"
 0E3C 23        	inx	h
 0E3D 23        	inx	h		; 1 byte "E5"
 0E3E EB        	xchg
 0E3F 213A18    	lxi	h,dpb
 0E42 010F00    	lxi	b,15
 0E45           	ldir			; 15 bytes of DPB
 0E47 210400    	lxi	h,buffer+4
 0E4A AF        	xra	a
 0E4B 0E18      	mvi	c,24		; (24 bytes to sum)
 0E4D 86        chksum: add	m
 0E4E 23        	inx	h
 0E4F 0D        	dcr	c
 0E50 C24D0E    	jnz	chksum
 0E53 2F        	cma
 0E54 12        	stax	d		; 1 byte Check-Sum
 0E55 010000    	lxi	b,buffer	; write the label out
 0E58 3E0C      	mvi	a,setdma
 0E5A CD2E0F    	call	biosc
 0E5D 010000    	lxi	b,0
 0E60 3E0A      	mvi	a,settrk
 0E62 CD2E0F    	call	biosc
 0E65 010000    	lxi	b,0
 0E68 3E0B      	mvi	a,setsec
 0E6A CD2E0F    	call	biosc
 0E6D 3E0E      	mvi	a,writes
 0E6F CD2E0F    	call	biosc		; write marker to disk
 0E72 B7        	ora	a
 0E73           	jrz	exit$setm	; jump if no error
 0E75 3E0D      	mvi	a,wmerrcd
 0E77 37        	stc
                exit$setm:			; returns [CY] if error
 0E78 C9        	ret
                
                
                ;
                ;	Update and display count of disks correctly formatted
                ;
                
                display$count:
 0E79 3AFC13    	lda	fmtcnt
 0E7C C601      	adi	1
 0E7E 27        	daa
 0E7F 32FC13    	sta	fmtcnt		; COUNT OF FORMATTED DISKS
 0E82 3AC918    	lda	tec		; GET ERROR COUNT FOR CURRENT DISK
 0E85 B7        	ora	a
 0E86           	jrnz	x23		; IF <>0, NO UPDATE
 0E88 3AFB13    	lda	medcnt		; GET COUNT
 0E8B C601      	adi	1
 0E8D 27        	daa			; IT'S BCD
 0E8E 32FB13    	sta	medcnt
                x23:
 0E91 211400    	lxi	h,20
 0E94 11FD13    	lxi	d,afmtd
 0E97 CD0000    	call	prtmsg
 0E9A 3AFC13    	lda	fmtcnt
 0E9D CDB30E    	call	bcdout		;PUT IN NUMBER ATTEMPTED
 0EA0 112514    	lxi	d,gapmsg
 0EA3 CD0000    	call	putlne
 0EA6 3AFB13    	lda	medcnt
 0EA9 CDB30E    	call	bcdout		;PUT IN NUMBER VERIFIED
 0EAC 111814    	lxi	d,vrfd
 0EAF CD0000    	call	putlne
 0EB2 C9        	ret
                
                bcdout:
 0EB3 CDC60E    	call	outbcd
 0EB6 F5        	push	psw
 0EB7 111214    	lxi	d,disk
 0EBA CD0000    	call	putlne
 0EBD F1        	pop	psw
 0EBE 3D        	dcr	a
 0EBF C8        	rz
 0EC0 3E73      	mvi	a,'s'		;FOR MORE THAN ONE
 0EC2 CD0000    	call	putchr
 0EC5 C9        	ret
                
 0EC6 FE10      outbcd: cpi	10h
 0EC8 DAD40E    	jc	lobcd
 0ECB F5        	push	psw
 0ECC 07        	rlc
 0ECD 07        	rlc
 0ECE 07        	rlc
 0ECF 07        	rlc
 0ED0 CDDA0E    	call	nible
 0ED3 F1        	pop	psw
 0ED4 F5        lobcd:	push	psw
 0ED5 CDDA0E    	call	nible		;NOW DO LOW DIGIT
 0ED8 F1        	pop	psw
 0ED9 C9        	ret
                
 0EDA E60F      nible:	ani	0fH
 0EDC C690      	adi	90H
 0EDE 27        	daa
 0EDF CE40      	aci	40H
 0EE1 27        	daa
 0EE2 C30000    	jmp	putchr
                
 0EE5 FE64      decout: cpi	100	;CONVERT BINARY 0-99 TO BCD
 0EE7           	jrc	lt100
 0EE9 3E63      	mvi	a,99
 0EEB 4F        lt100:	mov	c,a
 0EEC 0C        	inr	c
 0EED AF        	xra	a
 0EEE 0D        do0:	dcr	c
 0EEF CAC60E    	jz	outbcd
 0EF2 C601      	adi	1
 0EF4 27        	daa
 0EF5           	jr	do0
                
                ;
                ;	Restores the system to original state before start$dsk
                ;
                
                done$dsk:
 0EF7 21D218    	lxi	h,orgmode	; PUT BACK ORIGINAL MODE BYTES
 0EFA           	lded	modptr
 0EFE 010400    	lxi	b,4
 0F01           	ldir
 0F03 C9        	ret
                log$on:
 0F04 2A8418    	lhld	curmdl		; point to "JMP LOGIN" in driver
 0F07 010300    	lxi	b,3		; restore bytes that were overlayed
 0F0A 09        	dad	b
 0F0B 3EC3      	mvi	a,0c3h		; code for "JMP"
 0F0D BE        	cmp	m
 0F0E C8        	rz	; don't do this twice
 0F0F 77        	mov	m,a
 0F10 23        	inx	h
 0F11 3AB618    	lda	savbyte 	; restore saved byte
 0F14 77        	mov	m,a
 0F15 3A8013    	lda	drive		; SETUP TO RESET DRIVE JUST FORMATTED
 0F18 D640      	sui	'A'-1
 0F1A 110100    	lxi	d,1
 0F1D A7        	ana	a		; (CLEAR CARRY)
 0F1E 3D        agn:	dcr	a
 0F1F CA280F    	jz	resdr
 0F22           	ralr	e
 0F24           	ralr	d
 0F26           	jr	agn
 0F28 0E25      resdr:	mvi	c,restt
 0F2A CD0500    	call	bdos		; RESET DRIVE
 0F2D C9        	ret
                
                ;
                ;	Call BIOS through BDOS
                ;
                
                biosc:				; setup BIOS parameter block
 0F2E 32440F    	sta	biospb		; BIOS function number
 0F31           	sbcd	biospb+2	; BC register
 0F35           	sded	biospb+4	; DE register
 0F39 224A0F    	shld	biospb+6	; HL register
 0F3C 0E32      	mvi	c,cbios
 0F3E 11440F    	lxi	d,biospb	; call BIOS through BDOS
 0F41 C30500    	jmp	bdos
                
 0F44 0000      biospb: db	0,0
 0F46 0000000000	dw	0,0,0
                
                basmsg: 
 0F4C 53656C6563	db	'Selected Configuration:',CR,LF
 0F65 2020202020	db	'            Drive -',CR,LF
 0F7A 2020202020	db	'       Controller -',CR,LF
 0F8F 5265636F72	db	'Recording Density -',CR,LF
 0FA4 2020202020	db	'            Sides -',CR,LF
 0FB9 2020547261	db	'  Tracks per Inch -',CR,LF
 0FCE 2020202020	db	'        Step Rate -',CR,LF
 0FE3 2020202020	db	'      Format Type -',CR,LF
 0FF8 24        	db	'$'
                
 0FF9 456E746572NDSK:	DB	'Enter DRIVE-NAME: (and parameters) --$'
 101F 456E746572PARPRM: DB	'Enter (drive-name:) Parameters --$'
 1041 07496E7661INVP:	DB	BELL,'Invalid parameters or syntax!$'
 1060 074469736BFRM$ERR DB	BELL,'Disk did NOT format! Try again or Discard this diskette$'
 1099 0743616E6EHM$ERR: DB	BELL,'Cannot find track zero!$'
 10B2 07496D7072DR$ERR: DB	BELL,'Improper drive name!$'
 10C8 074469736BWR$PT:	DB	BELL,'Diskette is WRITE-PROTECTED!$'
 10E6 0744726976NT$RD:	DB	BELL,'Drive is NOT READY!$'
 10FB 0743616E6EHRDSEL: DB	BELL,'Cannot format that drive!$'
 1116 074572726FWTERR:	DB	BELL,'Error during Track Write/Step$'
 1135 074469736BFALT:	DB	BELL,'Disk Module is in Error!$'
 114F 07466F726DNOSUP:	DB	BELL,'Format not supported$'
 1165 074E6F2070BADPRT: DB	BELL,'No port selected for Z67 controller$'
 118A 0743616E27H$SEC:	DB	BELL,'Can''t format hard-sectored diskettes on this controller$'
 11C3 0743616E27S$Z17:	DB	BELL,'Can''t format soft-sectored diskettes on this controller$'
 11FC 0743616E6EDTER:	DB	BELL,'Cannot format '
 120B 2424207470GAP1:	DB	'$$ tpi in a '
 1217 2424207470GAP2:	DB	'$$ tpi drive.  '
 1226 5072657373	DB	'Press <RETURN> to acknowledge: $'
 1246 0744726976DSER:	DB	BELL,'Drive or media is not double sided.$'
 126B 0743616E20wmerr:	db	BELL,'Can not write Zenith''s format ID$'
 128D 0743616E20slaberr db	BELL,'Can not write directory date and time stamping label$'
 12C3 0743616E20initerr db	BELL,'Can not initialize directory for date and time stamping$'
 12FC 446F20796Fmormed: DB	'Do you have more media to FORMAT? Y',8,'$'
 1321 416E206572vqmess: DB	'An error has been found. '
 133A 546F205175	DB	'To Quit verifying this diskette, type ''Q''.$'
                
 1365 496E736572prmt:	DB	'Insert BLANK disk in drive '
 1380 403A2E2020drive:	DB	'@:.  Push RETURN to begin formatting, ^C to quit >$'
                
 13B3 070D0A0A52errver: db	bell,cr,lf,lf,'Requires CP/M 3.1 or later',cr,lf,'$'
 13D4 070D0A0A47nodper: db	bell,cr,lf,lf,'GETDP.REL not linked into system',cr,lf,'$'
                
 13FB 00        MEDCNT: DB	0
 13FC 00        FMTCNT: DB	0
 13FD 417474656DAFMTD:	DB	'Attempted to format $'
 1412 204469736BDISK:	DB	' Disk$'
 1418 2056657269VRFD:	DB	' Verified OK$'
 1425 2C202024  GAPMSG: DB	',  $'
                
 1429 4973207468askok:	DB	'Is this the format you want? (Y/N) Y',8,'$'
                
 144F 352E323520INCH5:	DB	'5.25 inch floppy$'
 1460 3820696E63INCH8:	DB	'8 inch floppy$'
 146E 3124      SSMSG:	DB	'1$'
 1470 3224      DSMSG:	DB	'2$'
 1472 53696E676CSDMSG:	DB	'Single$'
 1479 446F75626CDDMSG:	DB	'Double$'
 1480 343824    T48MSG: DB	'48$'
 1483 393624    T96MSG: DB	'96$'
 1486 3030206D69STRATE: DB	'00 milliseconds$'
 1496 413A2028  DSKLT:	DB	'A: ('
 149A 2020292024DSKNM:	DB	'  ) $' 	;drive size appended here
                
 149F 0D0A24    CRLF:	DB	CR,LF,'$'
                
                HELP:
 14A2 0D0A      	DB	CR,LF
 14A4 5468652046	DB	'The FORMAT utility is called in one of the following ways:'
 14DE 0D0A0A2020	DB	CR,LF,LF,'        FORMAT',CR,LF
 14F1 5768696368	DB	'Which outputs HELP information',CR,LF,LF
 1512 2020202020	DB	'        FORMAT d:',CR,LF
 1525 5768696368	DB	'Which formats the specified disk according to the'
 1556 2070726573	DB	' present drive status',CR,LF,LF
 156E 2020202020	DB	'        FORMAT d:arg1,arg2,arg3',CR,LF
 158F 5768696368	DB	'Which temporarily updates the drive status and '
 15BE 666F726D61	DB	'formats the disk',CR,LF,'accordingly. '
                
 15DD 56616C6964VALID:	DB	'Valid values for arguments are as follows:',CR,LF,LF
 160A 2020202020	DB	'        DS or SS = double or single sided',CR,LF
 1635 2020202020	DB	'        DT or ST = double (96 tpi) or single (48 tpi)'
 166A 2074726163	DB	' track',CR,LF
 1672 2020202020	DB	'        DD or SD = double or single density',CR,LF
 169F 2020202020	DB	'        S6, S30, etc. = step rate in milliseconds',CR,LF
 16D2 2020202020	DB	'        MMS, Z37, Z37X etc. (media formats)'
 16FD 3B20746865	DB	'; the X implies extended format.',CR,LF,LF
 1720 496E636F72	DB	'Incorrect arguments may be changed'
 1742 206265666F	DB	' before formatting begins.$'
                
 175D 0D0A0A5072THISUT: DB	CR,LF,LF,'Press RETURN to continue or ^C to exit.$'
                
                
 1788 2036313232STRTBL: DB	' 6122030 3 61015'	;  possible step rates, 2 bytes each
 1798 070D151F04STEPTB: DB	7,13,21,31,4,7,11,16
                
                
                ;SETUP THE BAR GRAPH DISPLAY
                
 17A0 302D2D2D2DBAR:	DB	'0---------1---------2---------3---------'
 17C8 342D2D2D2DBAR2:	DB	'4---------5---------6---------7---------'
 17F0 5349444520side0:	db	'SIDE 0$'
 17F7 5349444520side1:	db	'SIDE 1$'
 17FE 2020202054TKMSG:	DB	'    Tracks $'
 180A 206F6E2073ANU:	DB	' on side 1 are not used by the Operating System$'
                
 183A 0000      DPB:	DW	0
 183C 000000    	DB	0,0,0
 183F 00000000  	DW	0,0
 1843 0000      	DB	0,0
 1845 00000000  	DW	0,0
                
 1849 00        sfcb	db	0		; drive
 184A 2020202020	db	'        '	; default label
 1852 202020    	db	'   '
 1855 60        	db	0110$0000b	; enable access and update time and date
 1856 000000    	db	0,0,0
 1859 0000000000	db	0,0,0,0,0,0,0,0 ; no password
 1861 00000000  	db	0,0,0,0
 1865 00000000  	db	0,0,0,0
                
 1869 14002E2E2ELINE:	DB	20,0,'....................  '  
                
 1881 FF        DTFLAG0:DB	TRUE
 1882 FF        VFLAG0: DB	TRUE 
 1883 00        VFLAG:	DB	0	; verify flag
 1884 0000      curmdl	dw	0	; address of current module in system
 1886 00        reldrv	db	0	; drive number relative to drive zero
 1887 00        LOGDSK	DB	0	; currently logged on disk
 1888 00        CNFIG:	DB	0	; MMS=0,Z17=1... (ASCII DIGIT)
 1889 00        TRCK:	DB	0	; "D" or "S"
 188A 00        SDE:	DB	0	; "D" or "S"
 188B 00        DENSITY: DB	0	; "D" or "S"
 188C 00        STEPRT: DB	0	; binary number, 0-99
                
 188D 00        Z37MODE: DB	0	; mode for zenith sector zero label
 188E 0000      XTABLE: DW	0	; sector translation table address
 1890 0000      FMTTBL: DW	0	; format defination table address
 1892 0000      CMDPTR: DW	0	; command line buffer pointer
 1894 00        SPT0	DB	0	; sector-per-track value for selected drive
 1895 00        TRKS	DB	0	; number of tracks on side 0 (physically on drive)
 1896 00        	DB	0	; number of tracks used on side 1 (all are formatted)
 1897 00        TRK	DB	0	; current track number
 1898 00        SID	DB	0	; number of sides (0 or 1)
 1899 00        SPT	DB	0	; sectors-per-track (physical value)
 189A 00        SPTC	DB	0	; sector-per-track counter
 189B 00        SE	DB	0	; current sector number
 189C 0000      SECSIZ	DW	0	; size of sector (bytes)
 189E 00        SZ	DB	0	; sector size code
 189F 00        SZ0:	DB	0	; temp size code, used to build track image
 18A0 00        SIDES:	DB	0	; number of sides to format disk
 18A1 00        WD$FLAG: DB	0	; WD179X controller type controller if true
 18A2 00        MFM:	DB	0	; single or double density flag
 18A3 00        DSFLAG: DB	0	; allows DS test
 18A4 00        DTFLAG: DB	0	; allows DT test only once per drive.
 18A5 00        FLAG:	DB	0	; flag for extraction of buffer image pointers
 18A6 00        TRKS1:	DB	0	; track counter
 18A7 0000      FIRST$TRK: DW	0	; address to track byte in first sector header
 18A9 0000      BIAS:	DW	0	; number of bytes in each sector image
 18AB 00        initflg db	0	; initialize directory flag - if non zero then don't
 18AC 00        cflg	db	0	; config label flag  if 0FFh don't 
 18AD 0000      isec	dw	0	; initdir sector counter
 18AF 0000      itrk	dw	0	; initdir track counter
 18B1 0000      fmtbl:	DW	0	; table discribing format
 18B3 00        phydrv: db	0	; physical drive number (from BIOS)
 18B4 00        tphy:	db	0	; temporary for "phydrv" in get$drive
 18B5 00        tdrv:	db	0	; temporary for "drive"  in get$drive
 18B6 00        savbyte db	0	; byte saved from modification for module by start$dsk
 18B7 00        DSKST:	DB	0	; disk controller status 
 18B8 00        STEPR:	DB	0	; STEPRATE from mode byte
 18B9 0000      MODPTR: DW	0	; address of modes in BIOS
 18BB 00        LPS:	DB	0	; logical/physical sector ratio
 18BC 0000      SECTBL: DW	0	; sector table address from BIOS
 18BE 0000      SYSDPB: DW	0	; system dpb address
 18C0 0000      vsectb: dw	0	; verify sector table address
 18C2 0000      vsec:	dw	0	; sector counter for verify
 18C4 0000      vtrk:	dw	0	; track counter
 18C6 00        sptv:	db	0	; temporary sector per track for verify
 18C7 0000      vskew:	dw	0	; temporary address of verify skew table
 18C9 00        TEC:	DB	0	; track error counter
                
 18CA 00000000  MODES:	DB	0,0,0,0 ; mode for curently selected drive
 18CE 00000000  TMODE:	DB	0,0,0,0 ; temporary modes
 18D2 00000000  ORGMODE: DB	0,0,0,0 ; SPACE FOR ORIGINAL MODE VALUE
                
 18D6           	DS	64
 1916           STACK:	DS	0
                
 1916           SAVE$STACK	DS	2
                
 1918           	END
