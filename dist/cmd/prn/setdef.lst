PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE   1


ISIS-II PL/M-80 V3.1 COMPILATION OF MODULE SETDEF
OBJECT MODULE PLACED IN SETDEF.OBJ
COMPILER INVOKED BY:  :F1:PLM80 SETDEF.PLM PAGEWIDTH(132) DEBUG OPTIMIZE



              $ TITLE('CP/M 3.0 --- SETDEF')
   1          setdef:
              do;

              /*
                Copyright (C) 1982
                Digital Research
                P.O. Box 579
                Pacific Grove, CA 93950
              */

              /*
              Written:  27 July 82  by John Knight 
              Modified: 30 Sept 82  by Doug Huskey
              Modified: 03 Dec  82  by Bruce Skidmore
              Modified: 18 May 1998 by John Elliott
              */

              /********************************************
              *                                           *
              *       LITERALS AND GLOBAL VARIABLES       *
              *                       *
              ********************************************/

   2   1      declare
                  true            literally '1',
                  false           literally '0',
                  forever         literally 'while true',
                  lit             literally 'literally',
                  proc            literally 'procedure',
                  dcl             literally 'declare',
                  addr            literally 'address',
                  cr              literally '13',
                  tab         literally '9',
                  lf              literally '10',
                  ctrlc           literally '3',
                  ctrlx           literally '18h',
                  bksp            literally '8',
                  date$flag$offset    literally '0ch',    /* [JCE] Date in UK order? */
                  con$width$offset    literally '1ah',
                  drive0$offset   literally '4ch',
                  drive1$offset   literally '4dh',
                  drive2$offset   literally '4eh',
                  drive3$offset   literally '4fh',
                  temp$drive$offset   literally '50h',
                  ccp$flag1$offset    literally '17h',
                  ccp$flag2$offset    literally '18h',
                  pg$mode$offset  literally '2ch',
                  pg$def$offset   literally '2dh',
                  cpmversion      literally '30h';
                  
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE   2


   3   1        declare drive$table (4) byte;
   4   1        declare order$table (2) byte initial(0);
   5   1        declare drive (4) byte;
   6   1        declare temp$drive byte;
   7   1        declare date$flag byte;   /* [JCE] Date in UK form? */
   8   1        declare ccp$flag1 byte;
   9   1        declare ccp$flag2 byte;
  10   1        declare con$width byte;
  11   1        declare i byte;
  12   1        declare begin$buffer address;
  13   1        declare buf$length byte;

                /* display control variables */
  14   1        declare show$drive   byte initial(true);
  15   1        declare show$order   byte initial(true);
  16   1        declare show$temp    byte initial(true);
  17   1        declare show$page    byte initial(true);
  18   1        declare show$display byte initial(true);
  19   1        declare show$date    byte initial(true);  /* [JCE] */

  20   1        declare scbpd structure
                  (offset byte,
                   set    byte,
                   value  address);

                /* scanner variables and data */
  21   1        declare
                  options(*) byte data
                      ('TEMPORARY~ORDER~PAGE~DISPLAY~NO~COM~SUB~NOPAGE~NODISPLAY',
                        '~ON~OFF~UK~US',0ffh), /* [JCE] added US and UK */
                      
                  options$offset(*) byte data
                      (0,10,16,21,29,32,36,40,47,57,60,64,67,70),

                  drives(*) byte data
                      ('*~A:~B:~C:~D:~E:~F:~G:~H:~I:~J:~K:~',
                       'L:~M:~N:~O:~P:',0ffh),
                                 
                  drives$offset(*) byte data
                      (0,2,5,8,11,14,17,20,23,26,29,32,
                       35,38,41,44,47,49),

                  end$list    byte data (0ffh),

                  delimiters(*) byte data (0,'[]=, ./;()',0,0ffh),

                  SPACE   byte data(5),
                  j       byte initial(0),
                  buf$ptr address,
                  index   byte,
                  endbuf  byte,
                  delimiter   byte;
                  
  22   1          declare end$of$string   byte initial ('~');

  23   1       declare plm label public;
               
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE   3


                /**************************************
                 *                                    *
                 *       B D O S   INTERFACE          *
                 *                                    *
                 **************************************/


  24   1        mon1:
                  procedure (func,info) external;
  25   2            declare func byte;
  26   2            declare info address;
  27   2          end mon1;

  28   1        mon2:
                  procedure (func,info) byte external;
  29   2            declare func byte;
  30   2            declare info address;
  31   2          end mon2;

  32   1        mon3:
                  procedure (func,info) address external;
  33   2            declare func byte;
  34   2            declare info address;
  35   2          end mon3;

  36   1        declare cmdrv     byte    external;   /* command drive      */
  37   1        declare fcb (1)   byte    external;   /* 1st default fcb    */
  38   1        declare fcb16 (1) byte    external;   /* 2nd default fcb    */
  39   1        declare pass0     address external;   /* 1st password ptr   */
  40   1        declare len0      byte    external;   /* 1st passwd length  */
  41   1        declare pass1     address external;   /* 2nd password ptr   */
  42   1        declare len1      byte    external;   /* 2nd passwd length  */
  43   1        declare tbuff (1) byte    external;   /* default dma buffer */


                /**************************************
                 *                                    *
                 *       B D O S   Externals          *
                 *                                    *
                 **************************************/

  44   1        printchar: 
                  procedure(char);
  45   2          declare char byte;
  46   2          call mon1(2,char);
  47   2          end printchar;

  48   1        print$buf:
                  procedure (buffer$address);
  49   2            declare buffer$address address;
  50   2            call mon1 (9,buffer$address);
  51   2          end print$buf;

  52   1        version: procedure address;
                  /* returns current cp/m version # */
  53   2          return mon3(12,0);
  54   2          end version;
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE   4



  55   1        getscbbyte: procedure (offset) byte;
  56   2          declare offset byte;
  57   2          scbpd.offset = offset;
  58   2          scbpd.set = 0;
  59   2          return mon2(49,.scbpd);
  60   2        end getscbbyte;

  61   1        setscbbyte:
                  procedure (offset,value);
  62   2          declare offset byte;
  63   2          declare value byte;
  64   2          scbpd.offset = offset;
  65   2          scbpd.set = 0ffh;
  66   2          scbpd.value = double(value);
  67   2          call mon1(49,.scbpd);
  68   2        end setscbbyte;
                  
                /**************************************
                 *                                    *
                 *       S U B R O U T I N E S        *
                 *                                    *
                 **************************************/


              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                                  * * *  Option scanner  * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


  69   1      separator: procedure(character) byte;

                                  /* determines if character is a 
                                     delimiter and which one */
  70   2          declare k   byte,
                      character   byte;

  71   2          k = 1;
  72   2      loop:   if delimiters(k) = end$list then return(0);
  74   2          if delimiters(k) = character then return(k);    /* null = 25 */
  76   2              k = k + 1;
  77   2              go to loop;

  78   2      end separator;

  79   1      opt$scanner:    procedure(list$ptr,off$ptr,idx$ptr);
                                  /* scans the list pointed at by idxptr
                                     for any strings that are in the 
                                     list pointed at by list$ptr.
                                     Offptr points at an array that 
                                     contains the indices for the known
                                     list. Idxptr points at the index 
                                     into the list. If the input string
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE   5


                                     is unrecognizable then the index is
                                     0, otherwise > 0.

                                  First, find the string in the known
                                  list that starts with the same first 
                                  character.  Compare up until the next
                                  delimiter on the input. if every input
                                  character matches then check for 
                                  uniqueness.  Otherwise try to find 
                                  another known string that has its first
                                  character match, and repeat.  If none
                                  can be found then return invalid.

                                  To test for uniqueness, start at the 
                                  next string in the knwon list and try
                                  to get another match with the input.
                                  If there is a match then return invalid.

                                  else move pointer past delimiter and 
                                  return.

                              P.Balma     */

  80   2          declare
                      buff        based buf$ptr (1) byte,
                      idx$ptr     address,
                      off$ptr     address,
                      list$ptr    address;

  81   2          declare
                      i       byte,
                      j       byte,
                      list        based list$ptr (1) byte,
                      offsets     based off$ptr (1) byte,
                      wrd$pos     byte,
                      character   byte,
                      letter$in$word  byte,
                      found$first byte,
                      start       byte,
                      index       based idx$ptr byte,
                      save$index  byte,
                      (len$new,len$found) byte,
                      valid       byte;

              /*****************************************************************************/
              /*          internal subroutines                     */
              /*****************************************************************************/

  82   2      check$in$list: procedure;
                              /* find known string that has a match with 
                                 input on the first character.  Set index
                                 = invalid if none found.   */
                          
  83   3          declare i   byte;

  84   3          i = start;
  85   3          wrd$pos = offsets(i);
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE   6


  86   3          do while list(wrd$pos) <> end$list;
  87   4              i = i + 1;
  88   4              index = i;
  89   4              if list(wrd$pos) = character then return;
  91   4              wrd$pos = offsets(i);
  92   4          end;
                          /* could not find character */
  93   3          index = 0;
  94   3          return;
  95   3      end check$in$list;

  96   2      setup:  procedure;
  97   3          character = buff(0);
  98   3          call check$in$list;
  99   3          letter$in$word = wrd$pos;
                          /* even though no match may have occurred, position
                             to next input character.  */
 100   3          i = 1;
 101   3          character = buff(1);
 102   3      end setup;

 103   2      test$letter:    procedure;
                          /* test each letter in input and known string */

 104   3          letter$in$word = letter$in$word + 1;

                                  /* too many chars input? 0 means
                                     past end of known string */
 105   3          if list(letter$in$word) = end$of$string then valid = false;
                  else
 107   3          if list(letter$in$word) <> character then valid = false;

                  i = i + 1;
 110   3          character = buff(i);

 111   3      end test$letter;

 112   2      skip:   procedure;
                                  /* scan past the offending string;
                                     position buf$ptr to next string...
                                     skip entire offending string;
                                     ie., falseopt=mod, [note: comma or
                                     space is considered to be group 
                                     delimiter] */
 113   3          character = buff(i);
 114   3          delimiter = separator(character);
                  /* No skip for SETPATH */
 115   3              do while ((delimiter < 1) or (delimiter > 11));
 116   4              i = i + 1;
 117   4              character = buff(i);
 118   4              delimiter = separator(character);
 119   4          end;
 120   3          endbuf = i;
 121   3          buf$ptr = buf$ptr + endbuf + 1;
 122   3          return;
 123   3      end skip;

PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE   7


 124   2      eat$blanks: procedure;

 125   3          declare charac  based buf$ptr byte;


 126   3          do while ((delimiter := separator(charac)) = SPACE);
 127   4              buf$ptr = buf$ptr + 1;
 128   4          end;

 129   3      end eat$blanks;

              /*****************************************************************************/
              /*          end of internals                     */
              /*****************************************************************************/


                                  /* start of procedure */
 130   2          call eat$blanks;
 131   2          start = 0;
 132   2          call setup;

                                  /* match each character with the option
                                     for as many chars as input 
                                     Please note that due to the array
                                     indices being relative to 0 and the
                                     use of index both as a validity flag
                                     and as a index into the option/mods
                                     list, index is forced to be +1 as an
                                     index into array and 0 as a flag*/

 133   2          do while index <> 0;
 134   3              start = index;
 135   3              delimiter = separator(character);

                                  /* check up to input delimiter */

 136   3              valid = true;       /* test$letter resets this */
 137   3              do while delimiter = 0;
 138   4                  call test$letter;
 139   4                  if not valid then go to exit1;
 141   4                  delimiter = separator(character);
 142   4              end;

 143   3              go to good;

                                  /* input ~= this known string;
                                     get next known string that 
                                     matches */
 144   3      exit1:      call setup;
 145   3          end;
                                  /* fell through from above, did
                                     not find a good match*/
 146   2          endbuf = i;         /* skip over string & return*/
 147   2          call skip;
 148   2          return;

                                  /* is it a unique match in options
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE   8


                                     list? */
 149   2      good:   endbuf = i;
 150   2          len$found = endbuf;
 151   2          save$index = index;
 152   2          valid = false;
 153   2      next$opt:
                      start = index;
 154   2              call setup;
 155   2              if index = 0 then go to finished;

                                  /* look at other options and check
                                     uniqueness */

 157   2              len$new = offsets(index + 1) - offsets(index) - 1;
 158   2              if len$new = len$found then do;
 160   3                  valid = true;
 161   3                  do j = 1 to len$found;
 162   4                      call test$letter;
 163   4                      if not valid then go to next$opt;
 165   4                  end;
 166   3              end;
 167   2              else go to nextopt;
                                  /* fell through...found another valid
                                     match --> ambiguous reference */
 168   2          index = 0;
 169   2          call skip;      /* skip input field to next delimiter*/
 170   2          return;

 171   2      finished:           /* unambiguous reference */
                  index = save$index;
 172   2          buf$ptr = buf$ptr + endbuf;
 173   2          call eat$blanks;
 174   2          if delimiter <> 0 then
 175   2                buf$ptr = buf$ptr + 1;
                      else
 176   2                delimiter = 5;
 177   2          return;

 178   2      end opt$scanner;

              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

 179   1      crlf:   proc;
 180   2          call printchar(cr);
 181   2          call printchar(lf);
 182   2          end crlf;

              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

              /* The error processor.  This routine prints the command line
                with a carot '^' under the offending delimiter, or sub-string.
                The code passed to the routine determines the error message
                to be printed beneath the command string.                  */

 183   1      error: procedure (code);
 184   2        declare (code,i,j,nlines,rem) byte;
 185   2        declare (string$ptr,tstring$ptr) address;
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE   9


 186   2        declare chr1 based string$ptr byte;
 187   2        declare chr2 based tstring$ptr byte;
 188   2        declare carot$flag byte;

 189   2      print$command: procedure (size);
 190   3        declare size byte;
 191   3        do j=1 to size;   /* print command string */
 192   4          call printchar(chr1);
 193   4          string$ptr = string$ptr + 1;
 194   4        end;
 195   3        call crlf;
 196   3        do j=1 to size;   /* print carot if applicable */
 197   4          if .chr2 = buf$ptr then do;
 199   5            carot$flag = true;
 200   5            call printchar('^');
 201   5          end;
                  else
 202   4            call printchar(' ');
 203   4          tstring$ptr = tstring$ptr + 1;
 204   4        end;
 205   3        call crlf;
 206   3      end print$command;

 207   2        carot$flag = false;
 208   2        string$ptr,tstring$ptr = begin$buffer;
 209   2        con$width = getscbbyte(con$width$offset);
 210   2        if con$width < 40 then con$width = 40;
 212   2        nlines = buf$length / con$width;  /* num lines to print */
 213   2        rem = buf$length mod con$width;   /* num extra chars to print */
 214   2        if ((code = 1) or (code = 5)) then    /* adjust carot pointer */
 215   2          buf$ptr = buf$ptr - 1;  /* for delimiter errors */
                else
 216   2          buf$ptr = buf$ptr - endbuf - 1; /* all other errors */
 217   2        call crlf;
 218   2        do i=1 to nlines;
 219   3          tstring$ptr = string$ptr;
 220   3          call print$command(con$width);
 221   3        end;
 222   2        call print$command(rem);
 223   2        if carot$flag then
 224   2          call print$buf(.('Error at the ''^''; $'));
                else
 225   2          call print$buf(.('Error at end of line; $'));
 226   2        if con$width < 65 then
 227   2          call crlf;
 228   2        do case code;
 229   3          call print$buf(.('More than four drives specified$'));
 230   3          call print$buf(.('Invalid delimiter$'));
 231   3          call print$buf(.('Invalid drive$'));
 232   3          call print$buf(.('Invalid type for ORDER option$'));
 233   3          call print$buf(.('Invalid option$'));
 234   3          call print$buf(.('End of line expected$'));
 235   3          call print$buf(.('Drive defined twice in search path$'));
 236   3          call print$buf(.('Invalid ORDER specification$'));
 237   3          call print$buf(.('Must be ON or OFF$'));
 238   3        end;
 239   2        call crlf;
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE  10


 240   2        call mon1(0,0);
 241   2      end error;

              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

              /* This is the main screen display for SETPATH.  After every
                 successful operation, this procedure will be called to 
                 show the results.  This routine is also called whenever the
                 user just types SETPATH with no options.                  */

 242   1      display$path: procedure;
 243   2        declare i byte;
 244   2        declare (display$flag,pg$mode,order,date) byte;

                /* GET SETTINGS FROM SYSTEM CONTROL BLOCK */
 245   2        drive(0)     = getscbbyte(drive0$offset);
 246   2        drive(1)     = getscbbyte(drive1$offset);
 247   2        drive(2)     = getscbbyte(drive2$offset);
 248   2        drive(3)     = getscbbyte(drive3$offset);
 249   2        temp$drive   = getscbbyte(temp$drive$offset);
 250   2        pg$mode      = getscbbyte(pg$mode$offset);
 251   2        ccp$flag2    = getscbbyte(ccp$flag2$offset);
 252   2        date$flag    = getscbbyte(date$flag$offset);
 253   2        display$flag = ccp$flag2 and 00$000$011b;
 254   2        order        = shr((ccp$flag2 and 00$011$000b),3);  
 255   2        date         = (date$flag and 1);

                               /* 0 = COM, 1 = COM,SUB, 2 = SUB,COM  */

                /* DRIVE SEARCH PATH */
 256   2        if show$drive then do;
 258   3          call crlf;
 259   3          call print$buf(.('Drive Search Path:',cr,lf,'$'));
 260   3          i = 0;
 261   3          do while ((drive(i) <> 0ffh) and (i < 4));
 262   4            call printchar(i + '1');
 263   4            do case i;
 264   5              call print$buf(.('st$'));
 265   5              call print$buf(.('nd$'));
 266   5              call print$buf(.('rd$'));
 267   5              call print$buf(.('th$'));
 268   5            end;
 269   4               call print$buf(.(' Drive            - $'));
 270   4            if drive(i) = 0 then
 271   4              call print$buf(.('Default$'));
 272   4            else do;
 273   5              call printchar(drive(i) + 40h);
 274   5              call printchar(':');
 275   5            end;
 276   4            call crlf;
 277   4            i = i + 1;
 278   4          end;
 279   3        end;

                /* PROGRAM vs. SUBMIT SEARCH ORDER */
 280   2        if show$order then do;
 282   3          call crlf;
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE  11


 283   3          call print$buf(.('Search Order         - $'));
 284   3          do case order;
 285   4            call print$buf(.('COM$'));
 286   4            call print$buf(.('COM, SUB$'));
 287   4            call print$buf(.('SUB, COM$'));
 288   4          end;
 289   3        end;

                /* TEMPORARY FILE DRIVE */
 290   2        if show$temp then do;
 292   3          call crlf;
 293   3          call print$buf(.('Temporary Drive      - $'));
 294   3          if temp$drive > 16
                    then temp$drive = 0;
 296   3          if temp$drive = 0 then
 297   3            call print$buf(.('Default$'));
 298   3          else do;
 299   4            call printchar(temp$drive + 40h);
 300   4            call printchar(':');
 301   4          end;
 302   3        end;

                /* CONSOLE PAGE MODE */
 303   2        if show$page then do;
 305   3          call crlf;
 306   3          call print$buf(.('Console Page Mode    - $'));
 307   3          if pg$mode = 0 then
 308   3            call print$buf(.('On$'));
                  else
 309   3            call print$buf(.('Off$'));
 310   3        end;

                /* PROGRAM NAME & DRIVE DISPLAY */
 311   2        if show$display then do;
 313   3          call crlf;
 314   3          call print$buf(.('Program Name Display - $'));
 315   3          if display$flag = 0 then
 316   3            call print$buf(.('Off$'));
                  else
 317   3            call print$buf(.('On$'));
 318   3        end;

                /* [JCE] TIME FORMAT DISPLAY */
 319   2        if show$date then do;
 321   3          call crlf;
 322   3          call print$buf(.('Date format used     - $'));
 323   3          if date = 0 then
 324   3            call print$buf(.('US$'));
                  else
 325   3            call print$buf(.('UK$'));
 326   3        end;

 327   2      call crlf;
 328   2      end display$path;

              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE  12


              /* This routine processes the search drives string.  When called
                 this routine scans the command line expecting a drive name, a:-p:.
                 It puts the drive code in a drive table and continues the scan
                 collecting drives until more than 4 drives are specified (an error)
                 or an eoln or the delimiter '[' is encountered.  Next it modifies
                 the SCB searchchain bytes so that it reflects the drive order as
                 inputed.  No check is made to insure that the drive specified is
                 a known drive to the particular system being used.         */

 329   1      process$drives: procedure;
 330   2        declare (i,ct) byte;
 331   2        show$drive = true;
 332   2        index = 0;
 333   2        delimiter = 0;
 334   2        do i=0 to 3;  /* clear drive table */
 335   3          drive$table(i) = 0ffh;
 336   3        end;
 337   2        ct = 0;
 338   2        do while ((delimiter <> 1) and (delimiter <> 11));    /* not eoln */
 339   3          call opt$scanner(.drives(0),.drives$offset(0),.index);
 340   3          if ct > 3 then  /* too many drives */
 341   3            call error(0);
 342   3          if index = 0 then   /* invalid drive */
 343   3            call error(2);
 344   3          do i=0 to 3;
 345   4            if drive$table(i) = (index-1) then
 346   4              call error(6);  /* Drive already defined */
 347   4          end;
 348   3          drive$table(ct) = index-1;
 349   3          ct = ct + 1;
 350   3        end;
 351   2        do i=0 to 3;  /* update scb drive table */
 352   3          call setscbbyte(drive0$offset+i,drive$table(i));
 353   3        end;
 354   2      end process$drives;

              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

              /* This routine does all the processing for the options. Ie. any
                 string beginning with a '['.  The routine will handle basically
                 five options: Temporary, Order, Display, Page, No Display and
                 No Page.  Each routine is fairly short and can be found as a 
                 branch in the case statement.
                 */

 355   1      process$options: procedure;
 356   2        declare next$delim based buf$ptr byte;
 357   2        declare (first$sub,paren,val) byte;
 358   2        do while (delimiter <> 2) and (delimiter <> 11);
 359   3          index = 0;
 360   3          delimiter = 1;
 361   3          call opt$scanner(.options(0),.options$offset(0),.index);
 362   3          do case index;
                    
 363   4            call error(4);        /* not in options list (INVALID) */

 364   4            do;   /* temporary drive option */
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE  13


 365   5              show$temp = true;
 366   5              if delimiter <> 3 then  /* = */
 367   5                call error(1);
 368   5              call opt$scanner(.drives(0),.drives$offset(0),.index);
 369   5              if index = 0 then
 370   5                call error(2);
 371   5              call setscbbyte(temp$drive$offset,index-1);
 372   5            end;
                    
 373   4            do;   /* order option */
 374   5              show$order = true;
 375   5              first$sub,paren = false;
 376   5              if delimiter <> 3 then  /* = */
 377   5                call error(1);
 378   5              do while ((next$delim = ' ') or (next$delim = tab)); /* skip spaces */
 379   6                buf$ptr = buf$ptr + 1;
 380   6              end;
 381   5              if next$delim = '(' then do;
 383   6                paren = true;
 384   6                buf$ptr = buf$ptr + 1;
 385   6              end;
 386   5              call opt$scanner(.options(0),.options$offset(0),.index);
 387   5              if ((index <> 6) and (index <> 7)) then
 388   5                call error(3);
 389   5              if index = 7 then   /* note that the first entry was SUB */
 390   5                first$sub = true;
 391   5              order$table(0) = index - 6;
 392   5              if (first$sub and ((delimiter = 10) or not paren)) then 
 393   5                call error(7); /* (SUB) not allowed */
 394   5              if (delimiter <> 10) and paren then do;
 396   6                call opt$scanner(.options(0),.options$offset(0),.index);
 397   6                if ((index <> 6) and (index <> 7)) then
 398   6                  call error(3);
 399   6                order$table(1) = index - 6;
 400   6                if (first$sub and (index = 7)) then   /* can't have SUB,SUB */
 401   6                  call error(7);
 402   6              end;
 403   5              ccp$flag2 = getscbbyte(ccp$flag2$offset);
 404   5              if order$table(0) = 0 then
 405   5                ccp$flag2 = ccp$flag2 and 111$0$1111b;
                      else
 406   5                ccp$flag2 = ccp$flag2 or 000$1$0000b;
 407   5              if order$table(1) = 0 then
 408   5                ccp$flag2 = ccp$flag2 and 1111$0$111b;
                      else
 409   5                ccp$flag2 = ccp$flag2 or 0000$1$000b;
 410   5              call setscbbyte(ccp$flag2$offset,ccp$flag2);
 411   5              if paren then do;
 413   6                if delimiter <> 10 then
 414   6                  call error(1);
                        else
 415   6                  buf$ptr = buf$ptr + 1;
 416   6              end;
 417   5              else if delimiter = 10 then 
 418   5                  call error(1);
                      if next$delim = ']' or next$delim = 0 then  /* two delimiters */
 420   5                delimiter = 11;   /* eoln, so exit loop */
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE  14


 421   5            end;

                    /* PAGE Option */
 422   4            do;
 423   5              show$page = true;
 424   5              val = 0;
 425   5              if delimiter = 3 then do;  /* = */
 427   6                call opt$scanner(.options(0),.options$offset(0),.index);
 428   6            if index <> 10 then
 429   6                  if index = 11 then
 430   6                    val = 0ffh;
                          else
 431   6                    call error(8);
 432   6              end;
 433   5              call setscbbyte(pg$mode$offset,val);
 434   5              call setscbbyte(pg$def$offset,val);
 435   5            end;
                 
                    /* call error(4); page option now an error */
                        
 436   4            do;    /* DISPLAY option */
 437   5              show$display,val = true;
 438   5              if delimiter = 3 then do;  /* = */
 440   6                call opt$scanner(.options(0),.options$offset(0),.index);
 441   6            if index <> 10 then
 442   6                  if index = 11 then
 443   6                    val = false;
                          else
 444   6                    call error(8);
 445   6              end;
 446   5              ccp$flag2 = getscbbyte(ccp$flag2$offset);
 447   5              if val then
 448   5                ccp$flag2 = ccp$flag2 or 00000$0$11b;  /* set bits */
                      else
 449   5                ccp$flag2 = ccp$flag2 and 11111$1$00b;     /* clear bits */ 
 450   5            call setscbbyte(ccp$flag2$offset,ccp$flag2);
 451   5            end;

                    /* call error(4); Display option now an error */
                    
 452   4            do;    /* NO keyword */
 453   5              call opt$scanner(.options(0),.options$offset(0),.index);
 454   5              if (index <> 3) and (index <> 4) then 
 455   5                call error(4);
 456   5              if index = 3 then do;    /* NO PAGE option */
 458   6                show$page = true;
 459   6                call setscbbyte(pg$mode$offset,0FFh);
 460   6                call setscbbyte(pg$def$offset,0FFh);
 461   6              end;  
 462   5              else do;             /* NO DISPLAY option */
 463   6                show$display = true;
 464   6                ccp$flag2 = getscbbyte(ccp$flag2$offset);
 465   6                ccp$flag2 = ccp$flag2 and 11111$1$00b;     /* clear bits */ 
 466   6                call setscbbyte(ccp$flag2$offset,ccp$flag2);
 467   6              end;
 468   5            end;

PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE  15


                    /* call error(4); NO keyword is now an error */
                   
 469   4            call error(4);        /* COM is not an option */

 470   4            call error(4);        /* SUB is not an option */

                    /* NOPAGE option */
 471   4            do;
 472   5              show$page = true;
 473   5              call setscbbyte(pg$mode$offset,0FFh);
 474   5              call setscbbyte(pg$def$offset,0FFh);
 475   5            end;  

                    /* NODISPLAY option */
 476   4            do;
 477   5              show$display = true;
 478   5              ccp$flag2 = getscbbyte(ccp$flag2$offset);
 479   5              ccp$flag2 = ccp$flag2 and 11111$1$00b;   /* clear bits */ 
 480   5              call setscbbyte(ccp$flag2$offset,ccp$flag2);
 481   5            end;

 482   4            call error(4);        /* ON is not an option */

 483   4            call error(4);        /* OFF is not an option */

                    /* [JCE] UK option */
 484   4            do;
 485   5              show$date = true;
 486   5              date$flag = getscbbyte(date$flag$offset);
 487   5              date$flag = date$flag or 1;  /* Set that bit */ 
 488   5              call setscbbyte(date$flag$offset, date$flag);
 489   5            end;

                    /* [JCE] US option */
 490   4            do;
 491   5              show$date = true;
 492   5              date$flag = getscbbyte(date$flag$offset);
 493   5              date$flag = date$flag and 11111110b;     /* Clear that bit */ 
 494   5              call setscbbyte(date$flag$offset, date$flag);
 495   5            end;

 496   4          end;
 497   3        end;
 498   2      end process$options;

              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

 499   1      input$found: procedure (buffer$adr) byte;
 500   2        declare buffer$adr address;
 501   2        declare char based buffer$adr byte;
 502   2        do while (char = ' ') or (char = 9); /* tabs & spaces */
 503   3          buffer$adr = buffer$adr + 1;
 504   3        end;
 505   2        if char = 0 then  /* eoln */
 506   2          return false;   /* input not found */
                else
 507   2          return true;    /* input found */
PL/M-80 COMPILER    CP/M 3.0 --- SETDEF                                                                                     PAGE  16


 508   2      end input$found;

              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

               /**************************************
              *                                     *
              *       M A I N   P R O G R A M       *
              *                                     *
              **************************************/

 509   1      plm:
                do;
 510   2          if (low(version) < cpmversion) or (high(version) = 1) then do;
 512   3            call print$buf(.('Requires CP/M 3.0$'));
 513   3            call mon1(0,0);
 514   3          end;
 515   2          if not input$found(.tbuff(1)) then do; 
                    /* SHOW DEFAULTS */
 517   3            call display$path;
 518   3            call mon1(0,0);             /* & terminate  */
 519   3          end;

                  /* SET DEFAULTS */
 520   2          i = 1;          /* skip over leading spaces */
 521   2          do while (tbuff(i) = ' ');
 522   3            i = i + 1;
 523   3          end;
 524   2          show$drive,show$order,show$temp,show$page,show$display,show$date /*[JCE]*/ 
                    = false;
 525   2          begin$buffer = .tbuff(1);   /* note beginning of input */
 526   2          buf$length = tbuff(0);      /* note length of input */
 527   2          buf$ptr = .tbuff(i);        /* set up for scanner */
 528   2          if tbuff(i) = '[' then do;  /* options, no drives */
 530   3            buf$ptr = buf$ptr + 1;    /* skip over '[' */
 531   3            call process$options;
 532   3          end;
 533   2          else do;            /* drives first, maybe options too */
 534   3            call process$drives;
 535   3            if delimiter = 1 then /* options, because we found an '[' */
 536   3              call process$options;
 537   3          end;
 538   2          call display$path;      /* show results */
 539   2          call mon1(0,0);             /* & terminate  */
 540   2        end;
 541   1      end setdef;



MODULE INFORMATION:

     CODE AREA SIZE     = 0F0FH   3855D
     VARIABLE AREA SIZE = 0055H     85D
     MAXIMUM STACK SIZE = 000CH     12D
     894 LINES READ
     0 PROGRAM ERROR(S)

END OF PL/M-80 COMPILATION
