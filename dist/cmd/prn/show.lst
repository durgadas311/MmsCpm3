PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE   1


ISIS-II PL/M-80 V3.1 COMPILATION OF MODULE SHOW
OBJECT MODULE PLACED IN SHOW.OBJ
COMPILER INVOKED BY:  :F1:PLM80 SHOW.PLM DEBUG OPTIMIZE PAGEWIDTH(132)



              $ TITLE('CP/M 3.0 --- SHOW 3.1')
              /*
                 Revised:
                  17 May 1998 by John Elliott (year 2000 fix, CP/M Patch 16)
                       Oct 82 by Phillip Balma
                   14 Sept 81 by Doug Huskey
              */

              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                                     * * *  SHOW  * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


   1          show:
              do;
   2   1      declare
                  mpm        literally '30h';

   3   1      declare plm     label public;

   4   1      declare copyright(*) byte data 
                  (' Copyright (c) 1982, 1998 Caldera, Inc. ');

   5   1      declare verdate(*)      byte data('17May98 '),
                      version(*)      byte data('Show 3.1');


              /*
                          copyright(c) 1975, 1976, 1977, 1978, 1979, 1980, 1981,1982
                          digital research
                          box 579
                          pacific grove, ca
                          93950

                */

              /* modified 10/30/78 to fix the space computation */
              /* modified 01/28/79 to remove despool dependencies */
              /* modified 07/26/79 to operate under cp/m 2.0 */
              /* modified 01/20/80 by Thomas Rolander */
              /* show created 05/19/81 */
              /* modified 7/82 to add new options parser, # dir FCB's left, new DISK option,
                 # of files           by Phillip Balma */
              /* added paging, # SFCB's  Phillip Balma*/
              /* Modified 17 May 1998 for Year 2000 fix (John Elliott) */

              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE   2




                                * * *  DISK INTERFACE * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


   6   1      declare         dcnt            byte,
                              anything        byte,
                              dirbuf(128)     byte;

   7   1      declare 
                              line$page       byte,
                              line$out        byte,
                              drives(16)      byte,
                              drive           byte,
                              all             byte initial(0),
                              once$only       byte initial(0),
                              done$drive(16)  byte initial(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),

                              PAGE            byte initial(0),
                              NONBANK         byte initial(0),

                              user(16)        byte,           /* any files in user i? */
                              used(16)        address,        /* # files in user i */
                              free$dir        address,        /* # free directories */
                              nSFCB           address,        /* # SFCB's */

                              SCBPB           structure(
                               where          byte,
                               set            byte,
                               value          address) initial(0,0,0),

                              ERRORM(*)       byte data('ERROR: ',0),
                              input(*)        byte data('INPUT: ',0),
                              eoption(*)      byte data('OPTION: ',0),
                              dirdrive(*)     byte data('DRIVE: ',0),

                              err$unrecopt(*) byte data('Unrecognized Option.',0),
                              err$unrecd(*)   byte data('Unrecognized drive.',0),
                              err$version(*)  byte data('Requires CP/M 3 or higher.',0),
                              err$nolabel(*)  byte 
                                              data('No directory label exists on drive ',0),
                              err$input(*)    byte data('Unrecognized input.',0),

                              opt$dir         byte data(1),
                              opt$drive       byte data(2),
                              opt$label       byte data(3),
                              opt$space       byte data(0),
                              opt$user        byte data(4),
                              opt$page        byte data(6),          /*rel to 1 */
                              opt$nopage      byte data(7);

   8   1              declare

                              dirs(*) byte data
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE   3


                                           ('A:0B:0C:0D:0E:0F:0G:0H:0I:0J:0K:0L:0M:0N:0',
                                            'O:0P:',0ffh),
                              options(*) byte data('SPACE0DIRECTORY0DRIVES0LABEL0USERS0',
                                                    'PAGE0NOPAGE',0ffh),

                              off$dirs(*) byte data(0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,
                                                   45,47),
                              off$opt(*) byte data(0,6,16,23,29,35,40,46),

                              end$list        byte data (0ffh),
                              end$of$string   byte data (0),

                              delimiters(*) byte data (0,'[]=, :;<>%\|"()/#!@&+-*?',0,0ffh),
                              SPACE           byte data(5),   /* index into delim to space */
                              EOS             byte data(25),
                              COMMA           byte data(4),
                              COLON           byte data(6),
                              LBRACKET        byte data(1),
                              RBRACKET        byte data(2),

                              opt$map(21)     structure ( option(5) byte),

                              j               byte initial(0),
                              buf$ptr         address,
                              opt$index       byte,
                              endbuf          byte,
                              delimiter       byte;
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE   4


              $ eject

   9   1      declare
                      maxb            address external,       /* addr field of jmp BDOS */
                      fcb(33)         byte external,          /* default fcb */
                      buff(128)       byte external,          /* default buffer */
                      fcba            literally '.fcb',       /* default fcb */
                      dolla           literally '.fcb(6dh-5ch)',      /* $ position */
                      rreca           literally '.fcb(7dh-5ch)',      /* ran rcd 7d,7e,7f */
                      rreco           literally '.fcb(7fh-5ch)',      /* ran overflow */
                      sectorlen       literally '128',                /* sector length */
                      rrec            address at(rreca),      /* random record address */
                      rovf            byte at(rreco),         /* overflow on getfile */
                      doll            byte at(dolla),         /* dollar parameter */
                      user$code       byte,                   /* current user code */
                      cversion        address,                /* BDOS version # */
                      cdisk           byte,                   /* current disk  */

              /* function call 32 returns the address of the disk parameter
              block for the currently selected disk, which consists of:
                      scptrk      (2 by) number of sectors per track
                      blkshf      (1 by) log2 of blocksize (2**blkshf=blksize)
                      blkmsk      (1 by) 2**blkshf-1
                      extmsk      (1 by) logical/physical extents
                      maxall      (2 by) max alloc number
                      dirmax      (2 by) size of directory-1
                      alloc       (2 by) reservation bits for directory
                      chksiz      (2 by) size of checksum vector
                      offset      (2 by) offset for operating system
                      psh         (1 by) log2 of physical record size(2**psh * 128 = size)
                      psm         (1 by) 2**psh - 1 
              */

                      dpba            address,         /* disk parameter block address */
                      dpb             based dpba structure(
                              spt     address, 
                              bls     byte, 
                              bms     byte, 
                              exm     byte, 
                              mxa     address,
                              dmx     address, 
                              dbl     address, 
                              cks     address, 
                              ofs     address,
                              psh     byte,
                              psm     byte),

                      scptrk  literally 'dpb.spt',
                      blkshf  literally 'dpb.bls',
                      blkmsk  literally 'dpb.bms',
                      extmsk  literally 'dpb.exm',
                      maxall  literally 'dpb.mxa',
                      dirmax  literally 'dpb.dmx',
                      dirblk  literally 'dpb.dbl',
                      chksiz  literally 'dpb.cks',
                      offset  literally 'dpb.ofs',
                      physhf  literally 'dpb.psh',
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE   5


                      phymsk  literally 'dpb.psm';


  10   1      boot: procedure external;
                  /* reboot */
  11   2          end boot;

  12   1      mon1: procedure(f,a) external;
  13   2          declare f byte, a address;
  14   2          end mon1;

  15   1      mon2: procedure(f,a) byte external;
  16   2          declare f byte, a address;
  17   2          end mon2;

  18   1      declare mon3 literally 'mon2a';

  19   1      mon3: procedure(f,a) address external;
  20   2          declare f byte, a address;
  21   2          end mon3;

  22   1      declare alloca address,
                  /* alloca is the address of the disk allocation vector */
                  alloc based alloca (1024) byte;  /* allocation vector */

  23   1      declare
                  true        literally '1',
                  false       literally '0',
                  forever     literally 'while true',
                  lit         literally 'literally',
                  proc        literally 'procedure',
                  dcl         literally 'declare',
                  addr        literally 'address',
                  ctlc        literally '3',
                  cr          literally '13',
                  lf          literally '10';


  24   1      printchar: procedure(char);
  25   2          declare char byte;
  26   2          call mon1(2,char);
  27   2      end printchar;

  28   1      printb: procedure;
                                      /* print blank character */
  29   2          call printchar(' ');
  30   2      end printb;

  31   1      printx: procedure(a);
  32   2          declare a address;
  33   2          declare s based a byte;

  34   2              do while s <> 0;
  35   3                      call printchar(s);
  36   3                      a = a + 1;
  37   3              end;

PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE   6


  38   2      end printx;

  39   1      break: procedure byte;
  40   2          return mon2(11,0);          /* console ready */
  41   2      end break;


  42   1      crlf2: procedure;

  43   2              call printchar(cr);
  44   2              call printchar(lf);

  45   2      end crlf2;


  46   1      terminate: procedure;
  47   2              call crlf2;
  48   2              call mon1 (0,0);                                /* system reset */
  49   2      end terminate;



  50   1      crlf: procedure;

  51   2          if PAGE then do;
  53   3                      line$out = line$out + 1;
  54   3                      if line$out + 2 > line$page then do;

  56   4                              call crlf2;
  57   4                              call crlf2;

  58   4                              call printx(.('Press RETURN to continue.',0));

  59   4                              do while not break;     /* wait until a console break*/
  60   5                              end;
  61   4                              if mon2(1,0) = ctlc then call terminate;
  63   4                              line$out = 1;
  64   4                              call crlf2;
  65   4                      end;
  66   3          end;

  67   2              call crlf2;

  68   2      end crlf;


  69   1      print: procedure(a);
  70   2          declare a address;
                                      /* print the string starting at address a until the
                                         next 0 is encountered */
  71   2          call crlf;
  72   2          call printx(a);

  73   2      end print;


  74   1      get$version: procedure byte;
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE   7


                                              /* returns current cp/m version # */
  75   2          return mon3(12,0);
  76   2      end get$version;

  77   1      select: procedure(d);
  78   2          declare d byte;

  79   2          call mon1(14,d);
  80   2      end select;

  81   1      check$user: procedure;
  82   2          do forever;
  83   3              if anything then return;
  85   3              if dcnt = 0ffh then return;
  87   3              if dirbuf(ror (dcnt,3) and 110$0000b) = user$code then return;

  89   3              dcnt = mon2(18,0);

  90   3          end;
  91   2      end check$user;

  92   1      search: procedure(fcb);
  93   2          declare fcb address;
  94   2          declare fcb0 based fcb byte;

  95   2          anything = (fcb0 = '?');
  96   2          dcnt = mon2(17,fcb);
  97   2          call check$user;
  98   2      end search;

  99   1      searchn: procedure;
 100   2          dcnt = mon2(18,0);
 101   2          call check$user;
 102   2      end searchn;

 103   1      cselect: procedure byte;
                                                      /* return current disk number */
 104   2          return mon2(25,0);
 105   2      end cselect;

 106   1      setdma: procedure(dma);
 107   2          declare dma address;

 108   2          call mon1(26,dma);
 109   2      end setdma;

 110   1      getalloca: procedure address;
                                                      /* get base address of alloc vector */
 111   2          return mon3(27,0);
 112   2      end getalloca;

 113   1      getlogin: procedure address;
                                                      /* get the login vector */
 114   2          return mon3(24,0);
 115   2      end getlogin;

 116   1      getukdate: procedure byte;                /* [JCE] Date in UK format? */
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE   8



 117   2              SCBPB.where = 0ch;
 118   2              return (mon2(49,.SCBPB) and 1);

 119   2      end getukdate;


 120   1      getpage: procedure byte;                /* get the conole page length */

 121   2              SCBPB.where = 01ch;
 122   2              return mon2(49,.SCBPB);

 123   2      end getpage;


 124   1      getpagemode: procedure byte;

 125   2              SCBPB.where = 02ch;
 126   2              return mon2(49,.SCBPB);

 127   2      end getpagemode;

 128   1      getNB: procedure byte;
 129   2             SCBPB.where = 05dh;
 130   2             return high(mon3(49,.SCBPB));
 131   2      end getNB;

 132   1      getrodisk: procedure address;
                                                      /* get the read-only disk vector */
 133   2          return mon3(29,0);
 134   2      end getrodisk;

              /*setind: procedure;
                  call mon1(30,fcba);
              end setind;
              */

 135   1      set$dpb: procedure;
                                                      /* set disk parameter block values */
 136   2          dpba = mon3(31,0);                  /* base of dpb */
 137   2      end set$dpb;

 138   1      getuser: procedure byte;
                                                      /* return current user number */
 139   2          return mon2(32,0ffh);
 140   2      end getuser;

              /*setuser: procedure(user);
                  declare user byte;

                  call mon1(32,user);
              end setuser;
              */

 141   1      getfreesp: procedure(d);
 142   2          declare d byte;

PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE   9


 143   2          call mon1(46,d);
 144   2      end getfreesp;

 145   1      getlbl: procedure(d) byte;
 146   2          declare d byte;

 147   2          return mon2(101,d);
 148   2      end getlbl;

 149   1      e$print: procedure(msg);
 150   2              declare msg     address;

 151   2              call print(.ERRORM);
 152   2              call printx(msg);

 153   2      end e$print;


              /*****************************************************

                        Time & Date ASCII Conversion Code

               *****************************************************/

 154   1      declare tod$adr address;
 155   1      declare tod based tod$adr structure (
                opcode byte,
                date address,
                hrs byte,
                min byte,
                sec byte,
                ASCII (21) byte );

 156   1      declare string$adr address;
 157   1      declare string based string$adr (1) byte;
 158   1      declare index byte;

 159   1      emitchar: procedure(c);
 160   2          declare c byte;
 161   2          string(index := index + 1) = c;
 162   2          end emitchar;

 163   1      emitn: procedure(a);
 164   2          declare a address;
 165   2          declare c based a byte;
 166   2          do while c <> '$';
 167   3            string(index := index + 1) = c;
 168   3            a = a + 1;
 169   3          end;
 170   2          end emitn;


 171   1      emit$bcd: procedure(b);
 172   2          declare b byte;
 173   2          call emitchar('0'+b);
 174   2          end emit$bcd;

PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  10


 175   1      emit$bcd$pair: procedure(b);
 176   2          declare b byte;
 177   2          call emit$bcd(shr(b,4));
 178   2          call emit$bcd(b and 0fh);
 179   2          end emit$bcd$pair;

 180   1      emit$colon: procedure(b);
 181   2          declare b byte;
 182   2          call emit$bcd$pair(b);
 183   2          call emitchar(':');
 184   2          end emit$colon;

 185   1      emit$bin$pair: procedure(b);
 186   2          declare b byte;
 187   2          b = b mod 100;              /* [JCE] Year 2000 fix */
 188   2          call emit$bcd(b/10);        /* makes garbage if not < 10 */
 189   2          call emit$bcd(b mod 10);
 190   2          end emit$bin$pair;

 191   1      emit$slant: procedure(b);
 192   2          declare b byte;
 193   2          call emit$bin$pair(b);
 194   2          call emitchar('/');
 195   2          end emit$slant;

 196   1      declare chr byte;

 197   1      gnc: procedure;
                  /* get next command byte */
 198   2          if chr = 0 then return;
 200   2          if index = 20 then
 201   2          do;
 202   3            chr = 0;
 203   3            return;
 204   3          end;
 205   2          chr = string(index := index + 1);
 206   2          end gnc;

 207   1      deblank: procedure;
 208   2              do while chr = ' ';
 209   3              call gnc;
 210   3              end;
 211   2          end deblank;

 212   1      numeric: procedure byte;
                  /* test for numeric */
 213   2          return (chr - '0') < 10;
 214   2          end numeric;

 215   1      scan$numeric: procedure(lb,ub) byte;
 216   2          declare (lb,ub) byte;
 217   2          declare b byte;
 218   2          b = 0;
 219   2          call deblank;
 220   2          if not numeric then call terminate;
 222   2              do while numeric;
 223   3              if (b and 1110$0000b) <> 0 then call terminate;
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  11


 225   3              b = shl(b,3) + shl(b,1); /* b = b * 10 */
 226   3              if carry then call terminate;
 228   3              b = b + (chr - '0');
 229   3              if carry then call terminate;
 231   3              call gnc;
 232   3              end;
 233   2          if (b < lb) or (b > ub) then call terminate;
 235   2          return b;
 236   2          end scan$numeric;

 237   1      scan$delimiter: procedure(d,lb,ub) byte;
 238   2          declare (d,lb,ub) byte;
 239   2          call deblank;
 240   2          if chr <> d then call terminate;
 242   2          call gnc;
 243   2          return scan$numeric(lb,ub);
 244   2          end scan$delimiter;

 245   1      declare
                  base$year lit '78',   /* base year for computations */
                  base$day  lit '0',    /* starting day for base$year 0..6 */
                  month$size (*) byte data
                  /* jan feb mar apr may jun jul aug sep oct nov dec */
                  (   31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31),
                  month$days (*) address data
                  /* jan feb mar apr may jun jul aug sep oct nov dec */
                  (  000,031,059,090,120,151,181,212,243,273,304,334);

 246   1      leap$days: procedure(y,m) byte;
 247   2          declare (y,m) byte;
                  /* compute days accumulated by leap years */
 248   2          declare yp byte;
 249   2          yp = shr(y,2); /* yp = y/4 */
 250   2          if (y and 11b) = 0 and month$days(m) < 59 then
                      /* y not 00, y mod 4 = 0, before march, so not leap yr */
 251   2              return yp - 1;
                  /* otherwise, yp is the number of accumulated leap days */
 252   2          return yp;
 253   2          end leap$days;

 254   1      declare word$value address;

 255   1      bcd:
                procedure (val) byte;
 256   2          declare val byte;
 257   2          return shl((val/10),4) + val mod 10;
 258   2        end bcd;

 259   1      declare (month, day, year, hrs, min, sec) byte;

 260   1       set$date$time: procedure;
 261   2          declare
                      (i, leap$flag) byte; /* temporaries */
 262   2          month = scan$numeric(1,12) - 1;
                  /* may be feb 29 */
 263   2          if (leap$flag := month = 1) then i = 29;
 265   2              else i = month$size(month);
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  12


 266   2          day   = scan$delimiter('/',1,i);
 267   2          year  = scan$delimiter('/',base$year,99);
                  /* ensure that feb 29 is in a leap year */
 268   2          if leap$flag and day = 29 and (year and 11b) <> 0 then
 269   2              /* feb 29 of non-leap year */ call terminate;
                  /* compute total days */
 270   2          tod.date = month$days(month)
                              + 365 * (year - base$year)
                              + day
                              - leap$days(base$year,0)
                              + leap$days(year,month);

 271   2          tod.hrs   = bcd (scan$numeric(0,23));
 272   2          tod.min   = bcd (scan$delimiter(':',0,59));
 273   2          if tod.opcode = 2 then
                  /* date, hours and minutes only */
 274   2          do;
 275   3            if chr = ':'
                      then i = scan$delimiter (':',0,59);
 277   3            tod.sec = 0;
 278   3          end;
                  /* include seconds */
 279   2          else tod.sec   = bcd (scan$delimiter(':',0,59));

 280   2          end set$date$time;

 281   1      bcd$pair: procedure(a,b) byte;
 282   2          declare (a,b) byte;
 283   2          return shl(a,4) or b;
 284   2          end bcd$pair;


 285   1      compute$year: procedure;
                  /* compute year from number of days in word$value */
 286   2          declare year$length address;
 287   2          year = base$year;
 288   2              do forever;
 289   3              year$length = 365;
 290   3              if (year and 11b) = 0 then /* leap year */
 291   3                  year$length = 366;
 292   3              if word$value <= year$length then
 293   3                  return;
 294   3              word$value = word$value - year$length;
 295   3              year = year + 1;
 296   3              end;
 297   2          end compute$year;

 298   1      declare
                  week$day  byte, /* day of week 0 ... 6 */
                  day$list (*) byte data
                  ('Sun$Mon$Tue$Wed$Thu$Fri$Sat$'),
                  leap$bias byte; /* bias for feb 29 */

 299   1      compute$month: procedure;
 300   2          month = 12;
 301   2              do while month > 0;
 302   3              if (month := month - 1) < 2 then /* jan or feb */
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  13


 303   3                  leapbias = 0;
 304   3              if month$days(month) + leap$bias < word$value then return;
 306   3              end;
 307   2          end compute$month;

 308   1      get$date$time: procedure;
                  /* get date and time */
 309   2          hrs = tod.hrs;
 310   2          min = tod.min;
 311   2          sec = tod.sec;
 312   2          word$value = tod.date;
                  /* word$value contains total number of days */
 313   2          week$day = (word$value + base$day - 1) mod 7;
 314   2          call compute$year;
                  /* year has been set, word$value is remainder */
 315   2          leap$bias = 0;
 316   2          if (year and 11b) = 0 and word$value > 59 then
 317   2              /* after feb 29 on leap year */ leap$bias = 1;
 318   2          call compute$month;
 319   2          day = word$value - (month$days(month) + leap$bias);
 320   2          month = month + 1;
 321   2          end get$date$time;

 322   1      emit$date$time: procedure;

 323   2          if tod.opcode = 0 then
 324   2            do;
 325   3            call emitn(.day$list(shl(week$day,2)));
 326   3            call emitchar(' ');
 327   3            end;
 328   2          if getukdate = 0 then   /* [JCE] Vary the date format */
 329   2            do;
 330   3            call emit$slant(month);
 331   3            call emit$slant(day);
 332   3            end;
                  else
 333   2            do;
 334   3            call emit$slant(day);
 335   3            call emit$slant(month);
 336   3            end;          /* [JCE] ends */
 337   2          call emit$bin$pair(year);
 338   2          call emitchar(' ');
 339   2          call emit$colon(hrs);
 340   2          call emit$colon(min);
 341   2          if tod.opcode = 0 then
 342   2            call emit$bcd$pair(sec);
 343   2          end emit$date$time;

 344   1      tod$ASCII:
                procedure (parameter);
 345   2          declare parameter address;
 346   2          declare ret address;

 347   2          ret = 0;
 348   2          tod$adr = parameter;
 349   2          string$adr = .tod.ASCII;
 350   2          if  (tod.opcode = 0) or
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  14


                      (tod.opcode = 3) then
 351   2          do;
 352   3            call get$date$time;
 353   3            index = -1;
 354   3            call emit$date$time;
 355   3          end;
                  else
 356   2          do;
 357   3            if (tod.opcode = 1) or
                       (tod.opcode = 2) then
 358   3            do;
 359   4              chr = string(index:=0);
 360   4              call set$date$time;
 361   4              ret = .string(index);
 362   4            end;
                    else
 363   3            do;
 364   4              call terminate;
 365   4            end;
 366   3          end;
 367   2        end tod$ASCII;

              /********************************************************


                                TOD INTERFACE TO SHOW


               ********************************************************/


 368   1        declare lcltod structure (
                  opcode byte,
                  date address,
                  hrs byte,
                  min byte,
                  sec byte,
                  ASCII (21) byte );

              /*  declare extrnl$todadr address;
                declare extrnl$tod based extrnl$todadr structure (
                  date address,
                  hrs byte,
                  min byte,
                  sec byte );
              */

 369   1        declare ret address;

              /*  display$tod:
                  procedure;
                    lcltod.opcode = 0; 
                    call move (5,.extrnl$tod.date,.lcltod.date);
                    call tod$ASCII (.lcltod);
                    call write$console (0dh);
                    do i = 0 to 20;
                      call write$console (lcltod.ASCII(i));
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  15


                    end;
                  end display$tod; */

 370   1        display$ts:
                   procedure (tsadr);
 371   2           dcl i byte;
 372   2           dcl tsadr address;
 373   2           lcltod.opcode = 3;         /* display time and date stamp, no seconds */
 374   2           call move (4,tsadr,.lcltod.date);  /* don't copy seconds */
 375   2           call tod$ASCII (.lcltod);
 376   2           do i = 0 to 13;
 377   3             call printchar (lcltod.ASCII(i));
 378   3           end;       
 379   2        end display$ts;

              /******** End TOD Code ********/




              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                                     * * *  BASIC ROUTINES * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


 380   1      declare
                  fcbmax literally '512'; /* max fcb count */

 381   1      declare bpb address; /* bytes per block */


 382   1      set$bpb: procedure;

 383   2          call set$dpb;                               /* disk parameters set */
 384   2          bpb = shl(double(1),blkshf) * sectorlen;

 385   2      end set$bpb;


 386   1      select$disk: procedure(d);
 387   2          declare d byte;
                                                              /* select disk and set bpb */
 388   2          call select(cdisk:=d);
 389   2          call set$bpb;                               /* bytes per block */

 390   2      end select$disk;


 391   1      getalloc: procedure(i) byte;    /* return the ith bit of the alloc vector */
 392   2          declare i address;

 393   2          return
                  rol(alloc(shr(i,3)), (i and 111b) + 1);
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  16


 394   2          end getalloc;


              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


                                /* fill string @ s for c bytes with f */
 395   1      fill:   proc(s,f,c);
 396   2          dcl s addr,
                      (f,c) byte,
                      a based s byte;

 397   2              do while (c:=c-1)<>255;
 398   3              a = f;
 399   3              s = s+1;
 400   3              end;
 401   2          end fill;


              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                                 * * *  PRINT A NUMBER  * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


 402   1      declare
                  val (7) byte initial(0,0,0,0,0,0,0),   /* BCD digits    */
                  fac (7) byte initial(0,0,0,0,0,0,0),   /* hibyte factor */
                  f0  (7) byte initial(6,3,5,5,6,0,0),   /*    65,536     */
                  f1  (7) byte initial(2,7,0,1,3,1,0),   /*   131,072     */
                  f2  (7) byte initial(4,4,1,2,6,2,0),   /*   262,144     */
                  f3  (7) byte initial(8,8,2,4,2,5,0),   /*   524,288     */
                  f4  (7) byte initial(6,7,5,8,4,0,1),   /* 1,048,576     */
                  f5  (7) byte initial(2,5,1,7,9,0,2),   /* 2,097,152     */
                  f6  (7) byte initial(4,0,3,4,9,1,4),   /* 4,194,304     */
                  ptr (7) address initial(.f0,.f1,.f2,.f3,.f4,.f5,.f6);



                                /* print decimal value of address v */
 403   1      pdecimal: procedure(v,prec,zerosup);
                  /* print value v with precision prec (1,10,100,1000,10000)
                  with leading zero suppression if zerosup = true */
 404   2          declare
                      v address,    /* value to print */
                      prec address, /* precision */
                      zerosup byte, /* zero suppression flag */
                      d byte;       /* current decimal digit */

 405   2              do while prec <> 0;
 406   3                      d = v / prec;           /* get next digit */
 407   3                      v = v mod prec;         /* get remainder back to v */
 408   3                      prec = prec/10;         /* ready for next digit */

PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  17


 409   3                      if prec = 0 then go to pd0;
 411   3                      if d <> 0 then go to pd0;
 413   3                      if zerosup then do;
 415   4                              call printb;
 416   4                              go to pd1;
 417   4                      end;
 418   3      pd0:                    zerosup = false;
 419   3                              call printchar('0'+d);
 420   3      pd1:    end;

 421   2      end pdecimal;

              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


                                /* BCD - convert 16 bit binary to 
                                   7 one byte BCD digits */
 422   1      getbcd: procedure(value);
 423   2          declare
                      (value,prec) address,
                      i byte;

 424   2          prec = 10000;
 425   2          i = 5;                            /* digits: 4,3,2,1,0 */
 426   2              do while prec <> 0;
 427   3              val(i:=i-1) = value / prec;   /* get next digit */
 428   3              value = value mod prec;       /* remainder in value */
 429   3              prec = prec / 10;
 430   3              end;
 431   2          end getbcd;
              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


                                /* print BCD number in val array */
 432   1      printbcd: procedure;
 433   2         declare 
                     (zerosup, i) byte;

 434   2         pchar: procedure(c);
 435   3             declare c byte;
 436   3             if val(i) = 0 then
 437   3                 if zerosup then 
 438   3                     if i <> 0 then do;
 440   4                         call printb;
 441   4                         return;
 442   4                         end;
                     /* else */
 443   3             call printchar(c);
 444   3             zerosup = false;
 445   3         end pchar;

 446   2         zerosup = true;
 447   2         i = 7;
 448   2             do while (i:=i-1) <> -1;
 449   3             call pchar('0'+val(i));
 450   3             if i = 6 or i = 3 then 
 451   3                 call pchar(',');
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  18


 452   3             end;
 453   2         end printbcd;
              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


                                /* add two BCD numbers result in second */
 454   1      add: procedure(ap,bp);
 455   2          declare
                      (ap,bp)        address,
                      a based ap (7) byte,
                      b based bp (7) byte,
                      (c,i)          byte;

 456   2          c = 0;                               /* carry   */
 457   2              do i = 0 to 6;                   /* 0 = LSB */
 458   3              b(i) = a(i) + b(i) + c;
 459   3              c = b(i) / 10;
 460   3              b(i) = b(i) mod 10;
 461   3              end;
 462   2          end add;
              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


                                /* print 3 byte value based at byte3adr */
 463   1      p3byte: procedure(byte3adr);
 464   2         declare
                    i         byte,  
                    high$byte byte,
                    byte3adr  address,
                    b3 based  byte3adr structure (
                        lword address,
                        hbyte byte);

 465   2          call fill(.val,0,7);
 466   2          call fill(.fac,0,7);
 467   2          call getbcd(b3.lword);         /* put 16 bit value in val */
 468   2          high$byte = b3.hbyte;
 469   2              do i = 0 to 6;                 /* factor for bit i */
 470   3              if high$byte then              /* LSB is 1 */
 471   3                  call add(ptr(i),.fac);     /* add in factor */
 472   3              high$byte = shr(high$byte,1);  /* get next bit  */
 473   3              end;
 474   2          call add(.fac,.val);              /* add factor to value */
 475   2          call printbcd;                    /* print value */
 476   2          end p3byte;


                      /* divide 3 byte value by 8 */
 477   1      shr3byte: procedure(byte3adr);
 478   2            dcl byte3adr address,
                        b3 based byte3adr structure (
                        lword address,
                        hbyte byte),
                        temp1 based byte3adr (2) byte,
                        temp2 byte;

 479   2              temp2  = ror(b3.hbyte,3) and 11100000b;  /* get 3 bits */
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  19


 480   2              b3.hbyte = shr(b3.hbyte,3);
 481   2              b3.lword = shr(b3.lword,3);
 482   2              temp1(1) = temp1(1) or temp2;   /* or in 3 bits from hbyte */
 483   2              end shr3byte;


                      /* multiply 3 byte value by #records per block */
 484   1      shl3byte: procedure(byte3adr);
 485   2            dcl byte3adr address,
                        b3 based byte3adr structure (
                        lword address,
                        hbyte byte),
                        temp1 based byte3adr (2) byte;

 486   2              b3.hbyte = (rol(temp1(1),blkshf) and blkmsk) or shl(b3.hbyte,blkshf);
 487   2              b3.lword = shl(b3.lword,blkshf);
 488   2              end shl3byte;


 489   1      show$drive: procedure;

 490   2              call printchar(cdisk+'A');
 491   2              call printx(.(': ',0));

 492   2      end show$drive;




              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                              * * *  CALCULATE SIZE  * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


 493   1      add$block: procedure(ak,ab);
 494   2          declare (ak, ab) address;
                  /* add one block to the kilobyte accumulator */
 495   2          declare kaccum based ak address; /* kilobyte accum */
 496   2          declare baccum based ab address; /* byte accum */
 497   2          baccum = baccum + bpb;
 498   2              do while baccum >= 1024;
 499   3              baccum = baccum - 1024;
 500   3              kaccum = kaccum + 1;
 501   3              end;
 502   2          end add$block;

 503   1      count: procedure(mode) address;
 504   2          declare mode byte; /* true if counting 0's */
                  /* count kb remaining, kaccum set upon exit */
 505   2          declare
                      ka  address,  /* kb accumulator */
                      ba  address,  /* byte accumulator */
                      i   address,  /* local index */
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  20


                      bit byte;     /* always 1 if mode = false */
 506   2          ka, ba = 0;
 507   2          bit = 0;
 508   2              do i = 0 to maxall;
 509   3              if mode then bit = getalloc(i);
 511   3              if not bit then call add$block(.ka,.ba);
 513   3              end;
 514   2          return ka;
 515   2          end count;




              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                               * * *  STATUS ROUTINES  * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */



                                                /* characteristics of current drive */
 516   1      drivestatus: procedure;
 517   2            dcl b3a address,
                        b3 based b3a structure (
                           lword address,
                           hbyte byte),

                        psize address;


                                               /* print 3 byte value */
 518   2          pv3: procedure;
 519   3               call crlf;
 520   3               call p3byte(.dirbuf);
 521   3               call printchar(':');
 522   3               call printb;
 523   3          end pv3;

                                               /* print address value v */
 524   2           pv: procedure(v);
 525   3               dcl v address;
 526   3               b3.hbyte = 0;
 527   3               b3.lword = v;
 528   3               call pv3;
 529   3           end pv;

                  /* print the characteristics of the currently selected drive */

 530   2          b3a = .dirbuf;
 531   2          call print(.('        ',0));
 532   2          call show$drive;
 533   2          call printx(.('Drive Characteristics',0));
 534   2          b3.hbyte = 0;
 535   2          b3.lword = maxall + 1;       /* = # blocks */
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  21


 536   2          call shl3byte(.dirbuf);        /* # blocks * records/block */
 537   2          call pv3;
 538   2          call printx(.('128 Byte Record Capacity',0));
 539   2          call shr3byte(.dirbuf);        /* divide by 8 */
 540   2          call pv3;
 541   2          call printx(.('Kilobyte Drive  Capacity',0));
 542   2          call pv(dirmax+1);
 543   2          call printx(.('32 Byte  Directory Entries',0));
 544   2          call pv(shl(chksiz,2));
 545   2          call printx(.('Checked  Directory Entries',0));
 546   2          call pv((extmsk+1) * 128);
 547   2          call printx(.('Records / Directory Entry',0));
 548   2          call pv(shl(double(1),blkshf));
 549   2          call printx(.('Records / Block',0));
 550   2          call pv(scptrk);
 551   2          call printx(.('Records / Track',0));    /* [JCE] Saying "Sectors" is */
 552   2          call pv(offset);                /* misleading if sector size */
 553   2          call printx(.('Reserved  Tracks',0));   /* is >128 bytes */

 554   2              psize = 128;            /* 2**psh * 128 */
 555   2              if physhf > 0 then psize = shl(psize,physhf);

 557   2              call pv(psize);
 558   2              call printx(.('Bytes / Physical Record',0));
 559   2              call crlf;

 560   2          end drivestatus;
              /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                                     * * *  DISK STATUS  * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


 561   1      pvalue: procedure(v);
 562   2          declare (d,zero) byte,
                      (k,v) address;
 563   2          k = 10000;
 564   2          zero = false;
 565   2              do while k <> 0;
 566   3              d = low(v/k); v = v mod k;
 568   3              k = k / 10;
 569   3              if zero or k = 0 or d <> 0 then
 570   3                   do; zero = true; call printchar('0'+d);
 573   4                   end;
 574   3              end;
 575   2          end pvalue;


 576   1      prcount: procedure;

                  /* print the actual byte count */
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  22


 577   2          if cversion < mpm then do;
 579   3              alloca = getalloca;
 580   3              call pvalue(count(true));
 581   3              end;
 582   2          else do;
 583   3              call setdma(.dirbuf);
 584   3              call getfreesp(cdisk);
 585   3              call shr3byte(.dirbuf);
 586   3              call p3byte(.dirbuf);
 587   3              end; 
 588   2          call printchar('k');
 589   2          end prcount;

 590   1      stat: procedure(rodisk);
 591   2              declare rodisk address;

 592   2              call crlf;
 593   2              call show$drive;
 594   2              call printchar('R');
 595   2              if low(rodisk) then
 596   2                  call printchar('O'); else
 597   2                  call printchar('W');
 598   2              call printx(.(', Space: ',0));
 599   2              call prcount;
 600   2              end stat;

 601   1      prstatus: procedure;            /* print the status of the disk system */
 602   2          declare (login, rodisk) address;
 603   2          declare (d,save) byte;

 604   2              if once$only then return;               /* only execute this once if 
                                                                 all was specified > 1 */

 606   2              save = cdisk;
 607   2              login = getlogin;                       /* login vector set */
 608   2              rodisk = getrodisk;                     /* read only disk vector set */

 609   2              d = 0;
 610   2              do while login <> 0;
 611   3                      if low(login) then do; 
 613   4                              if not all then do;     /* do specified disk */
 615   5                                 if d = save then call stat(rodisk);
 617   5                              end;

 618   4                              else do;
 619   5                                      call select$disk(d);    /* do all disks */
 620   5                                      call stat(rodisk);              
 621   5                              end;
 622   4                      end;

 623   3                      login = shr(login,1); rodisk = shr(rodisk,1);
 625   3                      d = d + 1;
 626   3              end;

 627   2              if all then once$only = true;
 629   2              call crlf;

PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  23


 630   2          end prstatus;




              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                              * * *  USER STATUS * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


 631   1      prdir: procedure;

 632   2              call crlf;
 633   2              call crlf;
 634   2              call show$drive;

 635   2              if nSFCB > 0 then do;
 637   3                      call printx(.('Number of time/date directory entries: ',0));
 638   3                      call pdecimal(nSFCB,1000,true);
 639   3                      call crlf;
 640   3                      call show$drive;
 641   3              end;

 642   2              call printx(.('Number of free directory entries:      ',0));
 643   2              call pdecimal(free$dir,1000,true);
 644   2              call crlf;

 645   2      end prdir;


 646   1      get$usr$files: procedure;
 647   2              declare ufcb(*) byte data ('????????????',0,0,0),
                              (i,j)   byte,
                              nfcbs   address,
                              extptr  address,
                              modptr  address,
                              fmod    based modptr byte,
                              fext    based extptr byte;

 648   2              do i = 0 to 15;
 649   3                      user(i),used(i) = 0;
 650   3              end;
 651   2              nSFCB = 0;

 652   2              call setdma(.dirbuf);
 653   2              call search(.ufcb);
 654   2              nfcbs = 0;

 655   2              do while dcnt <> 255;
 656   3                      j = shl(dcnt,5);                /* which fcb in dirbuf */

 657   3      ge0:            if (i := dirbuf(j)) <> 0e5h then do;
 659   4                        if i <> 33 then do;           /* SFCB ? */
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  24


 661   5                              extptr = .dirbuf(j + 12);
 662   5                              modptr = extptr + 2;
 663   5                              nfcbs = nfcbs + 1;
 664   5                              j = i;                  /* save for xfcb test */
 665   5                              user(i := i and 0fh) = true;

 666   5                              if j > 15 then go to ge2;
 668   5                              if fext > extmsk then go to ge2;
 670   5                              if fmod = 0 then used(i) = used(i) + 1;
 672   5                        end;
 673   4                        else nSFCB = nSFCB + 1;
 674   4                      end;

 675   3      ge2:            call searchn;
 676   3              end;

 677   2              done$drive(cdisk) = true;
 678   2              if nSFCB > 0 then nSFCB = shr(dirmax+1,2);      /* because search ends
                                                                         at high water mark*/
 680   2              free$dir = ((dirmax + 1) - nSFCB) - nfcbs;

 681   2      end get$usr$files;


 682   1      userstatus: procedure;          /* display active user numbers */
 683   2          declare i byte;

 684   2              call crlf;
 685   2              call show$drive;
 686   2              call printx(.('Active User :',0,0)); /* [JCE] Patch 16 */
 687   2              call pdecimal(getuser,1000,true);
 688   2              call crlf;
 689   2              call show$drive;
 690   2              call printx(.('Active Files:',0,0)); /* [JCE] Patch 16 */

 691   2              if not done$drive(cdisk) then call get$usr$files;

 693   2              do i = 0 to last(user);
 694   3                      if user(i) then call pdecimal(i,1000,true);
 696   3              end;

 697   2              call crlf;
 698   2              call show$drive;
 699   2              call printx(.('# of files  :',0,0));    /* [JCE] Patch 16 */
 700   2              do i = 0 to last(user);
 701   3                      if user(i) then call pdecimal(used(i),1000,true);
 703   3              end;

 704   2              call prdir;

 705   2      end userstatus;



              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  25


                          * * *  DISK & FILE STATUS * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */



 706   1      directory: procedure;

 707   2              if not done$drive(cdisk) then call get$usr$files;
 709   2              call prdir;

 710   2      end directory;

              /*******************************************************

                              L A B E L   S T A T U S

              ********************************************************/

 711   1      readlbl: proc(relog);
 712   2              declare relog   byte,
                              d       byte data('?');

 713   2          call setdma(.dirbuf);
 714   2          call search(.d);
 715   2          if relog > 0 then return;

 717   2          do while dcnt <> 0ffH;
 718   3              if dirbuf(ror(dcnt,3) and 110$0000b)=20H then return;
 720   3              call searchn;
 721   3          end;

 722   2      end readlbl;

              /* HEADER */

 723   1      dcl label1 (*) byte data (
              'Directory     Passwds  Stamp   Stamp',0);
 724   1      dcl label2 (*) byte data (
              'Label         Reqd     ',0);
 725   1      dcl label3 (*) byte data (
                                                  '  Update  Label Created   Label Updated',0)

              ;
 726   1      dcl label4 (*) byte data (
              '------------  -------  ------  ------  --------------  --------------',0

              );


 727   1      labelstatus: procedure;
 728   2          dcl lbl             byte;
 729   2          dcl fnam lit '11';
 730   2          dcl ftyp lit '9';
 731   2          dcl fcbp address;
 732   2          dcl fcbv based fcbp (32) byte;      /* template over dirbuf */
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  26



 733   2        printfn: proc;                        /* print file name */
 734   3              declare k byte;

 735   3              do k = 1 to fnam;
 736   4                      if k = ftyp then 
 737   4                          call printchar('.');
 738   4                      call printchar(fcbv(k) and 7fh);
 739   4              end;
 740   3        end printfn;


 741   2          lbl = getlbl(cdisk);
 742   2          if lbl > 0 then do;
 744   3              call readlbl(0);
 745   3              fcbp = shl(dcnt,5) + .dirbuf;

 746   3              call print(.('Label for drive ',0));    /* print heading */
 747   3              call show$drive;
 748   3              call crlf;
 749   3              call print(.label1);
 750   3              call print(.label2);
 751   3              if (lbl and 40h) = 40h then
 752   3                  call printx(.('Access',0));
                      else
 753   3                  call printx(.('Create',0));
 754   3              call printx(.label3);
 755   3              call print(.label4);
 756   3              call crlf;
 757   3              call printfn;
 758   3              if not NONBANK and ((lbl and 80h) = 80h) then
 759   3                  call printx(.('    on   ',0));
                      else
 760   3                  call printx(.('    off  ',0));

 761   3              if (lbl and 40h) = 40h then
 762   3                  call printx(.('   on   ',0));
 763   3              else if(lbl and 10h) = 10h then
 764   3                  call printx(.('   on   ',0));
 765   3              else call printx(.('   off  ',0));

 766   3              if (lbl and 20h) = 20h then
 767   3                  call printx(.('   on ',0));
                      else
 768   3                  call printx(.('   off',0));

 769   3              call printx(.('    ',0));
 770   3              call display$ts(.fcbv(24));
 771   3              call printx(.('  ',0));
 772   3              call display$ts(.fcbv(28));
 773   3              end;
 774   2          else do;
 775   3              call e$print(.err$nolabel);
 776   3              call printchar(cdisk+'A');
 777   3          end;

 778   2          call crlf;
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  27



 779   2      end labelstatus;


PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  28


              $eject
              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                                  * * *  Option scanner  * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


 780   1      separator: procedure(character) byte;

                                                      /* determines if character is a 
                                                         delimiter and which one */
 781   2              declare k       byte,
                              character       byte;

 782   2              k = 1;
 783   2      loop:   if delimiters(k) = end$list then return(0);
 785   2              if delimiters(k) = character then return(k);    /* null = 25 */
 787   2                      k = k + 1;
 788   2                      go to loop;

 789   2      end separator;

 790   1      opt$scanner:    procedure(list$ptr,off$ptr) byte;
                                                      /* scans the list pointed at by idxptr
                                                         for any strings that are in the 
                                                         list pointed at by list$ptr.
                                                         Offptr points at an array that 
                                                         contains the indices for the known
                                                         list. Idxptr points at the index 
                                                         into the list. If the input string
                                                         is unrecognizable then the index is
                                                         0, otherwise > 0.

                                                      First, find the string in the known
                                                      list that starts with the same first 
                                                      character.  Compare up until the next
                                                      delimiter on the input. if every input
                                                      character matches then check for 
                                                      uniqueness.  Otherwise try to find 
                                                      another known string that has its first
                                                      character match, and repeat.  If none
                                                      can be found then return invalid.

                                                      To test for uniqueness, start at the 
                                                      next string in the knwon list and try
                                                      to get another match with the input.
                                                      If there is a match then return invalid.

                                                      else move pointer past delimiter and 
                                                      return.

                                              P.Balma         */

 791   2              declare
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  29


                              buff            based buf$ptr (1) byte,
                              off$ptr         address,
                              list$ptr        address;

 792   2              declare
                              i               byte,
                              j               byte,
                              list            based list$ptr (1) byte,
                              offsets         based off$ptr (1) byte,
                              wrd$pos         byte,
                              character       byte,
                              letter$in$word  byte,
                              found$first     byte,
                              start           byte,
                              index           byte,
                              save$index      byte,
                              (len$new,len$found)     byte,
                              valid           byte;

              /*****************************************************************************/
              /*                      internal subroutines                                 */
              /*****************************************************************************/

 793   2      check$in$list: procedure;
                                              /* find known string that has a match with 
                                                 input on the first character.  Set index
                                                 = invalid if none found.   */
                                      
 794   3              declare i       byte;

 795   3              i = start;
 796   3              wrd$pos = offsets(i);
 797   3              do while list(wrd$pos) <> end$list;
 798   4                      i = i + 1;
 799   4                      index = i;
 800   4                      if list(wrd$pos) = character then return;
 802   4                      wrd$pos = offsets(i);
 803   4              end;
                                      /* could not find character */
 804   3              index = 0;
 805   3              return;
 806   3      end check$in$list;

 807   2      setup:  procedure;
 808   3              character = buff(0);
 809   3              call check$in$list;
 810   3              letter$in$word = wrd$pos;
                                      /* even though no match may have occurred, position
                                         to next input character.  */
 811   3              i = 1;
 812   3              character = buff(1);
 813   3      end setup;

 814   2      test$letter:    procedure;
                                      /* test each letter in input and known string */

 815   3              letter$in$word = letter$in$word + 1;
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  30



                                                      /* too many chars input? 0 means
                                                         past end of known string */
 816   3              if list(letter$in$word) = end$of$string then valid = false;
                      else
 818   3              if list(letter$in$word) <> character then valid = false;

                      i = i + 1;
 821   3              character = buff(i);

 822   3      end test$letter;

 823   2      skip:   procedure;
                                                      /* scan past the offending string;
                                                         position buf$ptr to next string...
                                                         skip entire offending string;
                                                         ie., falseopt=mod, [note: comma or
                                                         space is considered to be group 
                                                         delimiter] */
 824   3              character = buff(i);
 825   3              delimiter = separator(character);
 826   3              do while ((delimiter <> 2) and (delimiter <> 4) and (delimiter <> 5)
                                 and (delimiter <> 25));
 827   4                      i = i + 1;
 828   4                      character = buff(i);
 829   4                      delimiter = separator(character);
 830   4              end;
 831   3              endbuf = i;
 832   3              buf$ptr = buf$ptr + endbuf + 1;
 833   3              return;
 834   3      end skip;

 835   2      eat$blanks: procedure;

 836   3              declare charac  based buf$ptr byte;


 837   3              do while(delimiter := separator(charac)) = SPACE;
 838   4                      bufptr = buf$ptr + 1;
 839   4              end;

 840   3      end eat$blanks;

              /*****************************************************************************/
              /*                      end of internals                                     */
              /*****************************************************************************/


                                                      /* start of procedure */
 841   2              call eat$blanks;
 842   2              start = 0;
 843   2              call setup;

                                                      /* match each character with the option
                                                         for as many chars as input 
                                                         Please note that due to the array
                                                         indices being relative to 0 and the
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  31


                                                         use of index both as a validity flag
                                                         and as a index into the option/mods
                                                         list, index is forced to be +1 as an
                                                         index into array and 0 as a flag*/

 844   2              do while index <> 0;
 845   3                      start = index;
 846   3                      delimiter = separator(character);

                                                      /* check up to input delimiter */

 847   3                      valid = true;           /* test$letter resets this */
 848   3                      do while delimiter = 0;
 849   4                              call test$letter;
 850   4                              if not valid then go to exit1;
 852   4                              delimiter = separator(character);
 853   4                      end;

 854   3                      go to good;

                                                      /* input ~= this known string;
                                                         get next known string that 
                                                         matches */
 855   3      exit1:          call setup;
 856   3              end;
                                                      /* fell through from above, did
                                                         not find a good match*/
 857   2              endbuf = i;                     /* skip over string & return*/
 858   2              call skip;
 859   2              return(index);

                                                      /* is it a unique match in options
                                                         list? */
 860   2      good:   endbuf = i;
 861   2              len$found = endbuf;
 862   2              save$index = index;
 863   2              valid = false;
 864   2      next$opt:
                              start = index;
 865   2                      call setup;
 866   2                      if index = 0 then go to finished;

                                                      /* look at other options and check
                                                         uniqueness */

 868   2                      len$new = offsets(index + 1) - offsets(index) - 1;
 869   2                      if len$new = len$found then do;
 871   3                              valid = true;
 872   3                              do j = 1 to len$found;
 873   4                                      call test$letter;
 874   4                                      if not valid then go to next$opt;
 876   4                              end;
 877   3                      end;
 878   2                      else go to nextopt;
                                                      /* fell through...found another valid
                                                         match --> ambiguous reference */
 879   2              index = 0;
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  32


 880   2              call skip;              /* skip input field to next delimiter*/
 881   2              return(0);

 882   2      finished:                       /* unambiguous reference */
                      index = save$index;
 883   2              buf$ptr = buf$ptr + endbuf;
 884   2              call eat$blanks;
 885   2              if delimiter <> 0 then  buf$ptr = buf$ptr + 1;
 887   2              else delimiter = SPACE;
 888   2              return(index);

 889   2      end opt$scanner;

 890   1      error$prt:      procedure;
 891   2              declare i       byte,
                              t       address,
                              char    based t byte;

 892   2              t = buf$ptr - endbuf - 1;
 893   2              do i = 1 to endbuf;
 894   3                      call printchar(char);
 895   3                      t = t + 1;
 896   3              end;

 897   2      end error$prt;

PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  33


              $eject
              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                                  * * *  EXECUTE * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

 898   1      do$option: procedure(i);
 899   2              declare i       byte;


 900   2                      if opt$map(i).option(opt$space) <> 0 then call prstatus;
 902   2                      if opt$map(i).option(opt$label) <> 0 then call labelstatus;
 904   2                      if opt$map(i).option(opt$drive) <> 0 then call drivestatus;
 906   2                      if opt$map(i).option(opt$user) <> 0 then call userstatus;
 908   2                      if opt$map(i).option(opt$dir) <> 0 then call directory;

 910   2      end do$option;

PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  34


              $eject

              /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


                                  * * *  PARSING  * * *


               * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

 911   1      declare         character       based buf$ptr byte;

 912   1      setdef$drive: procedure;

 913   2              if drive = 0ffh then do;
 915   3                      drive = cdisk;
 916   3                      drives(drive) = drive;
 917   3              end;

 918   2              return;

 919   2      end setdef$drive;


 920   1      parseoptions: procedure byte;
                                              /* find all options within [...] */

 921   2              buf$ptr = buf$ptr + 1;
 922   2              delimiter = separator(character);
 923   2              call setdef$drive;

 924   2              if delimiter = 0 then go to preloop;
 926   2              if delimiter <> RBRACKET then 
 927   2                 if delimiter <> EOS then go to preloop;

                                                                      /* [], turn on space */
 929   2              opt$map(drive).option(opt$space) = 1;
 930   2              buf$ptr = buf$ptr + 1;
 931   2              return(2);

 932   2      preloop:
                      if opt$map(drive).option(opt$space) = 0ffh then /* reset forced space*/
 933   2                      opt$map(drive).option(opt$space) = 0;

 934   2      loop:   if (opt$index := optscanner(.options,.off$opt)) = 0 then go to error;

 936   2              if opt$index = opt$page then PAGE = true;
 938   2              else if opt$index = opt$nopage then PAGE = false;
 940   2              else opt$map(drive).option(opt$index - 1) = 1;

 941   2              go to looptest;

 942   2      error:  call e$print(.err$unrecopt);
 943   2              call print(.eoption);
 944   2              call error$prt;

 945   2      looptest:
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  35


                      if delimiter = EOS then return(25);
 947   2              if delimiter = RBRACKET then return(2);

 949   2              go to loop;

 950   2      end parseoptions;

 951   1      parsedir: procedure;

 952   2              declare dirindex        byte;

 953   2              if (dir$index := optscanner(.dirs,.off$dirs)) = 0 then go to error1;

 955   2                      drive = dir$index - 1;
 956   2                      drives(drive) = drive;
 957   2                      opt$map(drive).option(opt$space) = 0ffh;/* only drive:,reset
                                                                         if other options and
                                                                         not space picked */
 958   2                      if delimiter <> COLON then buf$ptr = buf$ptr - 1;

 960   2              return;

 961   2      error1: call e$print(.err$unrecd);
 962   2      dprint: call print(.dirdrive);
 963   2              call error$prt;
 964   2              call terminate;

 965   2      end parsedir;


 966   1      parser: procedure;

 967   2              drive = 0ffh;

 968   2              if (delimiter := separator(character)) = EOS then do;
 970   3                      call setdef$drive;
 971   3                      opt$map(drive).option(opt$space) = 1;           /* default*/
 972   3                      all = true;
 973   3                      return;
 974   3              end;

 975   2      loop:   if delimiter = LBRACKET then delimiter = parseoptions;
 977   2              else if delimiter = 0 then call parsedir;

 979   2              else do;
 980   3                      if delimiter <> COMMA then
 981   3                      if delimiter <> SPACE then go to error;

 983   3                      drive = 0ffh;
 984   3                      buf$ptr = buf$ptr + 1;
 985   3              end;


 986   2      looptest:
                      if delimiter <> EOS then
 987   2                 if (delimiter := separator(character)) <> EOS then go to loop;

PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  36


 989   2              return;

 990   2      error:  call e$print(.err$input);
 991   2              call print(.input);
 992   2              call error$prt;
 993   2              call terminate;

 994   2      end parser;

PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  37


              $eject
              /*************************************************************************


                                      ***  MAIN PROGRAM  ***


              **************************************************************************/

 995   1              declare
                              i       byte initial(1);

 996   1              plm:
                              cversion = get$version;
 997   1                      if cversion < mpm then call e$print(.err$version);
 999   1                      else do;

1000   2                              do while buff(i) = ' ';
1001   3                                      i = i + 1;
1002   3                              end;
1003   2                              buf$ptr = .buff(i);

1004   2                              cdisk = cselect;
1005   2                              user$code = getuser;

1006   2                              do i = 0 to 15;
1007   3                                      drives(i) = 0ffh;
1008   3                              end;

1009   2                              if getpagemode = 0 then PAGE = true;
1011   2                              line$page = getpage;
1012   2                              line$out = 0;
1013   2                              if getNB = 0 then NONBANK = true;

1015   2                              call parser;

1016   2                              do i = 0 to 15;
1017   3                                      if (drive := drives(i)) <> 0ffh then do;
1019   4                                              call select$disk(drives(i));
1020   4                                              call readlbl(1); /* force login
                                                                          by wild card drive
                                                                          search.  */
1021   4                                              call do$option(i);
1022   4                                      end;
1023   3                              end;

1024   2                      end;
1025   1                      call terminate;

1026   1      end;



MODULE INFORMATION:

     CODE AREA SIZE     = 1D1BH   7451D
     VARIABLE AREA SIZE = 026CH    620D
PL/M-80 COMPILER    CP/M 3.0 --- SHOW 3.1                                                                                   PAGE  38


     MAXIMUM STACK SIZE = 0016H     22D
     1898 LINES READ
     0 PROGRAM ERROR(S)

END OF PL/M-80 COMPILATION
